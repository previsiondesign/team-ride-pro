<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tam High MTB Team Roster and Practice Manager</title>
    <link rel="stylesheet" href="styles.css?v=20241220b">
    <style>
        /* Unavailable rider styling in groups - high specificity to override other styles */
        .rider-card.rider-unavailable,
        .rider-card.rider-unavailable *,
        .rider-card.rider-unavailable .card-body,
        .rider-card.rider-unavailable .card-body strong,
        .rider-card.rider-unavailable .badge-single,
        .rider-card.rider-unavailable .badge-single *,
        .rider-card.rider-unavailable .avatar-placeholder {
            color: #999 !important;
            font-style: italic !important;
            text-decoration: line-through !important;
            opacity: 0.6 !important;
        }
        .rider-card.rider-unavailable .avatar-image {
            opacity: 0.5 !important;
            filter: grayscale(50%) !important;
        }
        /* Ensure checkbox remains visible */
        .rider-card.rider-unavailable .attendance-checkbox input {
            opacity: 1 !important;
        }
    </style>
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Supabase Configuration, Auth, Database Functions, and Roles -->
    <script src="scripts/supabase-config.js"></script>
    <script src="scripts/auth.js"></script>
    <script src="scripts/database.js"></script>
    <script src="scripts/roles.js"></script>
    <!-- jsPDF library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <!-- Google API Client Library for OAuth and Sheets API -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <div class="header-title-container">
                <img src="assets/tam-high-logo.png" alt="Tam High Logo" class="header-logo" id="header-logo" style="border-radius: 50%; object-fit: cover;">
                <h1>Tam High Mountain Bike Racing Team</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
                <div class="user-menu" id="user-menu">
                    <div class="user-info">
                        <span class="user-name" id="user-name">Adam Phillips</span>
                        <span class="user-role" id="user-role">Coach</span>
                    </div>
                    <div class="user-menu-buttons">
                        <button class="btn-small secondary" onclick="handleLogout()" data-readonly-allow="true">Sign Out</button>
                    </div>
                </div>
                <div class="mobile-menu-container">
                    <button class="mobile-menu-button" id="mobile-menu-button" onclick="toggleMobileMenu()" aria-label="Menu">
                    </button>
                    <div class="mobile-menu-dropdown" id="mobile-menu-dropdown">
                        <button class="mobile-menu-item active" onclick="selectMobileTab('settings')">Team Dashboard</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('roster')">Roster</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('routes')">Routes</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('practice-reporting')">Reporting</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('rides')">Practice Planner</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('assignments')">Rider Assignments</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('coach-assignments')">Coach Assignments</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('practice-reporting')">Practice Reporting</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tabs" id="desktop-tabs" style="display: flex; justify-content: space-between;">
                    <div style="display: flex;">
                <button class="tab active" onclick="switchTab('settings', this)">Team Dashboard</button>
                <button class="tab" onclick="switchTab('roster', this)">Roster</button>
                <button class="tab" onclick="switchTab('routes', this)">Routes</button>
                <button class="tab" onclick="switchTab('practice-reporting', this)">Reporting</button>
                <button class="tab" onclick="switchTab('rides', this)">Practice Planner</button>
            </div>
            <div style="display: flex;">
                <button class="tab" onclick="switchTab('assignments', this)">Rider Assignments</button>
                <button class="tab" onclick="switchTab('coach-assignments', this)">Coach Assignments</button>
            </div>
        </div>

        <div id="read-only-banner" style="display: none; background: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px 12px; border-radius: 6px; margin: 12px 0;">
            Read-only mode enabled.
        </div>

        <!-- SEASON CALENDAR TAB -->
        <div id="settings-tab" class="tab-content active">
            <div class="section">
                <div class="form-row" style="margin-bottom: 16px;">
                    <div style="flex:1;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <label class="field-label" style="margin:0;">Season Date Range</label>
                            <button class="btn-small secondary" onclick="applySeasonUpdates('dates')" title="Update calendar after changing dates">Update Dates</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button type="button" class="btn-small secondary" onclick="openSeasonDateRangePickerModal()" id="season-date-range-button" style="flex: 1; text-align: left; justify-content: flex-start; padding: 8px 12px; background: white; border: 1px solid #ddd; cursor: pointer; color: #333;">
                                Select Date Range
                            </button>
                            <!-- Hidden inputs for backwards compatibility with existing code -->
                            <input type="date" id="season-start-date" style="display: none;" onchange="updateSeasonDateRange(); updateSeasonDateRangeButton();">
                            <input type="date" id="season-end-date" style="display: none;" onchange="updateSeasonDateRange(); updateSeasonDateRangeButton();">
                        </div>
                    </div>
                </div>
                <div class="season-calendar-wrapper" id="season-calendar-wrapper-settings">
                    <div class="season-calendar-header" style="display: none;">
                        <h3 style="margin:0;">Season Calendar</h3>
                    </div>
                    <div id="season-calendar-settings" class="season-calendar-empty">
                        Set your season dates and practices to see the calendar here.
                    </div>
                </div>
                <div style="margin-top: 12px; display: flex; gap: 8px;">
                    <button class="btn-small" onclick="openPracticesModal()">Add/Edit Practices</button>
                    <button class="btn-small secondary" onclick="openAddRacesModal()">Add Races</button>
                </div>
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; margin-top: 16px;">
                        <label class="field-label" style="margin:0;">Regular Practices</label>
                        <button class="btn-small secondary" onclick="applySeasonUpdates('practices')" title="Reset all practices in the season">Reset All Practices</button>
                    </div>
                    <div id="practice-rows" class="practice-rows"></div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Coach Roles</h3>
                    <div id="coach-roles-container" style="margin-bottom: 20px;">
                        <!-- Coach roles will be dynamically added here -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="new-coach-role-name" placeholder="Role name (e.g., Head Coach)" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <select id="new-coach-role-coach" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">Select Coach</option>
                        </select>
                        <button class="btn-small" onclick="addCoachRole()">Add Role</button>
                    </div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Rider Roles</h3>
                    <div id="rider-roles-container" style="margin-bottom: 20px;">
                        <!-- Rider roles will be dynamically added here -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="new-rider-role-name" placeholder="Role name (e.g., Captain)" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <select id="new-rider-role-rider" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">Select Rider</option>
                        </select>
                        <button class="btn-small" onclick="addRiderRole()">Add Role</button>
                    </div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Rating Scales</h3>
                    <div class="form-row" style="margin-bottom: 12px;">
                        <label class="field-label" style="min-width: 200px;">Relative Pace Scale (1 to X):</label>
                        <input type="number" id="fitness-scale" min="3" max="20" style="width: 100px;" onchange="updateScaleSettings()" oninput="updateScaleSettings()" onblur="updateScaleSettings()">
                        <span style="color: #666; margin-left: 8px;">Current: 1-<span id="fitness-scale-display"></span></span>
                    </div>
                    <div class="form-row" style="margin-bottom: 12px;">
                        <label class="field-label" style="min-width: 200px;">Pace Scale Sorting</label>
                        <select id="pace-scale-order" style="width: 220px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" onchange="updateScaleSettings()">
                            <option value="fastest_to_slowest">Fastest to Slowest</option>
                            <option value="slowest_to_fastest">Slowest to Fastest</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <button class="btn-small secondary" onclick="flipPaceValuesOnce()">One-time Flip Pace Values</button>
                        <span style="margin-left: 8px; font-size: 12px; color: #666;">Fixes inverted pace values without changing the sorting setting</span>
                    </div>
                    <div class="form-row" style="margin-bottom: 12px;">
                        <label class="field-label" style="min-width: 200px;">Bike Skills Scale:</label>
                        <select id="skills-scale" style="width: 120px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" onchange="updateScaleSettings(); updateBikeSkillsDescriptions();">
                            <option value="">-- Select --</option>
                            <option value="3">3 Levels</option>
                            <option value="5">5 Levels</option>
                        </select>
                        <span style="color: #666; margin-left: 8px;">Current: 1-<span id="skills-scale-display"></span></span>
                    </div>
                    <div id="bike-skills-descriptions" style="margin-top: 12px; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; line-height: 1.6;">
                        <!-- Descriptions will be populated here -->
                    </div>
                    <div style="margin-top: 12px; padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 13px; color: #856404;">
                        <strong>Note:</strong> Changing scales will automatically convert all existing fitness and skills ratings to the new scale.
                    </div>
                    <div style="margin-top: 12px;">
                        <button class="btn-small" onclick="syncScaleSettings()" style="padding: 8px 16px; font-size: 14px; font-weight: 600; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Update Scales</button>
                        <span style="margin-left: 8px; font-size: 12px; color: #666;">Synchronizes scale settings across all locations</span>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="importSeasonSettings()">Import Settings</button>
                    <button class="btn-small" onclick="saveSeasonSettings()" style="margin-left: auto;">Save Settings</button>
                </div>
                
                <!-- Add Administrators Section -->
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Add Additional Administrators</h3>
                    <p style="font-size: 13px; color: #666; margin-bottom: 12px;">Send an invitation link to grant admin access to a new user. They will receive an email with a unique link to create their account.</p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="email" id="admin-invite-email" placeholder="Enter email address" style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <button class="btn-small" onclick="sendAdminInvitation()" style="background-color: #fc5200; color: white; border-color: #fc5200;">Send Invitation</button>
                    </div>
                    <div id="admin-invite-status" style="margin-top: 8px; font-size: 13px; display: none;"></div>
                    <div id="admin-invitations-list" style="margin-top: 16px; padding: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px;">
                        <button class="btn-small secondary" onclick="loadAdminInvitations()" style="margin-bottom: 12px;">Refresh Invitations</button>
                        <div id="admin-invitations-content">
                            <p style="color: #666; margin: 0;">Click "Refresh Invitations" to view pending invitations.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Users Section -->
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Registered Users</h3>
                    <div id="users-list-container" style="margin-bottom: 12px;">
                        <button class="btn-small secondary" onclick="loadUsersList()">Refresh Users List</button>
                        <div id="users-list" style="margin-top: 12px; padding: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px;">
                            <p style="color: #666; margin: 0;">Click "Refresh Users List" to load registered users.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Backup Section -->
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Backups</h3>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button class="btn-small" onclick="createManualBackup()">Make Backup</button>
                        <button class="btn-small secondary" onclick="loadBackupsList()">Refresh Backups</button>
                    </div>
                    <div id="backups-list-container" style="margin-bottom: 12px;">
                        <div id="backups-list" style="margin-top: 12px; padding: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px;">
                            <p style="color: #666; margin: 0;">Click "Refresh Backups" to load available backups.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ROSTER TAB -->
        <div id="roster-tab" class="tab-content">
            <div class="section" style="padding-top: 8px;">
                <div class="roster-controls" style="margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                        <button id="roster-toggle-riders" class="btn-small active" onclick="toggleRosterView('riders')" style="padding: 10px 20px; font-size: 15px; font-weight: 600;">Riders</button>
                        <button id="roster-toggle-coaches" class="btn-small secondary" onclick="toggleRosterView('coaches')" style="padding: 10px 20px; font-size: 15px; font-weight: 600;">Coaches</button>
                    </div>
                    <div class="group-by-control" id="roster-group-by-container">
                        <label id="roster-group-by-label" for="rider-group-by">Group by:</label>
                        <select id="rider-group-by" onchange="groupRiders(this.value)" style="display: block;">
                            <option value="">None</option>
                            <option value="name">Name</option>
                            <option value="gender">Gender</option>
                            <option value="grade">Grade</option>
                            <option value="racingGroup">Racing Group</option>
                            <option value="pace">Pace</option>
                            <option value="skills">Bike Skills</option>
                        </select>
                        <select id="coach-group-by" onchange="groupCoaches(this.value)" style="display: none;">
                            <option value="">None</option>
                            <option value="name">Name</option>
                            <option value="level">Coach Level</option>
                            <option value="pace">Pace</option>
                        </select>
                    </div>
                </div>
                
                <!-- RIDERS VIEW -->
                <div id="roster-riders-view">
                    <div id="riders-list" class="roster-grid"></div>
                    <div style="margin-top: 16px; text-align: center; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn-small" onclick="openAddRiderModal()">Add Team Rider</button>
                        <button class="btn-small secondary" onclick="importRidersFromCSV()">Import Riders from CSV</button>
                        <button class="btn-small secondary" onclick="updateRidersFromCSVFile()">Update Roster Changes from CSV</button>
                        <button class="btn-small secondary" onclick="openGoogleSheetsModal('riders')">Sync from Google Sheet</button>
                        <button class="btn-small danger" onclick="purgeRiders()">Purge Riders</button>
                    </div>
                    <div id="rider-update-debug" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; display: none; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;"></div>
                </div>

                <!-- COACHES VIEW -->
                <div id="roster-coaches-view" style="display: none;">
                    <div id="coaches-list" class="roster-grid"></div>
                    <div style="margin-top: 16px; text-align: center; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn-small" onclick="openAddCoachModal()">Add Coach</button>
                        <button class="btn-small secondary" onclick="importCoachesFromCSV()">Import Coaches from CSV</button>
                        <button class="btn-small secondary" onclick="updateCoachesFromCSVFile()">Update Roster Changes from CSV</button>
                        <button class="btn-small secondary" onclick="openGoogleSheetsModal('coaches')">Sync from Google Sheet</button>
                        <button class="btn-small danger" onclick="purgeCoaches()">Purge Coaches</button>
                    </div>
                    <div id="coach-update-debug" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; display: none; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>

        <!-- RIDES TAB -->
        <div id="rides-tab" class="tab-content">
            <div class="section">
                <div id="practice-navigation" style="display: none; margin-bottom: 16px;"></div>
            </div>

            <div id="current-ride" style="display: none;">
                <div class="section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h2 id="ride-title" style="margin: 0;"></h2>
                        <div id="practice-navigation-buttons" style="display: none; gap: 8px; flex-direction: row;">
                            <button class="btn-small secondary" onclick="navigateToPriorPractice()" id="prior-practice-btn">← Show Prior Practice</button>
                            <button class="btn-small secondary" onclick="navigateToNextPractice()" id="next-practice-btn">Show Next Practice →</button>
                        </div>
                    </div>
                    <div id="ride-details" style="margin-top: 8px; margin-bottom: 15px; font-size: 14px; color: #666;"></div>
                    <div style="margin-top: 10px; margin-bottom: 15px;">
                        <label for="practice-goals" style="display: block; margin-bottom: 6px; font-weight: 500; color: #555;">Practice Goals</label>
                        <input type="text" id="practice-goals" placeholder="Enter practice goals (e.g., Endurance training, Hill climbs, Technical skills)" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" onchange="updatePracticeGoals()">
                    </div>
                    
                    <!-- Practice Attendance Section -->
                    <div style="margin-top: 20px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;" onclick="togglePracticeAttendance()">
                            <strong style="font-size: 16px;">Practice Attendance</strong>
                            <span id="practice-attendance-arrow" style="font-size: 18px;">▼</span>
                        </div>
                        <div id="practice-attendance-content" style="display: none; margin-top: 8px; padding: 8px 0; background: #fff; position: relative;">
                            <div id="practice-attendance-resize-handle" style="position: absolute; bottom: 0; left: 0; right: 0; height: 8px; cursor: ns-resize; background: transparent; z-index: 10;" onmousedown="startResizeAttendance(event)"></div>
                            <div id="practice-attendance-lists-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 400px; overflow: hidden;">
                                <div id="practice-riders-list" class="assignment-column" style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
                                    <!-- Riders will be populated here -->
                                </div>
                                <div id="practice-coaches-list" class="assignment-column" style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
                                    <!-- Coaches will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Group Assignments Section -->
                    <div style="margin-top: 20px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;" onclick="toggleGroupAssignments()">
                            <strong style="font-size: 16px;">Group Assignments</strong>
                            <span id="group-assignments-arrow" style="font-size: 18px;">▶</span>
                        </div>
                        <div id="group-assignments-content" style="display: none; margin-top: 12px;">
                            <div class="action-bar" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
                                <button id="undo-btn" class="btn-small" onclick="undoAssignmentChange()" title="Undo last change" style="padding: 6px 10px; font-size: 18px; line-height: 1; opacity: 0.5; cursor: not-allowed; min-width: 32px;" disabled>↶</button>
                                <button id="redo-btn" class="btn-small" onclick="redoAssignmentChange()" title="Redo last undone change" style="padding: 6px 10px; font-size: 18px; line-height: 1; opacity: 0.5; cursor: not-allowed; min-width: 32px;" disabled>↷</button>
                                <div style="width: 1px; height: 20px; background: #ddd; margin: 0 4px;"></div>
                                <button class="btn-small" onclick="addGroup()">Add Group</button>
                                <button class="btn-small" onclick="addGroupsFromLastPractice()" style="background: #1976D2; color: white; border-color: #1976D2;">Add Groups from Last Practice</button>
                                <button class="btn-small" onclick="autoAssign()">Autofill Group Assignments</button>
                                <button class="btn-small secondary" onclick="openAutoAssignSettingsModal()">Auto-Assign Settings...</button>
                                <button id="unassigned-palette-toggle-btn" class="btn-small" onclick="toggleUnassignedPaletteVisibility()" style="background: #fff3cd; color: #856404; border-color: #ffc107;">Show Unassigned Palette</button>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <label for="group-pace-order" style="font-size: 12px; color: #555;">Group Pace Options:</label>
                                    <select id="group-pace-order" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px;" onchange="updateGroupPaceOrder(this.value)">
                                        <option value="fastest_to_slowest">Fastest to Slowest</option>
                                        <option value="slowest_to_fastest">Slowest to Fastest</option>
                                    </select>
                                </div>
                                <button id="more-groups-btn" class="btn-small secondary" onclick="tryMoreGroups()" style="display: none;">More/Smaller Groups</button>
                                <button id="fewer-groups-btn" class="btn-small secondary" onclick="tryFewerGroups()" style="display: none;">Fewer/Larger Groups</button>
                                <button class="btn-small danger" onclick="clearAssignments()" style="margin-left: auto;">Clear Group Assignments</button>
                            </div>
                            <div id="publish-groups-container" style="display: flex; justify-content: center; gap: 12px; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; flex-wrap: wrap;">
                                <button id="publish-groups-btn" class="btn-small" onclick="publishGroupAssignments()" style="padding: 12px 24px; font-size: 16px; font-weight: 600; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Publish Group Assignments</button>
                                <button id="unpublish-groups-btn" class="btn-small" onclick="unpublishGroupAssignments()" style="padding: 12px 24px; font-size: 16px; font-weight: 600; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Unpublish Group Assignments</button>
                                <button id="send-notification-btn" class="btn-small" onclick="sendGroupAssignmentNotification()" style="padding: 12px 24px; font-size: 16px; font-weight: 600; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Send Notification</button>
                                <button id="print-groups-btn" class="btn-small" onclick="printGroupAssignments()" style="padding: 12px 24px; font-size: 16px; font-weight: 600; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Print Group Assignments</button>
                            </div>
                            <div id="unassigned-new-attendees" style="display: none; margin-bottom: 16px;">
                                <!-- Unassigned new attendees will be shown here -->
                            </div>
                            <div id="assignments" class="assignments"></div>
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <strong>Auto-Assignment Debug Output</strong>
                            <button class="btn-small" onclick="copyDebugToClipboard()" id="copy-debug-btn" style="display: none;">Copy to Clipboard</button>
                        </div>
                        <pre id="auto-assign-debug" class="debug-output" style="display: none;"></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIDE ASSIGNMENTS TAB -->
        <div id="assignments-tab" class="tab-content">
            <div class="section">
                <div id="ride-assignments-container">
                    <!-- Ride assignments will be loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- COACH ASSIGNMENTS TAB -->
        <div id="coach-assignments-tab" class="tab-content">
            <div class="section">
                <div id="coach-assignments-container">
                    <!-- Coach assignments will be loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- PRACTICE REPORTING TAB -->
        <div id="practice-reporting-tab" class="tab-content">
            <div class="section">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap;">
                    <h2 id="practice-reporting-title" style="margin: 0;">Practice Reporting</h2>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <button class="btn-small secondary" id="practice-reporting-prev" onclick="navigatePracticeReporting(-1)" title="Previous practice">←</button>
                        <div id="practice-reporting-date" style="font-size: 14px; font-weight: 600; color: #333;">No practices found</div>
                        <button class="btn-small secondary" id="practice-reporting-next" onclick="navigatePracticeReporting(1)" title="Next practice">→</button>
                    </div>
                </div>
                <div id="practice-reporting-summary" style="margin-top: 6px; font-size: 12px; color: #666;"></div>
                <div style="margin-top: 12px; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: #f5f5f5;">
                            <tr>
                                <th onclick="togglePracticeReportingSort()" data-readonly-allow="true" style="text-align: left; padding: 10px; font-size: 12px; text-transform: uppercase; color: #555; cursor: pointer;">
                                    Rider <span id="practice-reporting-sort-indicator">↑</span>
                                </th>
                                <th style="text-align: left; padding: 10px; font-size: 12px; text-transform: uppercase; color: #555;">Status</th>
                            </tr>
                        </thead>
                        <tbody id="practice-reporting-table-body">
                            <tr><td colspan="2" style="padding: 12px; color: #666;">No practice data yet.</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- ROUTES TAB -->
        <div id="routes-tab" class="tab-content">
            <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button class="btn-small" onclick="openRoutesManagerModal()">Add/Edit Routes...</button>
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="routes-view-mode" style="font-size: 14px; color: #666;">View:</label>
                            <div id="routes-view-mode" class="routes-view-toggle">
                                <button id="routes-view-thumbnails" class="routes-view-btn" onclick="setRoutesViewMode('thumbnails')">Thumbnails</button>
                                <button id="routes-view-list" class="routes-view-btn" onclick="setRoutesViewMode('list')">List View</button>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="routes-sort-by" style="font-size: 14px; color: #666;">Sort By:</label>
                            <select id="routes-sort-by" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; cursor: pointer;" onchange="renderRoutes()">
                                <option value="distance-asc">Distance (shortest to longest)</option>
                                <option value="distance-desc">Distance (longest to shortest)</option>
                                <option value="elevation-asc">Elev Gain (least to most)</option>
                                <option value="elevation-desc">Elev Gain (most to least)</option>
                                <option value="time-asc">Duration (shortest to longest)</option>
                                <option value="time-desc">Duration (longest to shortest)</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="routes-grid" class="routes-grid">
                    <!-- Routes will be loaded dynamically -->
                </div>
            </div>
        </div>
    </div>

    <div id="season-setup-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 900px; width: min(900px, 95%);">
            <div class="modal-header">
                <span>Season Setup</span>
                <button class="btn-small secondary" onclick="closeSeasonSetupModal()">Close</button>
                </div>
            <div class="modal-body">
                <div class="form-row">
                    <div style="flex:1;">
                        <label class="field-label">Season Date Range</label>
                        <button type="button" class="btn-small secondary" onclick="openSeasonDateRangePickerModal()" id="season-date-range-button-setup" style="width: 100%; text-align: left; justify-content: flex-start; padding: 8px 12px; background: white; border: 1px solid #ddd; cursor: pointer; color: #333;">
                            Select Date Range
                        </button>
                        <!-- Hidden inputs for backwards compatibility with existing code - sharing IDs with main settings inputs -->
                        <input type="date" id="season-start-date-setup" style="display: none;" onchange="syncSeasonDatesToMain();">
                        <input type="date" id="season-end-date-setup" style="display: none;" onchange="syncSeasonDatesToMain();">
                    </div>
                </div>
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <label class="field-label" style="margin:0;">Regular Practices</label>
                        <div style="display:flex; gap:8px;">
                            <button class="btn-small secondary" onclick="addPracticeRow()">Add Recurring Practice</button>
                            <button class="btn-small secondary" onclick="openAddSinglePracticeModal()">Add single practice</button>
                            <button class="btn-small secondary" onclick="openAddRacesModal()">Add Races</button>
                        </div>
                    </div>
                    <div id="practice-rows" class="practice-rows"></div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="importSeasonSettings()">Import Settings</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="closeSeasonSetupModal()">Cancel</button>
                    <button class="btn-small" onclick="saveSeasonSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <div id="location-map-modal" class="modal-overlay" style="z-index: 2100;" aria-hidden="true">
        <div class="modal" style="max-width: 800px; width: min(800px, 95%);">
            <div class="modal-header">
                <span>Select Meet Location</span>
                <button class="btn-small secondary" onclick="closeLocationMapModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 12px;">
                    <label for="location-previous" class="field-label">Previous Locations</label>
                    <select id="location-previous" onchange="selectPreviousLocation(this.value)" style="width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; cursor: pointer;">
                        <option value="">-- Select from previous locations --</option>
                    </select>
                </div>
                <div style="margin-bottom: 12px;">
                    <label for="location-search" class="field-label">Search Location</label>
                    <input type="text" id="location-search" placeholder="Search for a location..." style="width: 100%; padding: 8px; margin-bottom: 8px;" onkeypress="if(event.key === 'Enter') searchLocation();">
                    <button class="btn-small" onclick="searchLocation()">Search</button>
                </div>
                <div id="map-container" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px; background: #f0f0f0; position: relative; z-index: 1;">
                    <div id="map-placeholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666; z-index: 0;">
                        <p>Map will load here</p>
                        <p style="font-size: 12px; margin-top: 8px;">Click on the map to set location</p>
                    </div>
                </div>
                <div class="form-row">
                    <div style="flex: 1;">
                        <label for="location-latitude" class="field-label">Latitude</label>
                        <input type="number" id="location-latitude" step="0.000001" placeholder="0.000000" style="width: 100%;">
                    </div>
                    <div style="flex: 1;">
                        <label for="location-longitude" class="field-label">Longitude</label>
                        <input type="number" id="location-longitude" step="0.000001" placeholder="0.000000" style="width: 100%;">
                    </div>
                </div>
                <div style="margin-top: 12px;">
                    <label for="location-address" class="field-label">Address</label>
                    <input type="text" id="location-address" placeholder="Address will appear here" style="width: 100%;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeLocationMapModal()">Cancel</button>
                <button class="btn-small" onclick="saveLocation()">Save Location</button>
            </div>
        </div>
    </div>

    <!-- Roster Refinement Modal -->
    <div id="roster-refinement-modal" class="modal-overlay" style="z-index: 2000;" aria-hidden="true">
        <div class="modal-content" style="width: 900px; height: 80vh; max-width: 900px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; background: #ffffff !important; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div class="modal-header" style="background-color: #2196F3; color: white;">
                <h3>Refine Roster</h3>
                <button class="modal-close" onclick="closeRosterRefinement()" aria-label="Close">&times;</button>
            </div>
            <div style="padding: 16px; overflow-y: auto; flex: 1; background: #ffffff !important;">
                <div style="margin-bottom: 16px;">
                    <label for="roster-filter-type" style="display: block; margin-bottom: 8px; font-weight: 500;">Filter by...</label>
                    <select id="roster-filter-type" onchange="updateRosterFilterOptions()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">-- Select filter type --</option>
                        <option value="grade">Grade</option>
                        <option value="gender">Gender</option>
                        <option value="racingGroup">Racing Group</option>
                    </select>
                </div>
                <div id="roster-filter-options" style="margin-bottom: 16px; display: none;">
                    <!-- Filter checkboxes will be populated here -->
                </div>
                <div style="margin-bottom: 16px; border-top: 1px solid #ddd; padding-top: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <strong>Riders (<span id="roster-filtered-count">0</span> shown)</strong>
                    </div>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead style="background: #f5f5f5; position: sticky; top: 0;">
                                <tr>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd; width: 30px;"></th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd;">Name</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd;">Grade</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd;">Gender</th>
                                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid #ddd;">Racing Group</th>
                                </tr>
                            </thead>
                            <tbody id="roster-filtered-list">
                                <!-- Riders will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeRosterRefinement()">Cancel</button>
                <button class="btn-small" onclick="saveRosterRefinement()">OK</button>
            </div>
        </div>
    </div>

    <div id="add-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span>Add Additional Practice</span>
                <button class="btn-small secondary" onclick="closeAddPracticeModal()">Close</button>
                </div>
            <div class="modal-body">
                <div class="form-row">
                    <div style="flex:1;">
                        <label for="practice-date" class="field-label">Date</label>
                        <input type="date" id="practice-date">
                    </div>
                    <div style="flex:1;">
                        <label for="practice-time" class="field-label">Time</label>
                        <input type="time" id="practice-time">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddPracticeModal()">Cancel</button>
                <button class="btn-small" onclick="saveAddPractice()">Add Practice</button>
            </div>
        </div>
    </div>

    <div id="add-races-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px; width: min(700px, 95%);">
            <div class="modal-header">
                <span>Add Races</span>
                <button class="btn-small secondary" onclick="closeAddRacesModal()">Close</button>
            </div>
            <div class="modal-body">
                <div id="races-list-container" style="margin-bottom: 16px;">
                    <!-- Race entries will be added here -->
                </div>
                <button class="btn-small secondary" onclick="addRaceEntry()" style="margin-bottom: 12px;">+ Add Another Race</button>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddRacesModal()">Cancel</button>
                <button class="btn-small" onclick="saveRaces()">Save Races</button>
            </div>
        </div>
    </div>

    <div id="practices-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 900px; width: min(900px, 95%);">
            <div class="modal-header">
                <span>Add/Edit Practices</span>
                <button class="btn-small secondary" onclick="closePracticesModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                    <label class="field-label" style="margin:0;">Regular Practices</label>
                    <div style="display:flex; gap:8px;">
                        <button class="btn-small" onclick="addPracticeRowInModal()">Add Recurring Practice</button>
                        <button class="btn-small secondary" onclick="openAddSinglePracticeModalInModal()">Add Single Practice</button>
                        <button class="btn-small secondary" onclick="applySeasonUpdates('practices')" title="Update calendar after changing regular practices">Update Practices</button>
                    </div>
                </div>
                <div id="practice-rows-modal" class="practice-rows"></div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closePracticesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="time-range-picker-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px; width: min(500px, 95%);">
            <div class="modal-header">
                <span>Set Practice Time Range</span>
                <button class="btn-small secondary" onclick="closeTimeRangePickerModal()">Close</button>
            </div>
            <div class="modal-body">
                <div class="form-row" style="flex-direction: column; gap: 20px;">
                    <div style="flex: 1;">
                        <label class="field-label">Start Time</label>
                        <input type="time" id="time-range-start" style="width: 100%; padding: 10px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div style="flex: 1;">
                        <label class="field-label">End Time</label>
                        <input type="time" id="time-range-end" style="width: 100%; padding: 10px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div style="padding: 12px; background: #f5f5f5; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Time Range</div>
                        <div id="time-range-preview" style="font-size: 18px; font-weight: 600; color: #333;">—</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeTimeRangePickerModal()">Cancel</button>
                <button class="btn-small" onclick="saveTimeRange()">Save Time Range</button>
            </div>
        </div>
    </div>

    <div id="season-date-range-picker-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px; width: min(700px, 95%);">
            <div class="modal-header">
                <span>Select Season Date Range</span>
                <button class="btn-small secondary" onclick="closeSeasonDateRangePickerModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="padding: 20px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                        <button type="button" onclick="navigateSeasonDateRangeMonths(-1)" style="background: none; border: none; cursor: pointer; font-size: 20px; color: #666; padding: 8px;">&lt;</button>
                        <div id="season-date-range-months-display" style="font-size: 16px; font-weight: 600; color: #333;"></div>
                        <button type="button" onclick="navigateSeasonDateRangeMonths(1)" style="background: none; border: none; cursor: pointer; font-size: 20px; color: #666; padding: 8px;">&gt;</button>
                    </div>
                    <div id="season-date-range-calendars" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                        <!-- Calendars will be rendered here -->
                    </div>
                    <div id="season-date-range-preview" style="margin-top: 20px; padding: 12px; background: #f5f5f5; border-radius: 4px; text-align: center;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Selected Range</div>
                        <div style="font-size: 16px; font-weight: 600; color: #333;">—</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="clearSeasonDateRange()">Clear</button>
                <button class="btn-small secondary" onclick="closeSeasonDateRangePickerModal()">Cancel</button>
                <button class="btn-small" onclick="saveSeasonDateRange()">Save Date Range</button>
            </div>
        </div>
    </div>

    <div id="auto-assign-settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px; width: min(700px, 95%);">
            <div class="modal-header">
                <span>Auto-Assign Settings</span>
                <button class="btn-small secondary" onclick="closeAutoAssignSettingsModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="padding: 20px;">
                    <p style="margin-bottom: 20px; color: #666; font-size: 14px;">
                        Adjust these settings to control how the auto-assignment algorithm creates groups and assigns riders and coaches.
                    </p>
                    <div id="auto-assign-settings-list">
                        <!-- Settings will be rendered here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAutoAssignSettingsModal()">Cancel</button>
                <button class="btn-small" onclick="saveAutoAssignSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <div id="edit-coach-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span id="edit-coach-modal-title">Edit Coach</span>
                <button class="btn-small secondary" onclick="closeEditCoachModal()">Close</button>
            </div>
            <div class="modal-body">
                <div class="modal-photo-section">
                    <div class="modal-photo-container">
                        <div class="modal-photo" id="edit-coach-photo-container" style="position: relative;">
                            <img id="edit-coach-photo-preview" src="" alt="Coach photo" style="display: none; width: 100%; height: 100%; object-fit: cover;">
                            <span id="edit-coach-photo-placeholder" class="photo-placeholder" style="display: flex;">🚴</span>
                            <div class="photo-edit-overlay">
                                <span class="photo-edit-icon">✏️</span>
                            </div>
                            <input type="file" id="edit-coach-photo-input" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleCoachPhotoUploadInModal(this)">
                        </div>
                    </div>
                    <div class="modal-name-field">
                        <div class="modal-name-row">
                            <div class="modal-name-col">
                                <label for="edit-coach-first-name" class="field-label">First Name</label>
                                <input type="text" id="edit-coach-first-name">
                            </div>
                            <div class="modal-name-col">
                                <label for="edit-coach-last-name" class="field-label">Last Name</label>
                                <input type="text" id="edit-coach-last-name">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-form-container" style="max-height: 70vh; overflow-y: auto;">
                    <div class="modal-labels-column">
                        <div class="modal-field-label">Email</div>
                        <div class="modal-field-label">Cell Phone</div>
                        <div class="modal-field-label">Work Phone</div>
                        <div class="modal-field-label">Home Phone</div>
                        <div class="modal-field-label">Gender</div>
                        <div class="modal-field-label">Coaching License Level</div>
                        <div class="modal-field-label">Registered</div>
                        <div class="modal-field-label">Paid</div>
                        <div class="modal-field-label">Background Check</div>
                        <div class="modal-field-label">Level 3 Exam Completed</div>
                        <div class="modal-field-label">PDU/CEU Units</div>
                        <div class="modal-field-label">Field Work Hours</div>
                        <div class="modal-field-label">First Aid Type, Expires</div>
                        <div class="modal-field-label">CPR Expires</div>
                        <div class="modal-field-label">Concussion Training Completed</div>
                        <div class="modal-field-label">NICA Philosophy Completed</div>
                        <div class="modal-field-label">Athlete Abuse Awareness Completed</div>
                        <div class="modal-field-label">License Level 1 Completed</div>
                        <div class="modal-field-label">License Level 2 Completed</div>
                        <div class="modal-field-label">License Level 3 Completed</div>
                        <div class="modal-field-label">OTB Skills 101 Classroom Completed</div>
                        <div class="modal-field-label">OTB Skills 101 Outdoor Completed</div>
                        <div class="modal-field-label">NICA Leader Summit Completed</div>
                        <div class="modal-field-label">Relative Pace (1-10)</div>
                        <div class="modal-field-label">Notes</div>
                    </div>
                    <div class="modal-inputs-column">
                        <div class="modal-form-row">
                            <input type="email" id="edit-coach-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-work-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-home-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-coach-gender" class="modal-field-input">
                                <option value="">Select Gender</option>
                                <option value="M">M</option>
                                <option value="F">F</option>
                                <option value="NB">Nonbinary</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-coach-level" class="modal-field-input">
                                <option value="N/A">N/A</option>
                                <option value="1">Level 1</option>
                                <option value="2">Level 2</option>
                                <option value="3">Level 3</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-registered" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-paid" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-background-check" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-level3-exam" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-pdu-ceu" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-field-work-hours" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-first-aid" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-cpr-expires" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-concussion-training" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-nica-philosophy" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-abuse-awareness" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level2" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level3" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-otb-classroom" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-otb-outdoor" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-nica-summit" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-coach-fitness" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <label for="edit-coach-skills" class="field-label">Bike Skills</label>
                            <input type="number" id="edit-coach-skills" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-coach-notes" rows="3" class="modal-field-input"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between;">
                <button id="delete-coach-btn" class="btn-small danger" onclick="deleteCoachFromModal()" style="display: none;">Delete Record</button>
                <div style="display: flex; gap: 8px; margin-left: auto;">
                    <button class="btn-small secondary" onclick="closeEditCoachModal()">Cancel</button>
                    <button class="btn-small" onclick="saveCoachFromModal()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="edit-rider-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span id="edit-rider-modal-title">Edit Team Rider</span>
                <button class="btn-small secondary" onclick="closeEditRiderModal()">Close</button>
            </div>
            <div class="modal-body">
                <div class="modal-photo-section">
                    <div class="modal-photo-container">
                        <div class="modal-photo" id="edit-rider-photo-container" style="position: relative;">
                            <img id="edit-rider-photo-preview" src="" alt="Rider photo" style="display: none; width: 100%; height: 100%; object-fit: cover;">
                            <span id="edit-rider-photo-placeholder" class="photo-placeholder" style="display: flex;">👤</span>
                            <div class="photo-edit-overlay">
                                <span class="photo-edit-icon">✏️</span>
                            </div>
                            <input type="file" id="edit-rider-photo-input" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleRiderPhotoUploadInModal(this)">
                        </div>
                    </div>
                    <div class="modal-name-field">
                        <div class="modal-name-row">
                            <div class="modal-name-col">
                                <label for="edit-rider-first-name" class="field-label">First Name</label>
                                <input type="text" id="edit-rider-first-name">
                            </div>
                            <div class="modal-name-col">
                                <label for="edit-rider-last-name" class="field-label">Last Name</label>
                                <input type="text" id="edit-rider-last-name">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-form-container" style="max-height: 70vh; overflow-y: auto;">
                    <div class="modal-labels-column">
                        <div class="modal-field-label">Email</div>
                        <div class="modal-field-label">Cell Phone</div>
                        <div class="modal-field-label">Address</div>
                        <div class="modal-field-label">Gender</div>
                        <div class="modal-field-label">Grade</div>
                        <div class="modal-field-label">Racing Group</div>
                        <div class="modal-field-label">Birthday</div>
                        <div class="modal-field-label">Primary Parent/Guardian</div>
                        <div class="modal-field-label">Primary Parent Cell</div>
                        <div class="modal-field-label">Primary Parent Email</div>
                        <div class="modal-field-label">Primary Parent Address</div>
                        <div class="modal-field-label">Second Parent/Guardian</div>
                        <div class="modal-field-label">Second Parent Cell</div>
                        <div class="modal-field-label">Second Parent Email</div>
                        <div class="modal-field-label">Alternate Contact Name</div>
                        <div class="modal-field-label">Alternate Contact Relationship</div>
                        <div class="modal-field-label">Alternate Contact Cell</div>
                        <div class="modal-field-label">Primary Physician</div>
                        <div class="modal-field-label">Primary Physician Phone</div>
                        <div class="modal-field-label">Medical Insurance Company</div>
                        <div class="modal-field-label">Medical Insurance Account #</div>
                        <div class="modal-field-label">Allergies/Medical Needs</div>
                        <div class="modal-field-label">Relative Pace (1-10)</div>
                        <div class="modal-field-label">Bike Skills (1-4)</div>
                        <div class="modal-field-label">Notes</div>
                    </div>
                    <div class="modal-inputs-column">
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-email" placeholder="Email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-phone" placeholder="(XXX) XXX-XXXX" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-address" placeholder="Address" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-gender" class="modal-field-input" onchange="updateRacingGroupOptions(); updateDefaultPhoto()">
                                <option value="">Select Gender</option>
                                <option value="M">M</option>
                                <option value="F">F</option>
                                <option value="NB">Nonbinary</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-grade" class="modal-field-input">
                                <option value="9th">9th</option>
                                <option value="10th">10th</option>
                                <option value="11th">11th</option>
                                <option value="12th">12th</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-racing-group" class="modal-field-input">
                                <option value="">Select Gender First</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-birthday" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-parent-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-primary-parent-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-primary-parent-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-parent-address" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-second-parent-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-second-parent-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-second-parent-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-alternate-contact-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-alternate-contact-relationship" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-alternate-contact-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-physician" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-primary-physician-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-medical-insurance-company" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-medical-insurance-account" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-rider-allergies" rows="2" class="modal-field-input"></textarea>
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-rider-fitness" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-rider-skills" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-rider-notes" rows="3" class="modal-field-input"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between;">
                <button id="delete-rider-btn" class="btn-small danger" onclick="deleteRiderFromModal()" style="display: none;">Delete Record</button>
                <div style="display: flex; gap: 8px; margin-left: auto;">
                    <button class="btn-small secondary" onclick="closeEditRiderModal()">Cancel</button>
                    <button class="btn-small" onclick="saveRiderFromModal()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="notes-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span id="notes-modal-title">Notes</span>
                <button class="btn-small secondary" onclick="closeNotesModal()">Close</button>
            </div>
            <div class="modal-body">
                <p id="notes-modal-content" style="white-space: pre-wrap; margin: 0;"></p>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeNotesModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Login/Auth Modal -->
    <div id="auth-overlay" class="auth-overlay hidden">
        <div class="login-container">
            <h2 class="login-title">Tam High MTB Team</h2>
            <p id="login-subtitle" class="login-subtitle">Sign in to access the practice manager</p>
            
            <div id="auth-error" class="error-message" style="display: none;"></div>
            
            <!-- Simplified Login Form (for riders/coaches) -->
            <div id="simplified-login-form" style="display: none;">
                <form onsubmit="event.preventDefault(); handleSimplifiedLogin(); return false;" style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label class="field-label" for="simplified-login-input">Phone or Email</label>
                        <input type="text" id="simplified-login-input" class="modal-field-input" placeholder="Enter phone number or email address" autocomplete="tel email" required>
                    </div>
                    <button type="submit" class="btn-small" style="width: 100%; margin-top: 8px;" id="simplified-login-button">Send Verification Code</button>
                    <div style="text-align: center; margin-top: 16px;">
                        <a href="#" class="auth-link" onclick="event.preventDefault(); showAdminLogin();">Admin Login</a>
                    </div>
                </form>
            </div>
            
            <!-- Verification Code Form (appears after code is sent) -->
            <div id="verification-code-form" style="display: none;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 8px;" id="verification-code-message">
                        We've sent a verification code to <strong id="verification-phone-email"></strong>. Please enter it below.
                    </p>
                    <div>
                        <label class="field-label" for="verification-code-input">Verification Code</label>
                        <input type="text" id="verification-code-input" class="modal-field-input" placeholder="Enter 6-digit code" maxlength="6" pattern="[0-9]{6}" required style="text-align: center; font-size: 24px; letter-spacing: 8px; font-weight: bold;" onkeypress="if(event.key === 'Enter') handleVerifyCode()">
                    </div>
                    <button type="button" class="btn-small" style="width: 100%; margin-top: 8px;" id="verify-code-button" onclick="handleVerifyCode()">Verify Code</button>
                    <div style="text-align: center; margin-top: 12px;">
                        <a href="#" class="auth-link" id="resend-code-link" onclick="event.preventDefault(); handleResendVerificationCode();">Resend Code</a>
                        <span style="margin: 0 8px;">|</span>
                        <a href="#" class="auth-link" onclick="event.preventDefault(); showSimplifiedLogin();">Change Phone/Email</a>
                    </div>
                </div>
            </div>
            
            <!-- Admin Login Form -->
            <div id="login-form">
                <form onsubmit="event.preventDefault(); handleLogin(); return false;" style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label class="field-label" for="login-email">Email</label>
                        <input type="email" id="login-email" class="modal-field-input" placeholder="your@email.com" autocomplete="email" required>
                    </div>
                    <div>
                        <label class="field-label" for="login-password">Password</label>
                        <input type="password" id="login-password" class="modal-field-input" placeholder="Password" autocomplete="current-password" required>
                    </div>
                    <button type="submit" class="btn-small" style="width: 100%; margin-top: 8px;">Sign In</button>
                    <div style="text-align: center; margin-top: 8px;">
                        <a href="#" class="auth-link" onclick="event.preventDefault(); showPasswordReset();">Forgot password?</a>
                    </div>
                    <div id="resend-verification" style="text-align: center; margin-top: 8px; display: none;">
                        <a href="#" class="auth-link" onclick="event.preventDefault(); handleResendVerification();">Resend verification email</a>
                    </div>
                </form>
                
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                    <span style="font-size: 14px; color: #64748b;">Need Admin Access? </span>
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showAdminRequest();">Request</a>
                </div>
            </div>
            
            <div id="admin-request-form" style="display: none;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 8px;">To get admin access, you need to receive an invitation from an existing administrator. Please contact your team administrator to request access.</p>
                    <p style="font-size: 13px; color: #999; margin-top: 8px;">If you have received an invitation link, please use that link to create your account.</p>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showLogin();">Back to sign in</a>
                </div>
            </div>
            
            <div id="password-reset-form" style="display: none;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 8px;">Enter your email to receive a password reset link.</p>
                    <div>
                        <label class="field-label" for="reset-email">Email</label>
                        <input type="email" id="reset-email" class="modal-field-input" placeholder="your@email.com" autocomplete="email">
                    </div>
                    <button class="btn-small" onclick="handlePasswordReset()" style="width: 100%; margin-top: 8px;">Send Reset Link</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showLogin();">Back to sign in</a>
                </div>
            </div>
        </div>
    </div>

    <!-- ADD ROUTE MODAL -->
    <div id="routes-manager-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 1000px; width: min(1000px, 95%);">
            <div class="modal-header">
                <span>Manage Routes</span>
                <button class="btn-small secondary" onclick="closeRoutesManagerModal()">Close</button>
            </div>
            <div class="modal-body">
                <div id="routes-manager-list" style="max-height: 500px; overflow-y: auto;">
                    <!-- Routes list will be loaded dynamically -->
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 12px;">
                    <button class="btn-small" onclick="openAddRouteModal(null)" style="background-color: #fc5200; color: white; border-color: #fc5200;">Add Strava Route</button>
                    <button class="btn-small" onclick="openAddRouteModal(null, true)">Add Route</button>
                </div>
            </div>
        </div>
    </div>

    <div id="add-route-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header" id="add-route-modal-header" style="background-color: #fc5200; color: white;">
                <span id="add-route-modal-title">Add Strava Route</span>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="position: relative;">
                        <label for="route-embed-code" class="field-label" style="display: flex; align-items: center; gap: 6px;">
                            Strava Embed Code
                            <span class="info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background-color: #666; color: white; font-size: 11px; font-weight: bold; cursor: help; user-select: none;" onmouseenter="showEmbedCodeTooltip(event)" onmouseleave="hideEmbedCodeTooltip()">i</span>
                        </label>
                        <div id="embed-code-tooltip" style="position: absolute; background-color: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 10000; pointer-events: none; display: none; max-width: 300px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); white-space: normal; line-height: 1.4;">To get the embed code: Go to your Strava route page → Click the "Share" button → Copy the embed code</div>
                        <textarea id="route-embed-code" class="modal-field-input" rows="6" placeholder="Paste the Strava embed iframe code here..."></textarea>
                        <div id="fetch-route-data-container" style="margin-top: 12px;">
                            <button type="button" id="fetch-route-data-btn" class="btn-small" onclick="fetchRouteDataFromEmbed()" disabled>
                                🔍 Auto-fill Route Info from Strava
                            </button>
                            <span id="fetch-route-status" style="margin-left: 8px; font-size: 12px; color: #666;"></span>
                        </div>
                    </div>
                    <div>
                        <label for="route-name" class="field-label">Route Name</label>
                        <input type="text" id="route-name" class="modal-field-input" placeholder="Will be auto-filled from Strava, or enter manually">
                    </div>
                    <div class="form-row">
                        <div style="flex:1;">
                            <label for="route-distance" class="field-label">Distance (Optional)</label>
                            <input type="text" id="route-distance" class="modal-field-input" placeholder="Will be auto-filled from Strava">
                        </div>
                        <div style="flex:1;">
                            <label for="route-elevation" class="field-label">Elevation Gain (Optional)</label>
                            <input type="text" id="route-elevation" class="modal-field-input" placeholder="Will be auto-filled from Strava">
                        </div>
                    </div>
                    <div>
                        <label for="route-time" class="field-label" style="display: flex; align-items: center; gap: 8px;">
                            <span>Approximate time range to complete route</span>
                            <button type="button" onclick="openTimeEstimationSettings()" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; color: #666;" title="Time estimation settings">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"></path>
                                </svg>
                            </button>
                        </label>
                        <input type="text" id="route-time" class="modal-field-input" placeholder="Will be calculated from distance and elevation" readonly style="background-color: #f5f5f5; cursor: not-allowed;">
                    </div>
                    <div>
                        <label class="field-label">Most appropriate Relative Pace Range</label>
                        <div id="route-fitness-slider-container" style="position: relative; padding: 5px 0;">
                            <div id="route-fitness-slider-track" style="position: relative; height: 6px; background: #e0e0e0; border-radius: 3px; margin: 8px 0;">
                                <div id="route-fitness-slider-range" style="position: absolute; height: 100%; background: #2196F3; border-radius: 3px; left: 0%; width: 100%; top: 0;"></div>
                                <div id="route-fitness-min-handle" class="slider-handle" data-slider="fitness" data-type="min" style="position: absolute; left: 0%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <div id="route-fitness-max-handle" class="slider-handle" data-slider="fitness" data-type="max" style="position: absolute; left: 100%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <input type="range" id="route-fitness-min" min="1" max="5" value="1" step="1" style="display: none;" oninput="updateFitnessRange()">
                                <input type="range" id="route-fitness-max" min="2" max="5" value="5" step="1" style="display: none;" oninput="updateFitnessRange()">
                            </div>
                            <div id="route-fitness-labels" style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: #666;">
                                <!-- Labels will be generated dynamically -->
                            </div>
                            <div style="text-align: center; margin-top: 4px; font-size: 12px; font-weight: 600; color: #2196F3;">
                                <span id="route-fitness-min-value">1</span> - <span id="route-fitness-max-value">5</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label class="field-label">Most appropriate Bike Skills Range</label>
                        <div id="route-skills-slider-container" style="position: relative; padding: 5px 0;">
                            <div id="route-skills-slider-track" style="position: relative; height: 6px; background: #e0e0e0; border-radius: 3px; margin: 8px 0;">
                                <div id="route-skills-slider-range" style="position: absolute; height: 100%; background: #2196F3; border-radius: 3px; left: 0%; width: 100%; top: 0;"></div>
                                <div id="route-skills-min-handle" class="slider-handle" data-slider="skills" data-type="min" style="position: absolute; left: 0%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <div id="route-skills-max-handle" class="slider-handle" data-slider="skills" data-type="max" style="position: absolute; left: 100%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <input type="range" id="route-skills-min" min="1" max="3" value="1" step="1" style="display: none;" oninput="updateSkillsRange()">
                                <input type="range" id="route-skills-max" min="2" max="3" value="3" step="1" style="display: none;" oninput="updateSkillsRange()">
                            </div>
                            <div id="route-skills-labels" style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: #666;">
                                <!-- Labels will be generated dynamically -->
                            </div>
                            <div style="text-align: center; margin-top: 4px; font-size: 12px; font-weight: 600; color: #2196F3;">
                                <span id="route-skills-min-value">1</span> - <span id="route-skills-max-value">3</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label for="route-description" class="field-label">Notes (Optional)</label>
                        <textarea id="route-description" class="modal-field-input" rows="3" placeholder="Brief description of the route..."></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddRouteModal()">Cancel</button>
                <button class="btn-small" onclick="saveRoute()">Save Route</button>
            </div>
        </div>
    </div>

    <!-- Time Estimation Settings Modal -->
    <div id="time-estimation-settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <span>Time Estimation Settings</span>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <p style="font-size: 14px; color: #666; margin: 0;">Adjust the speed parameters used to calculate route completion time estimates. Changes apply to all routes.</p>
                    
                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0;">Base Speeds (mph)</h3>
                        <div class="form-row">
                            <div style="flex: 1;">
                                <label for="time-settings-fast-speed" class="field-label">Faster Rider Base Speed</label>
                                <input type="number" id="time-settings-fast-speed" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Base speed for faster riders (mph)</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-slow-speed" class="field-label">Slower Rider Base Speed</label>
                                <input type="number" id="time-settings-slow-speed" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Base speed for slower riders (mph)</small>
                            </div>
                        </div>
                        <div class="form-row" style="margin-top: 12px;">
                            <div style="flex: 1;">
                                <label for="time-settings-fast-min" class="field-label">Faster Rider Minimum Speed</label>
                                <input type="number" id="time-settings-fast-min" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Minimum speed regardless of conditions (mph)</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-slow-min" class="field-label">Slower Rider Minimum Speed</label>
                                <input type="number" id="time-settings-slow-min" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Minimum speed regardless of conditions (mph)</small>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0;">Adjustments</h3>
                        <div class="form-row">
                            <div style="flex: 1;">
                                <label for="time-settings-elevation" class="field-label">Elevation Adjustment</label>
                                <input type="number" id="time-settings-elevation" class="modal-field-input" step="0.1" min="0" max="5" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Speed reduction (mph) per 1000 ft of elevation gain</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-length" class="field-label">Length Adjustment Factor</label>
                                <input type="number" id="time-settings-length" class="modal-field-input" step="0.01" min="0" max="1" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Speed reduction (mph) per mile over 10 miles</small>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <button class="btn-small secondary" onclick="resetTimeEstimationSettings()">Reset to Defaults</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="discardTimeEstimationSettings()">Discard Changes</button>
                <button class="btn-small" onclick="saveTimeEstimationSettings()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Practice Context Menu -->
    <div id="practice-context-menu" class="context-menu" style="display: none; position: absolute; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 10000; min-width: 180px;">
        <button class="context-menu-item" onclick="deletePracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Delete Practice</button>
        <button class="context-menu-item" onclick="cancelPracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Cancel Practice</button>
        <button id="restore-practice-btn" class="context-menu-item" onclick="restoreCancelledPractice()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333; display: none;">Restore Practice</button>
        <button class="context-menu-item" onclick="reschedulePracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Reschedule Practice</button>
    </div>
    
    <!-- Pace/Skills Badge Context Menu -->
    <div id="badge-context-menu" class="context-menu" style="display: none; position: fixed; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 10001; min-width: 150px;">
        <button class="context-menu-item" id="badge-increase-btn" onclick="handleBadgeAdjust('increase')" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333; border-bottom: 1px solid #eee;">Increase</button>
        <button class="context-menu-item" id="badge-decrease-btn" onclick="handleBadgeAdjust('decrease')" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Decrease</button>
    </div>
    
    <div id="coach-move-context-menu" class="context-menu" style="display: none; position: absolute; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 10000; min-width: 180px;">
        <div id="coach-move-role-options"></div>
        <hr style="margin: 4px 0; border: none; border-top: 1px solid #ddd;">
        <div id="coach-move-group-options"></div>
    </div>

    <!-- Cancel Practice Modal -->
    <div id="cancel-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span>Cancel Practice</span>
                <button class="btn-small secondary" onclick="closeCancelPracticeModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <p style="font-size: 14px; color: #666; margin: 0;">Please select a reason for cancelling this practice:</p>
                    <div>
                        <label for="cancel-reason" class="field-label">Cancellation Reason</label>
                        <select id="cancel-reason" class="modal-field-input">
                            <option value="Weather">Weather</option>
                            <option value="Staffing">Staffing</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeCancelPracticeModal()">Cancel</button>
                <button class="btn-small" onclick="confirmCancelPractice()" style="background-color: #f44336; color: white; border-color: #f44336;">Cancel Practice</button>
            </div>
        </div>
    </div>

    <!-- Clone Practice Modal -->
    <div id="clone-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <span>Clone Entire Practice</span>
                <button class="btn-small secondary" onclick="closeClonePracticeModal()">Close</button>
            </div>
            <div class="modal-body">
                <p style="font-size: 14px; color: #666; margin: 0 0 16px 0;">
                    Select a practice date to clone. This will copy all groups, assignments, and attendance settings to the current practice date.
                </p>
                <div id="clone-practice-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">
                    <!-- Practice list will be populated here -->
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeClonePracticeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Reschedule Practice Modal -->
    <div id="reschedule-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span>Reschedule Practice</span>
                <button class="btn-small secondary" onclick="closeReschedulePracticeModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label for="reschedule-date" class="field-label">New Date</label>
                        <input type="date" id="reschedule-date" class="modal-field-input">
                    </div>
                    <div class="form-row">
                        <div style="flex: 1;">
                            <label for="reschedule-time" class="field-label">Time</label>
                            <input type="time" id="reschedule-time" class="modal-field-input">
                        </div>
                        <div style="flex: 1;">
                            <label for="reschedule-end-time" class="field-label">End Time</label>
                            <input type="time" id="reschedule-end-time" class="modal-field-input">
                        </div>
                    </div>
                    <div>
                        <label for="reschedule-location" class="field-label">Location</label>
                        <input type="text" id="reschedule-location" class="modal-field-input" placeholder="Enter location">
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeReschedulePracticeModal()">Cancel</button>
                <button class="btn-small" onclick="confirmReschedulePractice()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Reschedule</button>
            </div>
        </div>
    </div>

    <!-- Google Sheets Sync Modal -->
    <div id="google-sheets-modal" class="modal-overlay" aria-hidden="true" style="display: none;">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <span id="google-sheets-modal-title">Sync from Google Sheet</span>
                <button class="btn-small secondary" onclick="closeGoogleSheetsModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <!-- Simple Option: Public Sheet -->
                    <div style="padding: 12px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #2e7d32;">✓ Easiest Option: Make Sheet Viewable by Link</div>
                        <div style="font-size: 12px; color: #666; line-height: 1.5; margin-bottom: 8px;">
                            <strong>No setup required!</strong> Just make your Google Sheet viewable:
                            <ol style="margin: 8px 0; padding-left: 20px;">
                                <li>Open your Google Sheet</li>
                                <li>Click <strong>"Share"</strong> button (top right)</li>
                                <li>Change to <strong>"Anyone with the link"</strong> → <strong>"Viewer"</strong></li>
                                <li>Click <strong>"Done"</strong></li>
                            </ol>
                            The sheet will be readable but not editable by others. This works immediately with no configuration!
                        </div>
                    </div>
                    
                    <!-- Google Sheet URL -->
                    <div>
                        <label class="field-label">Google Sheet URL:</label>
                        <input type="text" id="modal-google-sheet-url" placeholder="https://docs.google.com/spreadsheets/d/..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" value="">
                        <button class="btn-small" onclick="saveModalGoogleSheetUrl()" style="margin-top: 8px; padding: 6px 12px;">Save Link</button>
                    </div>
                    
                    <!-- Advanced Option: Private Sheet with OAuth (Collapsible) -->
                    <details style="padding: 12px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 4px;">
                        <summary style="font-weight: 600; cursor: pointer; color: #e65100; margin-bottom: 8px;">Advanced: Access Private Sheets (Requires Setup)</summary>
                        <div style="margin-top: 12px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 12px;">
                                If you need to keep the sheet completely private, you can set up Google OAuth. This requires a free Google Cloud account (no paid subscription needed).
                            </div>
                            
                            <!-- Google OAuth Client ID Configuration -->
                            <div style="padding: 12px; background: #fff; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px;">
                                <label class="field-label" style="margin-bottom: 8px; display: block;">Google OAuth Client ID:</label>
                                <input type="text" id="modal-google-client-id" placeholder="Enter your Google OAuth Client ID" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 8px;" value="">
                                <button class="btn-small" onclick="saveGoogleClientId()" style="padding: 6px 12px; margin-bottom: 8px;">Save Client ID</button>
                                <div style="font-size: 11px; color: #666; line-height: 1.4;">
                                    <strong>Free Setup (5 minutes):</strong><br>
                                    1. Go to <a href="https://console.cloud.google.com/" target="_blank" style="color: #2196F3;">Google Cloud Console</a> (free account)<br>
                                    2. Create a project (free)<br>
                                    3. Enable "Google Sheets API" (free)<br>
                                    4. Create OAuth 2.0 credentials → Web application (free)<br>
                                    5. Add your domain to authorized origins<br>
                                    6. Copy the Client ID and paste above
                                </div>
                            </div>
                            
                            <!-- Google Authorization -->
                            <div style="padding: 12px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <label class="field-label" style="margin: 0;">Google Access:</label>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span id="modal-google-auth-status" style="font-size: 12px; color: #666;">Not authorized</span>
                                        <button id="modal-google-auth-btn" class="btn-small" onclick="requestGoogleAuthorization()" style="padding: 6px 12px; background: #4285f4; color: white; border: none;">Sign in with Google</button>
                                    </div>
                                </div>
                                <div style="font-size: 12px; color: #666;">
                                    After saving your Client ID above, click "Sign in with Google" to authorize access.
                                </div>
                            </div>
                        </div>
                    </details>
                    
                    <!-- Info Note -->
                    <div style="padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 12px; color: #856404;">
                        <div id="modal-google-sheets-note"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeGoogleSheetsModal()">Cancel</button>
                <button id="modal-sync-button" class="btn-small" onclick="syncFromModal()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Sync Now</button>
            </div>
        </div>
    </div>

    <!-- CSV Field Mapping Modal -->
    <div id="csv-field-mapping-modal" class="modal-overlay" aria-hidden="true" style="display: none;" onclick="if(event.target === this) closeCSVFieldMappingModal();">
        <div class="modal" style="max-width: 900px; max-height: 90vh; overflow-y: auto;" onclick="event.stopPropagation();">
            <div class="modal-header">
                <span id="csv-mapping-modal-title">Map CSV Fields</span>
                <button class="btn-small secondary" onclick="closeCSVFieldMappingModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 16px; padding: 12px; background: #e3f2fd; border: 1px solid #2196F3; border-radius: 4px; font-size: 12px;">
                    <strong>Instructions:</strong> Check the boxes for fields you want to import, and select which CSV column maps to each field. 
                    Program-dependent fields (Pace, Bike Skills, Ride Group, Photo, Notes) can be mapped but cannot be unchecked.
                    Select "-- None --" to leave a field blank or use default values.
                </div>
                
                <!-- Name Format Selection -->
                <div style="margin-bottom: 16px; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">
                    <label class="field-label" style="margin-bottom: 8px; display: block;">Name Format:</label>
                    <div style="display: flex; gap: 16px; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="radio" name="name-format" id="name-format-split" value="split" checked>
                            <span>First Name + Last Name (separate fields)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="radio" name="name-format" id="name-format-single" value="single">
                            <span>Single Name Field</span>
                        </label>
                    </div>
                </div>
                
                <div id="csv-field-mapping-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- Field mappings will be generated here -->
                </div>
                
                <!-- Additional Fields Section -->
                <div id="additional-fields-section" style="margin-top: 24px; padding: 12px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <label class="field-label" style="margin: 0;">Additional Fields (map unassigned CSV columns):</label>
                        <button type="button" class="btn-small" onclick="addAdditionalFieldMapping()" style="padding: 4px 12px; font-size: 12px;">+ Add Field</button>
                    </div>
                    <div id="additional-fields-list" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Additional field mappings will be added here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeCSVFieldMappingModal()">Cancel</button>
                <button class="btn-small" onclick="applyCSVFieldMapping()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Apply Mapping & Import</button>
            </div>
        </div>
    </div>

    <script>
        // Debug logging control (use ?debug=1 or local file to enable verbose logs)
        const DEBUG_LOGS = new URLSearchParams(window.location.search).has('debug') || window.location.protocol === 'file:';
        if (!DEBUG_LOGS) {
            const originalLog = console.log;
            const originalInfo = console.info;
            console.log = () => {};
            console.info = () => {};
            // Preserve originals in case needed elsewhere
            console._originalLog = originalLog;
            console._originalInfo = originalInfo;
        }
        // Data storage
        let data = {
            riders: [],
            coaches: [],
            rides: [],
            routes: [],
            races: [],
            currentRide: null,
            seasonSettings: {
                startDate: '',
                endDate: '',
                practices: [],
                fitnessScale: 5,  // Default: 5 increments (1-5)
                skillsScale: 3,   // Default: 3 increments (1-3)
                paceScaleOrder: 'fastest_to_slowest',
                groupPaceOrder: 'fastest_to_slowest'
            },
            coachRoles: [],  // Array of { roleName: string, coachId: number }
            riderRoles: [],  // Array of { roleName: string, riderId: number }
            timeEstimationSettings: {
                fastSpeedBase: 12.5,      // mph - faster rider base speed
                slowSpeedBase: 10,        // mph - slower rider base speed
                fastSpeedMin: 5.5,        // mph - minimum speed for faster rider
                slowSpeedMin: 4,          // mph - minimum speed for slower rider
                elevationAdjustment: 0.5, // mph reduction per 1000 ft elevation
                lengthAdjustmentFactor: 0.1 // mph reduction per mile over 10 miles
            },
            autoAssignSettings: {
                parameters: [
                    { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 1, enabled: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' },
                    { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 2, enabled: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                    { id: 'preferredCoachesPerGroup', name: 'Preferred Coaches per Group', value: 3, priority: 3, enabled: true, type: 'number', min: 1, max: 10, description: 'Target number of coaches per group' },
                    { id: 'preferredGroupSize', name: 'Preferred Group Size Range', valueMin: 4, valueMax: 8, priority: 4, enabled: true, type: 'range', min: 1, max: 30, description: 'Preferred number of riders per group (min-max range)' }
                ]
            },
        };

        let practiceReportingRideIndex = null;
        let practiceReportingSortDirection = 'asc';

        let autoAssignDebugLog = '';
        let autoAssignSettingsDraft = null;
        
        // Global state for group section collapse/expand (synchronized across all groups)
        let groupSectionsState = {
            coaches: true,  // true = expanded, false = collapsed
            riders: true,
            route: true
        };
        let seasonSettingsDraft = null;

        let isReadOnlyMode = false;
        window.isReadOnlyMode = false;
        let readOnlyLockInfo = null;
        let readOnlyNoticeShown = false;
        let adminEditLockInterval = null;
        let unassignedPaletteVisibility = 'auto'; // 'auto' | 'show' | 'hide'
        let unassignedPaletteHeight = 300;

        
        // Helper functions to get rating scales
        function getFitnessScale() {
            return (data.seasonSettings && data.seasonSettings.fitnessScale) ? data.seasonSettings.fitnessScale : 5;
        }
        
        function getSkillsScale() {
            const scale = (data.seasonSettings && data.seasonSettings.skillsScale) ? data.seasonSettings.skillsScale : 3;
            // Only allow 3 or 5
            return (scale === 3 || scale === 5) ? scale : 3;
        }

        function normalizePaceScaleOrder(value, fallback = 'fastest_to_slowest') {
            if (value === 'fastest_to_slowest' || value === 'slowest_to_fastest') {
                return value;
            }
            return fallback;
        }

        function getPaceScaleOrder() {
            return normalizePaceScaleOrder(data.seasonSettings && data.seasonSettings.paceScaleOrder);
        }

        function normalizeGroupPaceOrder(value, fallback = 'fastest_to_slowest') {
            if (value === 'fastest_to_slowest' || value === 'slowest_to_fastest') {
                return value;
            }
            return fallback;
        }

        function getGroupPaceOrderForRide(ride) {
            return normalizeGroupPaceOrder(ride?.groupPaceOrder || data.seasonSettings?.groupPaceOrder);
        }

        function getGroupPaceComparator(ride) {
            const groupPaceOrder = getGroupPaceOrderForRide(ride);
            const sortDescending = groupPaceOrder === 'fastest_to_slowest';
            return (a, b) => {
                const fitnessA = getGroupFitnessScore(a);
                const fitnessB = getGroupFitnessScore(b);
                if (fitnessB !== fitnessA) return sortDescending ? (fitnessB - fitnessA) : (fitnessA - fitnessB);
                const sizeDiff = b.riders.length - a.riders.length;
                if (sizeDiff !== 0) return sizeDiff;
                return a.id - b.id;
            };
        }

        function invertPaceValue(value, scale) {
            return scale + 1 - value;
        }

        function getRelativePaceValue(value) {
            const scale = getFitnessScale();
            const normalized = normalizePaceScaleOrder(data.seasonSettings && data.seasonSettings.paceScaleOrder);
            if (!Number.isFinite(value)) return value;
            return normalized === 'fastest_to_slowest' ? invertPaceValue(value, scale) : value;
        }

        async function flipPaceValuesOnce() {
            const fitnessScale = getFitnessScale();
            const confirmed = confirm(`This will invert all rider and coach pace values across a 1-${fitnessScale} scale.\n\nExample: 1 ↔ ${fitnessScale}, 2 ↔ ${fitnessScale - 1}.\n\nContinue?`);
            if (!confirmed) return;

            let convertedCount = 0;
            let savedCount = 0;
            const applyInversion = (entry) => {
                const oldValue = parseInt(entry.fitness, 10);
                if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= fitnessScale) {
                    entry.fitness = String(invertPaceValue(oldValue, fitnessScale));
                    convertedCount++;
                    return true;
                }
                return false;
            };

            if (data.riders) {
                for (const rider of data.riders) {
                    if (rider.fitness && applyInversion(rider)) {
                        await saveRiderToDB(rider);
                        savedCount++;
                    }
                }
            }

            if (data.coaches) {
                for (const coach of data.coaches) {
                    if (coach.fitness && applyInversion(coach)) {
                        await saveCoachToDB(coach);
                        savedCount++;
                    }
                }
            }

            alert(`Flipped ${convertedCount} pace value(s) and saved ${savedCount} updates.`);
        }

        function convertAllPaceRatingsForOrderChange(oldOrder, newOrder, scale) {
            const normalizedOld = normalizePaceScaleOrder(oldOrder);
            const normalizedNew = normalizePaceScaleOrder(newOrder);
            if (normalizedOld === normalizedNew) return 0;

            let convertedCount = 0;
            const applyInversion = (entry) => {
                const oldValue = parseInt(entry.fitness, 10);
                if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= scale) {
                    entry.fitness = String(invertPaceValue(oldValue, scale));
                    convertedCount++;
                }
            };

            if (data.riders) {
                data.riders.forEach(rider => {
                    if (rider.fitness) {
                        applyInversion(rider);
                    }
                });
            }

            if (data.coaches) {
                data.coaches.forEach(coach => {
                    if (coach.fitness) {
                        applyInversion(coach);
                    }
                });
            }

            return convertedCount;
        }
        
        // Get tooltip text for bike skills level based on scale
        function getBikeSkillsTooltip(level, scale) {
            if (!scale) scale = getSkillsScale();
            
            if (scale === 3) {
                // 3-level scale: Beginner, Intermediate, Advanced
                if (level === 1) {
                    return 'Beginner (NICA Level 1–2)\nRiders are building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.';
                } else if (level === 2) {
                    return 'Intermediate (NICA Level 3)\nRiders are comfortable on varied trails and can manage sustained climbs, descents, and common trail features such as roots, rocks, and uneven surfaces. They demonstrate consistent bike control, thoughtful line choice, and the ability to ride predictably within a group.';
                } else if (level === 3) {
                    return 'Advanced (NICA Level 4–5)\nRiders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.';
                }
            } else if (scale === 5) {
                // 5-level scale: map to NICA levels more granularly
                if (level === 1) {
                    return 'Beginner (NICA Level 1)\nRiders are building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.';
                } else if (level === 2) {
                    return 'Beginner+ (NICA Level 2)\nRiders continue building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.';
                } else if (level === 3) {
                    return 'Intermediate (NICA Level 3)\nRiders are comfortable on varied trails and can manage sustained climbs, descents, and common trail features such as roots, rocks, and uneven surfaces. They demonstrate consistent bike control, thoughtful line choice, and the ability to ride predictably within a group.';
                } else if (level === 4) {
                    return 'Advanced (NICA Level 4)\nRiders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.';
                } else if (level === 5) {
                    return 'Advanced+ (NICA Level 5)\nRiders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.';
                }
            }
            return '';
        }
        
        // Get formatted level descriptions for display on team dashboard
        function getBikeSkillsLevelDescriptions(scale) {
            if (!scale) scale = getSkillsScale();
            
            if (scale === 3) {
                return [
                    { level: 1, label: 'Level 1: Beginner (NICA Level 1–2)', description: 'Riders are building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.' },
                    { level: 2, label: 'Level 2: Intermediate (NICA Level 3)', description: 'Riders are comfortable on varied trails and can manage sustained climbs, descents, and common trail features such as roots, rocks, and uneven surfaces. They demonstrate consistent bike control, thoughtful line choice, and the ability to ride predictably within a group.' },
                    { level: 3, label: 'Level 3: Advanced (NICA Level 4–5)', description: 'Riders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.' }
                ];
            } else if (scale === 5) {
                return [
                    { level: 1, label: 'Level 1: Beginner (NICA Level 1)', description: 'Riders are building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.' },
                    { level: 2, label: 'Level 2: Beginner+ (NICA Level 2)', description: 'Riders continue building foundational skills and confidence. The focus is on safe braking, smooth shifting, proper body position, and maintaining control at lower speeds.' },
                    { level: 3, label: 'Level 3: Intermediate (NICA Level 3)', description: 'Riders are comfortable on varied trails and can manage sustained climbs, descents, and common trail features such as roots, rocks, and uneven surfaces. They demonstrate consistent bike control, thoughtful line choice, and the ability to ride predictably within a group.' },
                    { level: 4, label: 'Level 4: Advanced (NICA Level 4)', description: 'Riders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.' },
                    { level: 5, label: 'Level 5: Advanced+ (NICA Level 5)', description: 'Riders confidently navigate demanding terrain with steep grades, tight turns, and complex trail conditions. They ride efficiently and composed at higher speeds, showing advanced handling skills, strong endurance, and sound tactical awareness in group and race-like settings.' }
                ];
            }
            return [];
        }
        
        // Update the bike skills descriptions display on team dashboard
        function updateBikeSkillsDescriptions() {
            const container = document.getElementById('bike-skills-descriptions');
            if (!container) return;
            
            const scale = getSkillsScale();
            const descriptions = getBikeSkillsLevelDescriptions(scale);
            
            if (descriptions.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            let html = '<div style="font-weight: 600; margin-bottom: 8px; color: #333;">Bike Skills Level Descriptions:</div>';
            descriptions.forEach(desc => {
                html += `
                    <div style="margin-bottom: 10px; padding: 8px; background: white; border-left: 3px solid #2196F3; border-radius: 2px;">
                        <div style="font-weight: 600; color: #2196F3; margin-bottom: 4px;">${escapeHtml(desc.label)}</div>
                        <div style="color: #555;">${escapeHtml(desc.description)}</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Convert a value from one scale to another (proportional conversion)
        function convertScale(value, oldMax, newMax) {
            if (oldMax === newMax) return value;
            if (value < 1) return 1;
            if (value > oldMax) value = oldMax;
            // Convert proportionally: (value - 1) / (oldMax - 1) * (newMax - 1) + 1
            const proportion = (value - 1) / (oldMax - 1);
            const newValue = Math.round(proportion * (newMax - 1) + 1);
            return Math.max(1, Math.min(newMax, newValue));
        }
        
        // Special conversion function for bike skills (3-level ↔ 5-level)
        // Maps NICA levels correctly:
        // 3-level: 1=Beginner, 2=Intermediate, 3=Advanced
        // 5-level: 1=Beginner, 2=Beginner+, 3=Intermediate, 4=Advanced, 5=Advanced+
        function convertBikeSkillsScale(value, oldScale, newScale) {
            if (oldScale === newScale) return value;
            if (value < 1) return 1;
            if (value > oldScale) value = oldScale;
            
            // Only handle 3 ↔ 5 conversions
            if ((oldScale === 3 && newScale === 5) || (oldScale === 5 && newScale === 3)) {
                if (oldScale === 3 && newScale === 5) {
                    // 3-level to 5-level: 1→1, 2→3, 3→5
                    const mapping = { 1: 1, 2: 3, 3: 5 };
                    return mapping[value] || value;
                } else {
                    // 5-level to 3-level: 1→1, 2→1, 3→2, 4→3, 5→3
                    const mapping = { 1: 1, 2: 1, 3: 2, 4: 3, 5: 3 };
                    return mapping[value] || value;
                }
            }
            
            // For other conversions, use proportional conversion
            return convertScale(value, oldScale, newScale);
        }
        
        // Helper functions to get auto-assignment settings
        function getAutoAssignSetting(id, defaultValue) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return defaultValue;
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return defaultValue;
            return param.value;
        }

        // Get range parameter min value
        function getAutoAssignSettingMin(id, defaultValue) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return defaultValue;
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return defaultValue;
            return param.valueMin || param.min || defaultValue;
        }

        // Get range parameter max value
        function getAutoAssignSettingMax(id, defaultValue) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return defaultValue;
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return defaultValue;
            return param.valueMax || param.max || defaultValue;
        }
        
        // Get priority of a parameter (lower number = higher priority)
        function getParamPriority(id) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return 999; // Low priority if not found
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return 999;
            return param.priority;
        }
        
        // Get all enabled parameters sorted by priority (requirements first)
        function getEnabledParamsByPriority() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled)
                .sort((a, b) => {
                    // Requirements always come first
                    if (a.requirement && !b.requirement) return -1;
                    if (!a.requirement && b.requirement) return 1;
                    // Then sort by priority
                    return a.priority - b.priority;
                });
        }
        
        // Get all requirements sorted by priority
        function getRequirements() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled && p.requirement)
                .sort((a, b) => a.priority - b.priority);
        }
        
        // Get all preferences sorted by priority
        function getPreferences() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled && !p.requirement)
                .sort((a, b) => a.priority - b.priority);
        }
        
        // Check if constraint A can be relaxed in favor of constraint B
        function canRelaxConstraint(constraintAId, constraintBId) {
            return getParamPriority(constraintAId) > getParamPriority(constraintBId);
        }
        
        // Legacy constants for backward compatibility (now use getAutoAssignSetting)
        function getMIN_GROUP_SIZE() { 
            const param = data.autoAssignSettings?.parameters?.find(p => p.id === 'preferredGroupSize');
            return param?.valueMin || 4; 
        }
        function getMAX_FITNESS_SPREAD() { return getAutoAssignSetting('organizeByPace', 2); }
        const DAYS_OF_WEEK = [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ];

        const COACH_NAMES_MALE = [
            'Alex Johnson', 'David Patel', 'Owen McCarthy', 'Cole Ramirez', 'Marcus Lee',
            'Noah Foster', 'Declan Scott', 'Gavin Brooks', 'Ryan Mitchell', 'James Wilson',
            'Michael Thompson', 'Christopher Davis', 'Daniel Martinez', 'Matthew Anderson'
        ];
        
        const COACH_NAMES_FEMALE = [
            'Maria Chen', 'Lisa Hernandez', 'Priya Singh', 'Jenna King', 'Emily Baker',
            'Harper Wright', 'Sofia Navarro', 'Sarah Johnson', 'Jessica Taylor', 'Amanda White',
            'Jennifer Brown', 'Nicole Garcia', 'Rachel Martinez', 'Lauren Rodriguez'
        ];
        
        const COACH_NAMES = [...COACH_NAMES_MALE, ...COACH_NAMES_FEMALE];

        const COACH_NOTES = [
            'Focuses on fundamentals and beginner confidence.',
            'Great with route planning and pacing.',
            'Specializes in technical climbing drills.',
            'Leads safety briefings and mechanical checks.',
            'Encourages endurance development on long rides.'
        ];

        const COACH_FITNESS_SAMPLES = [1, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9, 10];

        const RIDER_NAMES_MALE = [
            'Ethan Cole', 'Logan Price', 'Wyatt Brooks', 'Benjamin Ortiz', 'Caleb Jordan',
            'Landon Hayes', 'Julian Foster', 'Isaiah Blake', 'Xavier Dunn', 'Grayson Tate',
            'Leo Ramirez', 'Connor Walsh', 'Miles Curtis', 'Sebastian Ford', 'Jordan Knox',
            'Noah Parker', 'Lucas Bennett', 'Owen Carter', 'Mason Reed', 'Ethan Mitchell',
            'Aiden Cooper', 'Jackson Hill', 'Liam Walker', 'Hunter Scott', 'Carter Johnson',
            'Tyler Davis', 'Ryan Martinez', 'Nathan Brown', 'Dylan Wilson', 'Cole Anderson',
            'Blake Taylor', 'Jake Thompson', 'Luke Garcia'
        ];
        
        const RIDER_NAMES_FEMALE = [
            'Mia Torres', 'Ava Reed', 'Chloe Sanders', 'Layla Kim', 'Nora Fields',
            'Scarlett Evans', 'Zoe McCoy', 'Riley Porter', 'Paisley Grant', 'Brooklyn Shaw',
            'Piper Klein', 'Sage Elliott', 'Ellie Benson', 'Adeline Harper', 'Mila Lawson',
            'Sophia Martinez', 'Emma Davis', 'Olivia Wilson', 'Isabella Garcia', 'Amelia Rodriguez',
            'Charlotte Brown', 'Harper Lee', 'Evelyn Taylor', 'Abigail Moore'
        ];
        
        const RIDER_NAMES = [...RIDER_NAMES_MALE, ...RIDER_NAMES_FEMALE];

        const RIDER_NOTES = [
            'Consistent climber with strong endurance.',
            'Working on cornering technique.',
            'Prefers technical terrain and rock gardens.',
            'Great with group communication and morale.',
            'Developing sprint speed for race finishes.'
        ];

        const RIDER_FITNESS_SAMPLES = [
            1, 2,
            3, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5,
            6, 6, 6, 6, 6,
            7, 7, 7,
            8, 8,
            9,
            10
        ];
        const RIDER_GENDER_SAMPLES = ['M', 'F'];


        function buildDefaultSeasonSettings() {
            return {
                startDate: '',
                endDate: '',
                practices: [],
                fitnessScale: 5,
                skillsScale: 3,
                paceScaleOrder: 'fastest_to_slowest',
                groupPaceOrder: 'fastest_to_slowest'
            };
        }
        
        // Convert all fitness and skills ratings when scales change
        function convertAllRatingsToNewScales(oldFitnessScale, newFitnessScale, oldSkillsScale, newSkillsScale) {
            let convertedCount = 0;
            
            // Convert rider fitness and skills
            if (data.riders) {
                data.riders.forEach(rider => {
                    if (rider.fitness && oldFitnessScale !== newFitnessScale) {
                        const oldValue = parseInt(rider.fitness, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldFitnessScale) {
                            rider.fitness = String(convertScale(oldValue, oldFitnessScale, newFitnessScale));
                            convertedCount++;
                        }
                    }
                    if (rider.skills && oldSkillsScale !== newSkillsScale) {
                        const oldValue = parseInt(rider.skills, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldSkillsScale) {
                            rider.skills = String(convertBikeSkillsScale(oldValue, oldSkillsScale, newSkillsScale));
                            convertedCount++;
                        }
                    }
                });
            }
            
            // Convert coach fitness and skills
            if (data.coaches) {
                data.coaches.forEach(coach => {
                    if (coach.fitness && oldFitnessScale !== newFitnessScale) {
                        const oldValue = parseInt(coach.fitness, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldFitnessScale) {
                            coach.fitness = String(convertScale(oldValue, oldFitnessScale, newFitnessScale));
                            convertedCount++;
                        }
                    }
                    if (coach.skills && oldSkillsScale !== newSkillsScale) {
                        const oldValue = parseInt(coach.skills, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldSkillsScale) {
                            coach.skills = String(convertBikeSkillsScale(oldValue, oldSkillsScale, newSkillsScale));
                            convertedCount++;
                        }
                    }
                });
            }
            
            if (convertedCount > 0) {
                alert(`Converted ${convertedCount} rating(s) to the new scale(s).`);
            }
        }
        
        // Update scale settings UI when changed
        // Update scale inputs from data object (called after data loads)
        // Only sets values if data.seasonSettings exists - doesn't initialize defaults
        // Defaults are only set when we confirm Supabase has no saved data
        function updateScaleInputsFromData() {
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const paceScaleOrderInput = document.getElementById('pace-scale-order');
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            
            if (!fitnessScaleInput || !skillsScaleInput) return; // Elements not in DOM yet
            
            // Only update if we have seasonSettings (either from Supabase or initialized with defaults)
            if (data.seasonSettings) {
                const savedFitnessScale = data.seasonSettings.fitnessScale;
                const savedSkillsScale = data.seasonSettings.skillsScale;
                const savedPaceScaleOrder = normalizePaceScaleOrder(data.seasonSettings.paceScaleOrder);
                
                // Only set values if they exist (don't set defaults here)
                if (savedFitnessScale !== undefined && savedFitnessScale !== null) {
                    fitnessScaleInput.value = savedFitnessScale;
                    fitnessScaleInput.setAttribute('value', savedFitnessScale);
                    if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = savedFitnessScale;
                }
                if (savedSkillsScale !== undefined && savedSkillsScale !== null) {
                    skillsScaleInput.value = savedSkillsScale;
                    if (skillsScaleDisplay) skillsScaleDisplay.textContent = savedSkillsScale;
                }
                if (paceScaleOrderInput) {
                    paceScaleOrderInput.value = savedPaceScaleOrder;
                }
                updateInputMaxAttributes();
            }
            // If data.seasonSettings doesn't exist, do nothing - inputs stay blank
        }
        
        function updateScaleSettings() {
            console.log('=== updateScaleSettings() CALLED ===');
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            const paceScaleOrderInput = document.getElementById('pace-scale-order');
            
            console.log('Inputs found:', { 
                fitnessScaleInput: !!fitnessScaleInput, 
                skillsScaleInput: !!skillsScaleInput,
                fitnessValue: fitnessScaleInput?.value,
                skillsValue: skillsScaleInput?.value
            });
            
            if (fitnessScaleInput && fitnessScaleDisplay) {
                fitnessScaleDisplay.textContent = fitnessScaleInput.value;
            }
            if (skillsScaleInput && skillsScaleDisplay) {
                // For select dropdown, get value from selected option
                const selectedValue = skillsScaleInput.value || skillsScaleInput.selectedOptions[0]?.value || '3';
                skillsScaleDisplay.textContent = selectedValue;
            }
            
            // Update input max attributes
            updateInputMaxAttributes();
            
            // Update bike skills descriptions
            updateBikeSkillsDescriptions();
            
            // Save the scale settings to data and localStorage
            if (fitnessScaleInput && skillsScaleInput) {
                const fitnessScale = parseInt(fitnessScaleInput.value, 10);
                const skillsScale = parseInt(skillsScaleInput.value, 10);
                const nextPaceScaleOrder = normalizePaceScaleOrder(paceScaleOrderInput?.value);
                
                console.log('updateScaleSettings - parsed values:', { fitnessScale, skillsScale });
                
                // Only save if values are valid (skills scale must be 3 or 5)
                if (Number.isFinite(fitnessScale) && fitnessScale >= 3 && fitnessScale <= 20 &&
                    Number.isFinite(skillsScale) && (skillsScale === 3 || skillsScale === 5)) {
                    
                    // Initialize seasonSettings if it doesn't exist
                    if (!data.seasonSettings) {
                        console.log('Initializing seasonSettings');
                        data.seasonSettings = buildDefaultSeasonSettings();
                    }
                    
                    // Update seasonSettings
                    const oldFitnessScale = data.seasonSettings.fitnessScale;
                    const oldSkillsScale = data.seasonSettings.skillsScale;
                    const oldPaceScaleOrder = normalizePaceScaleOrder(data.seasonSettings.paceScaleOrder, nextPaceScaleOrder);
                    
                    console.log('Before update:', { 
                        oldFitness: oldFitnessScale, 
                        oldSkills: oldSkillsScale,
                        currentData: JSON.stringify(data.seasonSettings)
                    });
                    
                    data.seasonSettings.fitnessScale = fitnessScale;
                    data.seasonSettings.skillsScale = skillsScale;
                    data.seasonSettings.paceScaleOrder = nextPaceScaleOrder;

                    if (oldPaceScaleOrder !== nextPaceScaleOrder) {
                        const convertedCount = convertAllPaceRatingsForOrderChange(oldPaceScaleOrder, nextPaceScaleOrder, fitnessScale);
                        if (convertedCount > 0) {
                            alert(`Reassigned ${convertedCount} pace rating(s) due to scale direction change.`);
                        }
                    }
                    
                    console.log('After update:', { 
                        newFitness: data.seasonSettings.fitnessScale,
                        newSkills: data.seasonSettings.skillsScale
                    });
                    
                    // Save to Supabase (saveData() will handle this for authenticated users)
                    saveData();
                    
                    // Note: Verification log removed - when authenticated, localStorage is not used
                } else {
                    console.warn('Invalid scale values, not saving:', { fitnessScale, skillsScale });
                }
            } else {
                console.error('Inputs not found!', { fitnessScaleInput, skillsScaleInput });
            }
        }

        // Synchronize scale settings across all locations
        async function syncScaleSettings() {
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const paceScaleOrderInput = document.getElementById('pace-scale-order');
            
            if (!fitnessScaleInput || !skillsScaleInput) {
                alert('Scale inputs not found. Please refresh the page.');
                return;
            }

            const fitnessScale = parseInt(fitnessScaleInput.value, 10);
            const skillsScale = parseInt(skillsScaleInput.value, 10);

            // Validate inputs
            if (!Number.isFinite(fitnessScale) || fitnessScale < 3 || fitnessScale > 20) {
                alert('Relative Pace scale must be between 3 and 20.');
                return;
            }
            if (!Number.isFinite(skillsScale) || skillsScale < 2 || skillsScale > 10) {
                alert('Skills scale must be between 2 and 10.');
                return;
            }

            try {
                // Initialize seasonSettings if it doesn't exist
                if (!data.seasonSettings) {
                    data.seasonSettings = buildDefaultSeasonSettings();
                }

                // Get old scales for conversion
                const oldFitnessScale = data.seasonSettings.fitnessScale || 5;
                const oldSkillsScale = data.seasonSettings.skillsScale || 3;

                // Update local seasonSettings
                data.seasonSettings.fitnessScale = fitnessScale;
                data.seasonSettings.skillsScale = skillsScale;
                if (paceScaleOrderInput) {
                    data.seasonSettings.paceScaleOrder = normalizePaceScaleOrder(paceScaleOrderInput.value);
                }

                // Convert existing data if scales changed
                if (fitnessScale !== oldFitnessScale || skillsScale !== oldSkillsScale) {
                    convertAllRatingsToNewScales(oldFitnessScale, fitnessScale, oldSkillsScale, skillsScale);
                }

                // Update UI displays
                const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
                const skillsScaleDisplay = document.getElementById('skills-scale-display');
                if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = fitnessScale;
                if (skillsScaleDisplay) skillsScaleDisplay.textContent = skillsScale;

                // Update input max attributes
                updateInputMaxAttributes();

                // Save to localStorage
                saveData();

                // Update Supabase if available
                if (typeof updateSeasonSettings === 'function') {
                    try {
                        await updateSeasonSettings({
                            id: 'current',
                            start_date: data.seasonSettings.startDate || null,
                            end_date: data.seasonSettings.endDate || null,
                            practices: data.seasonSettings.practices || [],
                            fitnessScale: fitnessScale,
                            skillsScale: skillsScale,
                            paceScaleOrder: normalizePaceScaleOrder(data.seasonSettings.paceScaleOrder),
                            groupPaceOrder: normalizeGroupPaceOrder(data.seasonSettings.groupPaceOrder)
                        });
                        console.log('Scale settings synced to Supabase');
                    } catch (error) {
                        console.warn('Could not sync scale settings to Supabase:', error);
                        // Continue anyway - local save succeeded
                    }
                }

                // Show success message
                alert(`Scale settings updated successfully!\n\nRelative Pace Scale: 1-${fitnessScale}\nSkills Scale: 1-${skillsScale}\n\nAll ratings have been converted to the new scales.`);

            } catch (error) {
                console.error('Error syncing scale settings:', error);
                alert('Error updating scale settings. Please try again.');
            }
        }
        
        // Update max attributes of fitness/skills inputs based on current scales
        function updateInputMaxAttributes() {
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            
            const coachFitnessInput = document.getElementById('edit-coach-fitness');
            const coachSkillsInput = document.getElementById('edit-coach-skills');
            const riderFitnessInput = document.getElementById('edit-rider-fitness');
            const riderSkillsInput = document.getElementById('edit-rider-skills');
            
            // Route fitness/skills range inputs
            const routeFitnessMin = document.getElementById('route-fitness-min');
            const routeFitnessMax = document.getElementById('route-fitness-max');
            const routeSkillsMin = document.getElementById('route-skills-min');
            const routeSkillsMax = document.getElementById('route-skills-max');
            
            if (coachFitnessInput) coachFitnessInput.max = fitnessScale;
            if (coachSkillsInput) coachSkillsInput.max = skillsScale;
            if (riderFitnessInput) riderFitnessInput.max = fitnessScale;
            if (riderSkillsInput) riderSkillsInput.max = skillsScale;
            
            // Update route range inputs
            if (routeFitnessMin) {
                routeFitnessMin.max = fitnessScale - 1; // Max is constrained by max input
                // Round to whole number and clamp to valid range
                let currentMin = Math.round(parseFloat(routeFitnessMin.value) || 1);
                currentMin = Math.max(1, Math.min(currentMin, fitnessScale - 1));
                routeFitnessMin.value = currentMin;
            }
            if (routeFitnessMax) {
                routeFitnessMax.max = fitnessScale;
                // Ensure min is at least 2 (min + 1)
                const currentMin = routeFitnessMin ? Math.round(parseFloat(routeFitnessMin.value) || 1) : 1;
                routeFitnessMax.min = Math.max(2, currentMin + 1);
                // Round to whole number and clamp to valid range
                let currentMax = Math.round(parseFloat(routeFitnessMax.value) || fitnessScale);
                currentMax = Math.max(routeFitnessMax.min, Math.min(currentMax, fitnessScale));
                routeFitnessMax.value = currentMax;
            }
            if (routeSkillsMin) {
                routeSkillsMin.max = skillsScale - 1; // Max is constrained by max input
                // Round to whole number and clamp to valid range
                let currentMin = Math.round(parseFloat(routeSkillsMin.value) || 1);
                currentMin = Math.max(1, Math.min(currentMin, skillsScale - 1));
                routeSkillsMin.value = currentMin;
            }
            if (routeSkillsMax) {
                routeSkillsMax.max = skillsScale;
                // Ensure min is at least 2 (min + 1)
                const currentMin = routeSkillsMin ? Math.round(parseFloat(routeSkillsMin.value) || 1) : 1;
                routeSkillsMax.min = Math.max(2, currentMin + 1);
                // Round to whole number and clamp to valid range
                let currentMax = Math.round(parseFloat(routeSkillsMax.value) || skillsScale);
                currentMax = Math.max(routeSkillsMax.min, Math.min(currentMax, skillsScale));
                routeSkillsMax.value = currentMax;
            }
            
            // Update slider visual positions after rounding values
            if (routeFitnessMin || routeFitnessMax) {
                updateFitnessRange();
            }
            if (routeSkillsMin || routeSkillsMax) {
                updateSkillsRange();
            }
        }
        
        // Update route slider scale labels dynamically
        function updateRouteSliderLabels() {
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            
            // Update fitness slider labels
            const fitnessLabelsContainer = document.getElementById('route-fitness-labels');
            if (fitnessLabelsContainer) {
                fitnessLabelsContainer.innerHTML = '';
                for (let i = 1; i <= fitnessScale; i++) {
                    const span = document.createElement('span');
                    span.textContent = i;
                    fitnessLabelsContainer.appendChild(span);
                }
            }
            
            // Update skills slider labels
            const skillsLabelsContainer = document.getElementById('route-skills-labels');
            if (skillsLabelsContainer) {
                skillsLabelsContainer.innerHTML = '';
                for (let i = 1; i <= skillsScale; i++) {
                    const span = document.createElement('span');
                    span.textContent = i;
                    skillsLabelsContainer.appendChild(span);
                }
            }
        }

        function generateId() {
            return Date.now() + Math.floor(Math.random() * 100000);
        }

        function normalizeCoachId(value) {
            const id = parseInt(value, 10);
            return Number.isFinite(id) ? id : null;
        }

        function normalizeTimeValue(value) {
            if (!value && value !== 0) return '';
            const stringValue = String(value).trim();
            const match = stringValue.match(/^(\d{1,2})(?::?(\d{2}))?$/);
            if (!match) {
                const parts = stringValue.split(':');
                if (parts.length >= 2) {
                    const hour = Math.max(0, Math.min(23, parseInt(parts[0], 10) || 0));
                    const minute = Math.max(0, Math.min(59, parseInt(parts[1], 10) || 0));
                    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                }
                return '';
            }

            const hour = Math.max(0, Math.min(23, parseInt(match[1], 10) || 0));
            const minute = Math.max(0, Math.min(59, parseInt(match[2] !== undefined ? match[2] : '0', 10) || 0));
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        function normalizePracticeEntry(entry) {
            if (!entry || typeof entry !== 'object') {
                return null;
            }

            const normalizedDay = Number.isFinite(entry.dayOfWeek)
                ? entry.dayOfWeek
                : Number.isFinite(entry.day)
                    ? entry.day
                    : Number.isFinite(entry.weekday)
                        ? entry.weekday
                        : parseInt(entry.dayOfWeek ?? entry.day ?? entry.weekday, 10);

            const dayOfWeek = Number.isFinite(normalizedDay) ? normalizedDay : NaN;
            if (!Number.isFinite(dayOfWeek) || dayOfWeek < 0 || dayOfWeek > 6) {
                return null;
            }

            const time = normalizeTimeValue(entry.time || entry.startTime || '');
            if (!time) {
                return null;
            }

            const endTime = normalizeTimeValue(entry.endTime || '');

            return {
                id: entry.id || generateId(),
                dayOfWeek,
                time,
                endTime,
                description: entry.description || '',
                meetLocation: entry.meetLocation || '',
                locationLat: entry.locationLat != null && Number.isFinite(parseFloat(entry.locationLat)) ? parseFloat(entry.locationLat) : null,
                locationLng: entry.locationLng != null && Number.isFinite(parseFloat(entry.locationLng)) ? parseFloat(entry.locationLng) : null,
                rosterFilter: entry.rosterFilter || null
            };
        }

        function createGroup(label) {
            return {
                id: generateId(),
                label,
                coaches: {
                    leader: null,
                    sweep: null,
                    roam: null,
                    extraRoam: []
                },
                riders: [],
                fitnessTag: null,
                sortBy: 'pace', // Default sort by pace
                routeId: null // Route assigned to this group
            };
        }

        function computeGroupsInfo(ride) {
            return ride.groups.map(group => {
                const capacity = groupCapacity(group);
                const preferredGroupSizeMin = getAutoAssignSettingMin('preferredGroupSize', 4);
                const preferredGroupSizeMax = getAutoAssignSettingMax('preferredGroupSize', 8);
                const preferredGroupSize = getAutoAssignSetting('preferredGroupSize', 7);
                
                // Determine target sizes based on priority order
                // Capacity (ridersPerCoach) is the absolute limit
                // preferredGroupSize range is used for constraints
                const baseMax = Math.min(preferredGroupSizeMax, capacity);
                const targetMax = Math.max(1, baseMax);
                const targetPreferred = Math.min(preferredGroupSize, targetMax);
                const targetMin = Math.min(preferredGroupSizeMin, targetPreferred);
                
                return {
                    group,
                    capacity,
                    targetMin,
                    targetPreferred,
                    targetMax,
                    fitness: group.fitnessTag != null ? parseInt(group.fitnessTag, 10) : null,
                    // Store priorities for decision making
                    preferredGroupSizePriority: getParamPriority('preferredGroupSize')
                };
            }).filter(info => info.capacity > 0);
        }

        function addExtraCoach(group, coachId) {
            if (!coachId) return;
            if (group.coaches.leader === coachId || group.coaches.sweep === coachId || group.coaches.roam === coachId) {
                return;
            }
            if (!Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam = [];
            }
            if (!group.coaches.extraRoam.includes(coachId)) {
                group.coaches.extraRoam.push(coachId);
            }
        }

        function mergeSmallGroups(ride, debugLines) {
            let mergedSomething = true;
            while (mergedSomething) {
                mergedSomething = false;
                const infos = computeGroupsInfo(ride);
                const minGroupSize = getMIN_GROUP_SIZE();
                for (const info of infos) {
                    const group = info.group;
                    if (group.riders.length >= minGroupSize) {
                        continue;
                    }
                    const sourceFitness = info.fitness;
                    let bestCandidate = null;
                    for (const candidate of infos) {
                        if (candidate.group === group) continue;
                        // Use capacity as the limit (ridersPerCoach × coach count)
                        const capacityLimit = candidate.capacity;
                        if (candidate.group.riders.length + group.riders.length > capacityLimit) continue;
                        const targetFitness = candidate.fitness;
                        const maxFitnessSpread = getMAX_FITNESS_SPREAD();
                        const diff = (sourceFitness != null && targetFitness != null)
                            ? Math.abs(targetFitness - sourceFitness)
                            : maxFitnessSpread;
                        if (diff > maxFitnessSpread) continue;
                        if (
                            !bestCandidate ||
                            diff < bestCandidate.diff ||
                            (diff === bestCandidate.diff && candidate.group.riders.length < bestCandidate.info.group.riders.length)
                        ) {
                            bestCandidate = { info: candidate, diff };
                        }
                    }

                    if (bestCandidate) {
                        const target = bestCandidate.info.group;
                        const groupLabel = `${group.label}`;
                        const targetLabel = `${target.label}`;

                        if (group.coaches.sweep && !target.coaches.sweep) {
                            target.coaches.sweep = group.coaches.sweep;
                        } else {
                            addExtraCoach(target, group.coaches.sweep);
                        }

                        if (group.coaches.roam && !target.coaches.roam) {
                            target.coaches.roam = group.coaches.roam;
                        } else {
                            addExtraCoach(target, group.coaches.roam);
                        }

                        addExtraCoach(target, group.coaches.leader);

                        if (Array.isArray(group.coaches.extraRoam)) {
                            group.coaches.extraRoam.forEach(id => addExtraCoach(target, id));
                        }

                        target.riders = target.riders.concat(group.riders);
                        debugLines.push(`Merged ${groupLabel} (${group.riders.length} riders) into ${targetLabel} (fitness diff ${bestCandidate.diff}).`);

                        ride.groups = ride.groups.filter(g => g !== group);
                        mergedSomething = true;
                        break;
                    }
                }
            }

            const postMergeInfos = computeGroupsInfo(ride);
            const minGroupSize = getMIN_GROUP_SIZE();
            postMergeInfos.forEach(info => {
                if (info.group.riders.length < minGroupSize) {
                    debugLines.push(`⚠️ ${info.group.label} remains below minimum size with ${info.group.riders.length} riders.`);
                }
            });
        }

        function dissolveSmallGroups(ride, debugLines) {
            let dissolved = false;
            let groupsInfo = computeGroupsInfo(ride);
            const minGroupSize = getMIN_GROUP_SIZE();
            const maxFitnessSpread = getMAX_FITNESS_SPREAD();
            groupsInfo
                .filter(info => info.group.riders.length > 0 && info.group.riders.length < minGroupSize)
                .forEach(info => {
                    const sourceGroup = info.group;
                    const sourceFitness = info.fitness;
                    const riderCount = sourceGroup.riders.length;

                    let targetInfo = null;
                    let usedDiff = null;
                    const allowedDiffs = [maxFitnessSpread, maxFitnessSpread + 1, maxFitnessSpread + 2];

                    for (const allowedDiff of allowedDiffs) {
                        const candidates = computeGroupsInfo(ride)
                            .filter(candidate => candidate.group !== sourceGroup)
                            .map(candidate => {
                                const projectedSize = candidate.group.riders.length + riderCount;
                                const diff = (sourceFitness != null && candidate.fitness != null)
                                    ? Math.abs(candidate.fitness - sourceFitness)
                                    : 0;
                                return { candidate, projectedSize, diff };
                            })
                            .filter(entry => {
                                // Use capacity as the limit (ridersPerCoach × coach count)
                                const sizeLimit = entry.candidate.capacity;
                                return entry.projectedSize <= sizeLimit && entry.diff <= allowedDiff;
                            })
                            .sort((a, b) => {
                                if (a.diff !== b.diff) return a.diff - b.diff;
                                return a.candidate.group.riders.length - b.candidate.group.riders.length;
                            });

                        if (candidates.length > 0) {
                            targetInfo = candidates[0].candidate;
                            usedDiff = candidates[0].diff;
                            break;
                        }
                    }

                    if (!targetInfo) {
                        debugLines.push(`⚠️ Unable to dissolve ${sourceGroup.label}; no groups can accept ${riderCount} riders without exceeding size limits.`);
                        return;
                    }

                    const targetGroup = targetInfo.group;

                    sourceGroup.riders.forEach(riderId => {
                        if (!targetGroup.riders.includes(riderId)) {
                            targetGroup.riders.push(riderId);
                        }
                    });

                    if (targetGroup.fitnessTag == null && sourceGroup.fitnessTag != null) {
                        targetGroup.fitnessTag = sourceGroup.fitnessTag;
                    }

                    addExtraCoach(targetGroup, sourceGroup.coaches.leader);
                    if (sourceGroup.coaches.sweep && !targetGroup.coaches.sweep) {
                        targetGroup.coaches.sweep = sourceGroup.coaches.sweep;
                    } else {
                        addExtraCoach(targetGroup, sourceGroup.coaches.sweep);
                    }
                    if (sourceGroup.coaches.roam && !targetGroup.coaches.roam) {
                        targetGroup.coaches.roam = sourceGroup.coaches.roam;
                    } else {
                        addExtraCoach(targetGroup, sourceGroup.coaches.roam);
                    }
                    if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                        sourceGroup.coaches.extraRoam.forEach(id => addExtraCoach(targetGroup, id));
                    }

                    const diffNote = usedDiff != null ? ` (fitness diff ${usedDiff})` : '';
                    debugLines.push(`Dissolved ${sourceGroup.label} (${riderCount} riders) into ${targetGroup.label}${diffNote}.`);
                    ride.groups = ride.groups.filter(group => group !== sourceGroup);
                    dissolved = true;
                });

            // Don't renumber - keep group names persistent
        }

        function renderRiderCardHtml(rider, options = {}) {
            const {
                draggable = true,
                showAttendance = false,
                isAvailable = true,
                assignmentLabel = '',
                checkboxHandler = null,
                compact = false,
                showMoveControls = false,
                groupId = null,
                canMoveUp = false,
                canMoveDown = false,
                sortBy = 'pace',
                noPhoto = false, // New option to hide photo
                inGroup = false, // Flag for group context
                showUnavailableStyle = false, // Show unavailable styling (grey/italic/strikethrough)
                hideBadges = false // New option to hide all badges
            } = options;

            // Extract firstName and lastName for formatting
            let firstName = rider.firstName || '';
            let lastName = rider.lastName || '';
            if (!firstName && !lastName && rider.name) {
                const nameParts = rider.name.trim().split(/\s+/);
                if (nameParts.length > 1) {
                    lastName = nameParts.pop() || '';
                    firstName = nameParts.join(' ') || '';
                } else {
                    firstName = nameParts[0] || '';
                }
            }
            
            // Format name based on sortBy: "LASTNAME, FIRSTNAME" for lastName sort, otherwise "FIRSTNAME LASTNAME"
            let displayName;
            if (sortBy === 'lastName' && lastName) {
                displayName = lastName + (firstName ? ', ' + firstName : '');
            } else {
                displayName = (firstName + ' ' + lastName).trim() || rider.name || 'Rider';
            }
            const safeName = escapeHtml(displayName);
            const name = rider.name || 'Rider';
            const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
            
            // Apply unavailable styling if in group and unavailable
            const unavailableStyle = (inGroup && showUnavailableStyle) 
                ? 'color: #999; font-style: italic; text-decoration: line-through; opacity: 0.6;' 
                : '';
            const unavailableClass = (inGroup && showUnavailableStyle) ? 'rider-unavailable' : '';
            const unavailableStyleAttr = unavailableStyle ? `style="${unavailableStyle}"` : '';
            
            // Determine photo - use uploaded photo or default based on gender (unless noPhoto is true)
            let photoSrc = null;
            let photo = '';
            if (!noPhoto) {
                photoSrc = rider.photo;
                if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                    const gender = (rider.gender || '').toUpperCase();
                    if (gender === 'M') photoSrc = 'assets/male_default.png';
                    else if (gender === 'F') photoSrc = 'assets/female_default.png';
                    else photoSrc = 'assets/nonbinary_default.png';
                }
                photo = photoSrc ? escapeHtml(photoSrc) : '';
            }
            const fitnessScale = getFitnessScale();
            const fitness = String(Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10))));
            const genderValue = (rider.gender || '').toUpperCase();
            const gradeLabel = escapeHtml(formatGradeLabel(rider.grade));
            const classes = ['rider-card'];
            if (showAttendance) classes.push('attendance-card');
            if (!isAvailable) classes.push('attendance-off');
            if (compact) classes.push('compact');
            const dragAttributes = (draggable && isAvailable)
                ? `draggable="true"
                     data-drag-type="rider"
                     data-rider-id="${rider.id}"
                     ondragstart="drag(event)"
                     ondragend="dragEnd(event)"`
                : '';
            const checkboxId = showAttendance ? `attendance-rider-${rider.id}` : '';
            const checkboxHtml = showAttendance
                ? `<label class="attendance-checkbox" for="${checkboxId}">
                        <input type="checkbox" id="${checkboxId}" name="attendance-rider-${rider.id}" ${isAvailable ? 'checked' : ''} data-rider-id="${rider.id}" data-attendance-type="rider" class="attendance-checkbox-input">
                   </label>`
                : '';
            const assignmentNote = showAttendance && assignmentLabel
                ? `<span class="attendance-note">${assignmentLabel}</span>`
                : '';
            const nameHtml = showAttendance
                ? `<strong class="attendance-name" data-attendance-toggle="true">${safeName}</strong>`
                : `<strong>${safeName}</strong>`;
            const moveControlsHtml = showMoveControls && groupId !== null
                ? `<div class="rider-move-controls">
                    <button class="rider-move-btn" onclick="moveRiderBetweenGroups(${groupId}, ${rider.id}, -1)" ${!canMoveUp ? 'disabled' : ''} title="Move to previous group (higher fitness)">▲</button>
                    <button class="rider-move-btn" onclick="moveRiderBetweenGroups(${groupId}, ${rider.id}, 1)" ${!canMoveDown ? 'disabled' : ''} title="Move to next group (lower fitness)">▼</button>
                   </div>`
                : '';
            
            // Show only the badge for the current sort option
            // Make pace and skills badges clickable for context menu
            let badgeHtml = '';
            if (!hideBadges) {
            if (sortBy === 'pace') {
                    badgeHtml = `<span class="badge badge-pace-${fitness}" onclick="handleBadgeClick(event, 'rider', ${rider.id}, 'pace', ${fitness})" style="cursor: pointer;" data-rider-id="${rider.id}" data-badge-type="pace">Pace ${fitness}</span>`;
            } else if (sortBy === 'skills') {
                const skillsScale = getSkillsScale();
                const skills = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
                const skillsTooltip = getBikeSkillsTooltip(skills, skillsScale);
                    badgeHtml = `<span class="badge badge-skills-${skills}" onclick="handleBadgeClick(event, 'rider', ${rider.id}, 'skills', ${skills})" style="cursor: pointer;" title="${skillsTooltip.replace(/\n/g, '&#10;')}" data-rider-id="${rider.id}" data-badge-type="skills">Bike Skills ${skills}</span>`;
            } else if (sortBy === 'grade') {
                badgeHtml = gradeLabel ? `<span class="badge badge-grade">${gradeLabel}</span>` : '';
            } else if (sortBy === 'gender') {
                badgeHtml = genderValue ? `<span class="badge badge-gender">${escapeHtml(genderValue)}</span>` : '';
            } else {
                    // For name sort, show pace badge as default (clickable)
                    badgeHtml = `<span class="badge badge-pace-${fitness}" onclick="handleBadgeClick(event, 'rider', ${rider.id}, 'pace', ${fitness})" style="cursor: pointer;" data-rider-id="${rider.id}" data-badge-type="pace">Pace ${fitness}</span>`;
                }
            }
            
            // Make unavailable riders in groups clickable to toggle availability (but not the checkbox area)
            const clickHandler = (inGroup && showUnavailableStyle) 
                ? `onclick="if(event.target.type !== 'checkbox' && !event.target.closest('.attendance-checkbox') && !event.target.closest('.attendance-name')) { toggleRiderAvailability(${rider.id}); event.stopPropagation(); }" style="cursor: pointer;"` 
                : '';
            
            // Apply unavailable styling to the entire card when in group and unavailable
            // The CSS class .rider-unavailable will handle the styling via CSS rules
            const baseStyle = "border: none !important; border-style: none !important;";
            
            return `
                <div class="${classes.join(' ')} ${unavailableClass}" ${dragAttributes} ${clickHandler} style="${baseStyle}">
                    ${!noPhoto ? `<div class="avatar-circle">
                        ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                    </div>` : ''}
                    ${checkboxHtml}
                    <div class="card-body">
                        ${nameHtml}
                        ${badgeHtml ? `<span class="badge-single">${badgeHtml}</span>` : ''}
                        ${assignmentNote}
                    </div>
                    ${moveControlsHtml}
                </div>
            `;
        }

        function renderCoachCardHtml(coach, sourceGroupId, sourceRole, options = {}) {
            const {
                draggable = true,
                showAttendance = false,
                isAvailable = true,
                assignmentLabel = '',
                compact = false,
                checkboxHandler = null,
                sortBy = 'pace',
                noPhoto = false
            } = options;

            // Support both old 'level' and new 'coachingLicenseLevel' fields
            const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
            const level = escapeHtml(levelRaw);
            const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
            
            // Get fitness value clamped to current fitness scale (same as roster view)
            const fitnessScale = getFitnessScale();
            const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
            const fitness = escapeHtml(String(fitnessValue));
            
            // Extract firstName and lastName for formatting
            let firstName = coach.firstName || '';
            let lastName = coach.lastName || '';
            if (!firstName && !lastName && coach.name) {
                const nameParts = coach.name.trim().split(/\s+/);
                if (nameParts.length > 1) {
                    lastName = nameParts.pop() || '';
                    firstName = nameParts.join(' ') || '';
                } else {
                    firstName = nameParts[0] || '';
                }
            }
            
            // Format name based on sortBy: "LASTNAME, FIRSTNAME" for lastName sort, otherwise "FIRSTNAME LASTNAME"
            let displayName;
            if (sortBy === 'lastName' && lastName) {
                displayName = lastName + (firstName ? ', ' + firstName : '');
            } else {
                displayName = (firstName + ' ' + lastName).trim() || coach.name || 'Coach';
            }
            const safeName = escapeHtml(displayName);
            const name = coach.name || 'Coach';
            const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
            // Determine photo - use uploaded photo or default based on gender (same as riders)
            let photoSrc = coach.photo;
            if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                const gender = (coach.gender || '').toUpperCase();
                if (gender === 'M') photoSrc = 'assets/male_default.png';
                else if (gender === 'F') photoSrc = 'assets/female_default.png';
                else photoSrc = 'assets/nonbinary_default.png';
            }
            const photo = photoSrc ? escapeHtml(photoSrc) : '';
            const groupAttr = sourceGroupId != null ? `data-source-group-id="${sourceGroupId}"` : '';
            const roleAttr = sourceRole ? `data-source-role="${sourceRole}"` : '';
            const classes = ['coach-card'];
            if (showAttendance) classes.push('attendance-card');
            if (!isAvailable) classes.push('attendance-off');
            if (compact) classes.push('compact');
            // Add level-based class for styling
            if (levelRaw === 'N/A' || levelNum === 0) {
                classes.push('coach-level-na');
            } else if (levelNum === 1) classes.push('coach-level-1');
            else if (levelNum === 2) classes.push('coach-level-2');
            else if (levelNum === 3) classes.push('coach-level-3');
            const dragAttributes = (draggable && isAvailable)
                ? `draggable="true"
                     data-drag-type="coach"
                     data-coach-id="${coach.id}"
                     ${groupAttr}
                     ${roleAttr}
                     ondragstart="drag(event)"
                     ondragend="dragEnd(event)"`
                : `${groupAttr} ${roleAttr}`;
            const checkboxId = showAttendance ? `attendance-coach-${coach.id}` : '';
            const checkboxHtml = showAttendance
                ? `<label class="attendance-checkbox" for="${checkboxId}">
                        <input type="checkbox" id="${checkboxId}" name="attendance-coach-${coach.id}" ${isAvailable ? 'checked' : ''} data-coach-id="${coach.id}" data-attendance-type="coach" class="attendance-checkbox-input">
                   </label>`
                : '';
            const assignmentNote = showAttendance && assignmentLabel
                ? `<span class="attendance-note">${assignmentLabel}</span>`
                : '';
            const nameHtml = showAttendance
                ? `<strong class="attendance-name" data-attendance-toggle="true">${safeName}</strong>`
                : `<strong>${safeName}</strong>`;

            // Show only the badge for the current sort option (or default to pace for non-compact, show both for compact non-sorted)
            // Make pace badge clickable for context menu
            let badgeHtml = '';
            if (compact) {
                if (sortBy === 'pace') {
                    badgeHtml = `<span class="badge badge-pace-${fitnessValue}" onclick="handleBadgeClick(event, 'coach', ${coach.id}, 'pace', ${fitnessValue})" style="cursor: pointer;" data-coach-id="${coach.id}" data-badge-type="pace">Pace ${fitness}</span>`;
                } else if (sortBy === 'level') {
                    const levelDisplay = levelRaw === 'N/A' ? 'N/A' : `Level ${level}`;
                    badgeHtml = `<span class="badge badge-level">${levelDisplay}</span>`;
                } else {
                    // For name sort, show pace badge as default (clickable)
                    badgeHtml = `<span class="badge badge-pace-${fitnessValue}" onclick="handleBadgeClick(event, 'coach', ${coach.id}, 'pace', ${fitnessValue})" style="cursor: pointer;" data-coach-id="${coach.id}" data-badge-type="pace">Pace ${fitness}</span>`;
                }
            } else {
                // Non-compact mode: show both level and pace (pace is clickable)
                badgeHtml = `<div class="coach-meta">Level ${level} · <span class="badge badge-pace-${fitnessValue}" onclick="handleBadgeClick(event, 'coach', ${coach.id}, 'pace', ${fitnessValue})" style="cursor: pointer; display: inline;" data-coach-id="${coach.id}" data-badge-type="pace">Pace ${fitness}</span></div>`;
            }

            // Set background color based on coach level for practice planner (when showAttendance is true)
            // Use same colors as coach roster: L1=white, L2=grey, L3=gold
            let levelBackgroundColor = 'transparent';
            if (showAttendance) {
                if (levelNum === 1) {
                    levelBackgroundColor = '#ffffff'; // White for L1 (same as roster)
                } else if (levelNum === 2) {
                    levelBackgroundColor = '#e0e0e0'; // Grey for L2 (same as roster)
                } else if (levelNum === 3) {
                    levelBackgroundColor = '#fff1a4'; // Gold for L3 (same as roster)
                }
            }

            return `
                <div class="${classes.join(' ')}" ${dragAttributes} style="background: transparent !important; border: none !important; box-shadow: none !important; width: 100%;">
                    ${!noPhoto ? `<div class="avatar-circle coach">
                        ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                    </div>` : ''}
                    ${checkboxHtml}
                    <div class="card-body">
                        ${nameHtml}
                        ${badgeHtml ? (compact ? `<span class="badge-single">${badgeHtml}</span>` : badgeHtml) : ''}
                        ${assignmentNote}
                    </div>
                </div>
            `;
        }

        function renderGroupCoachesInline(group, ride) {
            // Build list of coaches in order: Leader, Sweep, Roam, then additional Roam
            const coachesList = [];
            
            // Check if leader is missing - if so, we'll show a drop zone for leader first
            const hasLeader = group.coaches.leader && getCoachById(group.coaches.leader);
            
            // Get all coaches with their roles (skip leader if missing - we'll add a drop zone for it)
            if (hasLeader) {
                const coach = getCoachById(group.coaches.leader);
                if (coach) coachesList.push({ coach, role: 'leader', roleLabel: 'Leader' });
            }
            if (group.coaches.sweep) {
                const coach = getCoachById(group.coaches.sweep);
                if (coach) coachesList.push({ coach, role: 'sweep', roleLabel: 'Sweep' });
            }
            if (group.coaches.roam) {
                const coach = getCoachById(group.coaches.roam);
                if (coach) coachesList.push({ coach, role: 'roam', roleLabel: 'Roam' });
            }
            // Add all extraRoam coaches as "Roam"
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(coachId => {
                    if (coachId) {
                        const coach = getCoachById(coachId);
                        if (coach) coachesList.push({ coach, role: 'extraRoam', roleLabel: 'Roam' });
                    }
                });
            }
            
            // Render coaches as draggable items
            let html = '';
            
            // If leader is missing, show a drop zone for leader first
            if (!hasLeader) {
                html += `
                    <div class="coach-drop-zone leader-drop-zone" 
                         data-drop-type="coach"
                         data-group-id="${group.id}"
                         data-role="leader"
                         ondrop="drop(event)"
                         ondragover="allowDrop(event)"
                         ondragleave="dragLeave(event)"
                         style="display: flex; align-items: center; justify-content: center; margin-bottom: 2px; padding: 8px; border-radius: 4px; background: #ffebee; border: 2px dashed #d32f2f; min-height: 40px; transition: all 0.2s;">
                        <span style="color: #d32f2f; font-weight: 500; font-size: 13px;">⚠️ Drop Leader here (Level ${getAutoAssignSetting('minLeaderLevel', 2)}+)</span>
                    </div>
                `;
            }
            
            coachesList.forEach(({ coach, role, roleLabel }, index) => {
                const isAvailable = ride.availableCoaches.includes(coach.id);
                const assignmentLabel = isAvailable ? '' : 'Unavailable';
                const coachCard = renderCoachCardHtml(coach, group.id, role, {
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel,
                    draggable: true, // Make coaches draggable
                    compact: true,
                    sortBy: 'pace',
                    inlineRole: roleLabel
                });
                
                // Get coach level for background color (same as roster: L1=white, L2=grey, L3=gold)
                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
                let levelBackgroundColor = index % 2 === 0 ? '#f9f9f9' : '#fff'; // Default alternating
                if (levelNum === 1) {
                    levelBackgroundColor = '#ffffff'; // White for L1
                } else if (levelNum === 2) {
                    levelBackgroundColor = '#e0e0e0'; // Grey for L2
                } else if (levelNum === 3) {
                    levelBackgroundColor = '#fff1a4'; // Gold for L3
                }
                
                // Add the coach item (no Move button) - make it a drop target for reordering
                html += `
                    <div class="coach-inline-item" 
                         data-coach-id="${coach.id}"
                         data-role="${role}"
                         data-group-id="${group.id}"
                         data-drop-type="coach"
                         ondrop="drop(event)"
                         ondragover="allowDrop(event)"
                         ondragleave="dragLeave(event)"
                         style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px; padding: 4px; border-radius: 4px; background: ${levelBackgroundColor}; width: 100%;">
                        <div style="flex: 1; min-width: 0; display: flex; align-items: center; width: 100%;">
                            ${coachCard}
                        </div>
                        <span class="coach-role-badge" style="margin-left: auto; padding: 2px 8px; background: #e3f2fd; color: #1976d2; border-radius: 12px; font-size: 11px; font-weight: 500; white-space: nowrap; flex-shrink: 0;">${roleLabel}</span>
                    </div>
                `;
            });
            
            // Add dropzone at the end (matching coach record dimensions)
            html += `
                <div class="coach-drop-zone" 
                     data-drop-type="coach"
                     data-group-id="${group.id}"
                     ondrop="drop(event)"
                     ondragover="allowDrop(event)"
                     ondragleave="dragLeave(event)"
                     style="display: flex; align-items: center; justify-content: center; margin-bottom: 2px; padding: 4px; border-radius: 4px; background: #f9f9f9; border: 2px dashed #ccc; min-height: 40px; transition: all 0.2s;">
                    <span style="color: #999; font-style: italic; font-size: 13px;">drop coach here</span>
                </div>
            `;
            
            return html;
        }
        
        function renderCoachSlotHtml(group, roleKey, label, ride) {
            let coachId = null;
            if (roleKey === 'extraRoam') {
                coachId = Array.isArray(group.coaches.extraRoam) ? group.coaches.extraRoam[0] : null;
            } else {
                coachId = group.coaches[roleKey];
            }

            const coach = coachId ? getCoachById(coachId) : null;
            const isAvailable = coach ? ride.availableCoaches.includes(coach.id) : false;
            const assignmentLabel = coach
                ? (isAvailable ? '' : 'Unavailable')
                : '';
            const content = coach
                ? renderCoachCardHtml(coach, group.id, roleKey, {
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel,
                    draggable: true,
                    compact: true,
                    sortBy: 'pace' // Coaches in groups always show pace (no sorting for coach slots)
                })
                : '<div class="coach-slot-empty">Drop coach here</div>';

            return `
                <div class="coach-role-slot ${coach ? '' : 'empty'}"
                     data-drop-type="coach"
                     data-group-id="${group.id}"
                     data-role="${roleKey}"
                     ondrop="drop(event)"
                     ondragover="allowDrop(event)"
                     ondragleave="dragLeave(event)"
                     style="border: none; border-style: none;">
                    <div class="coach-role-label">${label}</div>
                    ${content}
                </div>
            `;
        }

        function rebalanceGroupCoaches(ride, availableCoaches, debugLines) {
            let sortedCoaches = availableCoaches
                .slice()
                .sort((a, b) => {
                    const fitnessDiff = getCoachFitnessValue(b) - getCoachFitnessValue(a);
                    if (fitnessDiff !== 0) return fitnessDiff;
                    const levelDiff = (parseInt(b.level, 10) || 0) - (parseInt(a.level, 10) || 0);
                    if (levelDiff !== 0) return levelDiff;
                    return (b.name || '').localeCompare(a.name || '');
                });

            const groupsOrdered = ride.groups
                .map(group => ({
                    group,
                    fitness: getGroupFitnessScore(group),
                    size: group.riders.length
                }))
                .sort((a, b) => {
                    if (b.fitness !== a.fitness) return b.fitness - a.fitness;
                    return b.size - a.size;
                });

            // Preserve leaders that meet the requirement - don't clear them
            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const minLeaderLevelPriority = getParamPriority('minLeaderLevel');
            const useLeaderLevelConstraint = minLeaderLevelPriority < 999;
            const preservedLeaders = new Map(); // group -> leaderId
            
            ride.groups.forEach(group => {
                const currentLeader = getCoachById(group.coaches.leader);
                if (currentLeader) {
                    const leaderLevel = parseInt(currentLeader.level, 10) || 0;
                    if (leaderLevel >= minLeaderLevel) {
                        // Preserve this leader - it meets the requirement
                        preservedLeaders.set(group, currentLeader.id);
                    }
                }
                // Clear sweep, roam, and extraRoam (but preserve leader if it meets requirement)
                group.coaches.sweep = null;
                group.coaches.roam = null;
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                } else {
                    group.coaches.extraRoam = [];
                }
            });
            
            // Restore preserved leaders
            preservedLeaders.forEach((leaderId, group) => {
                group.coaches.leader = leaderId;
            });
            
            // Remove preserved leaders from available coaches list (they're already assigned)
            const preservedLeaderIds = new Set(Array.from(preservedLeaders.values()));
            sortedCoaches = sortedCoaches.filter(coach => !preservedLeaderIds.has(coach.id));

            const extraAssignments = [];

            const getCoachLevel = coach => {
                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                if (levelRaw === 'N/A') return 0;
                return parseInt(levelRaw, 10) || 0;
            };
            const popCoach = () => sortedCoaches.length ? sortedCoaches.shift() : null;

            groupsOrdered.forEach(entry => {
                if (sortedCoaches.length === 0) return;

                const picks = [];
                while (picks.length < 3 && sortedCoaches.length > 0) {
                    picks.push(popCoach());
                }

                if (picks.length === 0) return;

                // Only enforce leader level constraint if it's enabled and has priority
                if (useLeaderLevelConstraint && !picks.some(coach => getCoachLevel(coach) >= minLeaderLevel)) {
                    const eligibleIdx = sortedCoaches.findIndex(coach => getCoachLevel(coach) >= minLeaderLevel);
                    if (eligibleIdx >= 0) {
                        picks.push(sortedCoaches.splice(eligibleIdx, 1)[0]);
                    } else {
                        debugLines.push(`⚠️ ${entry.group.label} does not have a Level ${minLeaderLevel}+ coach available; using best available coach as leader.`);
                    }
                }

                if (!entry.group.coaches.leader) {
                    picks.sort((a, b) => getCoachFitnessValue(b) - getCoachFitnessValue(a));

                    let leaderIndex = -1;
                    if (useLeaderLevelConstraint) {
                        leaderIndex = picks.findIndex(coach => getCoachLevel(coach) >= minLeaderLevel);
                    } else {
                        // If constraint not enabled, just use the best coach
                        leaderIndex = 0;
                    }
                    let leaderCoach;
                    if (leaderIndex === -1) {
                        leaderCoach = picks.shift();
                    } else {
                        leaderCoach = picks.splice(leaderIndex, 1)[0];
                    }
                    if (leaderCoach) {
                        entry.group.coaches.leader = leaderCoach.id;
                    }
                }

                if (!entry.group.coaches.sweep) {
                    const sweepCoach = picks.shift();
                    if (sweepCoach) {
                        entry.group.coaches.sweep = sweepCoach.id;
                    }
                }

                if (!entry.group.coaches.roam) {
                    const roamCoach = picks.shift();
                    if (roamCoach) {
                        entry.group.coaches.roam = roamCoach.id;
                    }
                }

                picks.forEach(coach => {
                    if (coach) {
                        sortedCoaches.unshift(coach);
                    }
                });
            });

            // Helper function to count coaches in a group
            const countCoachesInGroup = (group) => {
                let count = 0;
                if (group.coaches.leader) count++;
                if (group.coaches.sweep) count++;
                if (group.coaches.roam) count++;
                if (Array.isArray(group.coaches.extraRoam)) {
                    count += group.coaches.extraRoam.filter(Boolean).length;
                }
                return count;
            };

            // Fair distribution: Only assign 4th coaches after all groups have 3 coaches
            // Only assign 3rd coaches after all groups have at least 2 coaches
            while (sortedCoaches.length > 0) {
                // Check if any group has fewer than 2 coaches
                const groupsWithOneCoach = ride.groups.filter(g => countCoachesInGroup(g) === 1);
                if (groupsWithOneCoach.length > 0) {
                    // Assign to groups with only 1 coach first
                    const targetGroup = groupsWithOneCoach[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!targetGroup.coaches.sweep) {
                            targetGroup.coaches.sweep = coach.id;
                        } else if (!targetGroup.coaches.roam) {
                            targetGroup.coaches.roam = coach.id;
                        }
                    }
                    continue;
                }
                
                // Check if any group has fewer than 3 coaches
                const groupsWithTwoCoaches = ride.groups.filter(g => countCoachesInGroup(g) === 2);
                if (groupsWithTwoCoaches.length > 0) {
                    // Assign to groups with only 2 coaches
                    const targetGroup = groupsWithTwoCoaches[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!targetGroup.coaches.roam) {
                            targetGroup.coaches.roam = coach.id;
                        } else {
                            if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                targetGroup.coaches.extraRoam = [];
                            }
                            targetGroup.coaches.extraRoam.push(coach.id);
                            extraAssignments.push({ coachId: coach.id, groupId: targetGroup.id });
                        }
                    }
                    continue;
                }
                
                // All groups have at least 3 coaches, now assign 4th coaches
                const groupsWithThreeCoaches = ride.groups.filter(g => countCoachesInGroup(g) === 3);
                if (groupsWithThreeCoaches.length > 0) {
                    const targetGroup = groupsWithThreeCoaches[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                            targetGroup.coaches.extraRoam = [];
                        }
                        targetGroup.coaches.extraRoam.push(coach.id);
                        extraAssignments.push({ coachId: coach.id, groupId: targetGroup.id });
                    }
                    continue;
                }
                
                // All groups have 4+ coaches, break
                break;
            }
            
            const allRolesFilled = ride.groups.every(group =>
                group.coaches.leader && group.coaches.sweep && group.coaches.roam
            );

            return {
                extrasAssigned: extraAssignments.length,
                extraAssignments,
                allGroupsStaffed: allRolesFilled
            };
        }

        function renderEmptyGroupCard() {
            return `
                <div class="coach-group empty-group">
                    <div class="empty-message">
                        No groups yet. Use Autofill Assignments or Add Group to begin assigning riders and coaches.
                    </div>
                </div>
            `;
        }

        // Permission check functions (always return true in localStorage mode)
        function canAdjustAssignments() {
            return true; // No authentication in localStorage mode
        }

        function assignCoachToGroup(ride, coachId, groupId, role) {
            if (!canAdjustAssignments()) {
                alert('You do not have permission to adjust assignments');
                return false;
            }

            const group = findGroupById(ride, groupId);
            if (!group) return false;

            // Find what role the dragged coach currently has (if any)
            let draggedCoachCurrentRole = null;
            let draggedCoachCurrentGroupId = null;
            
            ride.groups.forEach(g => {
                if (g.id === groupId) {
                    // Check if coach is already in this group
                    if (g.coaches.leader === coachId) {
                        draggedCoachCurrentRole = 'leader';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.sweep === coachId) {
                        draggedCoachCurrentRole = 'sweep';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.roam === coachId) {
                        draggedCoachCurrentRole = 'roam';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (Array.isArray(g.coaches.extraRoam) && g.coaches.extraRoam.includes(coachId)) {
                        draggedCoachCurrentRole = 'extraRoam';
                        draggedCoachCurrentGroupId = g.id;
                    }
                } else {
                    // Check other groups
                    if (g.coaches.leader === coachId) {
                        draggedCoachCurrentRole = 'leader';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.sweep === coachId) {
                        draggedCoachCurrentRole = 'sweep';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.roam === coachId) {
                        draggedCoachCurrentRole = 'roam';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (Array.isArray(g.coaches.extraRoam) && g.coaches.extraRoam.includes(coachId)) {
                        draggedCoachCurrentRole = 'extraRoam';
                        draggedCoachCurrentGroupId = g.id;
                    }
                }
            });

            // Check if target role is already occupied
            let existingCoachId = null;
            if (role === 'extraRoam') {
                if (Array.isArray(group.coaches.extraRoam) && group.coaches.extraRoam.length > 0) {
                    existingCoachId = group.coaches.extraRoam[0];
                }
            } else {
                existingCoachId = group.coaches[role] || null;
            }

            // If target role is occupied, swap the coaches (works within same group and between groups)
            if (existingCoachId && existingCoachId !== coachId) {
                // Find the source group (where the dragged coach currently is)
                const sourceGroup = draggedCoachCurrentGroupId 
                    ? findGroupById(ride, draggedCoachCurrentGroupId) 
                    : null;
                
                // First, remove both coaches from their current assignments
                removeCoachFromGroups(ride, coachId);
                removeCoachFromGroups(ride, existingCoachId);
                
                // Assign dragged coach to target role in target group
                if (role === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam[0] = coachId;
                    group.coaches.extraRoam = group.coaches.extraRoam.slice(0, 1);
                } else {
                    group.coaches[role] = coachId;
                }
                
                // If dragged coach had a previous role, assign existing coach to that role
                if (draggedCoachCurrentRole && sourceGroup) {
                    if (draggedCoachCurrentRole === 'extraRoam') {
                        if (!Array.isArray(sourceGroup.coaches.extraRoam)) {
                            sourceGroup.coaches.extraRoam = [];
                        }
                        sourceGroup.coaches.extraRoam[0] = existingCoachId;
                        sourceGroup.coaches.extraRoam = sourceGroup.coaches.extraRoam.slice(0, 1);
                    } else {
                        sourceGroup.coaches[draggedCoachCurrentRole] = existingCoachId;
                    }
                }
                // If dragged coach had no previous role, existing coach just becomes unassigned
                // (already handled by removeCoachFromGroups above)
            } else {
                // Target role is empty, just assign normally
                removeCoachFromGroups(ride, coachId);
                
                if (role === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam[0] = coachId;
                    group.coaches.extraRoam = group.coaches.extraRoam.slice(0, 1);
                } else {
                    group.coaches[role] = coachId;
                }
            }
            
            // Save ride immediately after assignment change
            saveRideToDB(ride);
            return true;
        }

        function getCoachById(id) {
            return data.coaches.find(coach => coach.id === id) || null;
        }

        function getRiderById(id) {
            if (id == null) return null;
            // Normalize ID for comparison (handle both string and number IDs)
            const normalizedId = typeof id === 'string' ? parseInt(id, 10) : id;
            if (!Number.isFinite(normalizedId)) return null;
            
            return data.riders.find(rider => {
                // Normalize rider ID for comparison
                const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                return riderId === normalizedId;
            }) || null;
        }

        function getCoachFitnessValue(coach) {
            const raw = parseInt(coach?.fitness ?? coach?.level ?? '5', 10);
            if (!Number.isFinite(raw)) return 5;
            return getRelativePaceValue(raw);
        }

        function getGroupFitnessScore(group) {
            if (group.fitnessTag != null) {
                const value = parseInt(group.fitnessTag, 10);
                if (Number.isFinite(value)) return getRelativePaceValue(value);
            }

            const riderFitnessValues = group.riders
                .map(id => getRiderById(id))
                .filter(Boolean)
                .map(rider => parseInt(rider.fitness || '5', 10))
                .filter(Number.isFinite)
                .map(value => getRelativePaceValue(value));

            if (riderFitnessValues.length === 0) {
                return 5;
            }

            const sum = riderFitnessValues.reduce((acc, value) => acc + value, 0);
            return Math.round(sum / riderFitnessValues.length);
        }

        function countGroupCoaches(group) {
            const baseCount = ['leader', 'sweep', 'roam'].reduce((count, role) => {
                return count + (group.coaches[role] ? 1 : 0);
            }, 0);
            const extra = Array.isArray(group.coaches.extraRoam) ? group.coaches.extraRoam.filter(Boolean).length : 0;
            return baseCount + extra;
        }

        function optimizeGroupCoachRoles(group) {
            // Optimize coach role assignments after a coach is removed
            // Rules:
            // 1. If sweep is removed and there's a roam coach, promote roam to sweep
            // 2. If leader is removed and there's a sweep or roam coach that's L2/L3, promote them to leader
            // 3. If there are only 2 coaches, they should be leader and sweep (unless neither is L2/L3)
            
            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            
            // Get current coaches and their levels (re-fetch after any changes)
            let leader = group.coaches.leader ? getCoachById(group.coaches.leader) : null;
            let sweep = group.coaches.sweep ? getCoachById(group.coaches.sweep) : null;
            let roam = group.coaches.roam ? getCoachById(group.coaches.roam) : null;
            const extraRoam = Array.isArray(group.coaches.extraRoam) 
                ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                : [];
            
            // Step 1: If sweep is missing and roam exists, promote roam to sweep
            if (!sweep && roam) {
                group.coaches.sweep = group.coaches.roam;
                group.coaches.roam = null;
                // Update local references
                sweep = roam;
                roam = null;
                console.log('🔄 Optimized: Promoted roam coach to sweep');
            }
            
            // Step 2: If leader is missing, try to promote sweep or roam to leader (if L2/L3)
            if (!leader) {
                const sweepLevel = sweep ? parseInt(sweep.coachingLicenseLevel || sweep.level || '1', 10) : 0;
                const roamLevel = roam ? parseInt(roam.coachingLicenseLevel || roam.level || '1', 10) : 0;
                
                if (sweep && Number.isFinite(sweepLevel) && sweepLevel >= minLeaderLevel) {
                    // Promote sweep to leader
                    group.coaches.leader = group.coaches.sweep;
                    group.coaches.sweep = null;
                    // If roam exists, promote it to sweep
                    if (roam) {
                        group.coaches.sweep = group.coaches.roam;
                        group.coaches.roam = null;
                        sweep = roam;
                        roam = null;
                    } else {
                        sweep = null;
                    }
                    leader = getCoachById(group.coaches.leader);
                    console.log('🔄 Optimized: Promoted sweep to leader');
                } else if (roam && Number.isFinite(roamLevel) && roamLevel >= minLeaderLevel) {
                    // Promote roam to leader
                    group.coaches.leader = group.coaches.roam;
                    group.coaches.roam = null;
                    leader = roam;
                    roam = null;
                    console.log('🔄 Optimized: Promoted roam to leader');
                } else if (extraRoam.length > 0) {
                    // Try to promote an extraRoam coach if they're L2/L3
                    const qualifiedExtra = extraRoam.find(c => {
                        const level = parseInt(c.coachingLicenseLevel || c.level || '1', 10);
                        return Number.isFinite(level) && level >= minLeaderLevel;
                    });
                    if (qualifiedExtra) {
                        // Remove from extraRoam and promote to leader
                        group.coaches.leader = qualifiedExtra.id;
                        group.coaches.extraRoam = group.coaches.extraRoam.filter(id => id !== qualifiedExtra.id);
                        leader = qualifiedExtra;
                        console.log('🔄 Optimized: Promoted extraRoam to leader');
                    }
                }
            }
            
            // Step 3: If there are only 2 coaches, ensure they're leader and sweep (unless neither is L2/L3)
            // Recalculate count after optimizations
            const coachCount = countGroupCoaches(group);
            if (coachCount === 2) {
                // Re-fetch current state after optimizations
                const currentLeader = group.coaches.leader ? getCoachById(group.coaches.leader) : null;
                const currentSweep = group.coaches.sweep ? getCoachById(group.coaches.sweep) : null;
                const currentRoam = group.coaches.roam ? getCoachById(group.coaches.roam) : null;
                
                // If we have leader and roam (but no sweep), move roam to sweep
                if (currentLeader && currentRoam && !currentSweep) {
                    group.coaches.sweep = group.coaches.roam;
                    group.coaches.roam = null;
                    console.log('🔄 Optimized: Moved roam to sweep (2-coach group)');
                }
                // If we have sweep and roam (but no leader), check if either is L2/L3
                else if (currentSweep && currentRoam && !currentLeader) {
                    const sweepLvl = parseInt(currentSweep.coachingLicenseLevel || currentSweep.level || '1', 10);
                    const roamLvl = parseInt(currentRoam.coachingLicenseLevel || currentRoam.level || '1', 10);
                    
                    // Promote the one that's L2/L3 to leader, other to sweep
                    if (Number.isFinite(sweepLvl) && sweepLvl >= minLeaderLevel) {
                        group.coaches.leader = group.coaches.sweep;
                        group.coaches.sweep = group.coaches.roam;
                        group.coaches.roam = null;
                        console.log('🔄 Optimized: Promoted sweep to leader, roam to sweep (2-coach group)');
                    } else if (Number.isFinite(roamLvl) && roamLvl >= minLeaderLevel) {
                        group.coaches.leader = group.coaches.roam;
                        group.coaches.sweep = group.coaches.sweep; // Keep existing sweep
                        group.coaches.roam = null;
                        console.log('🔄 Optimized: Promoted roam to leader (2-coach group)');
                    }
                }
            }
        }

        function groupCapacity(group) {
            const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
            return countGroupCoaches(group) * ridersPerCoach;
        }

        function findGroupById(ride, groupId) {
            return ride.groups.find(group => group.id === groupId) || null;
        }

        function removeRiderFromGroups(ride, riderId) {
            ride.groups.forEach(group => {
                group.riders = group.riders.filter(id => id !== riderId);
                if (group.riders.length === 0) {
                    group.fitnessTag = null;
                }
            });
        }

        function removeCoachFromGroups(ride, coachId) {
            ride.groups.forEach(group => {
                ['leader', 'sweep', 'roam'].forEach(role => {
                    if (group.coaches[role] === coachId) {
                        group.coaches[role] = null;
                    }
                });
                if (Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = group.coaches.extraRoam.filter(id => id !== coachId);
                }
                // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead
            });
        }

        function getCoachAssignmentMap(ride) {
            const map = {};
            ride.groups.forEach(group => {
                ['leader', 'sweep', 'roam'].forEach(role => {
                    const coachId = group.coaches[role];
                    if (coachId) {
                        map[coachId] = {
                            groupId: group.id,
                            role
                        };
                    }
                });
                if (Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam.forEach((coachId, index) => {
                        if (coachId) {
                            map[coachId] = {
                                groupId: group.id,
                                role: index === 0 ? 'extraRoam' : `extraRoam${index + 1}`
                            };
                        }
                    });
                }
            });
            return map;
        }

        function renumberGroups(ride, sequential = false) {
            if (sequential) {
                // Renumber all groups sequentially (1, 2, 3, 4...) without gaps
                ride.groups.forEach((group, index) => {
                    group.label = `Group ${index + 1}`;
                });
            } else {
                // Only assign labels to groups that don't have them
                // Preserve existing labels to maintain persistence
                const existingLabels = new Set(ride.groups.map(g => g.label).filter(Boolean));
                let nextNumber = 1;
                
                ride.groups.forEach((group) => {
                    if (!group.label || group.label.trim() === '') {
                        // Find next available group number
                        while (existingLabels.has(`Group ${nextNumber}`)) {
                            nextNumber++;
                        }
                        group.label = `Group ${nextNumber}`;
                        existingLabels.add(group.label);
                        nextNumber++;
                    }
                });
            }
        }

        function normalizeRideStructure(ride) {
            const updated = Object.assign({}, ride);
            let changed = false;

            if (!Array.isArray(updated.availableCoaches)) {
                updated.availableCoaches = [];
                changed = true;
            }

            if (!Array.isArray(updated.availableRiders)) {
                updated.availableRiders = [];
                changed = true;
            }

            // Only validate IDs if rosters are loaded - preserve assignments even if rosters aren't loaded yet
            const coachesLoaded = Array.isArray(data.coaches) && data.coaches.length > 0;
            const ridersLoaded = Array.isArray(data.riders) && data.riders.length > 0;
            
            // Normalize IDs when creating Sets for comparison (handle string/number mismatches)
            const validCoachIds = coachesLoaded ? new Set(data.coaches.map(coach => {
                const id = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                return Number.isFinite(id) ? id : coach.id;
            })) : new Set();
            const validRiderIds = ridersLoaded ? new Set(data.riders.map(rider => {
                const id = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                return Number.isFinite(id) ? id : rider.id;
            })) : new Set();

            // If rosters aren't loaded yet, preserve all IDs (they might be valid, just not loaded)
            // Only filter if rosters are loaded
            // Also filter out invalid timestamp IDs (IDs > 1 million are likely timestamps, not valid coach IDs)
            const uniqueCoaches = new Set();
            if (coachesLoaded) {
                updated.availableCoaches = updated.availableCoaches
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && validCoachIds.has(id) && !uniqueCoaches.has(id) && uniqueCoaches.add(id));
            } else {
                // Preserve IDs even if rosters aren't loaded - just deduplicate
                updated.availableCoaches = updated.availableCoaches
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && !uniqueCoaches.has(id) && uniqueCoaches.add(id));
            }

            const uniqueRiders = new Set();
            if (ridersLoaded) {
                const beforeLength = updated.availableRiders.length;
                updated.availableRiders = updated.availableRiders
                    .map(id => {
                        // Normalize ID to number for consistent comparison
                        const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                        return Number.isFinite(normalized) ? normalized : id;
                    })
                    .filter(id => {
                        // All IDs should be normalized to numbers at this point, but double-check
                        const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                        if (!Number.isFinite(normalized)) {
                            console.warn('🟡 normalizeRideStructure: Invalid rider ID filtered out:', id, '(ride ID:', updated.id, ')');
                            return false;
                        }
                        // Check if normalized ID exists in validRiderIds Set (which also contains normalized IDs)
                        const isValid = validRiderIds.has(normalized);
                        if (!isValid) {
                            console.warn('🟡 normalizeRideStructure: Rider ID not found in roster:', normalized, '(ride ID:', updated.id, ')');
                        }
                        return isValid && !uniqueRiders.has(normalized) && uniqueRiders.add(normalized);
                    });
                const afterLength = updated.availableRiders.length;
                if (beforeLength !== afterLength) {
                    console.log('🟡 normalizeRideStructure: Filtered availableRiders from', beforeLength, 'to', afterLength, 'for ride ID:', updated.id);
                }
            } else {
                // Preserve IDs even if rosters aren't loaded - just deduplicate
                updated.availableRiders = updated.availableRiders
                    .map(id => {
                        const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                        return Number.isFinite(normalized) ? normalized : id;
                    })
                    .filter(id => {
                        const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                        return Number.isFinite(normalized) && !uniqueRiders.has(normalized) && uniqueRiders.add(normalized);
                    });
            }

            if (!Array.isArray(updated.groups)) {
                updated.groups = [];
                changed = true;
            }

            if (updated.assignments && typeof updated.assignments === 'object') {
                let index = updated.groups.length + 1;
                Object.entries(updated.assignments).forEach(([coachIdStr, riderIds]) => {
                    const coachId = parseInt(coachIdStr, 10);
                    if (!Number.isFinite(coachId)) {
                        return;
                    }

                    const group = createGroup(`Group ${index++}`);
                    const coach = getCoachById(coachId);

                    if (coach) {
                        const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                        const level = levelRaw === 'N/A' ? 0 : parseInt(levelRaw, 10);
                        const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                        if (Number.isFinite(level) && level >= minLeaderLevel) {
                            group.coaches.leader = coachId;
                        } else {
                            group.coaches.sweep = coachId;
                        }

                        if (!updated.availableCoaches.includes(coachId)) {
                            updated.availableCoaches.push(coachId);
                        }
                    }

                    if (Array.isArray(riderIds)) {
                        // Preserve rider IDs even if rosters aren't loaded yet
                        if (ridersLoaded) {
                            group.riders = riderIds
                                .map(id => parseInt(id, 10))
                                .filter(id => Number.isFinite(id) && validRiderIds.has(id));
                        } else {
                            // Preserve all valid numeric IDs - rosters might not be loaded yet
                            group.riders = riderIds
                                .map(id => parseInt(id, 10))
                                .filter(id => Number.isFinite(id));
                        }

                        const shouldAutoIncludeGroupRiders = updated.attendanceInitialized !== true && updated.availableRiders.length === 0;
                        if (shouldAutoIncludeGroupRiders) {
                            group.riders.forEach(riderId => {
                                if (!updated.availableRiders.includes(riderId)) {
                                    updated.availableRiders.push(riderId);
                                }
                            });
                        }
                    }

                    updated.groups.push(group);
                });

                delete updated.assignments;
                changed = true;
            }

            updated.groups = updated.groups.map((group, idx) => {
                // Preserve coach IDs even if rosters aren't loaded yet
                const extraRoam = group.coaches && Array.isArray(group.coaches.extraRoam)
                    ? (coachesLoaded
                        ? group.coaches.extraRoam
                            .map(id => parseInt(id, 10))
                            .filter(id => Number.isFinite(id) && validCoachIds.has(id))
                        : group.coaches.extraRoam
                            .map(id => parseInt(id, 10))
                            .filter(id => Number.isFinite(id)))
                    : [];

                const legacyFitnessTag = group.fitnessTag || group.abilityTag || null;
                const normalized = {
                    id: typeof group.id === 'number' ? group.id : generateId(),
                    label: group.label || `Group ${idx + 1}`,
                    coaches: {
                        leader: group.coaches ? normalizeCoachId(group.coaches.leader) : null,
                        sweep: group.coaches ? normalizeCoachId(group.coaches.sweep) : null,
                        roam: group.coaches ? normalizeCoachId(group.coaches.roam) : null,
                        extraRoam: extraRoam
                    },
                    riders: Array.isArray(group.riders)
                        ? (ridersLoaded
                            ? Array.from(new Set(group.riders.map(id => parseInt(id, 10)).filter(id => Number.isFinite(id) && validRiderIds.has(id))))
                            : Array.from(new Set(group.riders.map(id => parseInt(id, 10)).filter(id => Number.isFinite(id)))))
                        : [],
                    fitnessTag: legacyFitnessTag,
                    routeId: group.routeId !== undefined ? group.routeId : null
                };

                if (!normalized.coaches.leader && normalized.coaches.sweep) {
                    const sweepCoach = getCoachById(normalized.coaches.sweep);
                    const level = sweepCoach ? parseInt(sweepCoach.level, 10) : 0;
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (Number.isFinite(level) && level >= minLeaderLevel) {
                        normalized.coaches.leader = normalized.coaches.sweep;
                        normalized.coaches.sweep = null;
                    }
                }

                if (normalized.coaches.leader && !updated.availableCoaches.includes(normalized.coaches.leader)) {
                    updated.availableCoaches.push(normalized.coaches.leader);
                }
                ['sweep', 'roam'].forEach(role => {
                    const coachId = normalized.coaches[role];
                    if (coachId && !updated.availableCoaches.includes(coachId)) {
                        updated.availableCoaches.push(coachId);
                    }
                });
                normalized.coaches.extraRoam.forEach(coachId => {
                    if (coachId && !updated.availableCoaches.includes(coachId)) {
                        updated.availableCoaches.push(coachId);
                    }
                });

                normalized.riders.forEach(riderId => {
                    if (!updated.availableRiders.includes(riderId)) {
                        updated.availableRiders.push(riderId);
                    }
                });

                return normalized;
            });

            updated.groups.forEach((group, index) => {
                group.label = group.label || `Group ${index + 1}`;
                // Ensure routeId exists
                if (group.routeId === undefined) {
                    group.routeId = null;
                    changed = true;
                }
            });

            updated.availableCoaches = Array.from(new Set(updated.availableCoaches));
            updated.availableRiders = Array.from(new Set(updated.availableRiders));

            return { ride: updated, changed };
        }

        // Authentication handlers
        function showAuthError(message, type = 'error') {
            const errorDiv = document.getElementById('auth-error');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                if (type === 'success') {
                    errorDiv.style.backgroundColor = '#d4edda';
                    errorDiv.style.color = '#155724';
                    errorDiv.style.borderColor = '#c3e6cb';
                } else {
                    errorDiv.style.backgroundColor = '#f8d7da';
                    errorDiv.style.color = '#721c24';
                    errorDiv.style.borderColor = '#f5c6cb';
                }
            }
        }

        function hideAuthError() {
            const errorDiv = document.getElementById('auth-error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        function showLogin() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('admin-request-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'none';
            hideAuthError();
        }

        function showAdminRequest() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('admin-request-form').style.display = 'block';
            document.getElementById('password-reset-form').style.display = 'none';
            hideAuthError();
        }

        function showPasswordReset() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('admin-request-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'block';
            document.getElementById('simplified-login-form').style.display = 'none';
            hideAuthError();
        }

        function showSimplifiedLogin() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('admin-request-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'none';
            document.getElementById('simplified-login-form').style.display = 'block';
            document.getElementById('verification-code-form').style.display = 'none';
            pendingVerification = null; // Clear pending verification
            const subtitle = document.getElementById('login-subtitle');
            if (subtitle) {
                subtitle.textContent = 'Enter your phone or email to access your assignments';
            }
            hideAuthError();
        }

        function showAdminLogin() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('admin-request-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'none';
            document.getElementById('simplified-login-form').style.display = 'none';
            const subtitle = document.getElementById('login-subtitle');
            if (subtitle) {
                subtitle.textContent = 'Sign in to access the practice manager';
            }
            hideAuthError();
        }

        // Store pending verification info temporarily
        let pendingVerification = null;

        // Simplified login handler for riders/coaches
        async function handleSimplifiedLogin() {
            hideAuthError();
            const input = document.getElementById('simplified-login-input');
            const button = document.getElementById('simplified-login-button');
            
            if (!input || !input.value.trim()) {
                showAuthError('Please enter your phone number or email address');
                return;
            }

            const phoneOrEmail = input.value.trim();
            const isEmail = phoneOrEmail.includes('@');
            
            // Disable button and show loading
            if (button) {
                button.disabled = true;
                button.textContent = 'Looking up...';
            }

            try {
                // Step 1: Lookup user
                const lookupResult = await lookupUserByPhoneOrEmail(phoneOrEmail);
                
                if (!lookupResult) {
                    showAuthError('No matching rider or coach found. Please check your phone number or email address.');
                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Send Verification Code';
                    }
                    return;
                }

                // Step 2: Generate verification code
                if (button) {
                    button.textContent = 'Generating code...';
                }
                
                const { code, id: codeId } = await createVerificationCode(
                    phoneOrEmail,
                    lookupResult.type,
                    lookupResult.id
                );
                
                // Step 3: Send verification code
                if (button) {
                    button.textContent = isEmail ? 'Sending email...' : 'Sending SMS...';
                }
                
                const sendResult = await sendVerificationCode(phoneOrEmail, code, isEmail);
                
                if (!sendResult.success) {
                    // If sending fails but we're in development, show the code
                    if (sendResult.error && sendResult.error.includes('not configured')) {
                        alert(`Development mode: Your verification code is ${code}. The sending service is not configured yet.`);
                    } else {
                        throw new Error(sendResult.error || 'Failed to send verification code');
                    }
                }
                
                // Step 4: Store pending verification and show code input form
                pendingVerification = {
                    phoneOrEmail: phoneOrEmail,
                    userType: lookupResult.type,
                    userId: lookupResult.id,
                    userName: lookupResult.name,
                    codeId: codeId,
                    isEmail: isEmail
                };
                
                // Show verification code form
                showVerificationCodeForm(phoneOrEmail, isEmail);
                
            } catch (error) {
                console.error('Error during simplified login:', error);
                showAuthError(error.message || 'An error occurred. Please try again.');
                if (button) {
                    button.disabled = false;
                    button.textContent = 'Send Verification Code';
                }
            }
        }

        // Show verification code input form
        function showVerificationCodeForm(phoneOrEmail, isEmail) {
            document.getElementById('simplified-login-form').style.display = 'none';
            document.getElementById('verification-code-form').style.display = 'block';
            
            const messageEl = document.getElementById('verification-code-message');
            const phoneEmailEl = document.getElementById('verification-phone-email');
            
            if (messageEl) {
                const method = isEmail ? 'email' : 'SMS';
                messageEl.textContent = `We've sent a verification code via ${method} to `;
            }
            
            if (phoneEmailEl) {
                phoneEmailEl.textContent = phoneOrEmail;
            }
            
            // Focus on code input
            setTimeout(() => {
                const codeInput = document.getElementById('verification-code-input');
                if (codeInput) {
                    codeInput.focus();
                }
            }, 100);
        }

        // Verify the code entered by user
        async function handleVerifyCode() {
            hideAuthError();
            const codeInput = document.getElementById('verification-code-input');
            const verifyButton = document.getElementById('verify-code-button');
            
            if (!codeInput || !codeInput.value.trim()) {
                showAuthError('Please enter the verification code');
                return;
            }
            
            if (!pendingVerification) {
                showAuthError('Session expired. Please start over.');
                showSimplifiedLogin();
                return;
            }
            
            const code = codeInput.value.trim();
            
            if (code.length !== 6 || !/^\d{6}$/.test(code)) {
                showAuthError('Please enter a valid 6-digit code');
                return;
            }
            
            // Disable button and show loading
            if (verifyButton) {
                verifyButton.disabled = true;
                verifyButton.textContent = 'Verifying...';
            }
            
            try {
                const verifyResult = await verifyCode(pendingVerification.phoneOrEmail, code);
                
                if (!verifyResult.valid) {
                    showAuthError(verifyResult.message || 'Invalid or expired code. Please try again or request a new code.');
                    if (verifyButton) {
                        verifyButton.disabled = false;
                        verifyButton.textContent = 'Verify Code';
                    }
                    // Clear the input
                    if (codeInput) {
                        codeInput.value = '';
                        codeInput.focus();
                    }
                    return;
                }
                
                // Verification successful - store login info and redirect
                window.sessionStorage.setItem('simplifiedLogin', JSON.stringify({
                    type: pendingVerification.userType,
                    id: pendingVerification.userId,
                    name: pendingVerification.userName,
                    timestamp: Date.now()
                }));
                
                // Route to assignments view
                window.location.href = 'teamridepro_v2.html?view=assignments';
                
            } catch (error) {
                console.error('Error verifying code:', error);
                showAuthError('An error occurred while verifying the code. Please try again.');
                if (verifyButton) {
                    verifyButton.disabled = false;
                    verifyButton.textContent = 'Verify Code';
                }
            }
        }

        // Resend verification code
        async function handleResendVerificationCode() {
            if (!pendingVerification) {
                showAuthError('Session expired. Please start over.');
                showSimplifiedLogin();
                return;
            }
            
            hideAuthError();
            const resendLink = document.getElementById('resend-code-link');
            
            if (resendLink) {
                resendLink.style.pointerEvents = 'none';
                resendLink.textContent = 'Sending...';
            }
            
            try {
                // Generate new code
                const { code, id: codeId } = await createVerificationCode(
                    pendingVerification.phoneOrEmail,
                    pendingVerification.userType,
                    pendingVerification.userId
                );
                
                // Send new code
                await sendVerificationCode(pendingVerification.phoneOrEmail, code, pendingVerification.isEmail);
                
                // Update pending verification
                pendingVerification.codeId = codeId;
                
                // Show success message
                showAuthError('New verification code sent!', 'success');
                
                // Clear code input
                const codeInput = document.getElementById('verification-code-input');
                if (codeInput) {
                    codeInput.value = '';
                    codeInput.focus();
                }
                
            } catch (error) {
                console.error('Error resending code:', error);
                showAuthError('Failed to resend code. Please try again.');
            } finally {
                if (resendLink) {
                    resendLink.style.pointerEvents = '';
                    resendLink.textContent = 'Resend Code';
                }
            }
        }

        async function handleLogin() {
            hideAuthError();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const loginButton = document.querySelector('#login-form button[type="submit"]');

            if (!email || !password) {
                showAuthError('Please enter both email and password');
                return;
            }

            // Disable button and show loading state to prevent multiple clicks
            if (loginButton) {
                const originalText = loginButton.textContent;
                loginButton.disabled = true;
                loginButton.textContent = 'Signing in...';
                loginButton.style.opacity = '0.6';
                loginButton.style.cursor = 'not-allowed';
            }

            try {
                await signInWithEmail(email, password);
                // Auth state listener will handle UI update and backups
            } catch (error) {
                // Re-enable button on error
                if (loginButton) {
                    loginButton.disabled = false;
                    loginButton.textContent = 'Sign In';
                    loginButton.style.opacity = '1';
                    loginButton.style.cursor = 'pointer';
                }
                
                // Check if error is about email not verified
                if (error.message && error.message.includes('Email not confirmed')) {
                    showAuthError('Please verify your email first. Check your inbox for the verification link.');
                    document.getElementById('resend-verification').style.display = 'block';
                } else {
                    showAuthError(error.message || 'Login failed. Please check your credentials.');
                }
            }
        }

        async function handleSignup() {
            hideAuthError();
            const name = document.getElementById('signup-name').value;
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;

            if (!name || !email || !password) {
                showAuthError('Please fill in all fields');
                return;
            }

            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }

            try {
                await signUpWithEmail(email, password, name);
                showAuthError('Account created! Please check your email to verify your account before signing in.');
            } catch (error) {
                showAuthError(error.message || 'Sign up failed. Please try again.');
            }
        }

        async function handleGoogleLogin() {
            hideAuthError();
            try {
                await signInWithGoogle();
                // OAuth will redirect, so no need to handle success here
            } catch (error) {
                showAuthError(error.message || 'Google login failed. Please try again.');
            }
        }

        async function handleAppleLogin() {
            hideAuthError();
            try {
                await signInWithApple();
                // OAuth will redirect, so no need to handle success here
            } catch (error) {
                showAuthError(error.message || 'Apple login failed. Please try again.');
            }
        }

        async function handlePasswordReset() {
            hideAuthError();
            const email = document.getElementById('reset-email').value;

            if (!email) {
                showAuthError('Please enter your email address');
                return;
            }

            try {
                await resetPassword(email);
                showAuthError('Password reset email sent! Check your inbox.');
            } catch (error) {
                showAuthError(error.message || 'Failed to send reset email. Please try again.');
            }
        }

        // Handle logout (Supabase authentication or simplified login)
        async function handleLogout() {
            try {
                // Check if this is simplified login mode
                if (simplifiedLoginInfo) {
                // Clear simplified login info
                window.sessionStorage.removeItem('simplifiedLogin');
                simplifiedLoginInfo = null;
                simplifiedLoginMode = null;
                
                // Redirect to simplified login page
                const urlParams = new URLSearchParams(window.location.search);
                const viewParam = urlParams.get('view');
                if (viewParam === 'assignments' || viewParam === 'rider' || viewParam === 'coach') {
                    window.location.href = 'teamridepro_v2.html?view=assignments';
                } else {
                    window.location.href = 'teamridepro_v2.html';
                }
                return;
                }
                
                // Regular admin logout
                // Create automatic backup before logout
                try {
                    await createAutomaticBackup('auto_logout');
                } catch (backupError) {
                    console.warn('Failed to create backup on logout:', backupError);
                    // Don't block logout if backup fails
                }
                
                await releaseAdminEditLock();
                
                // Check if we're using Supabase auth
                if (typeof signOut === 'function') {
                    try {
                        await signOut();
                    } catch (signOutError) {
                        // signOut handles 403/forbidden errors internally, but if it throws something else, log it
                        const message = (signOutError?.message || '').toLowerCase();
                        const isMissingSession = signOutError?.name === 'AuthSessionMissingError' || message.includes('auth session missing');
                        const isForbidden = signOutError?.status === 403 || signOutError?.code === '403' || message.includes('forbidden');
                        if (!isMissingSession && !isForbidden) {
                            console.error('Unexpected error during sign out:', signOutError);
                        }
                    }
                    // Always update UI state after sign out attempt, regardless of errors
                    handleAuthStateChange(false);
                } else {
                    // Fallback: just reload page (localStorage mode)
                    if (confirm('Sign out and reload page?')) {
                        window.location.reload();
                    }
                }
            } catch (error) {
                // Catch any unexpected errors, but still try to update UI
                console.error('Error during logout process:', error);
                handleAuthStateChange(false);
            }
        }

        // Override auth state change handler
        async function handleAuthStateChange(isAuthenticated) {
            console.log('handleAuthStateChange called:', isAuthenticated);
            const authOverlay = document.getElementById('auth-overlay');
            const userMenu = document.getElementById('user-menu');
            const mainContainer = document.querySelector('.container');

            // Check if we're in simplified login mode (any view param triggers simplified login)
            const urlParams = new URLSearchParams(window.location.search);
            const viewParam = urlParams.get('view');
            const needsSimplifiedLogin = (viewParam === 'assignments' || viewParam === 'rider' || viewParam === 'coach') && !simplifiedLoginInfo;

            if (needsSimplifiedLogin && !isAuthenticated) {
                // Show simplified login form
                if (authOverlay) {
                    authOverlay.classList.remove('hidden');
                    authOverlay.style.display = 'flex';
                }
                if (mainContainer) mainContainer.style.display = 'none';
                if (userMenu) userMenu.style.display = 'none';
                showSimplifiedLogin();
                return;
            }

            if (isAuthenticated || simplifiedLoginInfo) {
                console.log('Hiding auth overlay, showing main app');
                
                // For simplified login, hide auth overlay and show main app
                if (simplifiedLoginInfo && !isAuthenticated) {
                    // Simplified login mode - show main app without full auth
                    if (authOverlay) {
                        authOverlay.classList.add('hidden');
                        authOverlay.style.display = 'none';
                    }
                    if (mainContainer) mainContainer.style.display = 'block';
                    
                    // Apply simplified view mode based on stored login info
                    if (simplifiedLoginInfo.type === 'rider') {
                        simplifiedLoginMode = 'rider';
                        enableSimplifiedViewMode('rider');
                    } else if (simplifiedLoginInfo.type === 'coach') {
                        simplifiedLoginMode = 'coach';
                        enableSimplifiedViewMode('coach');
                    }
                    
                    // Load application data
                    await loadApplicationData();
                    return;
                }
                
                // Create automatic backup on login (only if this is a new login, not initial page load)
                // Check if this is a new login by checking if auth overlay was visible
                const wasAuthVisible = authOverlay && !authOverlay.classList.contains('hidden');
                if (wasAuthVisible) {
                    try {
                        await createAutomaticBackup('auto_login');
                    } catch (backupError) {
                        console.warn('Failed to create backup on login:', backupError);
                        // Don't block login if backup fails
                    }
                }
                
                // Hide auth overlay, show main app
                if (authOverlay) {
                    authOverlay.classList.add('hidden');
                    authOverlay.style.display = 'none'; // Explicitly hide
                    console.log('Auth overlay hidden');
                }
                if (mainContainer) {
                    mainContainer.style.display = 'block';
                    console.log('Main container shown');
                }
                
                // Show user menu
                if (userMenu) {
                    const currentUser = getCurrentUser();
                    const currentRole = getCurrentUserRole();
                    
                    const userNameEl = document.getElementById('user-name');
                    const userRoleEl = document.getElementById('user-role');
                    
                    if (userNameEl && currentUser) {
                        userNameEl.textContent = currentUser.user_metadata?.name || currentUser.email || 'User';
                    }
                    if (userRoleEl && currentRole) {
                        userRoleEl.textContent = currentRole.replace('_', ' ');
                    }
                    
                    userMenu.style.display = 'flex';
                }
                
                // Apply role-based UI restrictions
                applyRoleBasedAccess();
                
                // Wait for role to be fully loaded, then load data
                // Retry a few times if role isn't loaded yet
                let retries = 0;
                const maxRetries = 10; // Increased retries for role loading
                const checkRoleAndLoad = async () => {
                    const role = getCurrentUserRole();
                    // If role is loaded (even if null), or we've exhausted retries, load data
                    // For coaches, we want to make sure role is definitely loaded
                    if (role !== null || retries >= maxRetries) {
                        // Role is loaded (or null is expected), now load data
                        // Add a small delay to ensure RLS policies have the role
                        await new Promise(resolve => setTimeout(resolve, 300));
                        await loadApplicationData();
                        await initAdminEditLock();
                    } else {
                        // Wait a bit and retry
                        retries++;
                        setTimeout(checkRoleAndLoad, 300); // Increased delay between retries
                    }
                };
                
                // Start checking after a short delay to let role load
                setTimeout(checkRoleAndLoad, 200);
            } else {
                // Show auth overlay, hide main app
                if (authOverlay) {
                    authOverlay.classList.remove('hidden');
                    authOverlay.style.display = 'flex'; // Override inline style
                }
                if (mainContainer) mainContainer.style.display = 'none';
                if (userMenu) userMenu.style.display = 'none';
            }
        }

        // Apply role-based access control to UI
        function applyRoleBasedAccess() {
            // Hide/show tabs based on role
            const tabs = {
                'settings': document.querySelector('.tab[onclick*="settings"]'),
                'roster': document.querySelector('.tab[onclick*="roster"]'),
                'rides': document.querySelector('.tab[onclick*="rides"]'),
                'routes': document.querySelector('.tab[onclick*="routes"]')
            };

            const tabContents = {
                'settings': document.getElementById('settings-tab'),
                'roster': document.getElementById('roster-tab'),
                'rides': document.getElementById('rides-tab'),
                'routes': document.getElementById('routes-tab')
            };

            // Season Setup button is now in user menu - no need to show/hide header-actions

            if (tabs.routes) {
                tabs.routes.style.display = canViewRoutes() ? 'block' : 'none';
            }

            // Update mobile menu
            const mobileMenuItems = document.querySelectorAll('.mobile-menu-item');
            mobileMenuItems.forEach(item => {
                const text = item.textContent.trim();
                if (text.includes('Routes') && !canViewRoutes()) {
                    item.style.display = 'none';
                } else if (text.includes('Season') && !canViewSeasonSetup()) {
                    item.style.display = 'none';
                } else {
                    item.style.display = 'block';
                }
            });
        }

        function setReadOnlyMode(enabled, lockInfo = null) {
            isReadOnlyMode = enabled === true;
            window.isReadOnlyMode = isReadOnlyMode;
            readOnlyLockInfo = lockInfo || null;
            readOnlyNoticeShown = false;
            const banner = document.getElementById('read-only-banner');
            if (banner) {
                if (isReadOnlyMode) {
                    const name = lockInfo?.user_name || lockInfo?.email || 'another admin';
                    banner.textContent = `Read-only mode: ${name} is currently logged in with editing access.`;
                    banner.style.display = 'block';
                } else {
                    banner.style.display = 'none';
                }
            }
        }

        function isReadOnlyInteractionAllowed(target) {
            if (!target) return false;
            if (target.closest('.tab')) return true;
            if (target.closest('.mobile-menu-item')) return true;
            if (target.closest('.mobile-menu-button')) return true;
            if (target.closest('#practice-reporting-prev, #practice-reporting-next')) return true;
            if (target.closest('#prior-practice-btn, #next-practice-btn')) return true;
            if (target.closest('[data-readonly-allow="true"]')) return true;
            return false;
        }

        function handleReadOnlyInteraction(event) {
            if (!isReadOnlyMode) return;
            const target = event.target;
            const actionable = target.closest('button, input, select, textarea, a, [onclick], [draggable="true"]');
            if (!actionable) return;
            if (isReadOnlyInteractionAllowed(actionable)) return;
            event.preventDefault();
            event.stopPropagation();
            if (!readOnlyNoticeShown) {
                const name = readOnlyLockInfo?.user_name || readOnlyLockInfo?.email || 'another admin';
                alert(`Read-only mode: ${name} is currently logged in with editing access.`);
                readOnlyNoticeShown = true;
            }
        }

        document.addEventListener('click', handleReadOnlyInteraction, true);
        document.addEventListener('change', handleReadOnlyInteraction, true);
        document.addEventListener('input', handleReadOnlyInteraction, true);
        document.addEventListener('dragstart', handleReadOnlyInteraction, true);

        async function initAdminEditLock() {
            if (!isCoach()) return;
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            if (!currentUser) return;
            if (typeof getAdminEditLock !== 'function' || typeof upsertAdminEditLock !== 'function') {
                return;
            }
            try {
                const lock = await getAdminEditLock();
                const now = new Date();
                const lockUpdatedAt = lock?.updated_at ? new Date(lock.updated_at) : null;
                const lockFresh = lockUpdatedAt && (now - lockUpdatedAt) < 2 * 60 * 1000;
                if (lockFresh && lock.user_id && lock.user_id !== currentUser.id) {
                    setReadOnlyMode(true, lock);
                    const name = lock.user_name || lock.email || 'another admin';
                    alert(`Read-only mode enabled. ${name} is currently logged in with editing access.`);
                    return;
                }

                await upsertAdminEditLock({
                    user_id: currentUser.id,
                    email: currentUser.email || null,
                    user_name: currentUser.user_metadata?.name || currentUser.email || 'Admin'
                });
                setReadOnlyMode(false, null);

                if (adminEditLockInterval) {
                    clearInterval(adminEditLockInterval);
                }
                adminEditLockInterval = setInterval(async () => {
                    if (isReadOnlyMode) return;
                    await upsertAdminEditLock({
                        user_id: currentUser.id,
                        email: currentUser.email || null,
                        user_name: currentUser.user_metadata?.name || currentUser.email || 'Admin'
                    });
                }, 60 * 1000);
            } catch (error) {
                console.warn('Failed to initialize admin edit lock:', error);
            }
        }

        async function releaseAdminEditLock() {
            if (adminEditLockInterval) {
                clearInterval(adminEditLockInterval);
                adminEditLockInterval = null;
            }
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            if (!currentUser || typeof clearAdminEditLock !== 'function') return;
            await clearAdminEditLock(currentUser.id);
        }

        // Old loadApplicationData function removed - use async version below


        // Global variables for simplified login
        let simplifiedLoginMode = null; // 'rider' or 'coach'
        let simplifiedLoginInfo = null;

        // Initialize
        async function init() {
            // Check for simplified login view mode (any view param triggers simplified login)
            const urlParams = new URLSearchParams(window.location.search);
            const viewParam = urlParams.get('view');
            const isSimplifiedView = viewParam === 'assignments' || viewParam === 'rider' || viewParam === 'coach'; // Support old URLs too
            
            // Check for existing simplified login in sessionStorage
            try {
                const stored = window.sessionStorage.getItem('simplifiedLogin');
                if (stored) {
                    simplifiedLoginInfo = JSON.parse(stored);
                    // Check if stored info is still valid (within 24 hours)
                    const age = Date.now() - (simplifiedLoginInfo.timestamp || 0);
                    if (age < 24 * 60 * 60 * 1000) {
                        simplifiedLoginMode = simplifiedLoginInfo.type;
                    } else {
                        // Expired, clear it
                        window.sessionStorage.removeItem('simplifiedLogin');
                        simplifiedLoginInfo = null;
                    }
                }
            } catch (e) {
                console.warn('Error reading simplified login info:', e);
            }
            
            // If URL param indicates simplified view but no stored login, they need to log in
            if (isSimplifiedView && !simplifiedLoginInfo) {
                // Will show simplified login form in handleAuthStateChange
            } else if (simplifiedLoginInfo) {
                // Use stored login info and apply appropriate view
                simplifiedLoginMode = simplifiedLoginInfo.type;
                if (simplifiedLoginMode === 'rider') {
                    enableSimplifiedViewMode('rider');
                } else if (simplifiedLoginMode === 'coach') {
                    enableSimplifiedViewMode('coach');
                }
            }
            
            // Initialize Supabase client
            if (typeof initSupabase === 'function') {
                initSupabase();
            }
            
            // Initialize authentication (this will call handleAuthStateChange)
            if (typeof initAuth === 'function') {
                initAuth();
            } else {
                // Fallback: if auth not available, use localStorage mode
                await loadApplicationData();
            }

            setupAutoLogoutOnClose();
        }

        function setupAutoLogoutOnClose() {
            const handleClose = () => {
                try {
                    releaseAdminEditLock();
                    if (typeof signOut === 'function') {
                        signOut();
                    }
                } catch (error) {
                    console.warn('Auto-logout on close failed:', error);
                }
            };
            window.addEventListener('beforeunload', handleClose);
            window.addEventListener('pagehide', handleClose);
        }
        
        function enableRiderViewMode() {
            // Legacy function - redirect to new generic function
            enableSimplifiedViewMode('rider');
        }

        function enableSimplifiedViewMode(type) {
            // Hide the desktop tab bar entirely in simplified view (desktop + mobile)
            const desktopTabs = document.getElementById('desktop-tabs');
            if (desktopTabs) {
                if (!desktopTabs.dataset.originalDisplay) {
                    desktopTabs.dataset.originalDisplay = desktopTabs.style.display || 'flex';
                }
                desktopTabs.style.display = 'none';
            }

            // Hide all tabs except the appropriate assignment tab
            const allTabs = document.querySelectorAll('.tab, .mobile-menu-item');
            const targetTabName = type === 'rider' ? 'Rider Assignments' : 'Coach Assignments';
            const targetTabId = type === 'rider' ? 'assignments' : 'coach-assignments';
            
            allTabs.forEach(tab => {
                const tabText = tab.textContent.trim();
                const onClickAttr = tab.getAttribute('onclick') || '';
                const isTargetTab = tabText.includes(targetTabName) || onClickAttr.includes(targetTabId);
                
                if (!isTargetTab) {
                    tab.style.display = 'none';
                } else {
                    tab.style.display = '';
                }
            });
            
            // Hide header actions (user menu, etc.) except sign out
            const userMenu = document.getElementById('user-menu');
            if (userMenu) {
                // Keep user menu but show simplified user info
                const userNameEl = document.getElementById('user-name');
                if (userNameEl && simplifiedLoginInfo) {
                    userNameEl.textContent = simplifiedLoginInfo.name || (type === 'rider' ? 'Rider' : 'Coach');
                }
                const userRoleEl = document.getElementById('user-role');
                if (userRoleEl) {
                    userRoleEl.textContent = type === 'rider' ? 'Rider' : 'Coach';
                }
            }
            
            // Switch to the appropriate assignments tab
            setTimeout(() => {
                const targetTab = type === 'rider' 
                    ? document.querySelector('.tab[onclick*="assignments"]:not([onclick*="coach-assignments"])')
                    : document.querySelector('.tab[onclick*="coach-assignments"]');
                    
                if (targetTab) {
                    targetTab.click();
                } else {
                    // Fallback: switch programmatically
                    switchTab(targetTabId, null);
                }
            }, 100);
            
            // Prevent tab switching (override switchTab function for simplified view)
            const originalSwitchTab = window.switchTab;
            window.switchTab = function(tabName, element) {
                if (tabName !== targetTabId) {
                    // Only allow switching to the target assignment tab
                    return;
                }
                // Call original function
                if (originalSwitchTab) {
                    originalSwitchTab.call(this, tabName, element);
                }
            };
        }
        
        // Load application data (from Supabase if authenticated, otherwise localStorage)
        async function loadApplicationData() {
            // Check if we should load from Supabase
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            const hasSimplifiedLogin = simplifiedLoginInfo !== null;
            
            // Load from Supabase if:
            // 1. User is fully authenticated (has Supabase auth user), OR
            // 2. User has simplified login (rider/coach login via phone/email)
            if (client && (currentUser || hasSimplifiedLogin) && typeof loadDataFromSupabase === 'function') {
                // Try to load from Supabase (works for both authenticated and simplified login users)
                try {
                    await loadDataFromSupabase();
                    // Successfully loaded from Supabase - don't fall back to localStorage
                } catch (error) {
                    // Only fall back if it's a critical error, not just missing settings
                    const isSettingsError = error?.message?.includes('season') || error?.message?.includes('auto-assign') || error?.status === 406;
                    if (isSettingsError && hasSimplifiedLogin) {
                        // For simplified login, settings errors are expected - continue with loaded data
                        console.log('Settings not available for simplified login (expected)');
                    } else {
                        console.warn('Error loading from Supabase, falling back to localStorage:', error);
                        loadData();
                    }
                }
            } else {
                // Not authenticated and no simplified login - load from localStorage (edge case)
                console.warn('Not authenticated - loading from localStorage (fallback mode)');
                loadData();
            }
            
            // Upgrade/normalize data structure
            upgradeData();
            
            // Load season settings (needed for settings tab to display correctly on refresh)
            loadSeasonSettings();
            
            // Re-normalize rides after rosters are loaded to validate assignments
            if (Array.isArray(data.rides)) {
                data.rides = data.rides.map(ride => {
                    const { ride: normalizedRide, changed: rideChanged } = normalizeRideStructure(ride);
                    if (rideChanged) {
                        saveData(); // Save normalized ride
                    }
                    return normalizedRide;
                });
            }
            
            // Render everything
            renderRiders();
            renderCoaches();
            renderRides();
            renderRoutes();
            
            // Restore last active tab
            restoreLastActiveTab();
            
            // Suppress Mapbox errors from Strava embeds (these are harmless)
            // These errors come from Strava's internal Mapbox usage and don't affect functionality
            const originalConsoleError = console.error;
            console.error = function(...args) {
                const errorMsg = args.join(' ');
                // Suppress Mapbox-related errors from Strava embeds
                if (errorMsg.includes('Image "null"') || 
                    errorMsg.includes('Expected value to be of type number, but found null') ||
                    errorMsg.includes('styleimagemissing') ||
                    errorMsg.includes('map.addImage') ||
                    errorMsg.includes('sprite')) {
                    return; // Suppress these errors
                }
                originalConsoleError.apply(console, args);
            };
        }
        
        let lastVisibilityCheck = Date.now();
        let isReloading = false;
        
        // Flush any pending ride saves before reloading
        async function flushPendingSaves() {
            // Clear any pending debounced save
            if (window.rideSaveTimeout) {
                clearTimeout(window.rideSaveTimeout);
                window.rideSaveTimeout = null;
            }
            
            // Save current ride if it exists and has changes
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    try {
                        await saveRideToDB(ride);
                    } catch (error) {
                        console.error('Error flushing ride save:', error);
                    }
                }
            }
        }
        
        function handleVisibilityChange() {
            // Only reload if page becomes visible and it's been at least 5 seconds since last check
            if (!document.hidden && !isReloading) {
                const now = Date.now();
                // Only reload if it's been at least 5 seconds since last check (avoid rapid reloads)
                if (now - lastVisibilityCheck > 5000) {
                    lastVisibilityCheck = now;
                    loadApplicationData();
                }
            }
        }
        
        function handleWindowFocus() {
            // Reload data when window regains focus (but not if we just did a visibility check)
            if (!isReloading) {
                const now = Date.now();
                // Only reload if it's been at least 2 seconds since last check
                if (now - lastVisibilityCheck > 2000) {
                    lastVisibilityCheck = now;
                    loadApplicationData();
                }
            }
        }

        function escapeHtml(value) {
            if (value === undefined || value === null) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function mapAbilityToFitness(ability) {
            const numeric = parseInt(ability, 10);
            if (Number.isFinite(numeric)) {
                return Math.min(10, Math.max(1, numeric * 2));
            }
            return 5;
        }

        function convertRideLevelToFitness(level) {
            if (!level) return 5;
            const normalized = String(level).toLowerCase();
            const mapping = {
                'barely hanging on': 2,
                'ok for roam or sweep': 4,
                'ok to lead lower/middle groups': 7,
                'these kids are slow': 9
            };
            return mapping[normalized] || 5;
        }

        const GRADE_MAP = {
            freshman: '9th',
            sophomore: '10th',
            junior: '11th',
            senior: '12th',
            ninth: '9th',
            tenth: '10th',
            eleventh: '11th',
            twelfth: '12th',
            '9': '9th',
            '9th': '9th',
            '10': '10th',
            '10th': '10th',
            '11': '11th',
            '11th': '11th',
            '12': '12th',
            '12th': '12th'
        };

        function normalizeGradeValue(value) {
            if (!value) return '9th';
            const key = value.toString().trim().toLowerCase();
            return GRADE_MAP[key] || value.toString();
        }

        function formatGradeLabel(grade) {
            return normalizeGradeValue(grade);
        }

        function upgradeData() {
            let changed = false;

            // Ensure arrays exist - preserve existing data from Supabase
            if (!Array.isArray(data.coaches)) {
                data.coaches = [];
            }
            if (!Array.isArray(data.riders)) {
                data.riders = [];
            }
            
            // Initialize auto-assignment settings if missing
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                data.autoAssignSettings = {
                    parameters: [
                        { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 1, enabled: true, requirement: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' },
                        { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 2, enabled: true, requirement: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                        { id: 'preferredGroupSize', name: 'Preferred Min/Max Total Group Size', valueMin: 4, valueMax: 10, priority: 3, enabled: true, requirement: false, type: 'range', min: 1, max: 30, description: 'Preferred group size range (may be exceeded to meet requirements)' },
                        { id: 'organizeByPace', name: 'Organize Groups by Pace', value: 2, priority: 4, enabled: true, requirement: false, type: 'number', min: 0, max: 10, description: 'Preferred maximum pace range within groups' }
                    ]
                };
                changed = true;
            } else {
                // Migrate old parameters to new structure
                const oldParams = data.autoAssignSettings.parameters;
                const newParams = [];
                
                // Check if migration needed (old structure doesn't have requirement field)
                const needsMigration = !oldParams.some(p => p.hasOwnProperty('requirement'));
                
                if (needsMigration) {
                    // Find ridersPerCoach
                    const ridersPerCoach = oldParams.find(p => p.id === 'ridersPerCoach') || { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, enabled: true };
                    newParams.push({ ...ridersPerCoach, priority: 1, requirement: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' });
                    
                    // Find minLeaderLevel
                    const minLeaderLevel = oldParams.find(p => p.id === 'minLeaderLevel') || { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, enabled: true };
                    newParams.push({ ...minLeaderLevel, priority: 2, requirement: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' });
                    
                    // Combine min/max/preferred into single range parameter
                    const minGroupSize = oldParams.find(p => p.id === 'minGroupSize')?.value || 4;
                    const maxGroupSize = oldParams.find(p => p.id === 'maxGroupSize')?.value || 10;
                    newParams.push({ 
                        id: 'preferredGroupSize', 
                        name: 'Preferred Min/Max Total Group Size', 
                        valueMin: minGroupSize, 
                        valueMax: maxGroupSize, 
                        priority: 3, 
                        enabled: true, 
                        requirement: false, 
                        type: 'range', 
                        min: 1, 
                        max: 30, 
                        description: 'Preferred group size range (may be exceeded to meet requirements)' 
                    });
                    
                    // Convert maxFitnessSpread to organizeByPace
                    const maxFitnessSpread = oldParams.find(p => p.id === 'maxFitnessSpread') || { id: 'maxFitnessSpread', value: 2, enabled: true };
                    newParams.push({ 
                        id: 'organizeByPace', 
                        name: 'Organize Groups by Pace', 
                        value: maxFitnessSpread.value || 2, 
                        priority: 4, 
                        enabled: maxFitnessSpread.enabled !== false, 
                        requirement: false, 
                        type: 'number', 
                        min: 0, 
                        max: 10, 
                        description: 'Preferred maximum pace range within groups' 
                    });
                    
                    data.autoAssignSettings.parameters = newParams;
                    changed = true;
                }
            }

            data.coaches = data.coaches.map((coach, index) => {
                // Normalize phone number to 10 digits only
                let normalizedPhone = (coach.phone || '').replace(/\D/g, ''); // Remove all non-digits
                if (normalizedPhone.length !== 10) {
                    // If not 10 digits, generate a valid one based on index
                    normalizedPhone = `415555${(100 + index).toString().padStart(4, '0')}`;
                    changed = true;
                }
                
                // Support both old 'level' and new 'coachingLicenseLevel' fields
                const coachingLicenseLevel = coach.coachingLicenseLevel || coach.level || '1';
                
                // Preserve ALL existing fields, then override only the ones that need normalization
                const upgraded = {
                    ...coach, // Preserve all existing fields first
                    id: coach.id || Date.now(),
                    name: coach.name || '',
                    phone: normalizedPhone,
                    coachingLicenseLevel: coachingLicenseLevel,
                    level: coachingLicenseLevel, // Keep for backward compatibility
                    fitness: coach.fitness ? String(coach.fitness) : (coach.rideLevel ? String(convertRideLevelToFitness(coach.rideLevel)) : '5'),
                    photo: coach.photo || '',
                    notes: coach.notes || '',
                    // Ensure these fields exist (but don't overwrite if already present)
                    email: coach.email || '',
                    gender: coach.gender || '',
                    registered: coach.registered || '',
                    paid: coach.paid || '',
                    backgroundCheck: coach.backgroundCheck || '',
                    workPhone: coach.workPhone || '',
                    homePhone: coach.homePhone || ''
                };
                // Check if normalization actually changed anything
                // Since we use spread operator, all fields are preserved, so we only check normalized fields
                const originalPhone = (coach.phone || '').replace(/\D/g, '');
                const originalLevel = coach.coachingLicenseLevel || coach.level || '1';
                const originalFitness = coach.fitness ? String(coach.fitness) : (coach.rideLevel ? String(convertRideLevelToFitness(coach.rideLevel)) : '5');
                
                if (upgraded.phone !== originalPhone || 
                    upgraded.coachingLicenseLevel !== originalLevel ||
                    upgraded.fitness !== originalFitness) {
                    changed = true;
                }
                return upgraded;
            });

            const skillToFitness = {
                beginner: '2',
                intermediate: '4',
                advanced: '7',
                expert: '9'
            };

            data.riders = data.riders.map((rider, index) => {
                const normalizedGenderInput = (rider.gender || rider.sex || '').toString().trim().toUpperCase();
                const normalizedGender = ['M', 'F', 'NB'].includes(normalizedGenderInput) ? normalizedGenderInput : '';
                
                // Normalize phone number to 10 digits only
                let normalizedPhone = (rider.phone || '').replace(/\D/g, ''); // Remove all non-digits
                if (normalizedPhone.length !== 10) {
                    // If not 10 digits, generate a valid one based on index
                    normalizedPhone = `415556${(200 + index).toString().padStart(4, '0')}`;
                    changed = true;
                }
                
                // Preserve ALL existing fields, then override only the ones that need normalization
                const upgraded = {
                    ...rider, // Preserve all existing fields first
                    id: rider.id || Date.now(),
                    name: rider.name || '',
                    phone: normalizedPhone,
                    grade: normalizeGradeValue(rider.grade || '9th'),
                    racingGroup: rider.racingGroup || 'Freshman',
                    fitness: rider.fitness
                        ? String(rider.fitness)
                        : rider.abilityRanking
                            ? String(mapAbilityToFitness(rider.abilityRanking))
                            : (skillToFitness[rider.skillLevel] || '5'),
                    photo: rider.photo || '',
                    notes: rider.notes || '',
                    gender: normalizedGender,
                    // keep legacy skillLevel if present for compatibility
                    skillLevel: rider.skillLevel || undefined
                };
                if (!rider.fitness && (rider.abilityRanking || rider.skillLevel)) {
                    changed = true;
                }
                // Check if normalization actually changed anything
                // Since we use spread operator, all fields are preserved, so we only check normalized fields
                const originalPhone = (rider.phone || '').replace(/\D/g, '');
                const originalGrade = normalizeGradeValue(rider.grade || '9th');
                const originalRacingGroup = rider.racingGroup || 'Freshman';
                const originalFitness = rider.fitness ? String(rider.fitness) : (rider.abilityRanking ? String(mapAbilityToFitness(rider.abilityRanking)) : (skillToFitness[rider.skillLevel] || '5'));
                const originalGender = normalizedGender;
                
                if (upgraded.phone !== originalPhone ||
                    upgraded.grade !== originalGrade ||
                    upgraded.racingGroup !== originalRacingGroup ||
                    upgraded.fitness !== originalFitness ||
                    upgraded.gender !== originalGender) {
                    changed = true;
                }
                return upgraded;
            });

            // Initialize empty arrays if they don't exist
            if (!Array.isArray(data.riders)) {
                data.riders = [];
                changed = true;
            }
            if (!Array.isArray(data.coaches)) {
                data.coaches = [];
                changed = true;
            }

            if (!Array.isArray(data.rides)) {
                data.rides = [];
                changed = true;
            } else {
                data.rides = data.rides.map(ride => {
                    const { ride: normalizedRide, changed: rideChanged } = normalizeRideStructure(ride);
                    if (rideChanged) {
                        changed = true;
                    }
                    return normalizedRide;
                });
            }

            const previousSeasonState = JSON.stringify(data.seasonSettings || {});
            if (!data.seasonSettings || typeof data.seasonSettings !== 'object') {
                data.seasonSettings = buildDefaultSeasonSettings();
            }

            const normalizedPractices = Array.isArray(data.seasonSettings.practices)
                ? data.seasonSettings.practices
                    .map(practice => {
                        if (!practice || typeof practice !== 'object') {
                            return null;
                        }
                        
                        // Handle single practices (with specificDate) differently from recurring practices
                        const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined;
                        
                        if (isSinglePractice) {
                            // Single practice: require specificDate and time
                            const time = normalizeTimeValue(practice.time || practice.startTime || '');
                            if (!time || !practice.specificDate) {
                                return null;
                            }
                            
                            return {
                                id: practice.id || generateId(),
                                dayOfWeek: null,
                                specificDate: practice.specificDate,
                                time: time,
                                endTime: normalizeTimeValue(practice.endTime || '') || '',
                                description: practice.description || '',
                                meetLocation: practice.meetLocation || '',
                                locationLat: practice.locationLat || null,
                                locationLng: practice.locationLng || null,
                                rosterFilter: practice.rosterFilter || null
                            };
                        } else {
                            // Recurring practice: require dayOfWeek and time
                            const normalized = normalizePracticeEntry(practice);
                            if (!normalized) return null;
                            
                            // Preserve ALL fields from the original practice
                            return {
                                id: practice.id || normalized.id || generateId(),
                                dayOfWeek: normalized.dayOfWeek,
                                specificDate: null,
                                time: normalized.time,
                                endTime: practice.endTime || normalized.endTime || '',
                                description: practice.description || '',
                                meetLocation: practice.meetLocation || '',
                                locationLat: practice.locationLat || null,
                                locationLng: practice.locationLng || null,
                                rosterFilter: practice.rosterFilter || null
                            };
                        }
                    })
                    .filter(Boolean)
                : [];

            // Keep practices in the order they were created (no sorting)

            const normalizedSeason = {
                startDate: data.seasonSettings.startDate || '',
                endDate: data.seasonSettings.endDate || '',
                practices: normalizedPractices,
                // Preserve scale settings and other fields
                fitnessScale: data.seasonSettings.fitnessScale !== undefined ? data.seasonSettings.fitnessScale : 5,
                skillsScale: data.seasonSettings.skillsScale !== undefined ? data.seasonSettings.skillsScale : 3,
                paceScaleOrder: normalizePaceScaleOrder(data.seasonSettings.paceScaleOrder),
                groupPaceOrder: normalizeGroupPaceOrder(data.seasonSettings.groupPaceOrder)
            };
            
            // Preserve any other fields from the original seasonSettings (like Google Sheet URLs, etc.)
            Object.keys(data.seasonSettings).forEach(key => {
                if (!normalizedSeason.hasOwnProperty(key)) {
                    normalizedSeason[key] = data.seasonSettings[key];
                }
            });

            // Only update if the normalized version is actually different
            // This prevents unnecessary overwrites when data is already correct
            const normalizedSeasonStr = JSON.stringify(normalizedSeason);
            if (normalizedSeasonStr !== previousSeasonState) {
                changed = true;
                // Preserve all existing fields in seasonSettings (like csvFieldMappings, fitnessScale, etc.)
                data.seasonSettings = {
                    ...data.seasonSettings,
                    ...normalizedSeason
                };
            }
            // If unchanged, keep the original data.seasonSettings (preserves any extra fields)

            if (changed) {
                saveData();
            }
        }

        function handleFileChange(inputId, labelId) {
            const input = document.getElementById(inputId);
            const label = document.getElementById(labelId);
            if (!label) return;
            const defaultText = label.dataset.default || 'No file selected';

            if (input && input.files && input.files.length > 0) {
                label.textContent = input.files[0].name;
            } else {
                label.textContent = defaultText;
            }
        }

        function readPhotoFile(inputId) {
            return new Promise(resolve => {
                const input = document.getElementById(inputId);
                if (!input || !input.files || input.files.length === 0) {
                    resolve('');
                    return;
                }

                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('');
                reader.readAsDataURL(file);
            });
        }

        // Data persistence functions (using localStorage)
        const STORAGE_KEY = 'teamRideProData';
        const OLD_STORAGE_KEY = 'mtbRosterData'; // For migration from old filename

        // Show visible error alert when database saves fail
        function showSaveError(title, message, error) {
            const errorMsg = error?.message || error?.toString() || 'Unknown error';
            const fullMessage = `${message}\n\nError details: ${errorMsg}\n\nYour changes were NOT saved. Please try again or contact support if the problem persists.`;
            alert(`⚠️ ${title}\n\n${fullMessage}`);
            console.error(`Save error - ${title}:`, error);
        }

        async function saveData() {
            if (isReadOnlyMode) {
                console.warn('Read-only mode: saveData blocked.');
                return;
            }
            // Check if user is authenticated - only save to Supabase for authenticated users
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof updateSeasonSettings === 'function' && typeof updateAutoAssignSettings === 'function') {
                // Authenticated user - save to Supabase only (no localStorage fallback)
                try {
                    console.log('Saving settings to Supabase...');
                    // Check if user has coach-admin role before saving settings
                    const hasPermission = typeof hasRole === 'function' ? hasRole('coach-admin') : false;
                    
                    // Save season settings (including timeEstimationSettings) - only if user has permission
                    if (data.seasonSettings && hasPermission) {
                        try {
                            const seasonData = {
                                id: 'current',
                                start_date: data.seasonSettings.startDate || null,
                                end_date: data.seasonSettings.endDate || null,
                                practices: data.seasonSettings.practices || [],
                                fitnessScale: data.seasonSettings.fitnessScale !== undefined ? data.seasonSettings.fitnessScale : 5,
                                skillsScale: data.seasonSettings.skillsScale !== undefined ? data.seasonSettings.skillsScale : 3,
                                paceScaleOrder: normalizePaceScaleOrder(data.seasonSettings.paceScaleOrder),
                                groupPaceOrder: normalizeGroupPaceOrder(data.seasonSettings.groupPaceOrder),
                                csvFieldMappings: data.seasonSettings.csvFieldMappings || {},
                                coachRoles: Array.isArray(data.coachRoles) ? data.coachRoles : [],
                                riderRoles: Array.isArray(data.riderRoles) ? data.riderRoles : [],
                                timeEstimationSettings: data.timeEstimationSettings || {
                                    fastSpeedBase: 12.5,
                                    slowSpeedBase: 10,
                                    fastSpeedMin: 5.5,
                                    slowSpeedMin: 4,
                                    elevationAdjustment: 0.5,
                                    lengthAdjustmentFactor: 0.1
                                }
                            };
                            console.log('Saving season settings to Supabase:', { fitnessScale: seasonData.fitnessScale, skillsScale: seasonData.skillsScale, paceScaleOrder: seasonData.paceScaleOrder, groupPaceOrder: seasonData.groupPaceOrder });
                            const result = await updateSeasonSettings(seasonData);
                            console.log('Season settings saved to Supabase, returned:', { fitnessScale: result.fitnessScale, skillsScale: result.skillsScale });
                        } catch (error) {
                            // Handle RLS errors gracefully - user may not have coach-admin role yet
                            if (error.message && error.message.includes('row-level security')) {
                                console.warn('User does not have permission to save season settings. They may need to be assigned the coach-admin role.');
                                // Don't show error to user - this is expected for new users without roles
                            } else {
                                throw error; // Re-throw other errors
                            }
                        }
                    } else if (data.seasonSettings && !hasPermission) {
                        console.warn('User does not have coach-admin role - skipping season settings save');
                    }
                    
                    // Save auto-assign settings - only if user has permission
                    if (data.autoAssignSettings && data.autoAssignSettings.parameters && hasPermission) {
                        try {
                            const autoAssignData = {
                                id: 'current',
                                parameters: data.autoAssignSettings.parameters
                            };
                            await updateAutoAssignSettings(autoAssignData);
                            console.log('Auto-assign settings saved to Supabase');
                        } catch (error) {
                            // Handle RLS errors gracefully
                            if (error.message && error.message.includes('row-level security')) {
                                console.warn('User does not have permission to save auto-assign settings.');
                            } else {
                                throw error; // Re-throw other errors
                            }
                        }
                    }
                    
                    // Save races - only if user has permission
                    if (typeof upsertAllRaces === 'function' && Array.isArray(data.races) && hasPermission) {
                        try {
                            await upsertAllRaces(data.races);
                            console.log('Races saved to Supabase');
                        } catch (error) {
                            // Handle RLS errors gracefully
                            if (error.message && error.message.includes('row-level security')) {
                                console.warn('User does not have permission to save races.');
                            } else {
                                throw error; // Re-throw other errors
                            }
                        }
                    }
                    
                    console.log('Settings saved to Supabase successfully');
                } catch (error) {
                    // Handle network errors more gracefully
                    const isNetworkError = error?.message?.includes('Failed to fetch') || 
                                         error?.message?.includes('NetworkError') ||
                                         error?.name === 'TypeError' && error?.message?.includes('fetch');
                    
                    if (isNetworkError) {
                        console.warn('Network error saving to Supabase, falling back to localStorage:', error);
                        // Fallback to localStorage if network fails
                        try {
                            const dataToSave = {
                                riders: data.riders,
                                coaches: data.coaches,
                                rides: data.rides,
                                routes: data.routes,
                                races: data.races || [],
                                currentRide: data.currentRide,
                                seasonSettings: data.seasonSettings,
                                autoAssignSettings: data.autoAssignSettings,
                                coachRoles: data.coachRoles || [],
                                riderRoles: data.riderRoles || []
                            };
                            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                            console.log('Data saved to localStorage (network fallback)');
                            // Don't show error for network issues - just use localStorage fallback
                            return;
                        } catch (localError) {
                            // If localStorage also fails, show error
                            showSaveError(
                                'Failed to Save Settings',
                                'An error occurred while saving your settings. Network error and local storage both failed.',
                                error
                            );
                            throw error;
                        }
                    } else {
                        // Show error for other types of errors
                    showSaveError(
                        'Failed to Save Settings',
                        'An error occurred while saving your settings to the database.',
                        error
                    );
                    throw error; // Re-throw to prevent silent failures
                    }
                }
            } else {
                // Not authenticated - use localStorage (edge case, should rarely happen)
                // For simplified login users, this is expected (they can read from Supabase but save to localStorage)
                const hasSimplifiedLogin = simplifiedLoginInfo !== null;
                if (!hasSimplifiedLogin) {
                    if (!client || !currentUser) {
                        console.warn('User not authenticated - saving to localStorage as fallback');
                    } else {
                        console.warn('Database functions not available - saving to localStorage as fallback');
                    }
                } else {
                    // Simplified login user - silently save to localStorage (expected behavior)
                    console.log('Simplified login user - saving to localStorage (read-only mode)');
                }
                
                try {
                    const dataToSave = {
                        riders: data.riders,
                        coaches: data.coaches,
                        rides: data.rides,
                        routes: data.routes,
                        races: data.races || [],
                        currentRide: data.currentRide,
                        seasonSettings: data.seasonSettings,
                        autoAssignSettings: data.autoAssignSettings,
                        coachRoles: data.coachRoles || [],
                        riderRoles: data.riderRoles || []
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                    console.log('Data saved to localStorage (fallback mode)');
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                    alert('⚠️ Unable to save data. Local storage may be full. Please log in to save to the database.');
                }
            }
        }

        // Load data from Supabase (authenticated users only - no localStorage fallback)
        async function loadDataFromSupabase() {
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            const hasSimplifiedLogin = simplifiedLoginInfo !== null;
            
            if (!client) {
                throw new Error('Supabase client not available');
            }
            
            // Allow loading for authenticated users OR simplified login users
            // Simplified login users can read data if RLS policies allow
            if (!currentUser && !hasSimplifiedLogin) {
                throw new Error('Not authenticated - cannot load from Supabase');
            }
            
            if (typeof getAllRiders === 'undefined' || typeof getAllCoaches === 'undefined') {
                throw new Error('Database functions not available');
            }
            
            try {
                // For simplified login users, skip settings that require authentication
                // They only need riders, coaches, rides, and routes for the assignments view
                const loadPromises = [
                    getAllRiders().catch(err => { console.error('Error loading riders:', err); return []; }),
                    getAllCoaches().catch(err => { console.error('Error loading coaches:', err); return []; }),
                    getAllRides().catch(err => { console.error('Error loading rides:', err); return []; }),
                    getAllRoutes().catch(err => { console.error('Error loading routes:', err); return []; })
                ];
                
                // Only load settings if user is fully authenticated (not simplified login)
                let seasonSettings = null;
                let autoAssignSettings = null;
                if (currentUser) {
                    // Fully authenticated user - load settings
                    loadPromises.push(
                        getSeasonSettings().catch(err => { 
                            // Silently handle 406 errors for simplified login users
                            if (err?.code !== 'PGRST301' && err?.status !== 406) {
                                console.error('Error loading season settings:', err); 
                            }
                            return null; 
                        }),
                        getAutoAssignSettings().catch(err => { 
                            // Silently handle 406 errors for simplified login users
                            if (err?.code !== 'PGRST301' && err?.status !== 406) {
                                console.error('Error loading auto-assign settings:', err); 
                            }
                            return null; 
                        })
                    );
                } else {
                    // Simplified login user - skip settings (not needed for assignments view)
                    loadPromises.push(Promise.resolve(null), Promise.resolve(null));
                }
                
                // Load races if function is available
                loadPromises.push(
                    typeof getAllRaces === 'function' 
                        ? getAllRaces().catch(err => { console.error('Error loading races in Promise.all:', err); return []; }) 
                        : Promise.resolve([])
                );
                
                const [riders, coaches, rides, routes, seasonSettingsResult, autoAssignSettingsResult, races] = await Promise.all(loadPromises);
                seasonSettings = seasonSettingsResult;
                autoAssignSettings = autoAssignSettingsResult;
                
                // Map data to app structure
                data.riders = riders || [];
                data.coaches = coaches || [];
                data.routes = routes || [];
                
                // Normalize rides - keep only valid coach IDs if roster is loaded
                const validCoachIds = new Set((data.coaches || []).map(coach => {
                    const id = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                    return Number.isFinite(id) ? id : coach.id;
                }));
                const hasCoachRoster = validCoachIds.size > 0;
                data.rides = (rides || []).map(ride => {
                    const normalizedRide = { ...ride };
                    if (Array.isArray(normalizedRide.availableCoaches)) {
                        normalizedRide.availableCoaches = normalizedRide.availableCoaches
                            .map(id => typeof id === 'string' ? parseInt(id, 10) : id)
                            .filter(id => Number.isFinite(id) && (!hasCoachRoster || validCoachIds.has(id)));
                        normalizedRide.availableCoaches = Array.from(new Set(normalizedRide.availableCoaches)); // Deduplicate
                    }
                    return normalizedRide;
                });
                
                // Debug: Log deleted rides loaded from Supabase
                const deletedRides = data.rides.filter(r => r.deleted);
                console.log('📥 loadDataFromSupabase: Loaded', data.rides.length, 'rides,', deletedRides.length, 'deleted:', deletedRides.map(r => ({ id: r.id, date: r.date, deleted: r.deleted })));
                
                // Map season settings (getSeasonSettings already returns app format with fitnessScale and skillsScale)
                if (seasonSettings) {
                    console.log('Season settings from Supabase:', { 
                        fitnessScale: seasonSettings.fitnessScale, 
                        skillsScale: seasonSettings.skillsScale,
                        paceScaleOrder: seasonSettings.paceScaleOrder,
                        groupPaceOrder: seasonSettings.groupPaceOrder,
                        hasFitnessScale: 'fitnessScale' in seasonSettings,
                        hasSkillsScale: 'skillsScale' in seasonSettings
                    });
                    // Use ONLY Supabase data (no localStorage preservation)
                    // Convert null/undefined to empty string for consistency
                    const startDate = seasonSettings.startDate || seasonSettings.start_date || '';
                    const endDate = seasonSettings.endDate || seasonSettings.end_date || '';
                    data.seasonSettings = {
                        startDate: startDate,
                        endDate: endDate,
                        practices: seasonSettings.practices || [],
                        fitnessScale: seasonSettings.fitnessScale !== undefined && seasonSettings.fitnessScale !== null ? seasonSettings.fitnessScale : 5,
                        skillsScale: seasonSettings.skillsScale !== undefined && seasonSettings.skillsScale !== null ? seasonSettings.skillsScale : 3,
                        paceScaleOrder: seasonSettings.paceScaleOrder || 'fastest_to_slowest',
                        groupPaceOrder: seasonSettings.groupPaceOrder || 'fastest_to_slowest',
                        csvFieldMappings: seasonSettings.csvFieldMappings || seasonSettings.csv_field_mappings || {}
                    };
                    
                    // Load coachRoles and riderRoles from season settings
                    if (Array.isArray(seasonSettings.coachRoles)) {
                        data.coachRoles = seasonSettings.coachRoles;
                    } else {
                        data.coachRoles = [];
                    }
                    if (Array.isArray(seasonSettings.riderRoles)) {
                        data.riderRoles = seasonSettings.riderRoles;
                    } else {
                        data.riderRoles = [];
                    }
                    console.log('Mapped season settings:', { fitnessScale: data.seasonSettings.fitnessScale, skillsScale: data.seasonSettings.skillsScale, paceScaleOrder: data.seasonSettings.paceScaleOrder, groupPaceOrder: data.seasonSettings.groupPaceOrder });
                    
                    // Map timeEstimationSettings from seasonSettings
                    if (seasonSettings.timeEstimationSettings) {
                        data.timeEstimationSettings = seasonSettings.timeEstimationSettings;
                    } else {
                        // Provide defaults if not present
                        data.timeEstimationSettings = {
                            fastSpeedBase: 12.5,
                            slowSpeedBase: 10,
                            fastSpeedMin: 5.5,
                            slowSpeedMin: 4,
                            elevationAdjustment: 0.5,
                            lengthAdjustmentFactor: 0.1
                        };
                    }
                } else {
                    console.log('No season settings from Supabase - using defaults');
                    // No season settings in Supabase - initialize with defaults
                    data.seasonSettings = {
                        startDate: '',
                        endDate: '',
                        practices: [],
                        fitnessScale: 5,  // Default for first-time users
                        skillsScale: 3,   // Default for first-time users
                        paceScaleOrder: 'fastest_to_slowest',
                        groupPaceOrder: 'fastest_to_slowest'
                    };
                    // Initialize timeEstimationSettings with defaults if no season settings
                    data.timeEstimationSettings = {
                        fastSpeedBase: 12.5,
                        slowSpeedBase: 10,
                        fastSpeedMin: 5.5,
                        slowSpeedMin: 4,
                        elevationAdjustment: 0.5,
                        lengthAdjustmentFactor: 0.1
                    };
                }
                
                // Map auto-assign settings
                if (autoAssignSettings && autoAssignSettings.parameters) {
                    data.autoAssignSettings = {
                        parameters: autoAssignSettings.parameters
                    };
                }
                
                // Map races
                if (Array.isArray(races)) {
                    data.races = races;
                } else {
                    data.races = [];
                }
                
                console.log('Data loaded from Supabase:', {
                    riders: data.riders.length,
                    coaches: data.coaches.length,
                    rides: data.rides.length,
                    routes: data.routes.length,
                    races: data.races.length,
                    seasonSettings: !!data.seasonSettings,
                    autoAssignSettings: !!data.autoAssignSettings,
                    timeEstimationSettings: !!data.timeEstimationSettings
                });
                
                // Update scale inputs immediately after data loads (before DOMContentLoaded handler runs)
                updateScaleInputsFromData();
                
                // Update season settings UI (including date range button) after data loads
                loadSeasonSettings();
            } catch (error) {
                console.error('Error loading from Supabase:', error);
                // Do NOT fallback to localStorage - show error instead
                showSaveError(
                    'Failed to Load Data',
                    'An error occurred while loading data from the database. Please refresh the page or contact support if the problem persists.',
                    error
                );
                throw error; // Re-throw to prevent continuation with empty data
            }
        }

        function loadData() {
            // Check if user is authenticated - if so, don't load from localStorage
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser) {
                // Authenticated user - localStorage should NOT be used
                // Silently return (this is expected when renderRides() calls loadData())
                return;
            }
            
            try {
                // First, try to load from new key
                let stored = localStorage.getItem(STORAGE_KEY);
                
                // If not found, check for old key and migrate
                if (!stored) {
                    const oldStored = localStorage.getItem(OLD_STORAGE_KEY);
                    if (oldStored) {
                        console.log('Migrating data from old localStorage key...');
                        // Copy old data to new key
                        localStorage.setItem(STORAGE_KEY, oldStored);
                        stored = oldStored;
                        // Optionally remove old key (commented out to be safe)
                        // localStorage.removeItem(OLD_STORAGE_KEY);
                    }
                }
                
                if (stored) {
                    const parsed = JSON.parse(stored);
                    // Merge with existing data structure - preserve ALL fields
                    if (parsed.riders) data.riders = parsed.riders;
                    if (parsed.coaches) data.coaches = parsed.coaches;
                    if (parsed.rides) data.rides = parsed.rides;
                    if (parsed.routes) data.routes = parsed.routes;
                    if (Array.isArray(parsed.races)) data.races = parsed.races;
                    if (parsed.currentRide !== undefined) data.currentRide = parsed.currentRide;
                    if (parsed.seasonSettings) {
                        // Preserve the entire seasonSettings object
                        data.seasonSettings = parsed.seasonSettings;
                    }
                    if (parsed.autoAssignSettings) data.autoAssignSettings = parsed.autoAssignSettings;
                    if (parsed.timeEstimationSettings) data.timeEstimationSettings = parsed.timeEstimationSettings;
                    if (Array.isArray(parsed.coachRoles)) data.coachRoles = parsed.coachRoles;
                    else if (!data.coachRoles) data.coachRoles = [];
                    if (Array.isArray(parsed.riderRoles)) data.riderRoles = parsed.riderRoles;
                    else if (!data.riderRoles) data.riderRoles = [];
                    
                    // Ensure scale settings exist
                    if (!data.seasonSettings) {
                        data.seasonSettings = buildDefaultSeasonSettings();
                    }
                    // Only set defaults if the values are truly missing (not if they're 0 or null explicitly saved)
                    if (data.seasonSettings.fitnessScale === undefined || data.seasonSettings.fitnessScale === null) {
                        data.seasonSettings.fitnessScale = 5;
                    }
                    if (data.seasonSettings.skillsScale === undefined || data.seasonSettings.skillsScale === null) {
                        data.seasonSettings.skillsScale = 3;
                    }
                    
                    // Update scale input fields with saved values (after DOM is ready)
                    function updateScaleInputs() {
                        const fitnessScaleInput = document.getElementById('fitness-scale');
                        const skillsScaleInput = document.getElementById('skills-scale');
                        const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
                        const skillsScaleDisplay = document.getElementById('skills-scale-display');
                        
                        const savedFitnessScale = data.seasonSettings?.fitnessScale;
                        const savedSkillsScale = data.seasonSettings?.skillsScale;
                        
                        console.log('Updating scale inputs:', { savedFitnessScale, savedSkillsScale });
                        
                        if (fitnessScaleInput && savedFitnessScale !== undefined && savedFitnessScale !== null) {
                            fitnessScaleInput.value = savedFitnessScale;
                            fitnessScaleInput.setAttribute('value', savedFitnessScale); // Also set attribute
                            if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = savedFitnessScale;
                            console.log('Set fitness scale input to:', savedFitnessScale);
                        }
                        if (skillsScaleInput && savedSkillsScale !== undefined && savedSkillsScale !== null) {
                            // For select dropdown, set the selected option
                            const validScale = (savedSkillsScale === 3 || savedSkillsScale === 5) ? savedSkillsScale : 3;
                            skillsScaleInput.value = String(validScale);
                            // Also set selected attribute on the option
                            Array.from(skillsScaleInput.options).forEach(opt => {
                                opt.selected = opt.value === String(validScale);
                            });
                            if (skillsScaleDisplay) skillsScaleDisplay.textContent = validScale;
                            console.log('Set skills scale input to:', validScale);
                        }
                        // Update bike skills descriptions
                        updateBikeSkillsDescriptions();
                        // Update input max attributes
                        updateInputMaxAttributes();
                        // Update bike skills descriptions
                        updateBikeSkillsDescriptions();
                    }
                    
                    // Try to update immediately, and also after DOM is ready
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', () => {
                            updateScaleInputs();
                            updateBikeSkillsDescriptions();
                        });
                    } else {
                        // DOM is already ready, but wait a bit to ensure elements exist
                        setTimeout(updateScaleInputs, 100);
                    }
                    // Also try after a longer delay as backup
                    setTimeout(updateScaleInputs, 500);
                    // One more backup after even longer delay
                    setTimeout(updateScaleInputs, 1000);
                    // Update bike skills descriptions after inputs are set
                    setTimeout(updateBikeSkillsDescriptions, 1100);
                    
                    console.log('Data loaded from localStorage:', {
                        riders: data.riders.length,
                        coaches: data.coaches.length,
                        rides: data.rides.length,
                        routes: data.routes.length,
                        seasonSettings: data.seasonSettings ? {
                            startDate: data.seasonSettings.startDate,
                            endDate: data.seasonSettings.endDate,
                            practicesCount: data.seasonSettings.practices?.length || 0,
                            fitnessScale: data.seasonSettings.fitnessScale,
                            skillsScale: data.seasonSettings.skillsScale
                        } : null
                    });
                } else {
                    console.log('No data found in localStorage');
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Save rider to database or localStorage
        async function saveRiderToDB(riderData) {
            if (isReadOnlyMode) {
                console.warn('Read-only mode: saveRiderToDB blocked.');
                return;
            }
            // Check if database functions are available and user is authenticated
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof updateRider !== 'undefined' && typeof createRider !== 'undefined') {
                // Authenticated user - save to Supabase only
                try {
                    // Map app fields to database fields
                    const dbData = {
                        name: riderData.name,
                        phone: riderData.phone || null,
                        email: riderData.email || null,
                        grade: riderData.grade || null,
                        gender: riderData.gender || null,
                        racing_group: riderData.racingGroup || riderData.racing_group || null,
                        fitness: riderData.fitness || '5',
                        skills: riderData.skills || '3',
                        photo: riderData.photo || null,
                        notes: riderData.notes || null
                    };
                    
                    if (riderData.id && data.riders.find(r => r.id === riderData.id)) {
                        // Update existing - pass app format data (with racingGroup) not db format
                        const updated = await updateRider(riderData.id, riderData);
                        // Update local data (merge with existing fields)
                        const index = data.riders.findIndex(r => r.id === riderData.id);
                        if (index !== -1) {
                            data.riders[index] = { ...data.riders[index], ...riderData, ...updated };
                        }
                    } else {
                        // Create new
                        const created = await createRider(riderData);
                        // Merge with local extra fields and add to local data
                        const newRider = { ...riderData, ...created };
                        data.riders.push(newRider);
                        return newRider;
                    }
                    return;
                } catch (error) {
                    showSaveError(
                        'Failed to Save Rider',
                        `An error occurred while saving ${riderData.name || 'the rider'}.`,
                        error
                    );
                    throw error; // Re-throw to prevent silent failures
                }
            } else {
                // Not authenticated - use localStorage (edge case)
                console.warn('User not authenticated - saving rider to localStorage as fallback');
                if (riderData.id && data.riders.find(r => r.id === riderData.id)) {
                    // Update existing
                    const index = data.riders.findIndex(r => r.id === riderData.id);
                    if (index !== -1) {
                        data.riders[index] = { ...data.riders[index], ...riderData };
                    }
                } else {
                    // Create new
                    const newRider = {
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        ...riderData
                    };
                    data.riders.push(newRider);
                    return newRider;
                }
                await saveData();
            }
        }

        // Save coach to database or localStorage
        async function saveCoachToDB(coachData) {
            if (isReadOnlyMode) {
                console.warn('Read-only mode: saveCoachToDB blocked.');
                return;
            }
            // Check if database functions are available and user is authenticated
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof updateCoach !== 'undefined' && typeof createCoach !== 'undefined') {
                // Authenticated user - save to Supabase only
                try {
                    // Map app fields to database fields (database supports: name, phone, email, level, fitness, skills, photo, notes, user_id)
                    const dbData = {
                        name: coachData.name,
                        phone: coachData.phone || null,
                        email: coachData.email || null,
                        level: coachData.coachingLicenseLevel || coachData.level || '1',
                        fitness: coachData.fitness || '5',
                        skills: coachData.skills || '3',
                        photo: coachData.photo || null,
                        notes: coachData.notes || null
                    };
                    
                    if (coachData.id && data.coaches.find(c => c.id === coachData.id)) {
                        // Update existing
                        const updated = await updateCoach(coachData.id, coachData);
                        // Update local data
                        const index = data.coaches.findIndex(c => c.id === coachData.id);
                        if (index !== -1) {
                            // Merge database response with local extra fields
                            data.coaches[index] = { ...data.coaches[index], ...coachData, ...updated };
                        }
                    } else {
                        // Create new
                        const created = await createCoach(coachData);
                        // Merge with local extra fields and add to local data
                        const newCoach = { ...coachData, ...created };
                        data.coaches.push(newCoach);
                        return newCoach;
                    }
                    return;
                } catch (error) {
                    showSaveError(
                        'Failed to Save Coach',
                        `An error occurred while saving ${coachData.name || 'the coach'}.`,
                        error
                    );
                    throw error; // Re-throw to prevent silent failures
                }
            } else {
                // Not authenticated - use localStorage (edge case)
                console.warn('User not authenticated - saving coach to localStorage as fallback');
                if (coachData.id && data.coaches.find(c => c.id === coachData.id)) {
                    // Update existing
                    const index = data.coaches.findIndex(c => c.id === coachData.id);
                    if (index !== -1) {
                        data.coaches[index] = { ...data.coaches[index], ...coachData };
                    }
                } else {
                    // Create new
                    const newCoach = {
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        ...coachData
                    };
                    data.coaches.push(newCoach);
                    return newCoach;
                }
                await saveData();
            }
        }

        // Debounced ride save function (using localStorage)
        window.rideSaveTimeout = null;
        function debouncedSaveRide(ride) {
            if (!ride || !ride.id) return;
            
            clearTimeout(window.rideSaveTimeout);
            window.rideSaveTimeout = setTimeout(() => {
                saveRideToDB(ride);
            }, 500); // Save 0.5 seconds after last change
        }

        // Save ride to database or localStorage
        async function saveRideToDB(rideData) {
            if (isReadOnlyMode) {
                console.warn('Read-only mode: saveRideToDB blocked.');
                return;
            }
            // STEP 1: Always update local data immediately (synchronous)
            // This ensures data is available even if navigation happens before async save completes
            if (rideData.id && data.rides.find(r => r.id === rideData.id)) {
                // Update existing - preserve all fields
                const index = data.rides.findIndex(r => r.id === rideData.id);
                if (index !== -1) {
                    // Merge to preserve all existing fields
                    data.rides[index] = { ...data.rides[index], ...rideData };
                }
            } else {
                // Create new
                const newRide = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    date: rideData.date,
                    time: rideData.time || '',
                    endTime: rideData.endTime || '',
                    description: rideData.description || '',
                    meetLocation: rideData.meetLocation || '',
                    locationLat: rideData.locationLat != null ? rideData.locationLat : null,
                    locationLng: rideData.locationLng != null ? rideData.locationLng : null,
                    goals: rideData.goals || null,
                    availableCoaches: rideData.availableCoaches || [],
                    availableRiders: rideData.availableRiders || [],
                    assignments: rideData.assignments || {},
                    groups: rideData.groups || [],
                    cancelled: rideData.cancelled || false,
                    publishedGroups: rideData.publishedGroups || false,
                    ...rideData // Include any other fields from rideData
                };
                data.rides.push(newRide);
            }
            
            // STEP 2: Always save to localStorage immediately (synchronous backup)
            // This ensures data persists even if Supabase save fails or user navigates away
            try {
                const dataToSave = {
                    riders: data.riders,
                    coaches: data.coaches,
                    rides: data.rides,
                    routes: data.routes,
                    currentRide: data.currentRide,
                    seasonSettings: data.seasonSettings,
                    autoAssignSettings: data.autoAssignSettings,
                    sampleVersion: data.sampleVersion,
                    coachRoles: data.coachRoles || [],
                    riderRoles: data.riderRoles || []
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                console.log('💾 Saved ride to localStorage (backup):', rideData.id || 'new');
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                // Continue even if localStorage save fails - try Supabase
            }
            
            // STEP 3: Save to Supabase if authenticated (async)
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof updateRide !== 'undefined' && typeof createRide !== 'undefined') {
                // Authenticated user - save to Supabase
                try {
                    // Map app structure to database structure
                    const dbData = {
                        date: rideData.date,
                        time: rideData.time || '',
                        end_time: rideData.endTime || rideData.end_time || '',
                        description: rideData.description || '',
                        meet_location: rideData.meetLocation || rideData.meet_location || '',
                        location_lat: rideData.locationLat != null ? rideData.locationLat : (rideData.location_lat != null ? rideData.location_lat : null),
                        location_lng: rideData.locationLng != null ? rideData.locationLng : (rideData.location_lng != null ? rideData.location_lng : null),
                        goals: rideData.goals || '',
                        available_coaches: rideData.availableCoaches || rideData.available_coaches || [],
                        available_riders: rideData.availableRiders || rideData.available_riders || [],
                        assignments: rideData.assignments || {},
                        groups: rideData.groups || [],
                        cancelled: rideData.cancelled || false,
                        cancellation_reason: rideData.cancellationReason || rideData.cancellation_reason || '',
                        deleted: rideData.deleted === true ? true : (rideData.deleted === false ? false : false), // Explicitly handle true/false/undefined
                        rescheduled_from: rideData.rescheduledFrom || rideData.rescheduled_from || null,
                        published_groups: rideData.publishedGroups || rideData.published_groups || false
                    };
                    
                    console.log('💾 saveRideToDB: Saving ride to Supabase, id:', rideData.id, 'date:', rideData.date, 'deleted in rideData:', rideData.deleted, 'deleted in dbData:', dbData.deleted);
                    
                    const shouldCreateInDb = rideData.isPersisted !== true;
                    if (!shouldCreateInDb && rideData.id && data.rides.find(r => r.id === rideData.id)) {
                        // Update existing
                        console.log('💾 saveRideToDB: Updating existing ride, id:', rideData.id, 'deleted:', dbData.deleted);
                        const updated = await updateRide(rideData.id, dbData);
                        console.log('💾 saveRideToDB: Updated ride returned, deleted:', updated?.deleted, 'full updated:', updated);
                        // Update local data (merge with existing fields)
                        // Use availableCoaches from rideData (not from updated) to avoid corrupted timestamp IDs
                        const index = data.rides.findIndex(r => r.id === rideData.id);
                        if (index !== -1) {
                            const merged = { ...data.rides[index], ...rideData, ...updated };
                            // Override availableCoaches and availableRiders with the correct value from rideData
                            // This prevents database responses from overwriting locally-set values
                            if (rideData.availableCoaches !== undefined) {
                                merged.availableCoaches = rideData.availableCoaches;
                            }
                            if (rideData.availableRiders !== undefined) {
                                merged.availableRiders = rideData.availableRiders;
                            }
                            // Preserve location fields from rideData
                            if (rideData.meetLocation !== undefined) {
                                merged.meetLocation = rideData.meetLocation;
                            }
                            if (rideData.locationLat !== undefined) {
                                merged.locationLat = rideData.locationLat;
                            }
                            if (rideData.locationLng !== undefined) {
                                merged.locationLng = rideData.locationLng;
                            }
                            data.rides[index] = merged;
                            // Update localStorage again with merged data
                            try {
                                const dataToSave = {
                                    riders: data.riders,
                                    coaches: data.coaches,
                                    rides: data.rides,
                                    routes: data.routes,
                                    currentRide: data.currentRide,
                                    seasonSettings: data.seasonSettings,
                                    autoAssignSettings: data.autoAssignSettings,
                                    sampleVersion: data.sampleVersion,
                                    coachRoles: data.coachRoles || [],
                                    riderRoles: data.riderRoles || []
                                };
                                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                            } catch (error) {
                                console.error('Error updating localStorage after Supabase save:', error);
                            }
                        }
                    } else {
                        // Create new
                        console.log('💾 saveRideToDB: Creating new ride, date:', rideData.date, 'deleted:', dbData.deleted);
                        const created = await createRide(dbData);
                        console.log('💾 saveRideToDB: Created ride returned, id:', created?.id, 'deleted:', created?.deleted);
                        // Merge with local extra fields and add to local data
                        const newRide = { ...rideData, ...created };
                        const index = data.rides.findIndex(r => r.id === rideData.id || (!rideData.id && r.date === rideData.date && r.time === rideData.time));
                        if (index !== -1) {
                            data.rides[index] = newRide;
                        } else {
                        data.rides.push(newRide);
                        }
                        if (data.currentRide === rideData.id && newRide.id) {
                            data.currentRide = newRide.id;
                        }
                        // Update localStorage with new ride ID
                        try {
                            const dataToSave = {
                                riders: data.riders,
                                coaches: data.coaches,
                                rides: data.rides,
                                routes: data.routes,
                                currentRide: data.currentRide,
                                seasonSettings: data.seasonSettings,
                                autoAssignSettings: data.autoAssignSettings,
                                sampleVersion: data.sampleVersion,
                                coachRoles: data.coachRoles || [],
                                riderRoles: data.riderRoles || []
                            };
                            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                        } catch (error) {
                            console.error('Error updating localStorage after Supabase create:', error);
                        }
                        return newRide;
                    }
                    return;
                } catch (error) {
                    // Supabase save failed, but localStorage already has the data
                    console.error('Failed to save ride to Supabase (localStorage backup already saved):', error);
                    showSaveError(
                        'Failed to Save Practice to Cloud',
                        `An error occurred while saving the practice for ${rideData.date || 'this date'} to the cloud. Your changes have been saved locally and will be synced when you return.`,
                        error
                    );
                    // Don't throw - localStorage backup is already saved
                }
            } else {
                // Not authenticated - localStorage already saved above
                console.log('User not authenticated - ride saved to localStorage only');
            }
        }

        // Tab switching
        function switchTab(tabName, element) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.mobile-menu-item').forEach(t => t.classList.remove('active'));
            
            if (element) {
                element.classList.add('active');
            }
            const tab = document.getElementById(tabName + '-tab');
            if (tab) {
                tab.classList.add('active');
            }
            
            // Save active tab to localStorage for persistence
            try {
                localStorage.setItem('lastActiveTab', tabName);
            } catch (e) {
                console.warn('Could not save tab state:', e);
            }
            
            // Update mobile menu
            updateMobileMenu(tabName);
            
            // Hide/show headers and navigation in mobile view for assignments tab
            updateMobileHeaderVisibility(tabName);
            
            if (tabName === 'rides') {
                renderRides();
            } else if (tabName === 'settings') {
                loadSeasonSettings();
                renderSeasonCalendarForSettings();
                updateRoleDropdowns();
                if (typeof loadUsersList === 'function') {
                    loadUsersList();
                }
                if (typeof loadAdminInvitations === 'function') {
                    loadAdminInvitations();
                }
            } else if (tabName === 'roster') {
                applyRosterPreferences();
            } else if (tabName === 'assignments') {
                renderRideAssignments();
            } else if (tabName === 'coach-assignments') {
                renderCoachAssignments();
            } else if (tabName === 'practice-reporting') {
                renderPracticeReporting();
            } else if (tabName === 'routes') {
                // Routes tab doesn't need any special rendering
            }
            
            // Update header button visibility when switching tabs
            updateHeaderEditSeasonButton();
        }

        function toggleMobileMenu() {
            const dropdown = document.getElementById('mobile-menu-dropdown');
            const button = document.getElementById('mobile-menu-button');
            if (dropdown && button) {
                const isOpen = dropdown.classList.contains('show');
                if (isOpen) {
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                } else {
                    dropdown.classList.add('show');
                    button.classList.add('open');
                }
            }
        }

        function selectMobileTab(tabName) {
            // Find the corresponding desktop tab button
            const tabs = document.querySelectorAll('#desktop-tabs .tab');
            let targetElement = null;
            tabs.forEach(tab => {
                if (tab.textContent.trim() === getTabLabel(tabName)) {
                    targetElement = tab;
                }
            });
            
            switchTab(tabName, targetElement);
            toggleMobileMenu(); // Close the dropdown
        }

        function getTabLabel(tabName) {
            const labels = {
                'settings': 'Team Dashboard',
                'roster': 'Roster',
                'coaches': 'Coach Roster',
                'team': 'Team Roster',
                'rides': 'Practice Planner',
                'assignments': 'Rider Assignments',
                'coach-assignments': 'Coach Assignments',
                'practice-reporting': 'Reporting',
                'routes': 'Routes'
            };
            return labels[tabName] || tabName;
        }

        function updateMobileMenu(activeTabName) {
            const menuItems = document.querySelectorAll('.mobile-menu-item');
            
            menuItems.forEach(item => {
                item.classList.remove('active');
                const onclickAttr = item.getAttribute('onclick');
                if (onclickAttr) {
                    const match = onclickAttr.match(/'([^']+)'/);
                    if (match && match[1] === activeTabName) {
                        item.classList.add('active');
                    }
                }
            });
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
            const menuContainer = document.querySelector('.mobile-menu-container');
            const dropdown = document.getElementById('mobile-menu-dropdown');
            const button = document.getElementById('mobile-menu-button');
            
            if (menuContainer && dropdown && button) {
                if (!menuContainer.contains(event.target) && dropdown.classList.contains('show')) {
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                }
            }
        });

        // Initialize mobile menu on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial active tab for mobile menu
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                const tabId = activeTab.id;
                if (tabId) {
                    const tabName = tabId.replace('-tab', '');
                    updateMobileMenu(tabName);
                    // Apply mobile header hiding for assignments tab
                    updateMobileHeaderVisibility(tabName);
                }
            }
            
            // Don't set defaults here - wait for data to load from Supabase
            // updateScaleInputsFromData() will be called after loadDataFromSupabase() completes
            
            // Initialize Google OAuth after data is loaded
            setTimeout(() => {
                loadGoogleToken();
                if (getGoogleClientId()) {
                    initGoogleOAuth();
                }
                updateGoogleAuthStatus();
            }, 1000);
        });
        
        // Handle window resize to show/hide headers appropriately
        window.addEventListener('resize', function() {
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                const tabId = activeTab.id;
                if (tabId) {
                    const tabName = tabId.replace('-tab', '');
                    updateMobileHeaderVisibility(tabName);
                }
            }
        });
        
        function updateMobileHeaderVisibility(tabName) {
            const headerBar = document.querySelector('.header-bar');
            const desktopTabs = document.getElementById('desktop-tabs');
            const isMobile = window.innerWidth <= 768;

            // In simplified rider/coach mode we always hide the desktop tab bar,
            // regardless of viewport size, and we don't auto-toggle it on resize.
            if (typeof simplifiedLoginInfo !== 'undefined' && simplifiedLoginInfo) {
                if (desktopTabs) desktopTabs.style.display = 'none';
                return;
            }
            
            if (isMobile && (tabName === 'assignments' || tabName === 'coach-assignments')) {
                // Hide header and tabs in mobile view for assignments tabs
                if (headerBar) headerBar.style.display = 'none';
                if (desktopTabs) desktopTabs.style.display = 'none';
            } else {
                // Show header and tabs for other tabs or desktop view
                if (headerBar) headerBar.style.display = '';
                if (desktopTabs) {
                    // Restore to the original display if we have it
                    const original = desktopTabs.dataset?.originalDisplay || '';
                    desktopTabs.style.display = original;
                }
            }
        }

        // Rider management
        async function addRider() {
            if (!canEditRiders()) {
                alert('You do not have permission to add riders');
                return;
            }

            const name = document.getElementById('rider-name').value.trim();
            const phone = document.getElementById('rider-phone').value.trim();
            const grade = document.getElementById('rider-grade').value;
            const racingGroup = document.getElementById('rider-racing-group').value;
            const gender = document.getElementById('rider-gender').value || '';
            const fitnessInput = document.getElementById('rider-fitness').value;
            const notes = document.getElementById('rider-notes').value.trim();
            
            if (!name) {
                alert('Please enter a team rider name');
                return;
            }

            const fitnessValue = Math.max(1, Math.min(10, parseInt(fitnessInput || '5', 10)));

            const photo = await readPhotoFile('rider-photo');
            
            const riderData = {
                name,
                photo,
                phone,
                grade: normalizeGradeValue(grade),
                racing_group: racingGroup,
                gender: gender.toUpperCase(),
                fitness: String(fitnessValue),
                notes
            };

            await saveRiderToDB(riderData);
            resetRiderForm();
            renderRiders();
        }

        function resetRiderForm() {
            document.getElementById('rider-photo').value = '';
            document.getElementById('rider-name').value = '';
            document.getElementById('rider-phone').value = '';
            document.getElementById('rider-grade').value = '9th';
            document.getElementById('rider-racing-group').value = 'Freshman';
            document.getElementById('rider-gender').value = '';
            document.getElementById('rider-fitness').value = '5';
            document.getElementById('rider-notes').value = '';
            handleFileChange('rider-photo', 'rider-photo-name');
        }

        async function deleteRider(id) {
            if (!canEditRiders()) {
                alert('You do not have permission to delete riders');
                return;
            }

            if (confirm('Delete this rider?')) {
                // Remove from riders array
                data.riders = data.riders.filter(r => r.id !== id);
                
                // Also update any rides that reference this rider
                for (const ride of data.rides) {
                    if (ride.availableRiders && ride.availableRiders.includes(id)) {
                        ride.availableRiders = ride.availableRiders.filter(riderId => riderId !== id);
                        // Update groups if needed
                        if (ride.groups) {
                            ride.groups.forEach(group => {
                                if (group.riders) {
                                    group.riders = group.riders.filter(riderId => riderId !== id);
                                }
                            });
                        }
                        saveRideToDB(ride);
                    }
                }
                
                saveData();
                renderRiders();
                if (data.currentRide) {
                    renderRides();
                }
            }
        }

        let currentEditingRiderId = null;

        function openEditRiderModal(id) {
            const rider = data.riders.find(r => r.id === id);
            if (!rider) return;

            currentEditingRiderId = id;
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-rider-modal-title');
            if (titleEl) titleEl.textContent = 'Edit Team Rider';
            
            const deleteBtn = document.getElementById('delete-rider-btn');
            if (deleteBtn) deleteBtn.style.display = 'block';

            // Populate name fields (prefer explicit first/last if present, otherwise split full name)
            const riderFirstNameInput = document.getElementById('edit-rider-first-name');
            const riderLastNameInput = document.getElementById('edit-rider-last-name');
            const fullName = rider.name || '';
            let firstName = rider.firstName || '';
            let lastName = rider.lastName || '';
            if (!firstName && !lastName && fullName) {
                const parts = fullName.trim().split(' ');
                if (parts.length > 1) {
                    lastName = parts.pop();
                    firstName = parts.join(' ');
                } else {
                    firstName = fullName;
                }
            }
            if (riderFirstNameInput) riderFirstNameInput.value = firstName || '';
            if (riderLastNameInput) riderLastNameInput.value = lastName || '';
            
            // Populate all CSV fields
            document.getElementById('edit-rider-email').value = rider.email || '';
            
            // Format phone number
            const phone = (rider.phone || '').replace(/\D/g, '');
            if (phone.length === 10) {
                const formattedPhone = `(${phone.substring(0, 3)}) ${phone.substring(3, 6)}-${phone.substring(6, 10)}`;
                document.getElementById('edit-rider-phone').value = formattedPhone;
            } else {
                document.getElementById('edit-rider-phone').value = rider.phone || '';
            }
            
            document.getElementById('edit-rider-address').value = rider.address || '';
            
            const genderValue = (rider.gender || '').toUpperCase();
            document.getElementById('edit-rider-gender').value = (genderValue === 'M' || genderValue === 'F' || genderValue === 'NB') ? genderValue : '';
            document.getElementById('edit-rider-grade').value = rider.grade || '9th';
            document.getElementById('edit-rider-birthday').value = rider.birthday || '';
            
            document.getElementById('edit-rider-primary-parent-name').value = rider.primaryParentName || '';
            const primaryParentPhone = (rider.primaryParentPhone || '').replace(/\D/g, '');
            if (primaryParentPhone.length === 10) {
                document.getElementById('edit-rider-primary-parent-phone').value = `(${primaryParentPhone.substring(0, 3)}) ${primaryParentPhone.substring(3, 6)}-${primaryParentPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-primary-parent-phone').value = rider.primaryParentPhone || '';
            }
            document.getElementById('edit-rider-primary-parent-email').value = rider.primaryParentEmail || '';
            document.getElementById('edit-rider-primary-parent-address').value = rider.primaryParentAddress || '';
            
            document.getElementById('edit-rider-second-parent-name').value = rider.secondParentName || '';
            const secondParentPhone = (rider.secondParentPhone || '').replace(/\D/g, '');
            if (secondParentPhone.length === 10) {
                document.getElementById('edit-rider-second-parent-phone').value = `(${secondParentPhone.substring(0, 3)}) ${secondParentPhone.substring(3, 6)}-${secondParentPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-second-parent-phone').value = rider.secondParentPhone || '';
            }
            document.getElementById('edit-rider-second-parent-email').value = rider.secondParentEmail || '';
            
            document.getElementById('edit-rider-alternate-contact-name').value = rider.alternateContactName || '';
            document.getElementById('edit-rider-alternate-contact-relationship').value = rider.alternateContactRelationship || '';
            const alternateContactPhone = (rider.alternateContactPhone || '').replace(/\D/g, '');
            if (alternateContactPhone.length === 10) {
                document.getElementById('edit-rider-alternate-contact-phone').value = `(${alternateContactPhone.substring(0, 3)}) ${alternateContactPhone.substring(3, 6)}-${alternateContactPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-alternate-contact-phone').value = rider.alternateContactPhone || '';
            }
            
            document.getElementById('edit-rider-primary-physician').value = rider.primaryPhysician || '';
            const primaryPhysicianPhone = (rider.primaryPhysicianPhone || '').replace(/\D/g, '');
            if (primaryPhysicianPhone.length === 10) {
                document.getElementById('edit-rider-primary-physician-phone').value = `(${primaryPhysicianPhone.substring(0, 3)}) ${primaryPhysicianPhone.substring(3, 6)}-${primaryPhysicianPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-primary-physician-phone').value = rider.primaryPhysicianPhone || '';
            }
            document.getElementById('edit-rider-medical-insurance-company').value = rider.medicalInsuranceCompany || '';
            document.getElementById('edit-rider-medical-insurance-account').value = rider.medicalInsuranceAccountNumber || '';
            document.getElementById('edit-rider-allergies').value = rider.allergiesOrMedicalNeeds || '';
            
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-rider-fitness').value = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
            document.getElementById('edit-rider-skills').value = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
            document.getElementById('edit-rider-notes').value = rider.notes || '';

            // Update racing group options based on gender, then set value
            updateRacingGroupOptions();
            if (rider.racingGroup) {
                document.getElementById('edit-rider-racing-group').value = rider.racingGroup;
            }

            // Update photo preview - use default if no photo uploaded
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            if (rider.photo && !rider.photo.includes('_default.png')) {
                // Use uploaded photo (not a default)
                photoPreview.src = rider.photo;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                // Use default based on gender
                const gender = (rider.gender || '').toUpperCase();
                let defaultPhoto = '';
                if (gender === 'M') {
                    defaultPhoto = 'assets/male_default.png';
                } else if (gender === 'F') {
                    defaultPhoto = 'assets/female_default.png';
                } else if (gender === 'NB') {
                    defaultPhoto = 'assets/nonbinary_default.png';
                } else {
                    defaultPhoto = 'assets/nonbinary_default.png';
                }
                photoPreview.src = defaultPhoto;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function openAddRiderModal() {
            currentEditingRiderId = null;
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-rider-modal-title');
            if (titleEl) titleEl.textContent = 'Add Team Rider';
            
            const deleteBtn = document.getElementById('delete-rider-btn');
            if (deleteBtn) deleteBtn.style.display = 'none';

            const riderFirstNameInput = document.getElementById('edit-rider-first-name');
            const riderLastNameInput = document.getElementById('edit-rider-last-name');
            if (riderFirstNameInput) riderFirstNameInput.value = '';
            if (riderLastNameInput) riderLastNameInput.value = '';
            document.getElementById('edit-rider-phone').value = '';
            document.getElementById('edit-rider-gender').value = '';
            document.getElementById('edit-rider-grade').value = '9th';
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-rider-fitness').value = Math.ceil(fitnessScale / 2);
            document.getElementById('edit-rider-skills').value = Math.ceil(skillsScale / 2);
            document.getElementById('edit-rider-notes').value = '';

            // Reset racing group options
            updateRacingGroupOptions();

            // Reset photo preview
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            photoPreview.style.display = 'none';
            photoPlaceholder.style.display = 'flex';
            document.getElementById('edit-rider-photo-input').value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeEditRiderModal() {
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;
            // Blur any focused elements before hiding modal to avoid aria-hidden warning
            const focusedElement = document.activeElement;
            if (focusedElement && modal.contains(focusedElement)) {
                focusedElement.blur();
            }
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentEditingRiderId = null;
        }

        async function saveRiderFromModal() {
            if (!canEditRiders()) {
                alert('You do not have permission to edit riders');
                return;
            }

            const firstNameInput = document.getElementById('edit-rider-first-name');
            const lastNameInput = document.getElementById('edit-rider-last-name');
            const firstName = firstNameInput ? firstNameInput.value.trim() : '';
            const lastName = lastNameInput ? lastNameInput.value.trim() : '';
            const name = `${firstName} ${lastName}`.trim();
            if (!firstName && !lastName) {
                alert('Please enter a rider first or last name');
                return;
            }

            const phoneInputEl = document.getElementById('edit-rider-phone');
            if (!phoneInputEl) {
                alert('Phone input field not found');
                return;
            }
            const phoneInput = phoneInputEl.value.trim();
            const phoneDigits = phoneInput.replace(/\D/g, '');
            
            if (phoneDigits.length !== 10) {
                alert('Please enter a valid 10-digit phone number');
                return;
            }
            
            const phone = phoneDigits; // Store as digits only
            const gradeEl = document.getElementById('edit-rider-grade');
            const grade = gradeEl ? gradeEl.value.trim() : '9th';
            const racingGroupEl = document.getElementById('edit-rider-racing-group');
            const racingGroup = racingGroupEl ? racingGroupEl.value.trim() : '';
            const fitnessInputEl = document.getElementById('edit-rider-fitness');
            const fitnessInput = fitnessInputEl ? fitnessInputEl.value : String(Math.ceil(getFitnessScale() / 2));
            const skillsInputEl = document.getElementById('edit-rider-skills');
            const skillsInput = skillsInputEl ? skillsInputEl.value : String(Math.ceil(getSkillsScale() / 2));
            const notesEl = document.getElementById('edit-rider-notes');
            const notes = notesEl ? notesEl.value.trim() : '';
            const genderEl = document.getElementById('edit-rider-gender');
            const genderValue = genderEl?.value?.toUpperCase();
            
            if (!genderValue || (genderValue !== 'M' && genderValue !== 'F' && genderValue !== 'NB')) {
                alert('Please select a gender');
                return;
            }
            
            if (!racingGroup) {
                alert('Please select a racing group');
                return;
            }

            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(fitnessInput || Math.ceil(fitnessScale / 2), 10)));
            const skillsValue = Math.max(1, Math.min(skillsScale, parseInt(skillsInput || Math.ceil(skillsScale / 2), 10)));

            // Get photo from preview or use default based on gender
            let photo = '';
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoInput = document.getElementById('edit-rider-photo-input');
            
            // Check if a new photo was uploaded
            if (photoInput && photoInput.files && photoInput.files.length > 0) {
                // Read the uploaded file
                const file = photoInput.files[0];
                const reader = new FileReader();
                photo = await new Promise((resolve) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => resolve('');
                    reader.readAsDataURL(file);
                });
            } else if (photoPreview && photoPreview.style.display !== 'none' && photoPreview.src) {
                // Use existing photo from preview
                photo = photoPreview.src;
            } else {
                // Use default based on gender
                if (genderValue === 'M') {
                    photo = 'assets/male_default.png';
                } else if (genderValue === 'F') {
                    photo = 'assets/female_default.png';
                } else if (genderValue === 'NB') {
                    photo = 'assets/nonbinary_default.png';
                } else {
                    photo = 'assets/nonbinary_default.png';
                }
            }

            // Helper function to safely get field value
            const getFieldValue = (fieldId, defaultValue = '') => {
                const el = document.getElementById(fieldId);
                return el ? el.value.trim() : defaultValue;
            };
            
            // Helper function to safely get phone value
            const getPhoneValue = (fieldId) => {
                const el = document.getElementById(fieldId);
                if (!el) return '';
                const phoneInput = el.value.trim();
                const phoneDigits = phoneInput.replace(/\D/g, '');
                return phoneDigits.length === 10 ? phoneDigits : '';
            };
            
            // Get all CSV fields
            const email = getFieldValue('edit-rider-email');
            const address = getFieldValue('edit-rider-address');
            const birthday = getFieldValue('edit-rider-birthday');
            
            const primaryParentName = getFieldValue('edit-rider-primary-parent-name');
            const primaryParentPhone = getPhoneValue('edit-rider-primary-parent-phone');
            const primaryParentEmail = getFieldValue('edit-rider-primary-parent-email');
            const primaryParentAddress = getFieldValue('edit-rider-primary-parent-address');
            
            const secondParentName = getFieldValue('edit-rider-second-parent-name');
            const secondParentPhone = getPhoneValue('edit-rider-second-parent-phone');
            const secondParentEmail = getFieldValue('edit-rider-second-parent-email');
            
            const alternateContactName = getFieldValue('edit-rider-alternate-contact-name');
            const alternateContactRelationship = getFieldValue('edit-rider-alternate-contact-relationship');
            const alternateContactPhone = getPhoneValue('edit-rider-alternate-contact-phone');
            
            const primaryPhysician = getFieldValue('edit-rider-primary-physician');
            const primaryPhysicianPhone = getPhoneValue('edit-rider-primary-physician-phone');
            const medicalInsuranceCompany = getFieldValue('edit-rider-medical-insurance-company');
            const medicalInsuranceAccountNumber = getFieldValue('edit-rider-medical-insurance-account');
            const allergiesOrMedicalNeeds = getFieldValue('edit-rider-allergies');
            
            const riderData = {
                name,
                firstName,
                lastName,
                phone,
                photo,
                email,
                address,
                gender: genderValue,
                grade: normalizeGradeValue(grade || (currentEditingRiderId ? data.riders.find(r => r.id === currentEditingRiderId)?.grade : '9th')),
                birthday,
                primaryParentName,
                primaryParentPhone,
                primaryParentEmail,
                primaryParentAddress,
                secondParentName,
                secondParentPhone,
                secondParentEmail,
                alternateContactName,
                alternateContactRelationship,
                alternateContactPhone,
                primaryPhysician,
                primaryPhysicianPhone,
                medicalInsuranceCompany,
                medicalInsuranceAccountNumber,
                allergiesOrMedicalNeeds,
                racingGroup: racingGroup,
                fitness: String(fitnessValue),
                skills: String(skillsValue),
                notes
            };

            if (currentEditingRiderId) {
                riderData.id = currentEditingRiderId;
            }

            try {
                await saveRiderToDB(riderData);
                renderRiders();
                closeEditRiderModal();
                if (data.currentRide) {
                    const ride = data.rides.find(r => r.id === data.currentRide);
                    if (ride) {
                        renderAssignments(ride);
                    }
                }
            } catch (error) {
                console.error('Error saving rider:', error);
                alert('Error saving rider: ' + (error.message || 'Unknown error'));
            }
        }

        function deleteRiderFromModal() {
            if (!currentEditingRiderId) return;
            if (!confirm('Delete this rider?')) return;
            
            deleteRider(currentEditingRiderId);
            closeEditRiderModal();
        }

        function showNotesModal(id, type) {
            const modal = document.getElementById('notes-modal');
            if (!modal) return;

            let record = null;
            let name = '';
            let notes = '';

            if (type === 'coach') {
                record = data.coaches.find(c => c.id === id);
                name = record ? record.name || 'Coach' : 'Coach';
                notes = record ? record.notes || '' : '';
            } else if (type === 'rider') {
                record = data.riders.find(r => r.id === id);
                name = record ? record.name || 'Rider' : 'Rider';
                notes = record ? record.notes || '' : '';
            }

            document.getElementById('notes-modal-title').textContent = `Notes: ${name}`;
            document.getElementById('notes-modal-content').textContent = notes || '(No notes)';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeNotesModal() {
            const modal = document.getElementById('notes-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        async function handleCoachPhotoUpload(coachId, input) {
            if (!input.files || input.files.length === 0) return;
            
            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const file = input.files[0];
            const photo = await readPhotoFileFromInput(input);
            
            coach.photo = photo;
            saveData();
            renderCoaches();
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        async function handleRiderPhotoUpload(riderId, input) {
            if (!input.files || input.files.length === 0) return;
            
            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const file = input.files[0];
            const photo = await readPhotoFileFromInput(input);
            
            rider.photo = photo;
            saveData();
            renderRiders();
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        async function handleRiderPhotoUploadInModal(input) {
            if (!input.files || input.files.length === 0) return;
            
            const photo = await readPhotoFileFromInput(input);
            if (!photo) return;

            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            
            photoPreview.src = photo;
            photoPreview.style.display = 'block';
            photoPlaceholder.style.display = 'none';
        }

        function readPhotoFileFromInput(input) {
            return new Promise(resolve => {
                if (!input || !input.files || input.files.length === 0) {
                    resolve('');
                    return;
                }

                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('');
                reader.readAsDataURL(file);
            });
        }

        function formatPhoneNumber(input) {
            let value = input.value.replace(/\D/g, ''); // Remove all non-digits
            
            if (value.length > 10) {
                value = value.substring(0, 10); // Limit to 10 digits
            }
            
            let formattedValue = '';
            if (value.length > 0) {
                formattedValue = '(' + value.substring(0, 3);
            }
            if (value.length > 3) {
                formattedValue += ') ' + value.substring(3, 6);
            }
            if (value.length > 6) {
                formattedValue += '-' + value.substring(6, 10);
            }
            
            input.value = formattedValue;
        }

        function formatPhoneForDisplay(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6, 10)}`;
            }
            return phone;
        }

        function formatPhoneForTel(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return `tel:+1${digits}`;
            } else if (digits.length === 11 && digits.startsWith('1')) {
                return `tel:+${digits}`;
            } else if (digits.length > 0) {
                return `tel:+${digits}`;
            }
            return '';
        }

        function updateRacingGroupOptions() {
            const genderSelect = document.getElementById('edit-rider-gender');
            const racingGroupSelect = document.getElementById('edit-rider-racing-group');
            
            if (!genderSelect || !racingGroupSelect) return;
            
            const gender = genderSelect.value;
            const currentValue = racingGroupSelect.value; // Save current selection
            
            // Clear existing options
            racingGroupSelect.innerHTML = '';
            racingGroupSelect.disabled = false;
            
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select Racing Group';
            racingGroupSelect.appendChild(placeholder);
            
            // Set options based on gender (or all if gender unknown)
            const options = gender === 'M'
                ? ['Varsity Boys', 'JV1 Boys', 'JV2 Boys', 'Freshman Boys']
                : gender === 'F'
                    ? ['Varsity Girls', 'JV1 Girls', 'JV2 Girls', 'Freshman Girls']
                    : [
                        'Varsity Boys', 'Varsity Girls',
                        'JV1 Boys', 'JV1 Girls',
                        'JV2 Boys', 'JV2 Girls',
                        'Freshman Boys', 'Freshman Girls'
                    ];
            
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                racingGroupSelect.appendChild(opt);
            });
            
            // Restore previous selection only if it's still valid for the new gender
            if (currentValue && options.includes(currentValue)) {
                racingGroupSelect.value = currentValue;
            } else {
                // Clear selection if it's not valid for the new gender
                racingGroupSelect.value = '';
            }
        }

        function normalizeGenderValue(raw) {
            const value = (raw || '').toString().trim().toLowerCase();
            if (!value) return '';
            if (value === 'm' || value === 'male' || value === 'man' || value === 'men' || value === 'boy' || value === 'boys') return 'M';
            if (value === 'f' || value === 'female' || value === 'woman' || value === 'women' || value === 'girl' || value === 'girls') return 'F';
            if (value === 'nb' || value === 'nonbinary' || value === 'non-binary' || value === 'non binary') return 'NB';
            return value.toUpperCase();
        }

        function hasMedicalCondition(value) {
            const raw = (value || '').toString().trim();
            if (!raw) return false;
            const normalized = raw.toLowerCase().replace(/[^a-z0-9]/g, '');
            if (!normalized) return false;
            const emptyValues = new Set(['no', 'none', 'na', 'n/a', 'nil', 'false', '0']);
            return !emptyValues.has(normalized);
        }

        function getMedicalIconHtml(noteValue) {
            if (!hasMedicalCondition(noteValue)) return '';
            const title = escapeHtml(noteValue);
            return `
                <span title="${title}" aria-label="Medical or allergy info" style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; margin-left: 6px; flex-shrink: 0;">
                    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                        <path fill="#1976D2" d="M12 2l7 3v6c0 5.25-3.5 9.92-7 11-3.5-1.08-7-5.75-7-11V5l7-3z"/>
                        <path fill="#fff" d="M11 7h2v4h4v2h-4v4h-2v-4H7v-2h4z"/>
                    </svg>
                </span>
            `;
        }

        function updateDefaultPhoto() {
            const genderSelect = document.getElementById('edit-rider-gender');
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            const photoInput = document.getElementById('edit-rider-photo-input');
            
            if (!genderSelect || !photoPreview || !photoPlaceholder) return;
            
            // Only update if no photo has been uploaded
            if (photoInput && photoInput.files && photoInput.files.length > 0) {
                return; // Don't change if user has uploaded a photo
            }
            
            // Check if there's an existing photo that's not a default
            if (photoPreview.style.display !== 'none' && photoPreview.src) {
                const src = photoPreview.src;
                // If it's a default image, update it; otherwise keep the uploaded photo
                if (!src.includes('male_default') && !src.includes('female_default') && !src.includes('nonbinary_default')) {
                    return; // Keep uploaded photo
                }
            }
            
            const gender = genderSelect.value;
            let defaultPhoto = '';
            if (gender === 'M') {
                defaultPhoto = 'assets/male_default.png';
            } else if (gender === 'F') {
                defaultPhoto = 'assets/female_default.png';
            } else if (gender === 'NB') {
                defaultPhoto = 'assets/nonbinary_default.png';
            } else {
                defaultPhoto = 'assets/nonbinary_default.png';
            }
            
            if (defaultPhoto) {
                photoPreview.src = defaultPhoto;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                photoPreview.style.display = 'none';
                photoPlaceholder.style.display = 'flex';
            }
        }

        async function adjustCoachPace(coachId, delta) {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to update coach pace');
                return;
            }

            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const fitnessScale = getFitnessScale();
            const currentPace = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
            const newPace = Math.max(1, Math.min(fitnessScale, currentPace + delta));
            
            coach.fitness = String(newPace);
            // Save directly to database
            await saveCoachToDB(coach);
            
            // Update only the fitness display without re-sorting
            updateCoachFitnessDisplay(coachId, newPace);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }
        
        async function adjustCoachSkills(coachId, delta) {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to update coach skills');
                return;
            }

            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const skillsScale = getSkillsScale();
            const currentSkills = Math.max(1, Math.min(skillsScale, parseInt(coach.skills || Math.ceil(skillsScale / 2), 10)));
            const newSkills = Math.max(1, Math.min(skillsScale, currentSkills + delta));
            
            coach.skills = String(newSkills);
            // Save directly to database
            await saveCoachToDB(coach);
            
            // Update only the skills display without re-sorting
            updateCoachSkillsDisplay(coachId, newSkills);
        }

        async function adjustRiderPace(riderId, delta) {
            // Permission check - allow if canEditRiders exists, otherwise allow by default
            if (typeof canEditRiders === 'function' && !canEditRiders()) {
                alert('You do not have permission to update rider pace');
                return;
            }

            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const fitnessScale = getFitnessScale();
            const currentPace = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
            const newPace = Math.max(1, Math.min(fitnessScale, currentPace + delta));
            
            rider.fitness = String(newPace);
            // Save directly to database
            await saveRiderToDB(rider);
            
            // Update only the fitness display without re-sorting
            updateRiderFitnessDisplay(riderId, newPace);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        // Context menu handlers for pace/skills badges
        let badgeContextMenuData = null;
        let badgeContextMenuTimeout = null;

        function handleBadgeClick(event, type, id, badgeType, currentValue) {
            event.stopPropagation();
            
            // Determine min/max values based on badge type
            let minValue = 1;
            let maxValue;
            if (badgeType === 'pace') {
                maxValue = getFitnessScale();
            } else if (badgeType === 'skills') {
                maxValue = getSkillsScale();
            } else {
                maxValue = 10; // fallback
            }

            let increaseDelta = 1;
            let decreaseDelta = -1;
            if (badgeType === 'pace') {
                const paceOrder = getPaceScaleOrder();
                increaseDelta = paceOrder === 'fastest_to_slowest' ? -1 : 1;
                decreaseDelta = -increaseDelta;
            }

            // Check if we're at min or max to conditionally show options
            const canIncrease = currentValue + increaseDelta >= minValue && currentValue + increaseDelta <= maxValue;
            const canDecrease = currentValue + decreaseDelta >= minValue && currentValue + decreaseDelta <= maxValue;
            
            // Store context menu data
            badgeContextMenuData = {
                type: type, // 'rider' or 'coach'
                id: id,
                badgeType: badgeType, // 'pace' or 'skills'
                currentValue: currentValue,
                minValue: minValue,
                maxValue: maxValue,
                increaseDelta: increaseDelta,
                decreaseDelta: decreaseDelta
            };
            
            const contextMenu = document.getElementById('badge-context-menu');
            if (!contextMenu) return;
            
            // Show/hide buttons based on current value
            const increaseBtn = document.getElementById('badge-increase-btn');
            const decreaseBtn = document.getElementById('badge-decrease-btn');
            if (increaseBtn) {
                increaseBtn.style.display = canIncrease ? 'block' : 'none';
                increaseBtn.textContent = badgeType === 'pace' ? 'Faster' : 'Increase';
            }
            if (decreaseBtn) {
                decreaseBtn.style.display = canDecrease ? 'block' : 'none';
                decreaseBtn.textContent = badgeType === 'pace' ? 'Slower' : 'Decrease';
                // Remove border-bottom from decrease if increase is hidden
                if (!canIncrease && decreaseBtn) {
                    decreaseBtn.style.borderBottom = 'none';
                } else if (canIncrease && decreaseBtn) {
                    decreaseBtn.style.borderBottom = '1px solid #eee';
                }
            }
            
            // Don't show menu if no options are available
            if (!canIncrease && !canDecrease) {
                return;
            }
            
            // Close any existing context menus
            const practiceMenu = document.getElementById('practice-context-menu');
            if (practiceMenu) practiceMenu.style.display = 'none';
            
            // Find the badge element that was clicked (similar to calendar context menu)
            // Try multiple strategies to find the badge element
            let badgeElement = event.target;
            
            // Strategy 1: Check if target itself is a badge
            if (badgeElement.classList.contains('badge')) {
                // Found it
            } else {
                // Strategy 2: Look for badge in parent chain
                while (badgeElement && badgeElement.parentElement && !badgeElement.classList.contains('badge')) {
                    badgeElement = badgeElement.parentElement;
                }
                // Strategy 3: If still not found, try finding by data attribute
                if (!badgeElement || !badgeElement.classList.contains('badge')) {
                    const badgeType = event.target.getAttribute('data-badge-type');
                    const riderId = event.target.getAttribute('data-rider-id');
                    const coachId = event.target.getAttribute('data-coach-id');
                    if (badgeType && (riderId || coachId)) {
                        badgeElement = event.target.closest('.badge') || document.querySelector(`.badge[data-badge-type="${badgeType}"][data-${riderId ? 'rider' : 'coach'}-id="${riderId || coachId}"]`);
                    }
                }
            }
            
            // Position menu using getBoundingClientRect() for accurate viewport coordinates
            // This works correctly even after page scrolling
            if (badgeElement && badgeElement.getBoundingClientRect) {
                // Use the badge element's bounding rect for accurate positioning
                // getBoundingClientRect() returns viewport coordinates (accounts for scroll automatically)
                const badgeRect = badgeElement.getBoundingClientRect();
                
                // Position menu to the right of the badge, with top-left corner aligned to top of badge
                // Use fixed positioning with viewport coordinates
                contextMenu.style.position = 'fixed';
                contextMenu.style.left = `${badgeRect.right + 5}px`;
                contextMenu.style.top = `${badgeRect.top}px`;
                
                // Show the menu first so we can measure it
                contextMenu.style.display = 'block';
                contextMenu.style.visibility = 'visible';
                
                // Ensure menu stays within viewport (using requestAnimationFrame to ensure DOM is updated)
                requestAnimationFrame(() => {
                    const menuRect = contextMenu.getBoundingClientRect();
                    // Adjust horizontally if menu goes off right edge - show to the left of badge instead
                    if (menuRect.right > window.innerWidth) {
                        contextMenu.style.left = `${badgeRect.left - menuRect.width - 5}px`;
                    }
                    // Adjust vertically if menu goes off bottom edge - align to bottom of badge
                    if (menuRect.bottom > window.innerHeight) {
                        contextMenu.style.top = `${badgeRect.bottom - menuRect.height}px`;
                    }
                    // Ensure menu doesn't go off left edge
                    if (menuRect.left < 0) {
                        contextMenu.style.left = '10px';
                    }
                    // Ensure menu doesn't go off top edge
                    if (menuRect.top < 0) {
                        contextMenu.style.top = '10px';
                    }
                });
            } else {
                // Fallback to click coordinates if badge element not found
                // Use fixed positioning with viewport coordinates from click event
                contextMenu.style.position = 'fixed';
                const x = event.clientX || (event.touches && event.touches[0].clientX) || 0;
                const y = event.clientY || (event.touches && event.touches[0].clientY) || 0;
                contextMenu.style.left = `${x + 5}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.style.display = 'block';
                contextMenu.style.visibility = 'visible';
                
                console.warn('Badge element not found for context menu, using click coordinates');
            }
            
            // Close menu after 5 seconds
            if (badgeContextMenuTimeout) {
                clearTimeout(badgeContextMenuTimeout);
            }
            badgeContextMenuTimeout = setTimeout(() => {
                contextMenu.style.display = 'none';
                badgeContextMenuData = null;
            }, 5000);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target) && e.target !== event.target && !event.target.closest('.badge')) {
                    contextMenu.style.display = 'none';
                    if (badgeContextMenuTimeout) {
                        clearTimeout(badgeContextMenuTimeout);
                        badgeContextMenuTimeout = null;
                    }
                    document.removeEventListener('click', closeMenu);
                    badgeContextMenuData = null;
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeMenu, { once: true });
            }, 10);
        }

        async function handleBadgeAdjust(direction) {
            if (!badgeContextMenuData) return;
            
            const { type, id, badgeType, increaseDelta, decreaseDelta } = badgeContextMenuData;
            const delta = direction === 'increase' ? (increaseDelta ?? 1) : (decreaseDelta ?? -1);
            
            // Close the menu
            const contextMenu = document.getElementById('badge-context-menu');
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            if (badgeContextMenuTimeout) {
                clearTimeout(badgeContextMenuTimeout);
                badgeContextMenuTimeout = null;
            }
            
            // Call the appropriate adjustment function
            if (type === 'rider') {
                if (badgeType === 'pace') {
                    await adjustRiderPace(id, delta);
                } else if (badgeType === 'skills') {
                    await adjustRiderSkills(id, delta);
                }
            } else if (type === 'coach') {
                if (badgeType === 'pace') {
                    await adjustCoachPace(id, delta);
                } else if (badgeType === 'skills') {
                    await adjustCoachSkills(id, delta);
                }
            }
            
            // Refresh the attendance lists and assignments to show updated values
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderPracticeAttendanceLists();
                    renderAssignments(ride);
                }
            }
            
            badgeContextMenuData = null;
        }

        async function adjustRiderSkills(riderId, delta) {
            // Permission check - allow if canEditRiders exists, otherwise allow by default
            if (typeof canEditRiders === 'function' && !canEditRiders()) {
                alert('You do not have permission to update rider skills');
                return;
            }

            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const skillsScale = getSkillsScale();
            const currentSkills = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
            const newSkills = Math.max(1, Math.min(skillsScale, currentSkills + delta));
            
            rider.skills = String(newSkills);
            // Save directly to database
            await saveRiderToDB(rider);
            
            // Update only the skills display without re-sorting
            updateRiderSkillsDisplay(riderId, newSkills);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }
        
        function updateCoachFitnessDisplay(coachId, value) {
            // Update fitness display in roster without re-sorting
            // Look for pace-value in the pace column (first pace-controls div)
            const row = document.querySelector(`[data-coach-id="${coachId}"]`);
            if (row) {
                const paceCell = row.querySelector('[data-label="Pace"]');
                if (paceCell) {
                    const paceValue = paceCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }
        
        function updateCoachSkillsDisplay(coachId, value) {
            // Update skills display in roster without re-sorting
            // Look for pace-value in the skills column (second pace-controls div)
            const row = document.querySelector(`[data-coach-id="${coachId}"]`);
            if (row) {
                const skillsCell = row.querySelector('[data-label="Bike Skills"]');
                if (skillsCell) {
                    const paceValue = skillsCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                        // Update tooltip with new value
                        const skillsScale = getSkillsScale();
                        const tooltip = getBikeSkillsTooltip(value, skillsScale);
                        paceValue.setAttribute('title', tooltip);
                    }
                }
            }
        }
        
        function updateRiderFitnessDisplay(riderId, value) {
            // Update fitness display in roster without re-sorting
            // Look for pace-value in the pace column (first pace-controls div)
            const row = document.querySelector(`[data-rider-id="${riderId}"]`);
            if (row) {
                const paceCell = row.querySelector('[data-label="Pace"]');
                if (paceCell) {
                    const paceValue = paceCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }
        
        function updateRiderSkillsDisplay(riderId, value) {
            // Update skills display in roster without re-sorting
            // Look for pace-value in the skills column (second pace-controls div)
            const row = document.querySelector(`[data-rider-id="${riderId}"]`);
            if (row) {
                const skillsCell = row.querySelector('[data-label="Bike Skills"]');
                if (skillsCell) {
                    const paceValue = skillsCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                        // Update tooltip with new value
                        const skillsScale = getSkillsScale();
                        const tooltip = getBikeSkillsTooltip(value, skillsScale);
                        paceValue.setAttribute('title', tooltip);
                    }
                }
            }
        }


        // Sort state for rosters
        let riderSortColumn = null;
        let riderSortDirection = 'asc'; // 'asc' or 'desc'
        let coachSortColumn = null;
        let coachSortDirection = 'asc';
        
        // Column definitions for reordering
        const riderColumnDefs = [
            { key: 'photo', label: '', sortable: false, width: '41px' },
            { key: 'name', label: 'Name', sortable: true, width: 'minmax(220px, 1.8fr)' },
            { key: 'phone', label: 'Phone', sortable: false, width: 'minmax(160px, 1fr)' },
            { key: 'gender', label: 'Gender', sortable: true, width: 'minmax(90px, 0.7fr)' },
            { key: 'grade', label: 'Grade', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'racingGroup', label: 'Racing Group', sortable: true, width: 'minmax(160px, 1fr)' },
            { key: 'pace', label: 'Relative Pace', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'skills', label: 'Bike Skills', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'actions', label: '', sortable: false, width: 'minmax(120px, 0.8fr)' }
        ];
        
        const coachColumnDefs = [
            { key: 'photo', label: '', sortable: false, width: '41px' },
            { key: 'name', label: 'Name', sortable: true, width: 'minmax(220px, 1.8fr)' },
            { key: 'phone', label: 'Phone', sortable: false, width: 'minmax(160px, 1fr)' },
            { key: 'level', label: 'Coach Level', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'pace', label: 'Relative Pace', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'skills', label: 'Bike Skills', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'actions', label: '', sortable: false, width: 'minmax(120px, 0.8fr)' }
        ];
        
        // Load column order from localStorage
        function getRiderColumnOrder() {
            const saved = localStorage.getItem('riderColumnOrder');
            if (saved) {
                try {
                    const order = JSON.parse(saved);
                    // Validate order - ensure all columns are present
                    const savedKeys = new Set(order);
                    const allKeys = new Set(riderColumnDefs.map(c => c.key));
                    if (savedKeys.size === allKeys.size && [...savedKeys].every(k => allKeys.has(k))) {
                        return order;
                    }
                } catch (e) {
                    console.error('Error parsing rider column order:', e);
                }
            }
            return riderColumnDefs.map(c => c.key);
        }
        
        function getCoachColumnOrder() {
            const saved = localStorage.getItem('coachColumnOrder');
            if (saved) {
                try {
                    const order = JSON.parse(saved);
                    // Validate order - ensure all columns are present
                    const savedKeys = new Set(order);
                    const allKeys = new Set(coachColumnDefs.map(c => c.key));
                    if (savedKeys.size === allKeys.size && [...savedKeys].every(k => allKeys.has(k))) {
                        return order;
                    }
                } catch (e) {
                    console.error('Error parsing coach column order:', e);
                }
            }
            return coachColumnDefs.map(c => c.key);
        }
        
        // Save column order to localStorage
        function saveRiderColumnOrder(order) {
            localStorage.setItem('riderColumnOrder', JSON.stringify(order));
        }
        
        function saveCoachColumnOrder(order) {
            localStorage.setItem('coachColumnOrder', JSON.stringify(order));
        }
        
        // Load column widths from localStorage
        function getRiderColumnWidths() {
            const saved = localStorage.getItem('riderColumnWidths');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error parsing rider column widths:', e);
                }
            }
            return {};
        }
        
        function getCoachColumnWidths() {
            const saved = localStorage.getItem('coachColumnWidths');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error parsing coach column widths:', e);
                }
            }
            return {};
        }
        
        // Save column widths to localStorage
        function saveRiderColumnWidths(widths) {
            localStorage.setItem('riderColumnWidths', JSON.stringify(widths));
        }
        
        function saveCoachColumnWidths(widths) {
            localStorage.setItem('coachColumnWidths', JSON.stringify(widths));
        }
        
        // Calculate minimum width for a column based on content
        function calculateMinColumnWidth(type, key, order) {
            const items = type === 'rider' ? data.riders : data.coaches;
            if (!items || items.length === 0) {
                const def = type === 'rider' ? riderColumnDefs.find(c => c.key === key) : coachColumnDefs.find(c => c.key === key);
                return def ? parseInt(def.width.match(/\d+/)?.[0] || '100') : 100;
            }
            
            let maxWidth = 0;
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.whiteSpace = 'nowrap';
            tempDiv.style.fontSize = '14px';
            tempDiv.style.padding = '8px';
            document.body.appendChild(tempDiv);
            
            items.forEach(item => {
                let content = '';
                switch(key) {
                    case 'photo':
                        maxWidth = Math.max(maxWidth, 41);
                        break;
                    case 'name':
                        content = item.name || '';
                        break;
                    case 'phone':
                        content = formatPhoneForDisplay(item.phone || '');
                        break;
                    case 'gender':
                        content = (item.gender || 'M').toUpperCase();
                        break;
                    case 'grade':
                        content = formatGradeLabel(item.grade || '9th');
                        break;
                    case 'racingGroup':
                        content = item.racingGroup || '';
                        break;
                    case 'pace':
                        content = String(Math.max(1, Math.min(getFitnessScale(), parseInt(item.fitness || Math.ceil(getFitnessScale() / 2), 10))));
                        break;
                    case 'skills':
                        content = String(Math.max(1, Math.min(getSkillsScale(), parseInt(item.skills || Math.ceil(getSkillsScale() / 2), 10))));
                        break;
                    case 'level':
                        const levelRaw = item.coachingLicenseLevel || item.level || '1';
                        content = levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                        break;
                    case 'notes':
                        maxWidth = Math.max(maxWidth, 120);
                        break;
                    case 'actions':
                        maxWidth = Math.max(maxWidth, 100);
                        break;
                }
                if (content) {
                    tempDiv.textContent = content;
                    maxWidth = Math.max(maxWidth, tempDiv.offsetWidth);
                }
            });
            
            document.body.removeChild(tempDiv);
            
            // Add padding and ensure minimum
            return Math.max(maxWidth + 20, 80);
        }
        
        // Get grid template columns string based on order and widths
        function getRiderGridTemplate(order) {
            const widths = getRiderColumnWidths();
            return order.map((key, index) => {
                const def = riderColumnDefs.find(c => c.key === key);
                if (key === 'photo') {
                    return '41px'; // Photo column is fixed
                }
                if (widths[key]) {
                    return `${widths[key]}px`;
                }
                return def ? def.width : '1fr';
            }).join(' ');
        }
        
        function getCoachGridTemplate(order) {
            const widths = getCoachColumnWidths();
            return order.map((key, index) => {
                const def = coachColumnDefs.find(c => c.key === key);
                if (key === 'photo') {
                    return '41px'; // Photo column is fixed
                }
                if (widths[key]) {
                    return `${widths[key]}px`;
                }
                return def ? def.width : '1fr';
            }).join(' ');
        }
        
        // Column resizing handlers
        let resizingColumn = null;
        let resizingStartX = 0;
        let resizingStartWidth = 0;
        let resizingMinWidth = 0;
        let resizingHeaderElement = null;
        
        function handleColumnResizeStart(event, type, key) {
            event.preventDefault();
            event.stopPropagation();
            
            resizingColumn = { type, key };
            resizingStartX = event.clientX;
            resizingHeaderElement = event.target.closest('.roster-header');
            
            const order = type === 'rider' ? getRiderColumnOrder() : getCoachColumnOrder();
            const widths = type === 'rider' ? getRiderColumnWidths() : getCoachColumnWidths();
            const currentWidth = widths[key];
            
            if (currentWidth) {
                resizingStartWidth = currentWidth;
            } else {
                const def = type === 'rider' ? riderColumnDefs.find(c => c.key === key) : coachColumnDefs.find(c => c.key === key);
                const match = def.width.match(/(\d+)px/);
                resizingStartWidth = match ? parseInt(match[1]) : 200;
            }
            
            resizingMinWidth = calculateMinColumnWidth(type, key, order);
            
            document.addEventListener('mousemove', handleColumnResize);
            document.addEventListener('mouseup', handleColumnResizeEnd);
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        }
        
        function handleColumnResize(event) {
            if (!resizingColumn) return;
            
            const deltaX = event.clientX - resizingStartX;
            const newWidth = Math.max(resizingMinWidth, resizingStartWidth + deltaX);
            
            const widths = resizingColumn.type === 'rider' ? getRiderColumnWidths() : getCoachColumnWidths();
            widths[resizingColumn.key] = newWidth;
            
            if (resizingColumn.type === 'rider') {
                saveRiderColumnWidths(widths);
                renderRiders();
            } else {
                saveCoachColumnWidths(widths);
                renderCoaches();
            }
        }
        
        function handleColumnResizeEnd(event) {
            if (resizingColumn) {
                resizingColumn = null;
                resizingHeaderElement = null;
                document.removeEventListener('mousemove', handleColumnResize);
                document.removeEventListener('mouseup', handleColumnResizeEnd);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        }
        
        // Drag and drop handlers for column reordering
        let draggedColumnKey = null;
        let draggedColumnType = null;
        
        function handleColumnDragStart(event, type, key) {
            // Prevent dragging the name column (it's locked in position)
            if (key === 'name') {
                event.preventDefault();
                return false;
            }
            draggedColumnKey = key;
            draggedColumnType = type;
            event.dataTransfer.effectAllowed = 'move';
            event.target.style.opacity = '0.5';
        }
        
        function handleColumnDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const target = event.currentTarget;
            if (target !== event.target) {
                target.style.backgroundColor = '#e3f2fd';
            }
        }
        
        function handleColumnDrop(event, type, targetKey) {
            event.preventDefault();
            event.stopPropagation();
            
            // Prevent dropping on or moving the name column
            if (targetKey === 'name' || draggedColumnKey === 'name') {
                event.target.style.backgroundColor = '';
                return;
            }
            
            if (draggedColumnKey && draggedColumnType === type && draggedColumnKey !== targetKey) {
                // Prevent moving name column or dropping on name column
                if (draggedColumnKey === 'name' || targetKey === 'name') {
                    event.target.style.backgroundColor = '';
                    return;
                }
                
                let order = type === 'rider' ? getRiderColumnOrder() : getCoachColumnOrder();
                const draggedIndex = order.indexOf(draggedColumnKey);
                const targetIndex = order.indexOf(targetKey);
                
                // Ensure name column stays in its position (index 1, after photo)
                if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== 1 && targetIndex !== 1) {
                    // Remove dragged column from its position
                    order.splice(draggedIndex, 1);
                    // Insert at target position (but not at position 1 where name is)
                    const insertIndex = targetIndex > draggedIndex ? targetIndex - 1 : targetIndex;
                    if (insertIndex !== 1 && insertIndex !== 0) {
                        order.splice(insertIndex, 0, draggedColumnKey);
                    } else {
                        // If trying to insert at name position, insert after it
                        order.splice(2, 0, draggedColumnKey);
                    }
                    
                    // Save new order
                    if (type === 'rider') {
                        saveRiderColumnOrder(order);
                        renderRiders();
                    } else {
                        saveCoachColumnOrder(order);
                        renderCoaches();
                    }
                }
            }
            
            // Reset visual feedback
            event.target.style.backgroundColor = '';
        }
        
        function handleColumnDragEnd(event) {
            event.target.style.opacity = '';
            // Reset all header backgrounds
            const headers = document.querySelectorAll('.roster-header > div');
            headers.forEach(h => h.style.backgroundColor = '');
            draggedColumnKey = null;
            draggedColumnType = null;
        }
        
        // Group state for rosters
        let riderGroupBy = '';
        let coachGroupBy = '';

        function sortRiders(column) {
            // Toggle direction if clicking the same column
            if (riderSortColumn === column) {
                riderSortDirection = riderSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                riderSortColumn = column;
                riderSortDirection = 'asc';
            }
            renderRiders();
        }

        function sortCoaches(column) {
            // Toggle direction if clicking the same column
            if (coachSortColumn === column) {
                coachSortDirection = coachSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                coachSortColumn = column;
                coachSortDirection = 'asc';
            }
            renderCoaches();
        }

        function getSortableLastName(name) {
            if (!name) return '';
            const parts = name.trim().split(/\s+/);
            return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : (parts[0] || '').toLowerCase();
        }

        function getGradeSortValue(grade) {
            const gradeMap = { '9th': 1, '10th': 2, '11th': 3, '12th': 4 };
            return gradeMap[grade] || 0;
        }

        function getRacingGroupSortValue(racingGroup) {
            const groupOrder = {
                'Varsity Boys': 1, 'Varsity Girls': 2,
                'JV1 Boys': 3, 'JV1 Girls': 4,
                'JV2 Boys': 5, 'JV2 Girls': 6,
                'Freshman Boys': 7, 'Freshman Girls': 8
            };
            return groupOrder[racingGroup] || 99;
        }

        function groupRiders(groupBy) {
            riderGroupBy = groupBy || '';
            try {
                localStorage.setItem('rosterRiderGroupBy', riderGroupBy);
            } catch (e) {
                console.warn('Could not save rider group-by preference:', e);
            }
            renderRiders();
        }

        function groupCoaches(groupBy) {
            coachGroupBy = groupBy || '';
            try {
                localStorage.setItem('rosterCoachGroupBy', coachGroupBy);
            } catch (e) {
                console.warn('Could not save coach group-by preference:', e);
            }
            renderCoaches();
        }

        function getRiderGroupValue(rider, groupBy) {
            if (!groupBy) return '';
            switch (groupBy) {
                case 'name':
                    const lastName = getSortableLastName(rider.name || '');
                    return lastName ? lastName.charAt(0).toUpperCase() : 'Other';
                case 'gender':
                    return (rider.gender || 'M').toUpperCase();
                case 'grade':
                    return formatGradeLabel(rider.grade || '9th');
                case 'racingGroup':
                    return rider.racingGroup || 'No Group';
                case 'pace':
                    return `Pace ${rider.fitness || '5'}`;
                case 'skills':
                    return `Bike Skills ${rider.skills || '2'}`;
                default:
                    return '';
            }
        }

        function getCoachGroupValue(coach, groupBy) {
            if (!groupBy) return '';
            switch (groupBy) {
                case 'name':
                    const lastName = getSortableLastName(coach.name || '');
                    return lastName ? lastName.charAt(0).toUpperCase() : 'Other';
                case 'level':
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    return levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                case 'pace':
                    return `Pace ${coach.fitness || '5'}`;
                default:
                    return '';
            }
        }

        function renderRiders() {
            const list = document.getElementById('riders-list');
            if (data.riders.length === 0) {
                list.innerHTML = '<div class="empty-state">No riders yet. Click "Add Team Rider" below to get started.</div>';
                return;
            }
            
            // Sort riders
            let sortedRiders = [...data.riders];
            if (riderSortColumn) {
                sortedRiders.sort((a, b) => {
                    let aVal, bVal;
                    switch (riderSortColumn) {
                        case 'name':
                            const aLastName = getSortableLastName(a.name || '');
                            const bLastName = getSortableLastName(b.name || '');
                            if (aLastName !== bLastName) {
                                aVal = aLastName;
                                bVal = bLastName;
                            } else {
                                // If last names are equal, sort by first name
                                const aParts = (a.name || '').trim().split(/\s+/);
                                const bParts = (b.name || '').trim().split(/\s+/);
                                aVal = aParts[0] ? aParts[0].toLowerCase() : '';
                                bVal = bParts[0] ? bParts[0].toLowerCase() : '';
                            }
                            break;
                        case 'gender':
                            aVal = (a.gender || '').toUpperCase();
                            bVal = (b.gender || '').toUpperCase();
                            break;
                        case 'grade':
                            aVal = getGradeSortValue(a.grade || '9th');
                            bVal = getGradeSortValue(b.grade || '9th');
                            break;
                        case 'racingGroup':
                            aVal = getRacingGroupSortValue(a.racingGroup || '');
                            bVal = getRacingGroupSortValue(b.racingGroup || '');
                            if (aVal === bVal) {
                                // Secondary sort by name of group if same level
                                aVal = (a.racingGroup || '').toLowerCase();
                                bVal = (b.racingGroup || '').toLowerCase();
                            }
                            break;
                        case 'pace':
                            aVal = parseInt(a.fitness || '5', 10);
                            bVal = parseInt(b.fitness || '5', 10);
                            break;
                        case 'skills':
                            aVal = parseInt(a.skills || '2', 10);
                            bVal = parseInt(b.skills || '2', 10);
                            break;
                        default:
                            return 0;
                    }
                    
                    let comparison = 0;
                    if (aVal < bVal) comparison = -1;
                    if (aVal > bVal) comparison = 1;
                    
                    return riderSortDirection === 'asc' ? comparison : -comparison;
                });
            }
            
            const getSortIndicator = (column) => {
                if (riderSortColumn !== column) {
                    return '<span class="sort-indicator">⇅</span>';
                }
                return riderSortDirection === 'asc' 
                    ? '<span class="sort-indicator active">↑</span>' 
                    : '<span class="sort-indicator active">↓</span>';
            };
            
            // Get column order
            const columnOrder = getRiderColumnOrder();
            const gridTemplate = getRiderGridTemplate(columnOrder);
            
            // Build header cells in order
            const headerCells = columnOrder.map(key => {
                const def = riderColumnDefs.find(c => c.key === key);
                if (!def) return '<div></div>';
                
                let content = '';
                // Name column is not draggable (locked in position)
                const isDraggable = key !== 'name';
                const draggableAttr = isDraggable ? 'draggable="true"' : 'draggable="false"';
                const dragHandlers = isDraggable ? `ondragstart="handleColumnDragStart(event, 'rider', '${key}')" ondragover="handleColumnDragOver(event)" ondrop="handleColumnDrop(event, 'rider', '${key}')" ondragend="handleColumnDragEnd(event)"` : '';
                
                // Add resize handle for resizable columns (not photo, not actions)
                const resizeHandle = (key !== 'photo' && key !== 'actions') ? `<div class="column-resize-handle" onmousedown="handleColumnResizeStart(event, 'rider', '${key}')"></div>` : '';
                
                if (def.sortable) {
                    content = `<div class="roster-header-sortable" style="position: relative;" onclick="sortRiders('${key === 'name' ? 'name' : key === 'pace' ? 'pace' : key === 'skills' ? 'skills' : key}')" ${draggableAttr} ${dragHandlers}>${def.label} ${getSortIndicator(key === 'name' ? 'name' : key === 'pace' ? 'pace' : key === 'skills' ? 'skills' : key)}${resizeHandle}</div>`;
                } else {
                    content = `<div style="position: relative;" ${draggableAttr} ${dragHandlers}>${def.label}${resizeHandle}</div>`;
                }
                return content;
            });
            
            const header = `
                <div class="roster-header rider-grid-template" style="grid-template-columns: ${gridTemplate};">
                    ${headerCells.join('')}
                </div>
            `;

            // Group riders if grouping is enabled
            let groupedRiders = [];
            if (riderGroupBy) {
                const groups = new Map();
                sortedRiders.forEach(rider => {
                    const groupValue = getRiderGroupValue(rider, riderGroupBy);
                    if (!groups.has(groupValue)) {
                        groups.set(groupValue, []);
                    }
                    groups.get(groupValue).push(rider);
                });
                
                // Sort group keys
                const sortedGroupKeys = Array.from(groups.keys()).sort((a, b) => {
                    if (riderGroupBy === 'name') {
                        return a.localeCompare(b);
                    } else if (riderGroupBy === 'grade') {
                        return getGradeSortValue(a) - getGradeSortValue(b);
                    } else if (riderGroupBy === 'racingGroup') {
                        return getRacingGroupSortValue(a) - getRacingGroupSortValue(b);
                    } else if (riderGroupBy === 'pace') {
                        const aPace = parseInt(a.replace('Pace ', '') || '5', 10);
                        const bPace = parseInt(b.replace('Pace ', '') || '5', 10);
                        return aPace - bPace;
                    } else if (riderGroupBy === 'skills') {
                        const aSkills = parseInt(a.replace('Bike Skills ', '').replace('Skills ', '') || '2', 10);
                        const bSkills = parseInt(b.replace('Skills ', '') || '2', 10);
                        return aSkills - bSkills;
                    }
                    return a.localeCompare(b);
                });
                
                sortedGroupKeys.forEach(groupKey => {
                    groupedRiders.push({ type: 'header', value: groupKey });
                    groups.get(groupKey).forEach(rider => {
                        groupedRiders.push({ type: 'rider', data: rider });
                    });
                });
            } else {
                sortedRiders.forEach(rider => {
                    groupedRiders.push({ type: 'rider', data: rider });
                });
            }

            let htmlContent = header;
            groupedRiders.forEach(item => {
                if (item.type === 'header') {
                    // Convert gender values to display labels
                    let displayValue = item.value;
                    if (riderGroupBy === 'gender') {
                        if (item.value === 'F') {
                            displayValue = 'Girls';
                        } else if (item.value === 'M') {
                            displayValue = 'Boys';
                        }
                    }
                    htmlContent += `<div class="roster-group-header">${escapeHtml(displayValue)}</div>`;
                } else {
                    const rider = item.data;
                    const fitnessScale = getFitnessScale();
                    const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
                    let photoSrc = rider.photo;
                    if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                        const gender = (rider.gender || '').toUpperCase();
                        if (gender === 'M') photoSrc = 'assets/male_default.png';
                        else if (gender === 'F') photoSrc = 'assets/female_default.png';
                        else photoSrc = 'assets/nonbinary_default.png';
                    }
                    const photoMarkup = photoSrc
                        ? `<img src="${escapeHtml(photoSrc)}" alt="${escapeHtml(rider.name || 'Rider')}">`
                        : `<span class="photo-placeholder">👤</span>`;

                    const gradeValue = formatGradeLabel(rider.grade);
                    const racingValue = rider.racingGroup || '';
                    const genderValue = (rider.gender || 'M').toUpperCase();
                    const hasNotes = rider.notes && rider.notes.trim().length > 0;
                    const notesIcon = hasNotes ? `<span class="notes-icon" onclick="showNotesModal(${rider.id}, 'rider')" title="View notes">📝</span>` : '';

                    // Build row cells in column order
                    const rowCells = columnOrder.map(key => {
                        switch(key) {
                            case 'photo':
                                return `<div class="roster-photo" style="position: relative;">
                                    ${photoMarkup}
                                    <div class="photo-edit-overlay">
                                        <span class="photo-edit-icon">✏️</span>
                                    </div>
                                    <input type="file" id="rider-photo-input-${rider.id}" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleRiderPhotoUpload(${rider.id}, this)">
                                </div>`;
                            case 'name':
                                const riderRole = getRiderRole(rider.id);
                                const riderNameDisplay = riderRole 
                                    ? `${escapeHtml(rider.name || '')} <span style="font-style: italic; color: #666; margin-left: 8px; font-weight: normal;">${escapeHtml(riderRole)}</span>`
                                    : escapeHtml(rider.name || '');
                                const medicalIcon = getMedicalIconHtml(rider.allergiesOrMedicalNeeds || rider.medicalNotes || '');
                                return `<div class="roster-cell roster-name" data-label="Name">
                                    ${riderNameDisplay}
                                    ${medicalIcon}
                                    ${rider.phone ? `<a href="${formatPhoneForTel(rider.phone)}" class="roster-phone-icon" title="Call ${formatPhoneForDisplay(rider.phone)}" aria-label="Call ${formatPhoneForDisplay(rider.phone)}">📞</a>` : ''}
                                </div>`;
                            case 'phone':
                                return `<div class="roster-cell" data-label="Phone">
                                    ${formatPhoneForDisplay(rider.phone || '')}
                                </div>`;
                            case 'gender':
                                return `<div class="roster-cell" data-label="Gender">
                                    ${escapeHtml(genderValue)}
                                </div>`;
                            case 'grade':
                                return `<div class="roster-cell" data-label="Grade">
                                    ${escapeHtml(gradeValue)}
                                </div>`;
                            case 'racingGroup':
                                return `<div class="roster-cell" data-label="Racing Group">
                                    ${escapeHtml(racingValue)}
                                </div>`;
                            case 'pace':
                                return `<div class="roster-cell" data-label="Pace">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustRiderPace(${rider.id}, -1)">▼</span>
                                        <span class="pace-value">${fitnessValue}</span>
                                        <span class="pace-arrow" onclick="adjustRiderPace(${rider.id}, 1)">▲</span>
                                    </div>
                                </div>`;
                            case 'skills':
                                const riderSkillsScale = getSkillsScale();
                                const riderSkillsValue = Math.max(1, Math.min(riderSkillsScale, parseInt(rider.skills || Math.ceil(riderSkillsScale / 2), 10)));
                                const riderSkillsTooltip = getBikeSkillsTooltip(riderSkillsValue, riderSkillsScale);
                                return `<div class="roster-cell" data-label="Bike Skills">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustRiderSkills(${rider.id}, -1)">▼</span>
                                        <span class="pace-value" title="${riderSkillsTooltip.replace(/\n/g, '&#10;')}" style="cursor: help;">${riderSkillsValue}</span>
                                        <span class="pace-arrow" onclick="adjustRiderSkills(${rider.id}, 1)">▲</span>
                                    </div>
                                </div>`;
                            case 'notes':
                                return `<div class="roster-cell" data-label="Notes">
                                    ${notesIcon}
                                </div>`;
                            case 'actions':
                                return `<div class="roster-actions">
                                    <button class="btn-small" onclick="openEditRiderModal(${rider.id})">Edit Record</button>
                                </div>`;
                            default:
                                return '<div></div>';
                        }
                    });
                    
                    htmlContent += `
                        <div class="roster-row rider-grid-template" data-rider-id="${rider.id}" style="grid-template-columns: ${gridTemplate};">
                            ${rowCells.join('')}
                        </div>
                    `;
                }
            });
            list.innerHTML = htmlContent;
        }

        // Coach management
        async function addCoach() {
            if (!canEditCoaches()) {
                alert('You do not have permission to add coaches');
                return;
            }

            const name = document.getElementById('coach-name').value.trim();
            const phone = document.getElementById('coach-phone').value.trim();
            const level = document.getElementById('coach-level').value;
            const fitnessInput = document.getElementById('coach-fitness').value;
            const notes = document.getElementById('coach-notes').value.trim();
            
            if (!name) {
                alert('Please enter a coach name');
                return;
            }

            const fitnessValue = Math.max(1, Math.min(10, parseInt(fitnessInput || '5', 10)));

            // Read photo (readPhotoFile returns a Promise)
            const photo = await readPhotoFile('coach-photo');
            
            const coachData = {
                name,
                photo,
                phone,
                level,
                fitness: String(fitnessValue),
                notes
            };

            saveCoachToDB(coachData);
            resetCoachForm();
            renderCoaches();
        }

        function resetCoachForm() {
            document.getElementById('coach-photo').value = '';
            document.getElementById('coach-name').value = '';
            document.getElementById('coach-phone').value = '';
            document.getElementById('coach-level').value = '1';
            document.getElementById('coach-fitness').value = '5';
            document.getElementById('coach-notes').value = '';
            handleFileChange('coach-photo', 'coach-photo-name');
        }

        async function deleteCoach(id, skipConfirm = false) {
            if (!canEditCoaches()) {
                alert('You do not have permission to delete coaches');
                return;
            }

            if (skipConfirm || confirm('Delete this coach?')) {
                try {
                    const client = getSupabaseClient();
                    const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
                    if (client && currentUser && typeof deleteCoachFromDB === 'function') {
                        await deleteCoachFromDB(id);
                    }
                } catch (error) {
                    console.error('Error deleting coach from database:', error);
                    alert(error.message || 'Failed to delete coach.');
                    return;
                }
                
                // Remove from coaches array
                data.coaches = data.coaches.filter(c => c.id !== id);
                
                // Also update any rides that reference this coach
                for (const ride of data.rides) {
                    if (ride.availableCoaches && ride.availableCoaches.includes(id)) {
                        ride.availableCoaches = ride.availableCoaches.filter(coachId => coachId !== id);
                        // Update groups if needed
                        if (ride.groups) {
                            ride.groups.forEach(group => {
                                if (group.coaches) {
                                    Object.keys(group.coaches).forEach(key => {
                                        if (group.coaches[key] === id) {
                                            group.coaches[key] = null;
                                        }
                                    });
                                    // Also check extraRoam array
                                    if (Array.isArray(group.coaches.extraRoam)) {
                                        group.coaches.extraRoam = group.coaches.extraRoam.filter(coachId => coachId !== id);
                                    }
                                }
                            });
                        }
                        saveRideToDB(ride);
                    }
                }
                
                saveData();
                renderCoaches();
                if (data.currentRide) {
                    renderRides();
                }
            }
        }

        function renderCoaches() {
            const list = document.getElementById('coaches-list');
            if (data.coaches.length === 0) {
                list.innerHTML = '<div class="empty-state">No coaches yet. Click "Add Coach" below to get started.</div>';
                return;
            }
            
            // Separate coaches with roles from those without
            const coachesWithRoles = [];
            const coachesWithoutRoles = [];
            
            data.coaches.forEach(coach => {
                if (getCoachRole(coach.id)) {
                    coachesWithRoles.push(coach);
                } else {
                    coachesWithoutRoles.push(coach);
                }
            });
            
            // Sort coaches
            let sortedCoachesWithRoles = [...coachesWithRoles];
            let sortedCoachesWithoutRoles = [...coachesWithoutRoles];
            
            const sortCoachesArray = (coaches) => {
                if (!coachSortColumn) return coaches;
                return [...coaches].sort((a, b) => {
                    let aVal, bVal;
                    switch (coachSortColumn) {
                        case 'name':
                            const aLastName = getSortableLastName(a.name || '');
                            const bLastName = getSortableLastName(b.name || '');
                            if (aLastName !== bLastName) {
                                aVal = aLastName;
                                bVal = bLastName;
                            } else {
                                // If last names are equal, sort by first name
                                const aParts = (a.name || '').trim().split(/\s+/);
                                const bParts = (b.name || '').trim().split(/\s+/);
                                aVal = aParts[0] ? aParts[0].toLowerCase() : '';
                                bVal = bParts[0] ? bParts[0].toLowerCase() : '';
                            }
                            break;
                        case 'level':
                            // Support both old 'level' and new 'coachingLicenseLevel' fields
                            const aLevelRaw = a.coachingLicenseLevel || a.level || '1';
                            const bLevelRaw = b.coachingLicenseLevel || b.level || '1';
                            // Handle N/A as 0 for sorting
                            aVal = (aLevelRaw === 'N/A' || aLevelRaw === 'NA') ? 0 : parseInt(aLevelRaw, 10);
                            bVal = (bLevelRaw === 'N/A' || bLevelRaw === 'NA') ? 0 : parseInt(bLevelRaw, 10);
                            break;
                        case 'pace':
                            aVal = parseInt(a.fitness || '5', 10);
                            bVal = parseInt(b.fitness || '5', 10);
                            break;
                        case 'skills':
                            const skillsScale = getSkillsScale();
                            aVal = Math.max(1, Math.min(skillsScale, parseInt(a.skills || Math.ceil(skillsScale / 2), 10)));
                            bVal = Math.max(1, Math.min(skillsScale, parseInt(b.skills || Math.ceil(skillsScale / 2), 10)));
                            break;
                        default:
                            return 0;
                    }
                    
                    let comparison = 0;
                    if (aVal < bVal) comparison = -1;
                    if (aVal > bVal) comparison = 1;
                    
                    return coachSortDirection === 'asc' ? comparison : -comparison;
                });
            };
            
            sortedCoachesWithRoles = sortCoachesArray(sortedCoachesWithRoles);
            sortedCoachesWithoutRoles = sortCoachesArray(sortedCoachesWithoutRoles);
            
            // Combine: role coaches first, then others
            const sortedCoaches = [...sortedCoachesWithRoles, ...sortedCoachesWithoutRoles];
            
            const getSortIndicator = (column) => {
                if (coachSortColumn !== column) {
                    return '<span class="sort-indicator">⇅</span>';
                }
                return coachSortDirection === 'asc' 
                    ? '<span class="sort-indicator active">↑</span>' 
                    : '<span class="sort-indicator active">↓</span>';
            };
            
            // Get column order
            const columnOrder = getCoachColumnOrder();
            const gridTemplate = getCoachGridTemplate(columnOrder);
            
            // Build header cells in order
            const headerCells = columnOrder.map(key => {
                const def = coachColumnDefs.find(c => c.key === key);
                if (!def) return '<div></div>';
                
                // Name column is not draggable (locked in position)
                const isDraggable = key !== 'name';
                const draggableAttr = isDraggable ? 'draggable="true"' : 'draggable="false"';
                const dragHandlers = isDraggable ? `ondragstart="handleColumnDragStart(event, 'coach', '${key}')" ondragover="handleColumnDragOver(event)" ondrop="handleColumnDrop(event, 'coach', '${key}')" ondragend="handleColumnDragEnd(event)"` : '';
                
                // Add resize handle for resizable columns (not photo, not actions)
                const resizeHandle = (key !== 'photo' && key !== 'actions') ? `<div class="column-resize-handle" onmousedown="handleColumnResizeStart(event, 'coach', '${key}')"></div>` : '';
                
                let content = '';
                if (def.sortable) {
                    const sortKey = key === 'level' ? 'level' : key === 'pace' ? 'pace' : 'name';
                    content = `<div class="roster-header-sortable" style="position: relative;" onclick="sortCoaches('${sortKey}')" ${draggableAttr} ${dragHandlers}>${def.label} ${getSortIndicator(sortKey)}${resizeHandle}</div>`;
                } else {
                    content = `<div style="position: relative;" ${draggableAttr} ${dragHandlers}>${def.label}${resizeHandle}</div>`;
                }
                return content;
            });
            
            const header = `
                <div class="roster-header coach-grid-template" style="grid-template-columns: ${gridTemplate};">
                    ${headerCells.join('')}
                </div>
            `;

            // Group coaches if grouping is enabled
            let groupedCoaches = [];
            if (coachGroupBy) {
                const groups = new Map();
                // Use sortedCoaches which was created above
                sortedCoaches.forEach(coach => {
                    const groupValue = getCoachGroupValue(coach, coachGroupBy);
                    if (!groups.has(groupValue)) {
                        groups.set(groupValue, []);
                    }
                    groups.get(groupValue).push(coach);
                });
                
                // Sort group keys
                const sortedGroupKeys = Array.from(groups.keys()).sort((a, b) => {
                    if (coachGroupBy === 'name') {
                        return a.localeCompare(b);
                    } else if (coachGroupBy === 'level') {
                        const levelOrder = (label) => {
                            if (label === 'N/A') return 99;
                            const parsed = parseInt(label.replace('Level ', '') || '1', 10);
                            if (!Number.isFinite(parsed)) return 98;
                            return -parsed;
                        };
                        return levelOrder(a) - levelOrder(b);
                    } else if (coachGroupBy === 'pace') {
                        const aPace = parseInt(a.replace('Pace ', '') || '5', 10);
                        const bPace = parseInt(b.replace('Pace ', '') || '5', 10);
                        return aPace - bPace;
                    }
                    return a.localeCompare(b);
                });
                
                sortedGroupKeys.forEach(groupKey => {
                    groupedCoaches.push({ type: 'header', value: groupKey });
                    groups.get(groupKey).forEach(coach => {
                        groupedCoaches.push({ type: 'coach', data: coach });
                    });
                });
            } else {
                sortedCoaches.forEach(coach => {
                    groupedCoaches.push({ type: 'coach', data: coach });
                });
            }

            let htmlContent = header;
            let isFirstNonRoleCoach = true;
            let hasRoleCoaches = sortedCoachesWithRoles.length > 0;
            let lastItemWasRoleCoach = false;
            groupedCoaches.forEach((item, index) => {
                if (item.type === 'header') {
                    htmlContent += `<div class="roster-group-header">${escapeHtml(item.value)}</div>`;
                    lastItemWasRoleCoach = false;
                } else {
                    const coach = item.data;
                    // Check if this is the first coach without a role (after role coaches)
                    const hasRole = getCoachRole(coach.id);
                    if (hasRoleCoaches && !hasRole && isFirstNonRoleCoach) {
                        htmlContent += `<div style="grid-column: 1 / -1; height: 1px; background: #ddd; margin: 12px 0;"></div>`;
                        isFirstNonRoleCoach = false;
                    }
                    lastItemWasRoleCoach = hasRole;
                    // Support both old 'level' and new 'coachingLicenseLevel' fields
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
                    
                    // Determine photo - use uploaded photo or default based on gender
                    let photoSrc = coach.photo;
                    if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                        const gender = coach.gender || '';
                        if (gender === 'M') photoSrc = 'assets/male_default.png';
                        else if (gender === 'F') photoSrc = 'assets/female_default.png';
                        else photoSrc = 'assets/nonbinary_default.png';
                    }
                    const photoMarkup = photoSrc
                        ? `<img src="${escapeHtml(photoSrc)}" alt="${escapeHtml(coach.name || 'Coach')}">`
                        : `<span class="photo-placeholder">🚴</span>`;
                    const fitnessScale = getFitnessScale();
                    const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
                    const levelLabel = levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                    const hasNotes = coach.notes && coach.notes.trim().length > 0;
                    const notesIcon = hasNotes ? `<span class="notes-icon" onclick="showNotesModal(${coach.id}, 'coach')" title="View notes">📝</span>` : '';
                    const levelClass = levelRaw === 'N/A' || levelNum === 0 ? 'coach-level-na' : levelNum === 1 ? 'coach-level-1' : levelNum === 2 ? 'coach-level-2' : levelNum === 3 ? 'coach-level-3' : '';

                    // Build row cells in column order
                    const rowCells = columnOrder.map(key => {
                        switch(key) {
                            case 'photo':
                                return `<div class="roster-photo" style="position: relative;">
                                    ${photoMarkup}
                                    <div class="photo-edit-overlay">
                                        <span class="photo-edit-icon">✏️</span>
                                    </div>
                                    <input type="file" id="coach-photo-input-${coach.id}" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleCoachPhotoUpload(${coach.id}, this)">
                                </div>`;
                            case 'name':
                                const coachRole = getCoachRole(coach.id);
                                const coachNameDisplay = coachRole 
                                    ? `${escapeHtml(coach.name || '')} <span style="font-style: italic; color: #666; margin-left: 8px; font-weight: normal;">${escapeHtml(coachRole)}</span>`
                                    : escapeHtml(coach.name || '');
                                return `<div class="roster-cell roster-name" data-label="Name">
                                    ${coachNameDisplay}
                                    ${coach.phone ? `<a href="${formatPhoneForTel(coach.phone)}" class="roster-phone-icon coach-phone-icon" title="Call ${formatPhoneForDisplay(coach.phone)}" aria-label="Call ${formatPhoneForDisplay(coach.phone)}">📞</a>` : ''}
                                </div>`;
                            case 'phone':
                                return `<div class="roster-cell" data-label="Phone">
                                    ${formatPhoneForDisplay(coach.phone || '')}
                                </div>`;
                            case 'level':
                                return `<div class="roster-cell" data-label="Coach Level">
                                    ${escapeHtml(levelLabel)}
                                </div>`;
                            case 'pace':
                                return `<div class="roster-cell" data-label="Pace">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustCoachPace(${coach.id}, -1)">▼</span>
                                        <span class="pace-value">${fitnessValue}</span>
                                        <span class="pace-arrow" onclick="adjustCoachPace(${coach.id}, 1)">▲</span>
                                    </div>
                                </div>`;
                            case 'skills':
                                const coachSkillsScale = getSkillsScale();
                                const coachSkillsValue = Math.max(1, Math.min(coachSkillsScale, parseInt(coach.skills || Math.ceil(coachSkillsScale / 2), 10)));
                                const coachSkillsTooltip = getBikeSkillsTooltip(coachSkillsValue, coachSkillsScale);
                                return `<div class="roster-cell" data-label="Bike Skills">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustCoachSkills(${coach.id}, -1)">▼</span>
                                        <span class="pace-value" title="${coachSkillsTooltip.replace(/\n/g, '&#10;')}" style="cursor: help;">${coachSkillsValue}</span>
                                        <span class="pace-arrow" onclick="adjustCoachSkills(${coach.id}, 1)">▲</span>
                                    </div>
                                </div>`;
                            case 'notes':
                                return `<div class="roster-cell" data-label="Notes">
                                    ${notesIcon}
                                </div>`;
                            case 'actions':
                                return `<div class="roster-actions">
                                    <button class="btn-small" onclick="openEditCoachModal(${coach.id})">Edit Record</button>
                                </div>`;
                            default:
                                return '<div></div>';
                        }
                    });
                    
                    htmlContent += `
                        <div class="roster-row coach-grid-template ${levelClass}" data-coach-id="${coach.id}" style="grid-template-columns: ${gridTemplate};">
                            ${rowCells.join('')}
                        </div>
                    `;
                }
            });
            list.innerHTML = htmlContent;
        }

        // Ride management
        async function createRide() {
            if (!canCreateEditRides()) {
                alert('You do not have permission to create rides');
                return;
            }

            const date = document.getElementById('ride-date').value;
            
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            const rideData = {
                date: date,
                availableCoaches: [],
                availableRiders: [],
                assignments: {},
                groups: []
            };

            try {
                const newRide = saveRideToDB(rideData);
                data.currentRide = newRide.id;
                document.getElementById('ride-date').value = '';
                renderRides();
                loadCurrentRide();
            } catch (error) {
                console.error('Error creating ride:', error);
                alert('Error creating ride: ' + (error.message || 'Unknown error'));
            }
        }

        let currentEditingCoachId = null;

        function openEditCoachModal(id) {
            const coach = data.coaches.find(c => c.id === id);
            if (!coach) return;

            currentEditingCoachId = id;
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-coach-modal-title');
            if (titleEl) titleEl.textContent = 'Edit Coach';
            
            const deleteBtn = document.getElementById('delete-coach-btn');
            if (deleteBtn) deleteBtn.style.display = 'block';

            // Populate name fields (prefer explicit first/last if present, otherwise split full name)
            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            const coachFullName = coach.name || '';
            let coachFirstName = coach.firstName || '';
            let coachLastName = coach.lastName || '';
            if (!coachFirstName && !coachLastName && coachFullName) {
                const nameParts = coachFullName.trim().split(' ');
                if (nameParts.length > 1) {
                    coachLastName = nameParts.pop();
                    coachFirstName = nameParts.join(' ');
                } else {
                    coachFirstName = coachFullName;
                }
            }
            if (coachFirstNameInput) coachFirstNameInput.value = coachFirstName || '';
            if (coachLastNameInput) coachLastNameInput.value = coachLastName || '';
            
            // Format phone number
            const coachPhone = (coach.phone || '').replace(/\D/g, '');
            if (coachPhone.length === 10) {
                const formattedPhone = `(${coachPhone.substring(0, 3)}) ${coachPhone.substring(3, 6)}-${coachPhone.substring(6, 10)}`;
                document.getElementById('edit-coach-phone').value = formattedPhone;
            } else if (coach.phone) {
                document.getElementById('edit-coach-phone').value = formatPhoneForDisplay(coach.phone);
            } else {
                document.getElementById('edit-coach-phone').value = '';
            }
            
            // Populate all CSV fields
            document.getElementById('edit-coach-email').value = coach.email || '';
            
            // Format work phone
            const workPhone = (coach.workPhone || '').replace(/\D/g, '');
            if (workPhone.length === 10) {
                document.getElementById('edit-coach-work-phone').value = `(${workPhone.substring(0, 3)}) ${workPhone.substring(3, 6)}-${workPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-coach-work-phone').value = coach.workPhone || '';
            }
            
            // Format home phone
            const homePhone = (coach.homePhone || '').replace(/\D/g, '');
            if (homePhone.length === 10) {
                document.getElementById('edit-coach-home-phone').value = `(${homePhone.substring(0, 3)}) ${homePhone.substring(3, 6)}-${homePhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-coach-home-phone').value = coach.homePhone || '';
            }
            
            document.getElementById('edit-coach-gender').value = coach.gender || '';
            
            // Support both old 'level' and new 'coachingLicenseLevel' fields
            const coachLevel = coach.coachingLicenseLevel || coach.level || '1';
            document.getElementById('edit-coach-level').value = coachLevel;
            
            document.getElementById('edit-coach-registered').value = coach.registered || '';
            document.getElementById('edit-coach-paid').value = coach.paid || '';
            document.getElementById('edit-coach-background-check').value = coach.backgroundCheck || '';
            document.getElementById('edit-coach-level3-exam').value = coach.level3ExamCompleted || '';
            document.getElementById('edit-coach-pdu-ceu').value = coach.pduCeuUnits || '';
            document.getElementById('edit-coach-field-work-hours').value = coach.fieldWorkHours || '';
            document.getElementById('edit-coach-first-aid').value = coach.firstAidTypeExpires || '';
            document.getElementById('edit-coach-cpr-expires').value = coach.cprExpires || '';
            document.getElementById('edit-coach-concussion-training').value = coach.concussionTrainingCompleted || '';
            document.getElementById('edit-coach-nica-philosophy').value = coach.nicaPhilosophyCompleted || '';
            document.getElementById('edit-coach-abuse-awareness').value = coach.athleteAbuseAwarenessCompleted || '';
            document.getElementById('edit-coach-license-level1').value = coach.licenseLevel1Completed || '';
            document.getElementById('edit-coach-license-level2').value = coach.licenseLevel2Completed || '';
            document.getElementById('edit-coach-license-level3').value = coach.licenseLevel3Completed || '';
            document.getElementById('edit-coach-otb-classroom').value = coach.otbSkills101ClassroomCompleted || '';
            document.getElementById('edit-coach-otb-outdoor').value = coach.otbSkills101OutdoorCompleted || '';
            document.getElementById('edit-coach-nica-summit').value = coach.nicaLeaderSummitCompleted || '';
            
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-coach-fitness').value = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
            document.getElementById('edit-coach-skills').value = Math.max(1, Math.min(skillsScale, parseInt(coach.skills || Math.ceil(skillsScale / 2), 10)));
            document.getElementById('edit-coach-notes').value = coach.notes || '';

            // Update photo preview
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            if (coach.photo) {
                photoPreview.src = coach.photo;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                photoPreview.style.display = 'none';
                photoPlaceholder.style.display = 'flex';
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function openAddCoachModal() {
            currentEditingCoachId = null;
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-coach-modal-title');
            if (titleEl) titleEl.textContent = 'Add Coach';
            
            const deleteBtn = document.getElementById('delete-coach-btn');
            if (deleteBtn) deleteBtn.style.display = 'none';

            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            if (coachFirstNameInput) coachFirstNameInput.value = '';
            if (coachLastNameInput) coachLastNameInput.value = '';
            document.getElementById('edit-coach-phone').value = '';
            document.getElementById('edit-coach-level').value = 'N/A';
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-coach-fitness').value = Math.ceil(fitnessScale / 2);
            document.getElementById('edit-coach-skills').value = Math.ceil(skillsScale / 2);
            document.getElementById('edit-coach-notes').value = '';

            // Reset photo preview
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            photoPreview.style.display = 'none';
            photoPlaceholder.style.display = 'flex';
            document.getElementById('edit-coach-photo-input').value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeEditCoachModal() {
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;
            // Blur any focused elements before hiding modal to avoid aria-hidden warning
            const focusedElement = document.activeElement;
            if (focusedElement && modal.contains(focusedElement)) {
                focusedElement.blur();
            }
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentEditingCoachId = null;
        }

        async function saveCoachFromModal() {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to edit coach records');
                return;
            }

            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            const firstName = coachFirstNameInput ? coachFirstNameInput.value.trim() : '';
            const lastName = coachLastNameInput ? coachLastNameInput.value.trim() : '';
            const name = `${firstName} ${lastName}`.trim();
            if (!firstName && !lastName) {
                alert('Please enter a coach first or last name');
                return;
            }

            const phoneInputEl = document.getElementById('edit-coach-phone');
            if (!phoneInputEl) {
                alert('Phone input field not found');
                return;
            }
            const phoneInput = phoneInputEl.value.trim();
            const phoneDigits = phoneInput.replace(/\D/g, '');
            
            if (phoneDigits.length !== 10) {
                alert('Please enter a valid 10-digit phone number');
                return;
            }
            
            const phone = phoneDigits; // Store as digits only
            const levelInputEl = document.getElementById('edit-coach-level');
            const levelValue = levelInputEl ? levelInputEl.value : '1';
            const fitnessInputEl = document.getElementById('edit-coach-fitness');
            const fitnessInput = fitnessInputEl ? fitnessInputEl.value : String(Math.ceil(getFitnessScale() / 2));
            const notesInputEl = document.getElementById('edit-coach-notes');
            const notes = notesInputEl ? notesInputEl.value.trim() : '';

            const fitnessScale = getFitnessScale();
            const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(fitnessInput || Math.ceil(fitnessScale / 2), 10)));
            const coachingLicenseLevel = ['1', '2', '3', 'N/A'].includes(levelValue) ? levelValue : 'N/A';

            // Get gender value (needed for photo default and coachData)
            const genderEl = document.getElementById('edit-coach-gender');
            const gender = genderEl ? (genderEl.value || '').toUpperCase() : '';

            // Get photo from preview or input
            let photo = '';
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoInput = document.getElementById('edit-coach-photo-input');
            
            // Check if a new photo was uploaded
            if (photoInput && photoInput.files && photoInput.files.length > 0) {
                // Read the uploaded file
                const file = photoInput.files[0];
                const reader = new FileReader();
                photo = await new Promise((resolve) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => resolve('');
                    reader.readAsDataURL(file);
                });
            } else if (photoPreview && photoPreview.style.display !== 'none' && photoPreview.src) {
                // Use existing photo from preview
                photo = photoPreview.src;
            } else {
                // If no photo uploaded, use default based on gender
                if (gender === 'M') photo = 'assets/male_default.png';
                else if (gender === 'F') photo = 'assets/female_default.png';
                else photo = 'assets/nonbinary_default.png';
            }

            // Get all CSV fields
            const emailEl = document.getElementById('edit-coach-email');
            const email = emailEl ? emailEl.value.trim() : '';
            const workPhoneInputEl = document.getElementById('edit-coach-work-phone');
            const workPhoneInput = workPhoneInputEl ? workPhoneInputEl.value.trim() : '';
            const workPhoneDigits = workPhoneInput.replace(/\D/g, '');
            const workPhone = workPhoneDigits.length === 10 ? workPhoneDigits : '';
            const homePhoneInputEl = document.getElementById('edit-coach-home-phone');
            const homePhoneInput = homePhoneInputEl ? homePhoneInputEl.value.trim() : '';
            const homePhoneDigits = homePhoneInput.replace(/\D/g, '');
            const homePhone = homePhoneDigits.length === 10 ? homePhoneDigits : '';
            
            // Helper function to safely get field value
            const getFieldValue = (fieldId, defaultValue = '') => {
                const el = document.getElementById(fieldId);
                return el ? el.value.trim() : defaultValue;
            };
            
            const skillsInputEl = document.getElementById('edit-coach-skills');
            const skillsScale = getSkillsScale();
            const skillsValue = skillsInputEl ? Math.max(1, Math.min(skillsScale, parseInt(skillsInputEl.value || Math.ceil(skillsScale / 2), 10))) : Math.ceil(skillsScale / 2);
            
            const coachData = {
                name,
                firstName,
                lastName,
                phone,
                photo,
                email,
                workPhone,
                homePhone,
                gender,
                coachingLicenseLevel,
                registered: getFieldValue('edit-coach-registered'),
                paid: getFieldValue('edit-coach-paid'),
                backgroundCheck: getFieldValue('edit-coach-background-check'),
                level3ExamCompleted: getFieldValue('edit-coach-level3-exam'),
                pduCeuUnits: getFieldValue('edit-coach-pdu-ceu'),
                fieldWorkHours: getFieldValue('edit-coach-field-work-hours'),
                firstAidTypeExpires: getFieldValue('edit-coach-first-aid'),
                cprExpires: getFieldValue('edit-coach-cpr-expires'),
                concussionTrainingCompleted: getFieldValue('edit-coach-concussion-training'),
                nicaPhilosophyCompleted: getFieldValue('edit-coach-nica-philosophy'),
                athleteAbuseAwarenessCompleted: getFieldValue('edit-coach-abuse-awareness'),
                licenseLevel1Completed: getFieldValue('edit-coach-license-level1'),
                licenseLevel2Completed: getFieldValue('edit-coach-license-level2'),
                licenseLevel3Completed: getFieldValue('edit-coach-license-level3'),
                otbSkills101ClassroomCompleted: getFieldValue('edit-coach-otb-classroom'),
                otbSkills101OutdoorCompleted: getFieldValue('edit-coach-otb-outdoor'),
                nicaLeaderSummitCompleted: getFieldValue('edit-coach-nica-summit'),
                fitness: String(fitnessValue),
                skills: String(skillsValue),
                notes
            };

            // Note: Permission checks removed - all users can edit coach data in localStorage mode

            if (currentEditingCoachId) {
                coachData.id = currentEditingCoachId;
            }

            try {
                await saveCoachToDB(coachData);
                renderCoaches();
                closeEditCoachModal();
                if (data.currentRide) {
                    const ride = data.rides.find(r => r.id === data.currentRide);
                    if (ride) {
                        renderAssignments(ride);
                    }
                }
            } catch (error) {
                console.error('Error saving coach:', error);
                alert('Error saving coach: ' + (error.message || 'Unknown error'));
            }
        }

        async function handleCoachPhotoUploadInModal(input) {
            if (!input.files || input.files.length === 0) return;
            
            const photo = await readPhotoFileFromInput(input);
            if (!photo) return;

            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            
            photoPreview.src = photo;
            photoPreview.style.display = 'block';
            photoPlaceholder.style.display = 'none';
        }

        function deleteCoachFromModal() {
            if (!currentEditingCoachId) return;
            deleteCoach(currentEditingCoachId, true);
            closeEditCoachModal();
        }

        function getValidPracticeDates() {
            // Returns a Set of valid practice date strings (ISO format) that match the calendar
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            const validDates = new Set();
            let seasonStart = null;
            let seasonEnd = null;
            
            // If season dates are set, use them; otherwise determine from individual rides
            if (startDate && endDate && startDate <= endDate) {
                seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                
                // Add regular practices based on day of week
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                    if (matchedPractices.length > 0) {
                        validDates.add(dateKey);
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            } else {
                // No season dates set - determine range from individual rides
                const rideDates = [];
                if (Array.isArray(data.rides)) {
                    data.rides.forEach(ride => {
                        if (!ride.date) return;
                        const rideDate = parseISODate(ride.date);
                        if (rideDate) rideDates.push(rideDate);
                    });
                }
                
                if (rideDates.length === 0) {
                    return validDates; // Empty set
                }
                
                rideDates.sort((a, b) => a - b);
                seasonStart = new Date(rideDates[0].getFullYear(), rideDates[0].getMonth(), 1);
                const lastRideDate = rideDates[rideDates.length - 1];
                seasonEnd = new Date(lastRideDate.getFullYear(), lastRideDate.getMonth() + 1, 0);
            }
            
            // Add individual practices from data.rides that fall within the season date range
            // Exclude deleted practices and include rescheduled practices on their new date
            if (Array.isArray(data.rides) && seasonStart && seasonEnd) {
                data.rides.forEach(ride => {
                    if (!ride.date) return;
                    // Skip deleted practices
                    if (ride.deleted) return;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return;
                    
                    // Check if ride date is within season range
                    if (rideDate >= seasonStart && rideDate <= seasonEnd) {
                        const dateKey = formatDateToISO(rideDate);
                        // Include rescheduled practices on their new date
                        if (ride.rescheduledFrom) {
                            validDates.add(dateKey);
                        } else {
                            // For regular practices, only add if it matches a scheduled practice day
                            // (This prevents deleted/superseded practices from being considered valid)
                            const weekday = rideDate.getDay();
                            const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                            if (matchedPractices.length > 0) {
                                validDates.add(dateKey);
                            }
                        }
                    }
                });
            }
            
            return validDates;
        }

        function cleanInvalidRides() {
            // Remove rides that are outside the season date range (if season is set)
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            let cleaned = false;
            
            // Only clean up if season dates are explicitly set
            if (!startDate || !endDate || startDate > endDate) {
                // No season set, keep all rides (but remove ones without dates)
                const beforeLength = data.rides.length;
                data.rides = data.rides.filter(ride => {
                    if (!ride.date) {
                        cleaned = true;
                        return false;
                    }
                    return true;
                });
                if (cleaned && data.rides.length !== beforeLength) {
                    // Check if current ride was removed
                    if (data.currentRide && !data.rides.find(r => r.id === data.currentRide)) {
                        data.currentRide = null;
                    }
                    saveData();
                }
                return cleaned;
            }
            
            const seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
            const seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            // Build set of valid scheduled practice dates (dates that match recurring schedule)
            const validScheduledDates = new Set();
            if (practices.length > 0) {
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                    if (matchedPractices.length > 0) {
                        validScheduledDates.add(dateKey);
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            }
            
            // Remove rides outside season range, without dates, or that don't match the schedule
            const beforeLength = data.rides.length;
            data.rides = data.rides.filter(ride => {
                if (!ride.date) {
                    cleaned = true;
                    return false; // Remove rides without dates
                }
                const rideDate = parseISODate(ride.date);
                if (!rideDate) {
                    cleaned = true;
                    return false; // Remove rides with invalid dates
                }
                rideDate.setHours(0, 0, 0, 0);
                if (rideDate < seasonStart || rideDate > seasonEnd) {
                    cleaned = true;
                    return false; // Remove rides outside season range
                }
                
                // If there are scheduled practices defined, remove rides that don't match the schedule
                // BUT exclude rescheduled practices (they are exceptions and should be kept)
                if (practices.length > 0 && !ride.rescheduledFrom && !validScheduledDates.has(ride.date)) {
                    cleaned = true;
                    return false; // Remove rides that don't match the current schedule (unless rescheduled)
                }
                
                return true; // Keep rides within season range and matching schedule (or keep all if no schedule)
            });
            
            // If current ride was removed, clear it
            if (data.currentRide && !data.rides.find(r => r.id === data.currentRide)) {
                data.currentRide = null;
                cleaned = true;
            }
            
            if (cleaned) {
                saveData();
            }
            
            return cleaned;
        }

        // Helper function to determine if a ride corresponds to a refined practice
        // Helper function to get the practice object for a ride
        function getPracticeForRide(ride) {
            if (!ride || !ride.date) return null;
            
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            // Check for specific date practice first
            const specificPractice = practices.find(p => p.specificDate === ride.date);
            if (specificPractice) return specificPractice;
            
            // Check for recurring day-of-week practice
            const rideDate = parseISODate(ride.date);
            if (rideDate) {
                const weekday = rideDate.getDay(); // Returns 0-6 (0 = Sunday)
                // Normalize dayOfWeek to number for comparison (handle string/number mismatches)
                const recurringPractice = practices.find(p => {
                    const practiceDayOfWeek = typeof p.dayOfWeek === 'string' ? parseInt(p.dayOfWeek, 10) : p.dayOfWeek;
                    const hasSpecificDate = p.specificDate != null && p.specificDate !== undefined && p.specificDate !== '';
                    return Number(practiceDayOfWeek) === weekday && !hasSpecificDate;
                });
                if (recurringPractice) return recurringPractice;
            }
            
            return null;
        }
        
        // Helper function to determine if a ride corresponds to a refined practice
        function isRideRefined(ride) {
            const practice = getPracticeForRide(ride);
            if (practice && practice.rosterFilter && practice.rosterFilter.filterType) {
                console.log('🔵 isRideRefined: Found refined practice for date', ride.date);
                return true;
            }
            console.log('🔵 isRideRefined: No refined practice found for date', ride.date);
            return false;
        }
        
        // Helper function to get filtered rider IDs for a refined ride
        function getFilteredRiderIdsForRide(ride) {
            const practice = getPracticeForRide(ride);
            if (!practice || !practice.rosterFilter || !practice.rosterFilter.filterType) {
                // Not refined - return all rider IDs
                return (data.riders || []).map(r => r.id);
            }
            
            // Get filtered riders using existing function
            const filteredRiders = getFilteredRidersForPractice(practice);
            return filteredRiders.map(r => r.id);
        }
        
        async function ensureRidesFromSchedule() {
            // Create rides for any scheduled practice dates that don't have rides yet
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            if (!startDate || !endDate || startDate > endDate || practices.length === 0) {
                return; // No schedule to create rides from
            }
            
            const seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
            const seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
            
            // Get existing ride dates (non-deleted only)
            const existingRideDates = new Set();
            const deletedRideDates = new Set(); // Track deleted dates so we don't recreate them
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.date) {
                        if (ride.deleted) {
                            deletedRideDates.add(ride.date);
                        } else {
                            existingRideDates.add(ride.date);
                        }
                    }
                });
            }
            
            // Create rides for each scheduled practice date
            const cursor = new Date(seasonStart.getTime());
            let ridesCreated = false;
            
            while (cursor <= seasonEnd) {
                const dateKey = formatDateToISO(cursor);
                const weekday = cursor.getDay();
                
                // Check for specific date practice first, then day-of-week
                const specificPractice = practices.find(p => p.specificDate === dateKey);
                const matchedPractices = specificPractice 
                    ? [specificPractice]
                    : practices.filter(practice => practice.dayOfWeek === weekday && !practice.specificDate);
                
                // If this date has a scheduled practice and no non-deleted ride exists, create one
                // But skip if this date was explicitly deleted
                if (matchedPractices.length > 0 && !existingRideDates.has(dateKey) && !deletedRideDates.has(dateKey)) {
                    // Use the first practice time if multiple match the same day
                    const practice = matchedPractices[0];
                    const allRiderIds = (data.riders || []).map(r => r.id);
                    
                    // STEP 1 & 2: For refined rides, select only riders that qualify under the filter
                    // For regular rides, default to all riders selected
                    const isRefined = practice.rosterFilter != null && practice.rosterFilter.filterType != null;
                    let defaultAvailableRiders;
                    if (isRefined) {
                        // Get filtered riders that match the refinement rules
                        const filteredRiders = getFilteredRidersForPractice(practice);
                        defaultAvailableRiders = filteredRiders.map(r => r.id);
                        console.log('🔵 ensureRidesFromSchedule: Creating refined ride with', defaultAvailableRiders.length, 'filtered riders for date', dateKey);
                    } else {
                        // Regular ride - all riders selected by default
                        defaultAvailableRiders = [...allRiderIds];
                    }
                    
                    const ride = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + cursor.getTime(),
                        date: dateKey,
                        time: practice.time || practice.startTime || '',
                        endTime: practice.endTime || '',
                        description: practice.description || '',
                        meetLocation: practice.meetLocation || '',
                        locationLat: practice.locationLat || null,
                        locationLng: practice.locationLng || null,
                        goals: '',
                        groups: [],
                        availableRiders: defaultAvailableRiders,
                        availableCoaches: [],
                        cancelled: false,
                        deleted: false // Ensure new rides are not marked as deleted
                    };
                    
                    ridesCreated = true;
                    
                    // Save to Supabase if authenticated - call Supabase directly to avoid local createRide function shadowing
                    const client = typeof getSupabaseClient === 'function' ? getSupabaseClient() : null;
                    const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
                    if (client && currentUser) {
                        try {
                            console.log('🔵 ensureRidesFromSchedule: Creating ride in Supabase for date', dateKey);
                            // Map ride to database format (same as scripts/database.js createRide does)
                            const dbData = {
                                date: ride.date,
                                time: ride.time || '',
                                end_time: ride.endTime || '',
                                description: ride.description || '',
                                meet_location: ride.meetLocation || '',
                                location_lat: ride.locationLat != null ? ride.locationLat : null,
                                location_lng: ride.locationLng != null ? ride.locationLng : null,
                                goals: ride.goals || '',
                                available_coaches: ride.availableCoaches || [],
                                available_riders: ride.availableRiders || [],
                                assignments: ride.assignments || {},
                                groups: ride.groups || [],
                                cancelled: ride.cancelled || false,
                                cancellation_reason: '',
                                deleted: ride.deleted || false,
                                rescheduled_from: null,
                                published_groups: ride.publishedGroups || false
                            };
                            // Call Supabase directly (same as scripts/database.js createRide function)
                            const { data: createdData, error } = await client
                                .from('rides')
                                .insert([dbData])
                                .select()
                                .single();
                            if (error) throw error;
                            // Map back to app structure (same as scripts/database.js createRide does)
                            const created = {
                                id: createdData.id,
                                date: createdData.date,
                                time: createdData.time || '',
                                endTime: createdData.end_time || createdData.endTime || '',
                                description: createdData.description || '',
                                meetLocation: createdData.meet_location || createdData.meetLocation || '',
                                locationLat: createdData.location_lat != null ? createdData.location_lat : (createdData.locationLat != null ? createdData.locationLat : null),
                                locationLng: createdData.location_lng != null ? createdData.location_lng : (createdData.locationLng != null ? createdData.locationLng : null),
                                goals: createdData.goals || '',
                                availableCoaches: createdData.available_coaches || [],
                                availableRiders: createdData.available_riders || [],
                                assignments: createdData.assignments || {},
                                groups: createdData.groups || [],
                                cancelled: createdData.cancelled || false,
                                cancellationReason: createdData.cancellation_reason || createdData.cancellationReason || '',
                                deleted: createdData.deleted || false,
                                rescheduledFrom: createdData.rescheduled_from || createdData.rescheduledFrom || null,
                                publishedGroups: createdData.published_groups || false,
                                isPersisted: true
                            };
                            console.log('🔵 ensureRidesFromSchedule: Created ride in Supabase, id:', created.id, 'date:', created.date);
                            // Use the Supabase ID and merge with local data
                            const newRide = { ...ride, ...created };
                            data.rides.push(newRide);
                            // Also save to localStorage as backup
                            try {
                                const dataToSave = {
                                    riders: data.riders,
                                    coaches: data.coaches,
                                    rides: data.rides,
                                    routes: data.routes,
                                    currentRide: data.currentRide,
                                    seasonSettings: data.seasonSettings,
                                    autoAssignSettings: data.autoAssignSettings,
                                    sampleVersion: data.sampleVersion,
                                    coachRoles: data.coachRoles || [],
                                    riderRoles: data.riderRoles || []
                                };
                                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                            } catch (lsError) {
                                console.error('Error saving to localStorage:', lsError);
                            }
                        } catch (error) {
                            console.error('🔵 ensureRidesFromSchedule: Error creating ride in Supabase:', error);
                            // If create fails, add to local array as fallback
                            data.rides.push(ride);
                        }
                    } else {
                        // Not authenticated - add to local array
                        data.rides.push(ride);
                    }
                }
                
                cursor.setDate(cursor.getDate() + 1);
            }
            
            if (ridesCreated) {
                saveData(); // Also save to localStorage as backup
            }
        }
        
        function renderRides() {
            // Reload data to ensure we have the latest practice dates from team dashboard
            // This ensures practice dates are refreshed every time Practice Planner is opened
            const currentRideId = data.currentRide; // Preserve current selection
            loadData();
            if (currentRideId) {
                data.currentRide = currentRideId; // Restore current selection
            }
            
            // Clean up any rides that don't match the calendar before rendering calendar/current ride
            cleanInvalidRides();
            
            // Create rides for any scheduled practice dates that don't have rides yet
            ensureRidesFromSchedule();

            // Calendar is now rendered in settings tab, not here - refresh it to show latest dates
            renderSeasonCalendarForSettings();
            updateHeaderEditSeasonButton();
            
            // Get valid practice dates from the calendar (reads from refreshed data.seasonSettings)
            const validDates = getValidPracticeDates();
            
            // Find the next chronological practice based on current date
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time to start of day for comparison
            
            // Filter rides: exclude deleted, include cancelled (but not for auto-selection), include rescheduled on new date
            // First, get all valid rides (not deleted, today or future)
            const allValidRides = (data.rides || [])
                .filter(ride => {
                    if (!ride.date) return false;
                    // Exclude deleted practices
                    if (ride.deleted) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    
                    // Must be today or future
                    if (rideDate < today) return false;
                    
                    return true;
                });
            
            // Separate cancelled and non-cancelled rides
            const cancelledRides = allValidRides.filter(ride => ride.cancelled);
            const nonCancelledRides = allValidRides.filter(ride => !ride.cancelled);
            
            // For auto-selection, use only non-cancelled rides that match calendar (or rescheduled)
            const upcomingRides = nonCancelledRides
                .filter(ride => {
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    const dateKey = formatDateToISO(rideDate);
                    
                    // Include if it matches calendar OR if it's rescheduled (rescheduled practices are exceptions)
                    if (ride.rescheduledFrom) {
                        return true; // Always include rescheduled practices
                    }
                    
                    // For regular practices, must match a valid calendar date
                    if (validDates.size > 0 && !validDates.has(dateKey)) return false;
                    
                    return true;
                })
                .sort((a, b) => {
                    const dateA = parseISODate(a.date);
                    const dateB = parseISODate(b.date);
                    if (!dateA || !dateB) return 0;
                    return dateA - dateB;
                });
            
            // Set the next practice as current, or keep existing if it's still valid (today or future)
            if (upcomingRides.length > 0) {
                const nextRide = upcomingRides[0];
                const currentRide = data.currentRide ? data.rides.find(r => r.id === data.currentRide) : null;
                let shouldUpdate = false;
                
                if (!data.currentRide) {
                    // No current ride selected, use the next one
                    shouldUpdate = true;
                } else if (!currentRide) {
                    // Current ride ID doesn't exist anymore, use the next one
                    shouldUpdate = true;
                } else {
                    // If current ride is cancelled, keep it (user may want to reinstate it)
                    if (currentRide.cancelled) {
                        shouldUpdate = false;
                    } else {
                        const currentRideDate = parseISODate(currentRide.date);
                        if (currentRideDate) {
                            currentRideDate.setHours(0, 0, 0, 0);
                            const currentDateKey = formatDateToISO(currentRideDate);
                            
                            // Update if current ride is in the past
                            if (currentRideDate < today) {
                                shouldUpdate = true;
                            }
                            // Update if current ride doesn't match a valid calendar date (when calendar has valid dates)
                            else if (validDates.size > 0 && !validDates.has(currentDateKey)) {
                                shouldUpdate = true;
                            }
                            // If current ride is today or future and matches calendar, keep it (preserves manual selection)
                        } else {
                            // Invalid date, use the next one
                            shouldUpdate = true;
                        }
                    }
                }
                
                if (shouldUpdate) {
                    data.currentRide = nextRide.id;
                    saveData();
                }
            } else {
                // No upcoming non-cancelled practices for auto-selection
                // Check if we should show a cancelled practice
                const currentRide = data.currentRide ? data.rides.find(r => r.id === data.currentRide) : null;
                if (currentRide && currentRide.cancelled && !currentRide.deleted) {
                    // Keep cancelled practice visible so user can reinstate it
                    const currentRideDate = parseISODate(currentRide.date);
                    if (currentRideDate) {
                        currentRideDate.setHours(0, 0, 0, 0);
                        if (currentRideDate < today) {
                            // Cancelled practice is in the past, clear it
                            data.currentRide = null;
                            saveData();
                            const currentRideElement = document.getElementById('current-ride');
                            if (currentRideElement) {
                                currentRideElement.style.display = 'none';
                            }
                        }
                        // Otherwise keep it visible (today or future)
                    }
                } else if (!currentRide || (currentRide && currentRide.deleted)) {
                    // Hide the current ride section if it's deleted or doesn't exist
                    data.currentRide = null;
                    const currentRideElement = document.getElementById('current-ride');
                    if (currentRideElement) {
                        currentRideElement.style.display = 'none';
                    }
                }
            }
            
            if (data.currentRide) {
                const currentRide = data.rides.find(r => r.id === data.currentRide);
                // Only load if ride exists and is not deleted
                if (currentRide && !currentRide.deleted) {
                    loadCurrentRide();
                } else {
                    // Ride was deleted, clear selection
                    data.currentRide = null;
                    saveData();
                    const currentRideElement = document.getElementById('current-ride');
                    if (currentRideElement) {
                        currentRideElement.style.display = 'none';
                    }
                    const navSection = document.getElementById('practice-navigation');
                    if (navSection) navSection.style.display = 'none';
                }
            } else {
                // Hide navigation if no current ride
                const navSection = document.getElementById('practice-navigation');
                if (navSection) navSection.style.display = 'none';
            }
        }

        function updateHeaderEditSeasonButton() {
            // Season Setup button is now always visible in user menu - no need to show/hide
            // Function kept for backwards compatibility but does nothing
        }

        function loadRide(rideId) {
            data.currentRide = rideId;
            saveData();
            loadCurrentRide();
        }

        function loadSeasonSettings() {
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            
            // Populate date fields (main and setup modal)
            const startDateInput = document.getElementById('season-start-date');
            const endDateInput = document.getElementById('season-end-date');
            const startDateInputSetup = document.getElementById('season-start-date-setup');
            const endDateInputSetup = document.getElementById('season-end-date-setup');
            
            const startDateValue = settings.startDate || '';
            const endDateValue = settings.endDate || '';
            
            if (startDateInput) startDateInput.value = startDateValue;
            if (endDateInput) endDateInput.value = endDateValue;
            if (startDateInputSetup) startDateInputSetup.value = startDateValue;
            if (endDateInputSetup) endDateInputSetup.value = endDateValue;
            
            // Update the date range button display
            updateSeasonDateRangeButton();
            
            // Load scale settings - ensure we use saved values, not defaults
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            
            // Use saved value if it exists, otherwise use default
            const savedFitnessScale = settings.fitnessScale;
            const savedSkillsScale = settings.skillsScale;
            
            if (fitnessScaleInput) {
                // Only update if we have a saved value, otherwise keep the HTML default
                if (savedFitnessScale !== undefined && savedFitnessScale !== null) {
                    fitnessScaleInput.value = savedFitnessScale;
                }
                const displayValue = savedFitnessScale || fitnessScaleInput.value || 5;
                if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = displayValue;
            }
            if (skillsScaleInput) {
                // Only update if we have a saved value, otherwise keep the HTML default
                if (savedSkillsScale !== undefined && savedSkillsScale !== null) {
                    skillsScaleInput.value = savedSkillsScale;
                }
                const displayValue = savedSkillsScale || skillsScaleInput.value || 3;
                if (skillsScaleDisplay) skillsScaleDisplay.textContent = displayValue;
            }
            
            // Load practice rows
            seasonSettingsDraft = {
                startDate: settings.startDate || '',
                endDate: settings.endDate || '',
                practices: Array.isArray(settings.practices)
                    ? settings.practices.map(practice => ({
                        id: practice.id || generateId(),
                        dayOfWeek: practice.dayOfWeek,
                        specificDate: practice.specificDate || null,
                        time: practice.time || practice.startTime || '',
                        endTime: practice.endTime || '',
                        description: practice.description || '',
                        meetLocation: practice.meetLocation || '',
                        locationLat: practice.locationLat || null,
                        locationLng: practice.locationLng || null,
                        rosterFilter: practice.rosterFilter || null // Preserve rosterFilter when loading
                    }))
                    : []
            };
            
            renderPracticeRows();
            
            // Load and render roles
            renderCoachRoles();
            renderRiderRoles();
            updateRoleDropdowns();
            
            // Load Google Sheet URLs
            const riderSheetUrlInput = document.getElementById('rider-google-sheet-url');
            const coachSheetUrlInput = document.getElementById('coach-google-sheet-url');
            
            // Update Google auth status
            updateGoogleAuthStatus();
            
            if (riderSheetUrlInput && settings.riderGoogleSheetUrl) {
                riderSheetUrlInput.value = settings.riderGoogleSheetUrl;
            }
            if (coachSheetUrlInput && settings.coachGoogleSheetUrl) {
                coachSheetUrlInput.value = settings.coachGoogleSheetUrl;
            }
        }
        
        // Role management functions
        function renderCoachRoles() {
            const container = document.getElementById('coach-roles-container');
            if (!container) return;
            
            if (!data.coachRoles || data.coachRoles.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No coach roles assigned</div>';
                return;
            }
            
            let html = '';
            data.coachRoles.forEach((role, index) => {
                const coach = data.coaches.find(c => c.id === role.coachId);
                const coachName = coach ? coach.name : `Coach ID: ${role.coachId}`;
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
                        <span style="flex: 1; font-weight: 600;">${escapeHtml(role.roleName)}</span>
                        <span style="flex: 1;">${escapeHtml(coachName)}</span>
                        <button class="btn-small danger" onclick="removeCoachRole(${index})">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function renderRiderRoles() {
            const container = document.getElementById('rider-roles-container');
            if (!container) return;
            
            if (!data.riderRoles || data.riderRoles.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No rider roles assigned</div>';
                return;
            }
            
            let html = '';
            data.riderRoles.forEach((role, index) => {
                const rider = data.riders.find(r => r.id === role.riderId);
                const riderName = rider ? rider.name : `Rider ID: ${role.riderId}`;
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
                        <span style="flex: 1; font-weight: 600;">${escapeHtml(role.roleName)}</span>
                        <span style="flex: 1;">${escapeHtml(riderName)}</span>
                        <button class="btn-small danger" onclick="removeRiderRole(${index})">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateRoleDropdowns() {
            // Update coach dropdown
            const coachSelect = document.getElementById('new-coach-role-coach');
            if (coachSelect) {
                coachSelect.innerHTML = '<option value="">Select Coach</option>';
                data.coaches.forEach(coach => {
                    const option = document.createElement('option');
                    option.value = coach.id;
                    option.textContent = coach.name || 'Unnamed Coach';
                    coachSelect.appendChild(option);
                });
            }
            
            // Update rider dropdown
            const riderSelect = document.getElementById('new-rider-role-rider');
            if (riderSelect) {
                riderSelect.innerHTML = '<option value="">Select Rider</option>';
                data.riders.forEach(rider => {
                    const option = document.createElement('option');
                    option.value = rider.id;
                    option.textContent = rider.name || 'Unnamed Rider';
                    riderSelect.appendChild(option);
                });
            }
        }
        
        // ============ USERS MANAGEMENT ============
        
        function formatAdminInvitationError(error) {
            if (!error) return 'Failed to send invitation.';
            const message = String(error.message || '');
            const status = error.status || error?.response?.status;
            if (status === 404 || message.includes('404')) {
                return 'Admin invitations table not found. Please run sql/ADD_ADMIN_INVITATIONS_TABLE.sql in Supabase.';
            }
            if (status === 401 || status === 403) {
                return 'Permission denied. Please ensure you are signed in as a coach-admin.';
            }
            return message || 'Failed to send invitation.';
        }

        async function sendAdminInvitation() {
            const emailInput = document.getElementById('admin-invite-email');
            const statusDiv = document.getElementById('admin-invite-status');
            
            if (!emailInput || !statusDiv) return;
            
            const email = emailInput.value.trim();
            if (!email) {
                statusDiv.textContent = 'Please enter an email address.';
                statusDiv.style.display = 'block';
                statusDiv.style.color = '#d32f2f';
                return;
            }
            
            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                statusDiv.textContent = 'Please enter a valid email address.';
                statusDiv.style.display = 'block';
                statusDiv.style.color = '#d32f2f';
                return;
            }
            
            statusDiv.textContent = 'Sending invitation...';
            statusDiv.style.display = 'block';
            statusDiv.style.color = '#666';
            
            try {
                if (typeof getAdminInvitationsByEmail === 'function') {
                    const existingInvites = await getAdminInvitationsByEmail(email);
                    if (existingInvites && existingInvites.length > 0) {
                        const latest = existingInvites[0];
                        const isExpired = new Date(latest.expires_at) < new Date();
                        if (latest.used) {
                            statusDiv.textContent = 'This email is already registered. Ask them to sign in or use password reset.';
                            statusDiv.style.color = '#d32f2f';
                            return;
                        }
                        if (!isExpired) {
                            statusDiv.textContent = 'An active invitation already exists for this email. Please use the existing invite link.';
                            statusDiv.style.color = '#d32f2f';
                            return;
                        }
                    }
                }

                const invitation = await createAdminInvitation(email);
                
                // Generate invitation URL
                const invitationUrl = `${window.location.origin}${window.location.pathname.replace(/[^/]*$/, '')}accept-invitation.html?token=${invitation.token}`;
                
                // For now, we'll show the link. In production, you'd send this via email
                // You'll need to set up an email service (like SendGrid, AWS SES, or Supabase Edge Function)
                statusDiv.innerHTML = `
                    <div style="padding: 12px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px; margin-top: 8px;">
                        <strong style="color: #2e7d32;">Invitation created successfully!</strong><br>
                        <span style="font-size: 12px; color: #666; margin-top: 4px; display: block;">Invitation link (send this to ${email}):</span>
                        <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; word-break: break-all; font-family: monospace;">
                            ${invitationUrl}
                        </div>
                        <p style="font-size: 11px; color: #666; margin-top: 8px; margin-bottom: 0;">
                            <strong>Note:</strong> To automatically send emails, you'll need to set up an email service. 
                            For now, copy the link above and send it manually to the user.
                        </p>
                    </div>
                `;
                statusDiv.style.color = '#2e7d32';
                
                emailInput.value = '';
                
                // Refresh invitations list
                await loadAdminInvitations();
                
            } catch (error) {
                console.error('Error sending invitation:', error);
                statusDiv.textContent = `Error: ${formatAdminInvitationError(error)}`;
                statusDiv.style.color = '#d32f2f';
            }
        }

        async function resendAdminInvitation(email) {
            const statusDiv = document.getElementById('admin-invite-status');
            if (!statusDiv) return;

            statusDiv.textContent = 'Resending invitation...';
            statusDiv.style.display = 'block';
            statusDiv.style.color = '#666';

            try {
                if (typeof expireAdminInvitationsByEmail === 'function') {
                    await expireAdminInvitationsByEmail(email);
                }

                const invitation = await createAdminInvitation(email);
                const invitationUrl = `${window.location.origin}${window.location.pathname.replace(/[^/]*$/, '')}accept-invitation.html?token=${invitation.token}`;

                statusDiv.innerHTML = `
                    <div style="padding: 12px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px; margin-top: 8px;">
                        <strong style="color: #2e7d32;">Invitation resent successfully!</strong><br>
                        <span style="font-size: 12px; color: #666; margin-top: 4px; display: block;">New invitation link (send this to ${email}):</span>
                        <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; word-break: break-all; font-family: monospace;">
                            ${invitationUrl}
                        </div>
                    </div>
                `;
                statusDiv.style.color = '#2e7d32';

                await loadAdminInvitations();
            } catch (error) {
                console.error('Error resending invitation:', error);
                statusDiv.textContent = `Error: ${formatAdminInvitationError(error)}`;
                statusDiv.style.color = '#d32f2f';
            }
        }
        
        async function loadAdminInvitations() {
            const container = document.getElementById('admin-invitations-content');
            if (!container) return;
            
            container.innerHTML = '<p style="color: #666; margin: 0;">Loading invitations...</p>';
            
            try {
                const invitations = await getAllAdminInvitations();
                
                if (!invitations || invitations.length === 0) {
                    container.innerHTML = '<p style="color: #666; margin: 0;">No invitations found.</p>';
                    return;
                }

                const visibleInvites = invitations.filter(inv => !inv.used);
                if (visibleInvites.length === 0) {
                    container.innerHTML = '<p style="color: #666; margin: 0;">No active invitations. (Used invitations are hidden)</p>';
                    return;
                }

                let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
                html += '<thead><tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">';
                html += '<th style="padding: 8px; text-align: left;">Email</th>';
                html += '<th style="padding: 8px; text-align: left;">Status</th>';
                html += '<th style="padding: 8px; text-align: left;">Expires</th>';
                html += '<th style="padding: 8px; text-align: left;">Created</th>';
                html += '<th style="padding: 8px; text-align: left;">Actions</th>';
                html += '</tr></thead><tbody>';

                visibleInvites.forEach(inv => {
                    const isExpired = new Date(inv.expires_at) < new Date();
                    const status = inv.used ? 'Used' : (isExpired ? 'Expired' : 'Pending');
                    const statusColor = inv.used ? '#4caf50' : (isExpired ? '#f44336' : '#ff9800');
                    
                    html += '<tr style="border-bottom: 1px solid #eee;">';
                    html += `<td style="padding: 8px;">${escapeHtml(inv.email)}</td>`;
                    html += `<td style="padding: 8px; color: ${statusColor}; font-weight: 600;">${status}</td>`;
                    html += `<td style="padding: 8px;">${new Date(inv.expires_at).toLocaleDateString()}</td>`;
                    html += `<td style="padding: 8px;">${new Date(inv.created_at).toLocaleDateString()}</td>`;
                    html += `<td style="padding: 8px;">${!inv.used ? `<button class="btn-small secondary" onclick="resendAdminInvitation('${escapeHtml(inv.email)}')">Resend</button>` : ''}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading invitations:', error);
                container.innerHTML = `<p style="color: #d32f2f; margin: 0;">Error loading invitations: ${escapeHtml(formatAdminInvitationError(error))}</p>`;
            }
        }
        
        async function loadUsersList() {
            const container = document.getElementById('users-list');
            if (!container) return;
            
            container.innerHTML = '<p style="color: #666; margin: 0;">Loading users...</p>';
            
            try {
                if (typeof getAllUsersWithLoginInfo !== 'function') {
                    container.innerHTML = '<p style="color: #d32f2f; margin: 0;">Error: Database functions not available. Please ensure you are authenticated.</p>';
                    return;
                }
                
                const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
                const users = await getAllUsersWithLoginInfo();
                
                if (!users || users.length === 0) {
                    container.innerHTML = '<p style="color: #666; margin: 0;">No registered users found.</p>';
                    return;
                }
                
                let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
                html += '<thead><tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">';
                html += '<th style="padding: 8px; text-align: left;">Name</th>';
                html += '<th style="padding: 8px; text-align: left;">Email</th>';
                html += '<th style="padding: 8px; text-align: left;">Phone</th>';
                html += '<th style="padding: 8px; text-align: left;">Role</th>';
                html += '<th style="padding: 8px; text-align: left;">Registered</th>';
                html += '<th style="padding: 8px; text-align: left;">Actions</th>';
                html += '</tr></thead><tbody>';
                
                users.forEach(user => {
                    const isDisabled = user.isDisabled === true;
                    const rowStyle = isDisabled ? 'opacity: 0.6; font-style: italic;' : '';
                    const linkIcon = user.matchedType ? '<span title="Linked to roster record" style="margin-left: 6px;">🔗</span>' : '';
                    html += `<tr style="border-bottom: 1px solid #eee; ${rowStyle}">`;
                    html += `<td style="padding: 8px;">${escapeHtml(user.name || 'N/A')}${linkIcon}</td>`;
                    html += `<td style="padding: 8px;">${escapeHtml(user.email || 'N/A')}</td>`;
                    html += `<td style="padding: 8px;">${escapeHtml(user.phone || 'N/A')}</td>`;
                    html += `<td style="padding: 8px;">${escapeHtml(user.role || 'N/A')}</td>`;
                    const regDate = user.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A';
                    html += `<td style="padding: 8px;">${regDate}</td>`;
                    const isCurrentUser = currentUser && user.id === currentUser.id;
                    const actionButton = user.role === 'coach-admin'
                        ? (isDisabled
                            ? `<button class="btn-small secondary" onclick="enableAdmin('${user.id}')">Enable Admin</button>`
                            : (isCurrentUser ? '' : `<button class="btn-small danger" onclick="disableAdmin('${user.id}', '${escapeHtml(user.email || '')}')">Disable Admin</button>`))
                        : '';
                    html += `<td style="padding: 8px;">${actionButton}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading users:', error);
                container.innerHTML = `<p style="color: #d32f2f; margin: 0;">Error loading users: ${escapeHtml(error.message || 'Unknown error')}</p>`;
            }
        }

        async function disableAdmin(userId, email) {
            if (!userId) return;
            if (!confirm('Disable admin access for this user? They will no longer be able to access the site.')) return;

            try {
                if (typeof disableAdminUser !== 'function') {
                    throw new Error('Admin disable function not available.');
                }
                await disableAdminUser(userId, email || null);
                await loadUsersList();
            } catch (error) {
                console.error('Error disabling admin:', error);
                alert(error.message || 'Failed to disable admin.');
            }
        }

        async function enableAdmin(userId) {
            if (!userId) return;
            try {
                if (typeof enableAdminUser !== 'function') {
                    throw new Error('Admin enable function not available.');
                }
                await enableAdminUser(userId);
                await loadUsersList();
            } catch (error) {
                console.error('Error enabling admin:', error);
                alert(error.message || 'Failed to enable admin.');
            }
        }
        
        // ============ BACKUP MANAGEMENT ============
        
        // Create a complete backup of all data
        function getAllDataForBackup() {
            return {
                riders: data.riders || [],
                coaches: data.coaches || [],
                rides: data.rides || [],
                routes: data.routes || [],
                races: data.races || [],
                seasonSettings: data.seasonSettings || {},
                autoAssignSettings: data.autoAssignSettings || {},
                coachRoles: data.coachRoles || [],
                riderRoles: data.riderRoles || [],
                timeEstimationSettings: data.timeEstimationSettings || {},
                backupTimestamp: new Date().toISOString(),
                backupVersion: '1.0'
            };
        }
        
        // Create automatic backup (on login/logout)
        async function createAutomaticBackup(backupType) {
            try {
                if (typeof createBackup !== 'function') {
                    console.warn('createBackup function not available');
                    return;
                }
                
                const backupData = getAllDataForBackup();
                const backupName = `Auto Backup - ${backupType === 'auto_login' ? 'Login' : 'Logout'} - ${new Date().toLocaleString()}`;
                
                await createBackup(backupName, backupData, backupType);
                console.log(`✅ Automatic backup created: ${backupName}`);
            } catch (error) {
                console.error('Error creating automatic backup:', error);
                throw error;
            }
        }
        
        // Create manual backup
        async function createManualBackup() {
            try {
                if (typeof createBackup !== 'function') {
                    alert('Backup function not available. Please ensure you are authenticated.');
                    return;
                }
                
                const backupName = prompt('Enter a name for this backup:', `Manual Backup - ${new Date().toLocaleString()}`);
                if (!backupName) {
                    return; // User cancelled
                }
                
                const backupData = getAllDataForBackup();
                
                await createBackup(backupName, backupData, 'manual');
                alert('Backup created successfully!');
                
                // Refresh backups list
                await loadBackupsList();
            } catch (error) {
                console.error('Error creating backup:', error);
                alert('Error creating backup: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Load and display backups list
        async function loadBackupsList() {
            const container = document.getElementById('backups-list');
            if (!container) return;
            
            container.innerHTML = '<p style="color: #666; margin: 0;">Loading backups...</p>';
            
            try {
                if (typeof getAllBackups !== 'function') {
                    container.innerHTML = '<p style="color: #d32f2f; margin: 0;">Error: Database functions not available. Please ensure you are authenticated.</p>';
                    return;
                }
                
                const backups = await getAllBackups();
                
                if (!backups || backups.length === 0) {
                    container.innerHTML = '<p style="color: #666; margin: 0;">No backups found.</p>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
                
                backups.forEach(backup => {
                    const backupDate = new Date(backup.created_at).toLocaleString();
                    const backupTypeLabel = backup.backup_type === 'manual' ? 'Manual' : 
                                          backup.backup_type === 'auto_login' ? 'Auto (Login)' : 
                                          backup.backup_type === 'auto_logout' ? 'Auto (Logout)' : 'Unknown';
                    
                    html += `<div style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; background: white;">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">`;
                    html += `<div style="flex: 1;">`;
                    html += `<strong style="display: block; margin-bottom: 4px;">${escapeHtml(backup.backup_name || 'Unnamed Backup')}</strong>`;
                    html += `<span style="color: #666; font-size: 12px;">${backupDate} • ${backupTypeLabel}</span>`;
                    html += `</div>`;
                    html += `<div style="display: flex; gap: 8px;">`;
                    html += `<button class="btn-small" onclick="restoreFromBackup(${backup.id})" style="padding: 4px 12px; font-size: 12px;">Restore</button>`;
                    html += `<button class="btn-small danger" onclick="deleteBackupById(${backup.id})" style="padding: 4px 12px; font-size: 12px;">Delete</button>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `</div>`;
                });
                
                html += '</div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading backups:', error);
                container.innerHTML = `<p style="color: #d32f2f; margin: 0;">Error loading backups: ${escapeHtml(error.message || 'Unknown error')}</p>`;
            }
        }
        
        // Restore from backup
        async function restoreFromBackup(backupId) {
            if (!confirm('⚠️ WARNING: This will replace ALL current data with the backup data. This action cannot be undone. Continue?')) {
                return;
            }
            
            if (!confirm('Are you absolutely sure? All current data will be lost.')) {
                return;
            }
            
            try {
                if (typeof getBackupById !== 'function') {
                    alert('Backup function not available. Please ensure you are authenticated.');
                    return;
                }
                
                const backup = await getBackupById(backupId);
                if (!backup || !backup.backup_data) {
                    alert('Backup not found or invalid.');
                    return;
                }
                
                const backupData = backup.backup_data;
                
                // Restore all data
                data.riders = backupData.riders || [];
                data.coaches = backupData.coaches || [];
                data.rides = backupData.rides || [];
                data.routes = backupData.routes || [];
                data.races = backupData.races || [];
                data.seasonSettings = backupData.seasonSettings || {};
                data.autoAssignSettings = backupData.autoAssignSettings || {};
                data.coachRoles = backupData.coachRoles || [];
                data.riderRoles = backupData.riderRoles || [];
                data.timeEstimationSettings = backupData.timeEstimationSettings || {};
                
                // Save to localStorage immediately
                saveData();
                
                // Save to Supabase (this will update all tables)
                await saveAllDataToSupabase();
                
                alert('✅ Backup restored successfully! The page will now reload.');
                
                // Reload page to reflect changes
                window.location.reload();
            } catch (error) {
                console.error('Error restoring backup:', error);
                alert('Error restoring backup: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Delete backup
        async function deleteBackupById(backupId) {
            if (!confirm('Are you sure you want to delete this backup? This action cannot be undone.')) {
                return;
            }
            
            try {
                if (typeof deleteBackup !== 'function') {
                    alert('Backup function not available. Please ensure you are authenticated.');
                    return;
                }
                
                await deleteBackup(backupId);
                alert('Backup deleted successfully.');
                
                // Refresh backups list
                await loadBackupsList();
            } catch (error) {
                console.error('Error deleting backup:', error);
                alert('Error deleting backup: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Save all data to Supabase (used during restore)
        async function saveAllDataToSupabase() {
            // This function would need to call individual save functions for each data type
            // For now, we'll rely on the existing save mechanisms
            // In a full implementation, you'd want to:
            // 1. Save all riders
            // 2. Save all coaches
            // 3. Save all rides
            // 4. Save all routes
            // 5. Save season settings
            // 6. Save auto-assign settings
            // etc.
            
            console.log('Saving all data to Supabase after restore...');
            // The existing save mechanisms will handle this on next interaction
            // For immediate save, we'd need to implement batch save functions
        }
        
        // ============ TAB STATE PERSISTENCE ============
        
        // Restore last active tab on page load
        function restoreLastActiveTab() {
            try {
                const lastTab = localStorage.getItem('lastActiveTab');
                if (lastTab) {
                    // Find the tab button
                    const tabs = document.querySelectorAll('#desktop-tabs .tab');
                    let targetTab = null;
                    tabs.forEach(tab => {
                        if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(`'${lastTab}'`)) {
                            targetTab = tab;
                        }
                    });
                    
                    if (targetTab) {
                        // Switch to the last active tab
                        switchTab(lastTab, targetTab);
                    }
                }
            } catch (e) {
                console.warn('Could not restore tab state:', e);
            }
        }
        
        function addCoachRole() {
            const roleNameInput = document.getElementById('new-coach-role-name');
            const coachSelect = document.getElementById('new-coach-role-coach');
            
            if (!roleNameInput || !coachSelect) return;
            
            const roleName = roleNameInput.value.trim();
            const coachId = parseInt(coachSelect.value, 10);
            
            if (!roleName) {
                alert('Please enter a role name');
                return;
            }
            
            if (!coachId) {
                alert('Please select a coach');
                return;
            }
            
            // Check if coach already has a role
            const existingRole = data.coachRoles.find(r => r.coachId === coachId);
            if (existingRole) {
                if (!confirm(`Coach already has role "${existingRole.roleName}". Replace it?`)) {
                    return;
                }
                // Remove existing role
                data.coachRoles = data.coachRoles.filter(r => r.coachId !== coachId);
            }
            
            // Add new role
            data.coachRoles.push({ roleName, coachId });
            saveData();
            
            // Clear inputs
            roleNameInput.value = '';
            coachSelect.value = '';
            
            // Refresh display
            renderCoachRoles();
            renderCoaches();
        }
        
        function addRiderRole() {
            const roleNameInput = document.getElementById('new-rider-role-name');
            const riderSelect = document.getElementById('new-rider-role-rider');
            
            if (!roleNameInput || !riderSelect) return;
            
            const roleName = roleNameInput.value.trim();
            const riderId = parseInt(riderSelect.value, 10);
            
            if (!roleName) {
                alert('Please enter a role name');
                return;
            }
            
            if (!riderId) {
                alert('Please select a rider');
                return;
            }
            
            // Check if rider already has a role
            const existingRole = data.riderRoles.find(r => r.riderId === riderId);
            if (existingRole) {
                if (!confirm(`Rider already has role "${existingRole.roleName}". Replace it?`)) {
                    return;
                }
                // Remove existing role
                data.riderRoles = data.riderRoles.filter(r => r.riderId !== riderId);
            }
            
            // Add new role
            data.riderRoles.push({ roleName, riderId });
            saveData();
            
            // Clear inputs
            roleNameInput.value = '';
            riderSelect.value = '';
            
            // Refresh display
            renderRiderRoles();
            renderRiders();
        }
        
        function removeCoachRole(index) {
            if (confirm('Remove this coach role?')) {
                data.coachRoles.splice(index, 1);
                saveData();
                renderCoachRoles();
                renderCoaches();
            }
        }
        
        function removeRiderRole(index) {
            if (confirm('Remove this rider role?')) {
                data.riderRoles.splice(index, 1);
                saveData();
                renderRiderRoles();
                renderRiders();
            }
        }
        
        // Helper to get role for a coach/rider
        function getCoachRole(coachId) {
            if (!data.coachRoles) return null;
            const role = data.coachRoles.find(r => r.coachId === coachId);
            return role ? role.roleName : null;
        }
        
        function getRiderRole(riderId) {
            if (!data.riderRoles) return null;
            const role = data.riderRoles.find(r => r.riderId === riderId);
            return role ? role.roleName : null;
        }

        function toggleRosterView(view) {
            const ridersView = document.getElementById('roster-riders-view');
            const coachesView = document.getElementById('roster-coaches-view');
            const ridersBtn = document.getElementById('roster-toggle-riders');
            const coachesBtn = document.getElementById('roster-toggle-coaches');
            const riderGroupBy = document.getElementById('rider-group-by');
            const coachGroupBy = document.getElementById('coach-group-by');
            const groupByLabel = document.getElementById('roster-group-by-label');
            
            if (view === 'riders') {
                if (ridersView) ridersView.style.display = 'block';
                if (coachesView) coachesView.style.display = 'none';
                if (ridersBtn) {
                    ridersBtn.classList.remove('secondary');
                    ridersBtn.classList.add('active');
                }
                if (coachesBtn) {
                    coachesBtn.classList.remove('active');
                    coachesBtn.classList.add('secondary');
                }
                if (riderGroupBy) riderGroupBy.style.display = 'block';
                if (coachGroupBy) coachGroupBy.style.display = 'none';
                if (groupByLabel) groupByLabel.setAttribute('for', 'rider-group-by');
                renderRiders();
            } else {
                if (ridersView) ridersView.style.display = 'none';
                if (coachesView) coachesView.style.display = 'block';
                if (ridersBtn) {
                    ridersBtn.classList.remove('active');
                    ridersBtn.classList.add('secondary');
                }
                if (coachesBtn) {
                    coachesBtn.classList.remove('secondary');
                    coachesBtn.classList.add('active');
                }
                if (riderGroupBy) riderGroupBy.style.display = 'none';
                if (coachGroupBy) coachGroupBy.style.display = 'block';
                if (groupByLabel) groupByLabel.setAttribute('for', 'coach-group-by');
                renderCoaches();
            }
            try {
                localStorage.setItem('rosterView', view);
            } catch (e) {
                console.warn('Could not save roster view preference:', e);
            }
        }

        function applyRosterPreferences() {
            let savedView = 'riders';
            let savedRiderGroupBy = '';
            let savedCoachGroupBy = '';
            try {
                savedView = localStorage.getItem('rosterView') || 'riders';
                savedRiderGroupBy = localStorage.getItem('rosterRiderGroupBy') || '';
                savedCoachGroupBy = localStorage.getItem('rosterCoachGroupBy') || '';
            } catch (e) {
                console.warn('Could not load roster preferences:', e);
            }
            const riderGroupBySelect = document.getElementById('rider-group-by');
            if (riderGroupBySelect && savedRiderGroupBy) {
                riderGroupBySelect.value = savedRiderGroupBy;
            }
            const coachGroupBySelect = document.getElementById('coach-group-by');
            if (coachGroupBySelect && savedCoachGroupBy) {
                coachGroupBySelect.value = savedCoachGroupBy;
            }
            riderGroupBy = savedRiderGroupBy || '';
            coachGroupBy = savedCoachGroupBy || '';
            toggleRosterView(savedView);
        }

        function openSeasonSetupModal() {
            // Switch to settings tab instead of opening modal
            switchTab('settings', document.querySelector('.tab[onclick*="settings"]'));
        }

        function closeSeasonSetupModal() {
            const modal = document.getElementById('season-setup-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            seasonSettingsDraft = null;
        }

        function openPracticesModal() {
            const modal = document.getElementById('practices-modal');
            if (!modal) return;
            
            ensureSeasonDraft();
            renderPracticeRows('practice-rows-modal');
            
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closePracticesModal() {
            const modal = document.getElementById('practices-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            
            // Re-render the dashboard practice rows to show updated list
            renderPracticeRows('practice-rows');
        }

        function addPracticeRowInModal() {
            addPracticeRow();
            renderPracticeRows('practice-rows-modal');
        }

        function openAddSinglePracticeModalInModal() {
            addSinglePracticeRow();
            renderPracticeRows('practice-rows-modal');
        }

        // Time Range Picker Modal
        let currentPracticeIdForTimeRange = null;

        function openTimeRangePickerModal(practiceId) {
            currentPracticeIdForTimeRange = practiceId;
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;

            const modal = document.getElementById('time-range-picker-modal');
            if (!modal) return;

            const startInput = document.getElementById('time-range-start');
            const endInput = document.getElementById('time-range-end');
            const preview = document.getElementById('time-range-preview');

            if (startInput) startInput.value = practice.time || '';
            if (endInput) endInput.value = practice.endTime || '';
            
            updateTimeRangePreview();

            // Add event listeners for live preview
            if (startInput) {
                startInput.oninput = updateTimeRangePreview;
            }
            if (endInput) {
                endInput.oninput = updateTimeRangePreview;
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeTimeRangePickerModal() {
            const modal = document.getElementById('time-range-picker-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentPracticeIdForTimeRange = null;
        }

        function updateTimeRangePreview() {
            const startInput = document.getElementById('time-range-start');
            const endInput = document.getElementById('time-range-end');
            const preview = document.getElementById('time-range-preview');

            if (!preview) return;

            const startTime = startInput ? startInput.value : '';
            const endTime = endInput ? endInput.value : '';

            if (startTime && endTime) {
                const startFormatted = formatTimeForDisplay(startTime);
                const endFormatted = formatTimeForDisplay(endTime);
                preview.textContent = `${startFormatted} – ${endFormatted}`;
            } else if (startTime) {
                preview.textContent = `${formatTimeForDisplay(startTime)} – (no end time)`;
            } else if (endTime) {
                preview.textContent = `(no start time) – ${formatTimeForDisplay(endTime)}`;
            } else {
                preview.textContent = '—';
            }
        }

        function saveTimeRange() {
            if (!currentPracticeIdForTimeRange) return;

            const startInput = document.getElementById('time-range-start');
            const endInput = document.getElementById('time-range-end');

            const startTime = startInput ? startInput.value : '';
            const endTime = endInput ? endInput.value : '';

            if (startTime) {
                updatePracticeDraft(currentPracticeIdForTimeRange, 'time', startTime);
            }
            if (endTime) {
                updatePracticeDraft(currentPracticeIdForTimeRange, 'endTime', endTime);
            }

            closeTimeRangePickerModal();
        }

        // Season Date Range Picker
        let seasonDateRangePickerState = {
            currentMonth: new Date(),
            startDate: null,
            endDate: null,
            selectingStart: true
        };

        function openSeasonDateRangePickerModal() {
            const modal = document.getElementById('season-date-range-picker-modal');
            if (!modal) return;

            // Load current season dates
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = settings.startDate ? parseISODate(settings.startDate) : null;
            const endDate = settings.endDate ? parseISODate(settings.endDate) : null;

            seasonDateRangePickerState = {
                currentMonth: startDate ? new Date(startDate.getFullYear(), startDate.getMonth(), 1) : new Date(),
                startDate: startDate,
                endDate: endDate,
                selectingStart: !startDate
            };

            renderSeasonDateRangeCalendars();
            updateSeasonDateRangePreview();

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeSeasonDateRangePickerModal() {
            const modal = document.getElementById('season-date-range-picker-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            updateSeasonDateRangeButton();
        }

        function navigateSeasonDateRangeMonths(delta) {
            const newDate = new Date(seasonDateRangePickerState.currentMonth);
            newDate.setMonth(newDate.getMonth() + delta);
            seasonDateRangePickerState.currentMonth = newDate;
            renderSeasonDateRangeCalendars();
        }

        function renderSeasonDateRangeCalendars() {
            const container = document.getElementById('season-date-range-calendars');
            const monthsDisplay = document.getElementById('season-date-range-months-display');
            if (!container || !monthsDisplay) return;

            const month1 = new Date(seasonDateRangePickerState.currentMonth);
            const month2 = new Date(month1);
            month2.setMonth(month2.getMonth() + 1);

            const month1Name = month1.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            const month2Name = month2.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            monthsDisplay.textContent = `${month1Name} & ${month2Name}`;

            const calendar1 = renderSeasonDateRangeCalendar(month1, 0);
            const calendar2 = renderSeasonDateRangeCalendar(month2, 1);

            container.innerHTML = calendar1 + calendar2;
        }

        function renderSeasonDateRangeCalendar(month, index) {
            const year = month.getFullYear();
            const monthIndex = month.getMonth();

            const firstDay = new Date(year, monthIndex, 1);
            const lastDay = new Date(year, monthIndex + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            const monthName = month.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            const dayLabels = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];

            let html = `
                <div class="season-date-range-calendar" style="flex: 1;">
                    <div style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: #333;">${monthName}</div>
                    <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px;">
                        ${dayLabels.map(label => `
                            <div style="text-align: center; font-size: 11px; font-weight: 600; color: #666; padding: 8px 4px;">${label}</div>
                        `).join('')}
            `;

            // Add empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                html += `<div style="padding: 8px;"></div>`;
            }

            // Add day cells
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, monthIndex, day);
                const dateKey = formatDateToISO(date);
                const isSelected = isDateInRange(date, seasonDateRangePickerState.startDate, seasonDateRangePickerState.endDate);
                const isStart = seasonDateRangePickerState.startDate && formatDateToISO(seasonDateRangePickerState.startDate) === dateKey;
                const isEnd = seasonDateRangePickerState.endDate && formatDateToISO(seasonDateRangePickerState.endDate) === dateKey;
                const isToday = formatDateToISO(new Date()) === dateKey;

                let bgColor = 'transparent';
                let textColor = '#333';
                if (isStart || isEnd) {
                    bgColor = '#2196F3';
                    textColor = 'white';
                } else if (isSelected) {
                    bgColor = '#e3f2fd';
                    textColor = '#1976d2';
                } else if (isToday) {
                    bgColor = '#fff9c4';
                    textColor = '#333';
                }

                const hoverBg = isStart || isEnd ? bgColor : '#f5f5f5';
                html += `
                    <div onclick="selectSeasonDateRange('${dateKey}')" 
                         data-date-key="${dateKey}"
                         data-is-start="${isStart}"
                         data-is-end="${isEnd}"
                         data-bg-color="${bgColor}"
                         style="padding: 8px; text-align: center; cursor: pointer; border-radius: 4px; background: ${bgColor}; color: ${textColor}; ${(isStart || isEnd) ? 'font-weight: 600;' : ''} transition: background 0.2s;"
                         onmouseover="if (this.dataset.isStart !== 'true' && this.dataset.isEnd !== 'true') this.style.background='${hoverBg}';"
                         onmouseout="this.style.background=this.dataset.bgColor;">
                        ${day}
                    </div>
                `;
            }

            html += `</div></div>`;
            return html;
        }

        function isDateInRange(date, startDate, endDate) {
            if (!startDate || !endDate) return false;
            const dateKey = formatDateToISO(date);
            const startKey = formatDateToISO(startDate);
            const endKey = formatDateToISO(endDate);
            return dateKey >= startKey && dateKey <= endKey;
        }

        function selectSeasonDateRange(dateKey) {
            const date = parseISODate(dateKey);
            if (!date) return;

            if (!seasonDateRangePickerState.startDate || 
                (seasonDateRangePickerState.startDate && seasonDateRangePickerState.endDate)) {
                // Start new selection
                seasonDateRangePickerState.startDate = date;
                seasonDateRangePickerState.endDate = null;
                seasonDateRangePickerState.selectingStart = false;
            } else if (seasonDateRangePickerState.startDate && formatDateToISO(date) < formatDateToISO(seasonDateRangePickerState.startDate)) {
                // New start date is before current start, swap them
                seasonDateRangePickerState.endDate = seasonDateRangePickerState.startDate;
                seasonDateRangePickerState.startDate = date;
            } else {
                // Complete the range
                seasonDateRangePickerState.endDate = date;
                seasonDateRangePickerState.selectingStart = true;
            }

            renderSeasonDateRangeCalendars();
            updateSeasonDateRangePreview();
        }

        function updateSeasonDateRangePreview() {
            const preview = document.getElementById('season-date-range-preview');
            if (!preview) return;

            const previewText = preview.querySelector('div:last-child');
            if (!previewText) return;

            if (seasonDateRangePickerState.startDate && seasonDateRangePickerState.endDate) {
                const startStr = seasonDateRangePickerState.startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const endStr = seasonDateRangePickerState.endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                previewText.textContent = `${startStr} – ${endStr}`;
            } else if (seasonDateRangePickerState.startDate) {
                const startStr = seasonDateRangePickerState.startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                previewText.textContent = `${startStr} – (select end date)`;
            } else {
                previewText.textContent = '—';
            }
        }

        function clearSeasonDateRange() {
            seasonDateRangePickerState.startDate = null;
            seasonDateRangePickerState.endDate = null;
            seasonDateRangePickerState.selectingStart = true;
            renderSeasonDateRangeCalendars();
            updateSeasonDateRangePreview();
        }

        function syncSeasonDatesToMain() {
            // Sync dates from setup modal inputs to main inputs (they share the same IDs)
            const startSetup = document.getElementById('season-start-date-setup');
            const endSetup = document.getElementById('season-end-date-setup');
            const startMain = document.getElementById('season-start-date');
            const endMain = document.getElementById('season-end-date');
            
            if (startSetup && startMain) startMain.value = startSetup.value;
            if (endSetup && endMain) endMain.value = endSetup.value;
            
            updateSeasonDateRange();
            updateSeasonDateRangeButton();
        }

        function saveSeasonDateRange() {
            if (!seasonDateRangePickerState.startDate) {
                alert('Please select a start date.');
                return;
            }
            if (!seasonDateRangePickerState.endDate) {
                alert('Please select an end date.');
                return;
            }

            const startDateStr = formatDateToISO(seasonDateRangePickerState.startDate);
            const endDateStr = formatDateToISO(seasonDateRangePickerState.endDate);

            // Update all date inputs (main and setup modal)
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            const startInputSetup = document.getElementById('season-start-date-setup');
            const endInputSetup = document.getElementById('season-end-date-setup');

            if (startInput) startInput.value = startDateStr;
            if (endInput) endInput.value = endDateStr;
            if (startInputSetup) startInputSetup.value = startDateStr;
            if (endInputSetup) endInputSetup.value = endDateStr;

            // Save to data.seasonSettings immediately
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            data.seasonSettings.startDate = startDateStr;
            data.seasonSettings.endDate = endDateStr;
            
            // Save to database
            saveData();
            
            // Update UI
            updateSeasonDateRange();
            updateSeasonDateRangeButton();
            
            // Refresh calendar to show new dates
            renderAllCalendars();
            
            closeSeasonDateRangePickerModal();
        }

        function updateSeasonDateRangeButton() {
            const button = document.getElementById('season-date-range-button');
            const buttonSetup = document.getElementById('season-date-range-button-setup');
            const buttons = [button, buttonSetup].filter(Boolean);

            if (buttons.length === 0) return;

            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = settings.startDate ? parseISODate(settings.startDate) : null;
            const endDate = settings.endDate ? parseISODate(settings.endDate) : null;

            let buttonText = 'Select Date Range';
            if (startDate && endDate) {
                const startStr = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const endStr = endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                buttonText = `${startStr} – ${endStr}`;
            } else if (startDate) {
                const startStr = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                buttonText = `${startStr} – (no end date)`;
            }

            buttons.forEach(btn => {
                btn.textContent = buttonText;
            });
        }

        function ensureSeasonDraft() {
            if (!seasonSettingsDraft) {
                const settings = data.seasonSettings || buildDefaultSeasonSettings();
                seasonSettingsDraft = {
                    startDate: settings.startDate || '',
                    endDate: settings.endDate || '',
                    practices: Array.isArray(settings.practices)
                        ? settings.practices.map(practice => ({
                            id: practice.id || generateId(),
                            dayOfWeek: practice.dayOfWeek,
                            specificDate: practice.specificDate || null,
                            time: practice.time || practice.startTime || '',
                            endTime: practice.endTime || '',
                            description: practice.description || '',
                            meetLocation: practice.meetLocation || '',
                            locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null,
                        rosterFilter: practice.rosterFilter || null // Preserve rosterFilter when loading
                        }))
                        : []
                };
            }
        }

        // Store original practice states for change tracking
        let originalPracticeStates = new Map();

        function renderPracticeRows(containerId = 'practice-rows') {
            ensureSeasonDraft();
            const container = document.getElementById(containerId);
            if (!container) return;

            if (!seasonSettingsDraft || seasonSettingsDraft.practices.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding:12px;">
                        No regular practices yet. Add one to get started.
                    </div>
                `;
                originalPracticeStates.clear();
                return;
            }
            
            // Store original states if not already stored
            seasonSettingsDraft.practices.forEach(practice => {
                const key = String(practice.id);
                if (!originalPracticeStates.has(key)) {
                    originalPracticeStates.set(key, JSON.parse(JSON.stringify(practice)));
                }
            });
            
            // Determine if this is read-only view (dashboard) or editable view (modal)
            const isReadOnly = containerId === 'practice-rows';
            
            // Keep practices in the order they were created (no sorting)
            const rowsHtml = seasonSettingsDraft.practices.map((practice, index) => {
                const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined;
                const hasLocation = practice.locationLat && practice.locationLng;
                
                // Generate description if not set
                let defaultDescription = practice.description;
                if (!defaultDescription || defaultDescription.startsWith('Weekly Practice')) {
                    if (isSinglePractice) {
                        const practiceDate = parseISODate(practice.specificDate);
                        if (practiceDate) {
                            const dayName = DAYS_OF_WEEK[practiceDate.getDay()];
                            defaultDescription = generatePracticeDescription(dayName, practice.time || '15:30');
                        } else {
                            defaultDescription = 'Practice';
                        }
                    } else if (practice.dayOfWeek !== null && practice.dayOfWeek !== undefined) {
                        const dayName = DAYS_OF_WEEK[practice.dayOfWeek];
                        defaultDescription = generatePracticeDescription(dayName, practice.time || '15:30');
                    } else {
                        defaultDescription = `Practice ${index + 1}`;
                    }
                }

                // Render day of week or date field
                let dayFieldHtml = '';
                if (isReadOnly) {
                    // Read-only text display for dashboard
                    if (isSinglePractice) {
                        const practiceDate = parseISODate(practice.specificDate);
                        const dateStr = practiceDate ? practiceDate.toLocaleDateString() : practice.specificDate || '';
                        dayFieldHtml = `
                            <div class="practice-row-field">
                                <label>Date</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${dateStr}</div>
                            </div>
                        `;
                    } else {
                        const dayName = practice.dayOfWeek !== null && practice.dayOfWeek !== undefined 
                            ? DAYS_OF_WEEK[practice.dayOfWeek] 
                            : '';
                        dayFieldHtml = `
                            <div class="practice-row-field">
                                <label>Day of Week</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${dayName}</div>
                            </div>
                        `;
                    }
                } else {
                    // Editable fields for modal
                    if (isSinglePractice) {
                        dayFieldHtml = `
                            <div class="practice-row-field">
                                <label>Date</label>
                                <input type="date" value="${practice.specificDate || ''}" onchange="updatePracticeDraft(${practice.id}, 'specificDate', this.value); updatePracticeDescription(${practice.id});">
                            </div>
                        `;
                    } else {
                        const options = DAYS_OF_WEEK.map((day, dayIndex) => `
                            <option value="${dayIndex}" ${practice.dayOfWeek === dayIndex ? 'selected' : ''}>${day}</option>
                        `).join('');
                        dayFieldHtml = `
                            <div class="practice-row-field">
                                <label>Day of Week</label>
                                <select onchange="updatePracticeDraft(${practice.id}, 'dayOfWeek', this.value); updatePracticeDescription(${practice.id});">
                                    ${options}
                                </select>
                            </div>
                        `;
                    }
                }

                // Format time range for display
                const timeRange = (practice.time || '') && (practice.endTime || '') 
                    ? `${practice.time} – ${practice.endTime}`
                    : practice.time || practice.endTime || '';
                
                // Format time range for button display
                let timeRangeDisplay = 'Set Time Range';
                if (practice.time && practice.endTime) {
                    timeRangeDisplay = `${formatTimeForDisplay(practice.time)} – ${formatTimeForDisplay(practice.endTime)}`;
                } else if (practice.time) {
                    timeRangeDisplay = `${formatTimeForDisplay(practice.time)} – (no end time)`;
                } else if (practice.endTime) {
                    timeRangeDisplay = `(no start time) – ${formatTimeForDisplay(practice.endTime)}`;
                }

                if (isReadOnly) {
                    // Read-only view for dashboard
                    const ridersDescription = getRosterFilterDescription(practice);
                    return `
                        <div class="practice-row" data-practice-id="${practice.id}" style="grid-template-columns: minmax(140px, 1fr) minmax(180px, 1.2fr) minmax(200px, 1.5fr) minmax(200px, 1.5fr) minmax(150px, 1fr);">
                            ${dayFieldHtml}
                            <div class="practice-row-field">
                                <label>Time Range</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${timeRangeDisplay}</div>
                            </div>
                            <div class="practice-row-field">
                                <label>Description</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${escapeHtml(defaultDescription)}</div>
                            </div>
                            <div class="practice-row-field">
                                <label>Meet Location</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${escapeHtml(practice.meetLocation || '—')}</div>
                            </div>
                            <div class="practice-row-field">
                                <label>Riders</label>
                                <div style="padding: 6px 8px; font-size: 13px; color: #333;">${escapeHtml(ridersDescription)}</div>
                            </div>
                        </div>
                    `;
                } else {
                    // Editable view for modal - buttons on separate line
                    return `
                        <div style="border: 1px solid #e0e0e0; border-radius: 4px; background: #f9f9f9; padding: 10px; margin-bottom: 10px;">
                            <div class="practice-row" data-practice-id="${practice.id}" style="grid-template-columns: minmax(140px, 1fr) minmax(180px, 1.2fr) minmax(200px, 1.5fr) minmax(200px, 1.5fr); border: none; background: transparent; padding: 0; margin: 0;">
                                ${dayFieldHtml}
                                <div class="practice-row-field">
                                    <label>Time Range</label>
                                    <button type="button" class="btn-small secondary" onclick="openTimeRangePickerModal(${practice.id})" style="width: 100%; text-align: left; justify-content: flex-start; padding: 8px 12px; background: white; border: 1px solid #ddd; cursor: pointer; color: #333;">
                                        ${escapeHtml(timeRangeDisplay)}
                                    </button>
                                </div>
                                <div class="practice-row-field">
                                    <label>Description</label>
                                    <input type="text" value="${escapeHtml(defaultDescription)}" placeholder="Practice description" onchange="updatePracticeDraft(${practice.id}, 'description', this.value)" id="practice-desc-${practice.id}" style="width: 100%;">
                                </div>
                                <div class="practice-row-field">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <label>Meet Location</label>
                                        <span style="font-size: 10px; color: #666; margin-right: 4px;">Map</span>
                                    </div>
                                    <div style="display: flex; gap: 4px; align-items: flex-start;">
                                        <input type="text" value="${escapeHtml(practice.meetLocation || '')}" placeholder="Enter location" onchange="updatePracticeDraft(${practice.id}, 'meetLocation', this.value)" style="flex: 1; min-height: 32px; box-sizing: border-box;">
                                        <button type="button" class="btn-small location-button" onclick="openLocationMap(${practice.id})" title="Set location on map" style="height: 32px; padding: 6px 12px; display: flex; align-items: center; justify-content: center; margin-top: 0;">
                                            ${hasLocation ? '📍' : '🗺️'}
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; padding-top: 12px; border-top: 1px solid #e0e0e0; margin-top: 12px;">
                                <button type="button" class="btn-small secondary" onclick="openRosterRefinement(${practice.id})" style="white-space: nowrap;">Refine Roster...</button>
                                <div style="flex: 1;"></div>
                                <div id="practice-actions-${practice.id}" style="display: none; gap: 8px;">
                                    <button class="btn-small" onclick="savePracticeChanges(${practice.id})">Save Changes</button>
                                    <button class="btn-small secondary" onclick="discardPracticeChanges(${practice.id})">Discard</button>
                                </div>
                                <button class="btn-small danger" onclick="removePracticeRow(${practice.id})">Remove</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            container.innerHTML = rowsHtml;
            
            // Check for changes and show/hide buttons
            seasonSettingsDraft.practices.forEach(practice => {
                checkPracticeChanges(practice.id);
            });
        }
        
        function checkPracticeChanges(practiceId) {
            const key = String(practiceId);
            const original = originalPracticeStates.get(key);
            if (!original) return;
            
            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;
            
            // Compare current state with original
            // Also check rosterFilter by comparing JSON strings
            const originalRosterFilter = original.rosterFilter ? JSON.stringify(original.rosterFilter) : null;
            const currentRosterFilter = practice.rosterFilter ? JSON.stringify(practice.rosterFilter) : null;
            const rosterFilterChanged = originalRosterFilter !== currentRosterFilter;
            
            const hasChanges = (
                practice.dayOfWeek !== original.dayOfWeek ||
                practice.specificDate !== original.specificDate ||
                practice.time !== original.time ||
                practice.endTime !== original.endTime ||
                practice.description !== original.description ||
                practice.meetLocation !== original.meetLocation ||
                practice.locationLat !== original.locationLat ||
                practice.locationLng !== original.locationLng ||
                rosterFilterChanged
            );
            
            const actionsDiv = document.getElementById(`practice-actions-${practiceId}`);
            if (actionsDiv) {
                actionsDiv.style.display = hasChanges ? 'flex' : 'none';
            }
        }

        function updatePracticeDraft(id, field, value) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(practice => String(practice.id) === String(id));
            if (practiceIndex === -1) return;

            if (field === 'dayOfWeek') {
                const day = parseInt(value, 10);
                if (Number.isFinite(day) && day >= 0 && day <= 6) {
                    seasonSettingsDraft.practices[practiceIndex].dayOfWeek = day;
                    seasonSettingsDraft.practices[practiceIndex].specificDate = null; // Clear specific date when day of week is set
                    updatePracticeDescription(id);
                    // Refresh calendar to show updated practice days
                    renderAllCalendars();
                }
            } else if (field === 'specificDate') {
                seasonSettingsDraft.practices[practiceIndex].specificDate = value || null;
                seasonSettingsDraft.practices[practiceIndex].dayOfWeek = null; // Clear day of week when specific date is set
                updatePracticeDescription(id);
                // Refresh calendar to show updated practice dates
                renderAllCalendars();
            } else if (field === 'time') {
                const normalizedTime = normalizeTimeValue(value);
                seasonSettingsDraft.practices[practiceIndex].time = normalizedTime;
                updatePracticeDescription(id);
                // Refresh calendar when time changes (affects display)
                renderAllCalendars();
            } else if (field === 'endTime') {
                const normalizedTime = normalizeTimeValue(value);
                seasonSettingsDraft.practices[practiceIndex].endTime = normalizedTime;
            } else if (field === 'description') {
                seasonSettingsDraft.practices[practiceIndex].description = value || '';
            } else if (field === 'meetLocation') {
                seasonSettingsDraft.practices[practiceIndex].meetLocation = value || '';
            } else if (field === 'locationLat') {
                const lat = parseFloat(value);
                seasonSettingsDraft.practices[practiceIndex].locationLat = Number.isFinite(lat) ? lat : null;
            } else if (field === 'locationLng') {
                const lng = parseFloat(value);
                seasonSettingsDraft.practices[practiceIndex].locationLng = Number.isFinite(lng) ? lng : null;
            }

            // Re-render both containers if they exist
            renderPracticeRows('practice-rows');
            renderPracticeRows('practice-rows-modal');
            // Check for changes after update
            checkPracticeChanges(id);
        }

        function addPracticeRow() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const defaultDay = seasonSettingsDraft.practices.length > 0
                ? (seasonSettingsDraft.practices[seasonSettingsDraft.practices.length - 1].dayOfWeek + 2) % 7
                : 2; // Wednesday default

            const practiceNumber = seasonSettingsDraft.practices.length + 1;
            const dayName = DAYS_OF_WEEK[defaultDay];
            const timeStr = '15:30';
            const description = generatePracticeDescription(dayName, timeStr);

            const newPractice = {
                id: generateId(),
                dayOfWeek: defaultDay,
                specificDate: null, // Recurring practice
                time: timeStr,
                endTime: '17:00',
                description: description,
                meetLocation: '',
                locationLat: null,
                locationLng: null,
                rosterFilter: null
            };

            seasonSettingsDraft.practices.push(newPractice);

            // Immediately save to data.seasonSettings so it persists and shows on calendar
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            if (!Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices = [];
            }
            
            // Normalize and add to data.seasonSettings
            const normalized = normalizePracticeEntry(newPractice);
            if (normalized) {
                data.seasonSettings.practices.push({
                    ...normalized,
                    description: newPractice.description || '',
                    meetLocation: newPractice.meetLocation || '',
                    locationLat: newPractice.locationLat || null,
                    locationLng: newPractice.locationLng || null,
                    rosterFilter: newPractice.rosterFilter || null
                });
                
                // Save to database/localStorage
                saveData();
                
                // Refresh calendar to show new practice
                renderAllCalendars();
            }

            // Re-render both containers if they exist
            renderPracticeRows('practice-rows');
            renderPracticeRows('practice-rows-modal');
            
            // Always refresh calendar when any practice field changes (ensures calendar stays in sync)
            renderAllCalendars();
        }

        function addSinglePracticeRow() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            // Default to today's date
            const today = new Date();
            const defaultDate = today.toISOString().split('T')[0];
            
            // Get day name for description
            const dayName = DAYS_OF_WEEK[today.getDay()];
            const timeStr = '15:30';
            const description = generatePracticeDescription(dayName, timeStr);

            const newPractice = {
                id: generateId(),
                dayOfWeek: null, // Single practice uses specificDate instead
                specificDate: defaultDate,
                time: timeStr,
                endTime: '17:00',
                description: description,
                meetLocation: '',
                locationLat: null,
                locationLng: null,
                rosterFilter: null
            };

            seasonSettingsDraft.practices.push(newPractice);

            // Immediately save to data.seasonSettings so it persists and shows on calendar
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            if (!Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices = [];
            }
            
            // Single practices use specificDate, so save directly (don't normalize)
            data.seasonSettings.practices.push({
                id: newPractice.id,
                dayOfWeek: null,
                specificDate: newPractice.specificDate,
                time: newPractice.time,
                endTime: newPractice.endTime,
                description: newPractice.description || '',
                meetLocation: newPractice.meetLocation || '',
                locationLat: newPractice.locationLat || null,
                locationLng: newPractice.locationLng || null,
                rosterFilter: newPractice.rosterFilter || null
            });
            
            // Save to database/localStorage
            saveData();
            
            // Refresh calendar to show new practice
            renderAllCalendars();

            renderPracticeRows();
        }

        function parseISODate(dateStr) {
            if (!dateStr) return null;
            try {
                const date = new Date(dateStr + 'T00:00:00');
                if (isNaN(date.getTime())) return null;
                return date;
            } catch (e) {
                return null;
            }
        }

        function generatePracticeDescription(dayName, timeStr) {
            if (!dayName || !timeStr) return 'Practice';
            
            // Parse time to determine morning/afternoon/evening
            const timeParts = timeStr.split(':');
            const hour = parseInt(timeParts[0], 10);
            const minute = parseInt(timeParts[1], 10);
            const totalMinutes = hour * 60 + minute;
            
            let timeOfDay = 'practice';
            if (totalMinutes < 12 * 60) {
                timeOfDay = 'morning practice';
            } else if (totalMinutes < 17 * 60) {
                timeOfDay = 'afternoon practice';
            } else {
                timeOfDay = 'evening practice';
            }
            
            return `${dayName} ${timeOfDay}`;
        }

        function updatePracticeDescription(practiceId) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(p => String(p.id) === String(practiceId));
            if (practiceIndex === -1) return;

            const practice = seasonSettingsDraft.practices[practiceIndex];
            
            // Only update if description hasn't been manually edited (starts with day name pattern)
            const descInput = document.getElementById(`practice-desc-${practiceId}`);
            if (!descInput) return;
            
            const currentDesc = descInput.value.trim();
            // Check if description matches auto-generated pattern (day name + time of day)
            const isAutoGenerated = currentDesc && (
                currentDesc.includes('morning practice') ||
                currentDesc.includes('afternoon practice') ||
                currentDesc.includes('evening practice') ||
                currentDesc.startsWith('Weekly Practice') ||
                currentDesc === 'Practice'
            );
            
            if (isAutoGenerated || !currentDesc) {
                let dayName = null;
                
                if (practice.specificDate) {
                    const practiceDate = parseISODate(practice.specificDate);
                    if (practiceDate) {
                        dayName = DAYS_OF_WEEK[practiceDate.getDay()];
                    }
                } else if (practice.dayOfWeek !== null && practice.dayOfWeek !== undefined) {
                    dayName = DAYS_OF_WEEK[practice.dayOfWeek];
                }
                
                if (dayName && practice.time) {
                    const newDescription = generatePracticeDescription(dayName, practice.time);
                    practice.description = newDescription;
                    descInput.value = newDescription;
                }
            }
        }

        function savePracticeChanges(practiceId) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;
            
            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;
            
            // Get the practice row inputs
            const row = document.querySelector(`[data-practice-id="${practiceId}"]`);
            if (!row) return;
            
            // Get updated values from the row
            const dayOfWeekSelect = row.querySelector('select[onchange*="dayOfWeek"]');
            const dateInput = row.querySelector('input[type="date"]');
            const timeInput = row.querySelector('input[type="time"]:not([placeholder="End"])');
            const endTimeInput = row.querySelector('input[type="time"][placeholder="End"]');
            const descriptionInput = row.querySelector('input[id^="practice-desc-"]');
            const locationInput = row.querySelector('input[onchange*="meetLocation"]');
            
            // Get updated values
            // Determine practice type based on which input exists (select = recurring, date input = single)
            const isRecurringPractice = dayOfWeekSelect !== null;
            const isSinglePractice = dateInput !== null && !dayOfWeekSelect;
            
            let updatedDayOfWeek = null;
            let updatedSpecificDate = null;
            
            if (isRecurringPractice) {
                // Recurring practice - get day of week from select
                const dayValue = dayOfWeekSelect.value;
                if (dayValue !== '' && dayValue !== null && dayValue !== undefined) {
                    const parsedDay = parseInt(dayValue, 10);
                    if (Number.isFinite(parsedDay) && parsedDay >= 0 && parsedDay <= 6) {
                        updatedDayOfWeek = parsedDay;
                    }
                }
                // Always fallback to practice.dayOfWeek if select value is invalid or empty
                // This handles cases where the select exists but hasn't been changed yet
                if ((updatedDayOfWeek === null || updatedDayOfWeek === undefined) && 
                    practice.dayOfWeek !== null && practice.dayOfWeek !== undefined && 
                    Number.isFinite(practice.dayOfWeek)) {
                    updatedDayOfWeek = practice.dayOfWeek;
                }
            } else if (isSinglePractice) {
                // Single practice - get specific date from date input
                updatedSpecificDate = dateInput.value || practice.specificDate || null;
            } else {
                // Neither input found - use practice data
                if (practice.dayOfWeek !== null && practice.dayOfWeek !== undefined && Number.isFinite(practice.dayOfWeek)) {
                    updatedDayOfWeek = practice.dayOfWeek;
                } else if (practice.specificDate) {
                    updatedSpecificDate = practice.specificDate;
                }
            }
            
            const updatedTime = timeInput ? timeInput.value : practice.time;
            const updatedEndTime = endTimeInput ? endTimeInput.value : practice.endTime;
            const updatedDescription = descriptionInput ? descriptionInput.value : practice.description;
            const updatedMeetLocation = locationInput ? locationInput.value : practice.meetLocation;
            
            // Get location from practice draft (may have been set via map)
            const updatedLocationLat = practice.locationLat;
            const updatedLocationLng = practice.locationLng;
            
            // Validate that we have either a day of week or specific date
            // Check if dayOfWeek is a valid number (0-6, where 0 is Sunday)
            const hasValidDayOfWeek = updatedDayOfWeek !== null && 
                                      updatedDayOfWeek !== undefined && 
                                      Number.isFinite(updatedDayOfWeek) && 
                                      updatedDayOfWeek >= 0 && 
                                      updatedDayOfWeek <= 6;
            const hasSpecificDate = updatedSpecificDate && updatedSpecificDate.trim() !== '';
            
            if (!hasValidDayOfWeek && !hasSpecificDate) {
                alert('Practice must have either a day of week or a specific date.');
                return;
            }
            
            const isRecurring = hasValidDayOfWeek && !hasSpecificDate;
            const isSingle = hasSpecificDate && !hasValidDayOfWeek;
            
            // Find all practices in the same series (same dayOfWeek for recurring, or same specificDate for single)
            // Exclude cancelled, rescheduled, and deleted practices
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (isRecurring) {
                // Apply to all practices with the same dayOfWeek that are not cancelled, rescheduled, or deleted
                data.rides.forEach(ride => {
                    if (!ride.date || ride.deleted || ride.cancelled || ride.rescheduledFrom) return;
                    
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return;
                    
                    // Check if this ride matches the day of week
                    if (rideDate.getDay() === updatedDayOfWeek && rideDate >= today) {
                        // Update this practice
                        ride.time = updatedTime;
                        ride.endTime = updatedEndTime;
                        ride.description = updatedDescription;
                        ride.meetLocation = updatedMeetLocation;
                        ride.locationLat = updatedLocationLat;
                        ride.locationLng = updatedLocationLng;
                    }
                });
            } else if (isSingle) {
                // For single practices, only update that specific practice
                const targetDate = parseISODate(updatedSpecificDate);
                if (targetDate) {
                    const targetDateKey = formatDateToISO(targetDate);
                    const ride = data.rides.find(r => {
                        if (!r.date || r.deleted || r.cancelled || r.rescheduledFrom) return false;
                        return formatDateToISO(parseISODate(r.date)) === targetDateKey;
                    });
                    
                    if (ride) {
                        ride.time = updatedTime;
                        ride.endTime = updatedEndTime;
                        ride.description = updatedDescription;
                        ride.meetLocation = updatedMeetLocation;
                        ride.locationLat = updatedLocationLat;
                        ride.locationLng = updatedLocationLng;
                    }
                }
            }
            
            // Also update the draft practice
            practice.dayOfWeek = isRecurring ? updatedDayOfWeek : null;
            practice.specificDate = isSingle ? updatedSpecificDate : null;
            practice.time = updatedTime;
            practice.endTime = updatedEndTime;
            practice.description = updatedDescription;
            practice.meetLocation = updatedMeetLocation;
            practice.locationLat = updatedLocationLat;
            practice.locationLng = updatedLocationLng;
            // Preserve rosterFilter from draft (it's already there from saveRosterRefinement)
            const rosterFilter = practice.rosterFilter || null;
            
            // Save to data.seasonSettings.practices
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            if (!Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices = [];
            }
            
            const settingsPracticeIndex = data.seasonSettings.practices.findIndex(
                p => String(p.id) === String(practiceId)
            );
            if (settingsPracticeIndex >= 0) {
                // Update existing practice in seasonSettings
                data.seasonSettings.practices[settingsPracticeIndex].dayOfWeek = practice.dayOfWeek;
                data.seasonSettings.practices[settingsPracticeIndex].specificDate = practice.specificDate;
                data.seasonSettings.practices[settingsPracticeIndex].time = practice.time;
                data.seasonSettings.practices[settingsPracticeIndex].endTime = practice.endTime;
                data.seasonSettings.practices[settingsPracticeIndex].description = practice.description;
                data.seasonSettings.practices[settingsPracticeIndex].meetLocation = practice.meetLocation;
                data.seasonSettings.practices[settingsPracticeIndex].locationLat = practice.locationLat;
                data.seasonSettings.practices[settingsPracticeIndex].locationLng = practice.locationLng;
                data.seasonSettings.practices[settingsPracticeIndex].rosterFilter = rosterFilter;
            }
            
            // Save changes
            saveData();
            
            // Update original state to reflect saved changes
            const key = String(practiceId);
            originalPracticeStates.set(key, JSON.parse(JSON.stringify(practice)));
            
            // Re-render both containers
            renderPracticeRows('practice-rows');
            renderPracticeRows('practice-rows-modal');
            renderAllCalendars();
            
            alert('Practice changes have been saved and applied to all practices in the series (excluding cancelled, rescheduled, and deleted practices).');
        }
        
        function discardPracticeChanges(practiceId) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;
            
            const key = String(practiceId);
            const original = originalPracticeStates.get(key);
            if (!original) return;
            
            const practiceIndex = seasonSettingsDraft.practices.findIndex(p => String(p.id) === String(practiceId));
            if (practiceIndex === -1) return;
            
            // Restore original values
            const practice = seasonSettingsDraft.practices[practiceIndex];
            practice.dayOfWeek = original.dayOfWeek;
            practice.specificDate = original.specificDate;
            practice.time = original.time;
            practice.endTime = original.endTime;
            practice.description = original.description;
            practice.meetLocation = original.meetLocation;
            practice.locationLat = original.locationLat;
            practice.locationLng = original.locationLng;
            
            // Re-render both containers to show original values
            renderPracticeRows('practice-rows');
            renderPracticeRows('practice-rows-modal');
        }

        function removePracticeRow(id) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            // Find the practice to check if it's a single practice
            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(id));
            const isSinglePractice = practice && practice.specificDate != null && practice.specificDate !== undefined && practice.specificDate !== '';

            // Remove from original states
            originalPracticeStates.delete(String(id));
            
            seasonSettingsDraft.practices = seasonSettingsDraft.practices.filter(practice => String(practice.id) !== String(id));
            
            // Also remove from data.seasonSettings and save to database
            if (data.seasonSettings && Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices = data.seasonSettings.practices.filter(practice => String(practice.id) !== String(id));
                saveData(); // Persist the deletion to Supabase
            }
            
            // If this is a single practice, also mark the corresponding ride as deleted
            if (isSinglePractice && practice.specificDate) {
                const ride = data.rides.find(r => r.date === practice.specificDate && !r.deleted);
                if (ride) {
                    ride.deleted = true;
                    saveData();
                }
            }
            
            // Re-render both containers
            renderPracticeRows('practice-rows');
            renderPracticeRows('practice-rows-modal');
            
            // Refresh calendar to immediately reflect the deletion
            renderAllCalendars();
        }


        function updateSeasonDateRange() {
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            if (startInput && endInput && startInput.value && endInput.value) {
                const startDate = parseISODate(startInput.value);
                const endDate = parseISODate(endInput.value);
                if (startDate && endDate && startDate > endDate) {
                    // Auto-adjust end date if it's before start date
                    endInput.value = startInput.value;
                }
            }
        }

        function applySeasonUpdates(scope) {
            const applyAll = confirm('Apply updates to the whole season?\n\nOK = Whole season (cancelled/rescheduled practices will be lost)\nCancel = Only from today forward');
            const fromDate = applyAll ? new Date(0) : new Date();
            fromDate.setHours(0, 0, 0, 0);
            
            // Persist current season settings (dates + regular practices) to data before re-rendering
            ensureSeasonDraft();
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            const startDateValue = startInput ? startInput.value : '';
            const endDateValue = endInput ? endInput.value : '';
            const cleanedPractices = (seasonSettingsDraft?.practices || [])
                .map(practice => {
                    if (!practice || typeof practice !== 'object') {
                        return null;
                    }
                    
                    // Handle single practices (with specificDate) differently from recurring practices
                    const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined && practice.specificDate !== '';
                    
                    if (isSinglePractice) {
                        // Single practice: require specificDate and time
                        const time = normalizeTimeValue(practice.time || practice.startTime || '');
                        if (!time || !practice.specificDate) {
                            return null;
                        }
                        
                        return {
                            id: practice.id || generateId(),
                            dayOfWeek: null,
                            specificDate: practice.specificDate,
                            time: time,
                            endTime: normalizeTimeValue(practice.endTime || '') || '',
                description: practice.description || '',
                meetLocation: practice.meetLocation || '',
                locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null,
                            rosterFilter: practice.rosterFilter || null
                        };
                    } else {
                        // Recurring practice: use normalizePracticeEntry
                        const normalized = normalizePracticeEntry(practice);
                        if (!normalized) return null;
                        // Preserve rosterFilter and other fields from original practice
                        return {
                            ...normalized,
                            description: practice.description || '',
                            meetLocation: practice.meetLocation || '',
                            locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null,
                            rosterFilter: practice.rosterFilter || null
                        };
                    }
                })
                .filter(Boolean);
            const practicesData = cleanedPractices;
            // Preserve all existing fields in seasonSettings (like csvFieldMappings, fitnessScale, etc.)
            data.seasonSettings = {
                ...data.seasonSettings,
                startDate: startDateValue || '',
                endDate: endDateValue || '',
                practices: practicesData
            };
            
            // Update the date range button to reflect saved dates
            updateSeasonDateRangeButton();
            
            // Determine current season range (if set)
            const seasonStart = startDateValue ? parseISODate(startDateValue) : null;
            const seasonEnd = endDateValue ? parseISODate(endDateValue) : null;
            if (seasonStart) seasonStart.setHours(0,0,0,0);
            if (seasonEnd) seasonEnd.setHours(0,0,0,0);
            
            // If applying to whole season, drop rescheduled instances entirely and force recalculation
            if (applyAll) {
                data.rides = (data.rides || []).filter(ride => !ride.rescheduledFrom);
                data.currentRide = null; // force next practice recalculation
                
                // If no regular practices remain, clear all generated rides
                if (practicesData.length === 0) {
                    data.rides = [];
                } else if (seasonStart && seasonEnd) {
                    // Trim rides outside the new season range
                    data.rides = (data.rides || []).filter(ride => {
                        if (!ride.date) return false;
                        const d = parseISODate(ride.date);
                        if (!d) return false;
                        d.setHours(0,0,0,0);
                        return d >= seasonStart && d <= seasonEnd;
                    });
                }
            }
            
            (data.rides || []).forEach(ride => {
                const rideDate = parseISODate(ride.date);
                if (!rideDate) return;
                rideDate.setHours(0, 0, 0, 0);
                if (rideDate >= fromDate) {
                    ride.cancelled = false;
                    ride.cancellationReason = '';
                    ride.rescheduledFrom = null;
                    ride.deleted = false;
                }
            });
            
            saveData();
            // Recompute calendars and current ride after cleaning
            renderAllCalendars();
            renderRides();
            alert('Updates applied. Cancelled and rescheduled practices within the selected range have been reset.');
        }

        async function saveSeasonSettings() {
            ensureSeasonDraft();
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');

            const startDateValue = startInput ? startInput.value : '';
            const endDateValue = endInput ? endInput.value : '';

            if (startDateValue && endDateValue) {
                const startDate = parseISODate(startDateValue);
                const endDate = parseISODate(endDateValue);
                if (startDate && endDate && startDate > endDate) {
                    alert('Season end date must be on or after the start date.');
                    return;
                }
            }

            const cleanedPractices = (seasonSettingsDraft?.practices || [])
                .map(practice => {
                    if (!practice || typeof practice !== 'object') {
                        return null;
                    }
                    
                    // Handle single practices (with specificDate) differently from recurring practices
                    const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined && practice.specificDate !== '';
                    
                    if (isSinglePractice) {
                        // Single practice: require specificDate and time
                        const time = normalizeTimeValue(practice.time || practice.startTime || '');
                        if (!time || !practice.specificDate) {
                            return null;
                        }
                        
                        return {
                            id: practice.id || generateId(),
                            dayOfWeek: null,
                            specificDate: practice.specificDate,
                            time: time,
                            endTime: normalizeTimeValue(practice.endTime || '') || '',
                description: practice.description || '',
                meetLocation: practice.meetLocation || '',
                locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null,
                            rosterFilter: practice.rosterFilter || null
                        };
                    } else {
                        // Recurring practice: use normalizePracticeEntry
                        const normalized = normalizePracticeEntry(practice);
                        if (!normalized) return null;
                        // Preserve rosterFilter and other fields from original practice
                        return {
                            ...normalized,
                            description: practice.description || '',
                            meetLocation: practice.meetLocation || '',
                            locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null,
                            rosterFilter: practice.rosterFilter || null
                        };
                    }
                })
                .filter(Boolean);

            const practicesData = cleanedPractices;

            // Get scale settings - preserve existing saved values if inputs haven't been updated
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            
            // Get old scales for conversion (before updating)
            const oldFitnessScale = data.seasonSettings?.fitnessScale || 5;
            const oldSkillsScale = data.seasonSettings?.skillsScale || 3;
            
            // Use input value if valid, otherwise preserve existing saved value
            let fitnessScale = oldFitnessScale;
            let skillsScale = oldSkillsScale;
            
            if (fitnessScaleInput) {
                const inputValue = parseInt(fitnessScaleInput.value, 10);
                if (Number.isFinite(inputValue) && inputValue >= 3 && inputValue <= 20) {
                    fitnessScale = inputValue;
                }
            }
            if (skillsScaleInput) {
                const inputValue = parseInt(skillsScaleInput.value, 10);
                if (Number.isFinite(inputValue) && inputValue >= 2 && inputValue <= 10) {
                    skillsScale = inputValue;
                }
            }
            
            // Preserve all existing fields in seasonSettings (like csvFieldMappings, etc.)
            data.seasonSettings = {
                ...data.seasonSettings,
                startDate: startDateValue || '',
                endDate: endDateValue || '',
                practices: practicesData,
                fitnessScale: fitnessScale,
                skillsScale: skillsScale,
                paceScaleOrder: normalizePaceScaleOrder(paceScaleOrderInput?.value || data.seasonSettings?.paceScaleOrder),
                groupPaceOrder: normalizeGroupPaceOrder(data.seasonSettings?.groupPaceOrder)
            };
            
            // Convert existing data if scales changed
            if (fitnessScale !== oldFitnessScale || skillsScale !== oldSkillsScale) {
                convertAllRatingsToNewScales(oldFitnessScale, fitnessScale, oldSkillsScale, skillsScale);
            }
            
            // Update scale displays
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = fitnessScale;
            if (skillsScaleDisplay) skillsScaleDisplay.textContent = skillsScale;

            // Save to localStorage
            saveData();
            
            // Export complete data backup
            await exportAllData();
            
            closeSeasonSetupModal();
            renderAllCalendars();
            updateHeaderEditSeasonButton();
            // Trigger cleanup and validation if on Practice Planner tab
            renderRides();
        }

        // Simple encryption key (base key for obfuscation - not for strong security)
        const ENCRYPTION_KEY_BASE = 'TeamRidePro2024SecureBackup';

        // Encrypt data using Web Crypto API
        async function encryptBackupData(plaintext) {
            try {
                // Convert plaintext to bytes
                const encoder = new TextEncoder();
                const data = encoder.encode(plaintext);

                // Generate a key from our base key
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(ENCRYPTION_KEY_BASE.padEnd(32, '0').substring(0, 32)),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode('TeamRideProSalt'),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );

                // Generate IV
                const iv = crypto.getRandomValues(new Uint8Array(12));

                // Encrypt
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );

                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);

                // Convert to base64 safely (handle large arrays by building string directly)
                let binaryString = '';
                for (let i = 0; i < combined.length; i++) {
                    binaryString += String.fromCharCode(combined[i]);
                }
                return btoa(binaryString);
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Failed to encrypt backup data');
            }
        }

        // Decrypt data using Web Crypto API
        async function decryptBackupData(encryptedBase64) {
            try {
                // Decode from base64 safely (handle large strings)
                const binaryString = atob(encryptedBase64);
                const combined = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    combined[i] = binaryString.charCodeAt(i);
                }

                // Extract IV and encrypted data
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);

                // Generate the same key
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(ENCRYPTION_KEY_BASE.padEnd(32, '0').substring(0, 32)),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode('TeamRideProSalt'),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['decrypt']
                );

                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );

                // Convert to string
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Failed to decrypt backup data. The file may be corrupted or not encrypted with this version.');
            }
        }

        async function exportAllData() {
            // Ensure data is up to date before exporting
            saveData();
            
            // Build complete export with all data
            const exportData = {
                version: '2.0',
                exportedAt: new Date().toISOString(),
                data: {
                    riders: data.riders || [],
                    coaches: data.coaches || [],
                    rides: data.rides || [],
                    routes: data.routes || [],
                    races: data.races || [],
                    currentRide: data.currentRide || null,
                    seasonSettings: data.seasonSettings || null,
                    autoAssignSettings: data.autoAssignSettings || null,
                    timeEstimationSettings: data.timeEstimationSettings || null,
                    coachRoles: data.coachRoles || [],
                    riderRoles: data.riderRoles || []
                }
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            
            // Encrypt the data
            const encryptedData = await encryptBackupData(jsonString);
            
            // Create a wrapper object to identify encrypted backups
            const encryptedWrapper = {
                encrypted: true,
                version: '2.0',
                data: encryptedData
            };
            
            const encryptedJsonString = JSON.stringify(encryptedWrapper);
            const blob = new Blob([encryptedJsonString], { type: 'application/json' });
            
            // Try to use File System Access API for save dialog (modern browsers)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `team-ride-pro-backup-${new Date().toISOString().split('T')[0]}.trpb`,
                        types: [{
                            description: 'Team Ride Pro Backup files',
                            accept: { 'application/json': ['.trpb'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    alert('Complete team data backup exported successfully!');
                    return;
                } catch (error) {
                    // User cancelled or error - fall back to download
                    if (error.name !== 'AbortError') {
                        console.error('File System Access API error:', error);
                    } else {
                        // User cancelled, don't show error
                        return;
                    }
                }
            }
            
            // Fallback to download (for browsers without File System Access API)
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `team-ride-pro-backup-${new Date().toISOString().split('T')[0]}.trpb`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('Complete team data backup exported successfully!');
        }

        async function exportSeasonSettings() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) {
                alert('No season settings to export.');
                return;
            }

            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            
            const exportData = {
                startDate: startInput ? startInput.value : seasonSettingsDraft.startDate || '',
                endDate: endInput ? endInput.value : seasonSettingsDraft.endDate || '',
                practices: (seasonSettingsDraft.practices || []).map(practice => ({
                    id: practice.id,
                    dayOfWeek: practice.dayOfWeek,
                    specificDate: practice.specificDate || null,
                    time: practice.time || '',
                    endTime: practice.endTime || '',
                    description: practice.description || '',
                    meetLocation: practice.meetLocation || '',
                    locationLat: practice.locationLat || null,
                    locationLng: practice.locationLng || null
                })),
                exportedAt: new Date().toISOString(),
                version: '1.0'
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // Try to use File System Access API for save dialog (modern browsers)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `team-ride-pro-settings-${new Date().toISOString().split('T')[0]}.json`,
                        types: [{
                            description: 'JSON files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    return;
                } catch (error) {
                    // User cancelled or error - fall back to download
                    if (error.name !== 'AbortError') {
                        console.error('File System Access API error:', error);
                    }
                }
            }
            
            // Fallback to download (for browsers without File System Access API)
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `team-ride-pro-settings-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importSeasonSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.trpb';
            input.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (!importedData || typeof importedData !== 'object') {
                            throw new Error('Invalid file format');
                        }

                        // Check if this is a full backup (version 2.0) or old season settings format
                        let dataToImport = null;
                        if (importedData.version === '2.0' && importedData.data) {
                            // Full backup format - restore all data
                            if (!confirm('This is a complete backup file. This will REPLACE ALL existing data (riders, coaches, rides, assignments, settings, etc.). This action cannot be undone. Continue?')) {
                                return;
                            }
                            dataToImport = importedData.data;
                        } else {
                            // Old format - just season settings
                            dataToImport = importedData;
                        }

                        // If it's a full backup, restore everything
                        if (importedData.version === '2.0' && importedData.data) {
                            // Restore all data
                            if (Array.isArray(dataToImport.riders)) {
                                data.riders = dataToImport.riders;
                            }
                            if (Array.isArray(dataToImport.coaches)) {
                                data.coaches = dataToImport.coaches;
                            }
                            if (Array.isArray(dataToImport.rides)) {
                                data.rides = dataToImport.rides;
                            }
                            if (Array.isArray(dataToImport.routes)) {
                                data.routes = dataToImport.routes;
                            }
                            if (Array.isArray(dataToImport.races)) {
                                data.races = dataToImport.races;
                            }
                            if (dataToImport.currentRide !== undefined) {
                                data.currentRide = dataToImport.currentRide;
                            }
                            if (dataToImport.seasonSettings) {
                                data.seasonSettings = dataToImport.seasonSettings;
                            }
                            if (dataToImport.autoAssignSettings) {
                                data.autoAssignSettings = dataToImport.autoAssignSettings;
                            }
                            if (dataToImport.timeEstimationSettings) {
                                data.timeEstimationSettings = dataToImport.timeEstimationSettings;
                            }
                            if (Array.isArray(dataToImport.coachRoles)) {
                                data.coachRoles = dataToImport.coachRoles;
                            }
                            if (Array.isArray(dataToImport.riderRoles)) {
                                data.riderRoles = dataToImport.riderRoles;
                            }

                            // Save to localStorage
                            saveData();

                            // Reload season settings into UI
                            loadSeasonSettings();

                            // Re-render everything
                            renderRiders();
                            renderCoaches();
                            renderRides();
                            renderRoutes();
                            renderAllCalendars();
                            updateHeaderEditSeasonButton();

                            alert('Complete backup restored successfully! All data has been restored.');
                            return;
                        }

                        // Old format: Just season settings
                        // Validate and import season settings data
                        if (dataToImport.startDate) {
                            const startInput = document.getElementById('season-start-date');
                            if (startInput) startInput.value = dataToImport.startDate;
                        }

                        if (dataToImport.endDate) {
                            const endInput = document.getElementById('season-end-date');
                            if (endInput) endInput.value = dataToImport.endDate;
                        }

                        if (Array.isArray(dataToImport.practices)) {
                            ensureSeasonDraft();
                            if (seasonSettingsDraft) {
                                // Merge imported practices (or replace if user confirms)
                                if (seasonSettingsDraft.practices.length > 0) {
                                    if (!confirm(`You currently have ${seasonSettingsDraft.practices.length} practices. Import will ${dataToImport.practices.length > 0 ? 'replace' : 'clear'} them. Continue?`)) {
                                        return;
                                    }
                                }
                                
                                seasonSettingsDraft.practices = dataToImport.practices.map(practice => ({
                                    id: practice.id || generateId(),
                                    dayOfWeek: practice.specificDate ? null : (practice.dayOfWeek !== undefined ? practice.dayOfWeek : 0),
                                    specificDate: practice.specificDate || null,
                                    time: practice.time || '15:30',
                                    endTime: practice.endTime || '17:00',
                                    description: practice.description || '',
                                    meetLocation: practice.meetLocation || '',
                                    locationLat: practice.locationLat || null,
                                    locationLng: practice.locationLng || null
                                }));
                                
                                renderPracticeRows();
                                alert(`Successfully imported ${dataToImport.practices.length} practice(s).`);
                            }
                        } else {
                            alert('No practices found in imported file.');
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        alert('Error importing settings: ' + (error.message || 'Invalid file format'));
                    }
                };
                reader.onerror = () => {
                    alert('Error reading file.');
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // CSV Import function for riders only
        function importRidersFromCSV() {
            if (!confirm('This will replace ALL existing rider data with data from the CSV file. This action cannot be undone. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const ridersText = await readFileAsText(file);
                    // Parse CSV to get headers
                    const parsed = parseCSV(ridersText);
                    if (parsed.length < 2) {
                        alert('CSV file must contain at least a header row and one data row.');
                        return;
                    }
                    
                    // Store for mapping
                    pendingCSVData = ridersText;
                    pendingCSVType = 'riders';
                    pendingCSVHeaders = parsed[0];
                    
                    // Show mapping modal
                    openCSVFieldMappingModal('riders', parsed[0], true); // true = isImport (replace all)
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // CSV Import function for coaches only
        function importCoachesFromCSV() {
            if (!confirm('This will replace ALL existing coach data with data from the CSV file. This action cannot be undone. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const coachesText = await readFileAsText(file);
                    // Parse CSV to get headers
                    const parsed = parseCSV(coachesText);
                    if (parsed.length < 2) {
                        alert('CSV file must contain at least a header row and one data row.');
                        return;
                    }
                    
                    // Store for mapping
                    pendingCSVData = coachesText;
                    pendingCSVType = 'coaches';
                    pendingCSVHeaders = parsed[0];
                    
                    // Show mapping modal
                    openCSVFieldMappingModal('coaches', parsed[0], true); // true = isImport (replace all)
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // Helper to read file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // Google Sheets integration
        function extractGoogleSheetId(url) {
            if (!url) return null;
            
            // Handle different Google Sheets URL formats
            // Format 1: https://docs.google.com/spreadsheets/d/{SHEET_ID}/edit#gid={GID}
            // Format 2: https://docs.google.com/spreadsheets/d/{SHEET_ID}/edit?gid={GID}
            // Format 3: https://docs.google.com/spreadsheets/d/{SHEET_ID}
            
            const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            if (!match) return null;
            
            const sheetId = match[1];
            
            // Extract GID if present
            let gid = '0'; // Default to first sheet
            const gidMatch = url.match(/[#&?]gid=([0-9]+)/);
            if (gidMatch) {
                gid = gidMatch[1];
            }
            
            return { sheetId, gid };
        }

        function getGoogleSheetCSVUrl(sheetId, gid = '0') {
            return `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
        }

        // Google OAuth configuration
        // NOTE: You need to set up a Google Cloud Project and OAuth 2.0 Client ID
        // 1. Go to https://console.cloud.google.com/
        // 2. Create a project or select existing
        // 3. Enable Google Sheets API
        // 4. Create OAuth 2.0 credentials (Web application)
        // 5. Add your domain to authorized JavaScript origins
        // 6. Set the client ID in seasonSettings.googleClientId or set GOOGLE_CLIENT_ID_DEFAULT below
        const GOOGLE_CLIENT_ID_DEFAULT = ''; // Set your Google OAuth Client ID here, or set it in seasonSettings.googleClientId
        
        const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/spreadsheets.readonly';
        let googleAccessToken = null;
        let googleTokenClient = null;

        function getGoogleClientId() {
            return data.seasonSettings?.googleClientId || GOOGLE_CLIENT_ID_DEFAULT;
        }

        // Initialize Google OAuth
        function initGoogleOAuth() {
            const clientId = getGoogleClientId();
            if (!clientId) {
                console.warn('Google Client ID not configured. OAuth will not work. Set data.seasonSettings.googleClientId or GOOGLE_CLIENT_ID_DEFAULT constant.');
                return;
            }

            if (typeof google !== 'undefined' && google.accounts) {
                try {
                    google.accounts.id.initialize({
                        client_id: clientId
                    });

                    google.accounts.oauth2.initTokenClient({
                        client_id: clientId,
                        scope: GOOGLE_SCOPES,
                        callback: (response) => {
                            if (response.access_token) {
                                googleAccessToken = response.access_token;
                                // Store token securely (encrypted in localStorage)
                                try {
                                    localStorage.setItem('google_access_token', response.access_token);
                                    localStorage.setItem('google_token_expiry', String(Date.now() + (response.expires_in * 1000)));
                                } catch (e) {
                                    console.warn('Could not store Google token:', e);
                                }
                                // Update status display
                                updateGoogleAuthStatus();
                            }
                        }
                    }).then(client => {
                        googleTokenClient = client;
                    }).catch(err => {
                        console.error('Error initializing Google OAuth:', err);
                    });
                } catch (err) {
                    console.error('Error setting up Google OAuth:', err);
                }
            } else {
                console.warn('Google API not loaded. Make sure the Google API scripts are included in the page.');
            }
        }

        // Load stored Google token
        function loadGoogleToken() {
            try {
                const storedToken = localStorage.getItem('google_access_token');
                const expiry = localStorage.getItem('google_token_expiry');
                if (storedToken && expiry && Date.now() < parseInt(expiry, 10)) {
                    googleAccessToken = storedToken;
                    return true;
                } else {
                    // Token expired or doesn't exist
                    localStorage.removeItem('google_access_token');
                    localStorage.removeItem('google_token_expiry');
                    googleAccessToken = null;
                    return false;
                }
            } catch (e) {
                return false;
            }
        }

        // Request Google OAuth authorization
        async function authorizeGoogle() {
            const clientId = getGoogleClientId();
            if (!clientId) {
                alert('Google OAuth is not configured. Please set up a Google Cloud Project and OAuth Client ID.\n\nSee instructions in the code comments or contact your administrator.');
                return false;
            }

            if (!googleTokenClient) {
                initGoogleOAuth();
                // Wait a bit for initialization
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!googleTokenClient) {
                    alert('Google OAuth initialization failed. Please refresh the page and try again.');
                    return false;
                }
            }

            return new Promise((resolve) => {
                try {
                    googleTokenClient.requestAccessToken({ prompt: 'consent' });
                    // The callback will set googleAccessToken
                    // Check after a delay to allow OAuth popup
                    setTimeout(() => {
                        if (googleAccessToken) {
                            updateGoogleAuthStatus();
                        }
                        resolve(!!googleAccessToken);
                    }, 2000);
                } catch (err) {
                    console.error('Error requesting access token:', err);
                    resolve(false);
                }
            });
        }

        // Public function to request authorization (called by button)
        async function requestGoogleAuthorization() {
            const authorized = await authorizeGoogle();
            if (authorized) {
                alert('Successfully authorized Google access! You can now sync private Google Sheets.');
            } else {
                alert('Authorization failed. Please try again or make sure your Google Sheet is publicly viewable.');
            }
        }

        // Update the authorization status display
        function updateGoogleAuthStatus() {
            const riderStatus = document.getElementById('rider-google-auth-status');
            const coachStatus = document.getElementById('coach-google-auth-status');
            const modalStatus = document.getElementById('modal-google-auth-status');
            const riderBtn = document.getElementById('rider-google-auth-btn');
            const coachBtn = document.getElementById('coach-google-auth-btn');
            const modalBtn = document.getElementById('modal-google-auth-btn');
            
            const isAuthorized = !!googleAccessToken;
            const statusText = isAuthorized ? '✓ Authorized' : 'Not authorized';
            const statusColor = isAuthorized ? '#4caf50' : '#666';
            const btnText = isAuthorized ? 'Re-authorize' : 'Sign in with Google';
            
            if (riderStatus) {
                riderStatus.textContent = statusText;
                riderStatus.style.color = statusColor;
            }
            if (coachStatus) {
                coachStatus.textContent = statusText;
                coachStatus.style.color = statusColor;
            }
            if (modalStatus) {
                modalStatus.textContent = statusText;
                modalStatus.style.color = statusColor;
            }
            if (riderBtn) {
                riderBtn.textContent = btnText;
            }
            if (coachBtn) {
                coachBtn.textContent = btnText;
            }
            if (modalBtn) {
                modalBtn.textContent = btnText;
            }
        }

        // Fetch Google Sheet using Sheets API v4 (with OAuth) or CSV export (public)
        async function fetchGoogleSheetCSV(url, useAuth = true) {
            try {
                const sheetInfo = extractGoogleSheetId(url);
                if (!sheetInfo) {
                    throw new Error('Invalid Google Sheets URL. Please use a URL like: https://docs.google.com/spreadsheets/d/SHEET_ID/edit');
                }

                // Try authenticated API first if token is available
                if (useAuth && googleAccessToken) {
                    try {
                        // First, get sheet metadata to find the sheet name by GID
                        const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetInfo.sheetId}?fields=sheets.properties`;
                        const metadataResponse = await fetch(metadataUrl, {
                            headers: {
                                'Authorization': `Bearer ${googleAccessToken}`
                            }
                        });

                        let sheetName = 'Sheet1'; // Default
                        if (metadataResponse.ok) {
                            const metadata = await metadataResponse.json();
                            const targetSheet = metadata.sheets?.find(sheet => 
                                String(sheet.properties.sheetId) === String(sheetInfo.gid)
                            );
                            if (targetSheet) {
                                sheetName = targetSheet.properties.title;
                            } else if (metadata.sheets && metadata.sheets.length > 0) {
                                // Fallback to first sheet if GID doesn't match
                                sheetName = metadata.sheets[0].properties.title;
                            }
                        }

                        // Use Google Sheets API v4
                        const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetInfo.sheetId}/values/${encodeURIComponent(sheetName)}?alt=json`;
                        const response = await fetch(apiUrl, {
                            headers: {
                                'Authorization': `Bearer ${googleAccessToken}`
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            // Convert to CSV format
                            const rows = data.values || [];
                            if (rows.length === 0) {
                                throw new Error('Sheet appears to be empty');
                            }
                            const csvRows = rows.map(row => {
                                // Escape commas and quotes in CSV
                                return row.map(cell => {
                                    if (cell === null || cell === undefined) return '';
                                    const cellStr = String(cell);
                                    if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                                        return `"${cellStr.replace(/"/g, '""')}"`;
                                    }
                                    return cellStr;
                                }).join(',');
                            });
                            return csvRows.join('\n');
                        } else if (response.status === 401) {
                            // Token expired or invalid, try to re-authorize
                            googleAccessToken = null;
                            localStorage.removeItem('google_access_token');
                            localStorage.removeItem('google_token_expiry');
                            throw new Error('AUTH_REQUIRED');
                        } else {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }
                    } catch (apiError) {
                        if (apiError.message === 'AUTH_REQUIRED') {
                            throw apiError;
                        }
                        console.warn('Google Sheets API failed, falling back to CSV export:', apiError);
                        // Fall through to CSV export
                    }
                }

                // Fallback to public CSV export
                const csvUrl = getGoogleSheetCSVUrl(sheetInfo.sheetId, sheetInfo.gid);
                const response = await fetch(csvUrl);
                if (!response.ok) {
                    if (useAuth && !googleAccessToken) {
                        throw new Error('AUTH_REQUIRED');
                    }
                    throw new Error(`Failed to fetch Google Sheet: ${response.status} ${response.statusText}. The sheet may be private. Please authorize access or make the sheet publicly viewable.`);
                }
                
                const csvText = await response.text();
                return csvText;
            } catch (error) {
                console.error('Error fetching Google Sheet:', error);
                throw error;
            }
        }

        function saveRiderGoogleSheetUrl() {
            const urlInput = document.getElementById('rider-google-sheet-url');
            if (!urlInput) return;
            
            const url = urlInput.value.trim();
            if (!url) {
                alert('Please enter a Google Sheets URL.');
                return;
            }

            // Validate URL
            const sheetInfo = extractGoogleSheetId(url);
            if (!sheetInfo) {
                alert('Invalid Google Sheets URL. Please use a URL like: https://docs.google.com/spreadsheets/d/SHEET_ID/edit');
                return;
            }

            // Save to settings
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            data.seasonSettings.riderGoogleSheetUrl = url;
            saveData();
            
            alert('Google Sheet URL saved! You can now use "Sync from Google Sheet" to update riders.');
        }

        function saveCoachGoogleSheetUrl() {
            const urlInput = document.getElementById('coach-google-sheet-url');
            if (!urlInput) return;
            
            const url = urlInput.value.trim();
            if (!url) {
                alert('Please enter a Google Sheets URL.');
                return;
            }

            // Validate URL
            const sheetInfo = extractGoogleSheetId(url);
            if (!sheetInfo) {
                alert('Invalid Google Sheets URL. Please use a URL like: https://docs.google.com/spreadsheets/d/SHEET_ID/edit');
                return;
            }

            // Save to settings
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            data.seasonSettings.coachGoogleSheetUrl = url;
            saveData();
            
            alert('Google Sheet URL saved! You can now use "Sync from Google Sheet" to update coaches.');
        }

        // Save Google Client ID
        function saveGoogleClientId() {
            const clientIdInput = document.getElementById('modal-google-client-id');
            if (!clientIdInput) return;
            
            const clientId = clientIdInput.value.trim();
            if (!clientId) {
                alert('Please enter a Google OAuth Client ID.');
                return;
            }

            // Save to settings
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            data.seasonSettings.googleClientId = clientId;
            saveData();
            
            // Re-initialize OAuth with new client ID
            initGoogleOAuth();
            updateGoogleAuthStatus();
            
            alert('Google Client ID saved! You can now authorize access to private Google Sheets.');
        }

        // Open Google Sheets modal
        function openGoogleSheetsModal(type) {
            const modal = document.getElementById('google-sheets-modal');
            const title = document.getElementById('google-sheets-modal-title');
            const urlInput = document.getElementById('modal-google-sheet-url');
            const clientIdInput = document.getElementById('modal-google-client-id');
            const note = document.getElementById('modal-google-sheets-note');
            
            if (!modal) return;
            
            // Set type (riders or coaches)
            modal.dataset.syncType = type;
            
            // Update title
            if (title) {
                title.textContent = `Sync ${type === 'riders' ? 'Riders' : 'Coaches'} from Google Sheet`;
            }
            
            // Load Client ID
            if (clientIdInput) {
                clientIdInput.value = getGoogleClientId() || '';
            }
            
            // Load URL
            if (urlInput) {
                const urlKey = type === 'riders' ? 'riderGoogleSheetUrl' : 'coachGoogleSheetUrl';
                urlInput.value = data.seasonSettings?.[urlKey] || '';
            }
            
            // Update note
            if (note) {
                if (type === 'riders') {
                    note.innerHTML = '<strong>Note:</strong> Only updates: name, email, phone, grade, gender, address, parent info, medical info.<br>Preserves: fitness, bike skills, photo, notes, racing group.';
                } else {
                    note.innerHTML = '<strong>Note:</strong> Only updates: name, email, phone, level, gender, registration info.<br>Preserves: fitness, photo, notes.';
                }
            }
            
            // Update auth status
            updateGoogleAuthStatus();
            
            // Show modal
            modal.style.display = 'flex';
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeGoogleSheetsModal() {
            const modal = document.getElementById('google-sheets-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        function saveModalGoogleSheetUrl() {
            const modal = document.getElementById('google-sheets-modal');
            const type = modal?.dataset.syncType;
            const urlInput = document.getElementById('modal-google-sheet-url');
            
            if (!type || !urlInput) return;
            
            const url = urlInput.value.trim();
            if (!url) {
                alert('Please enter a Google Sheets URL.');
                return;
            }

            // Validate URL
            const sheetInfo = extractGoogleSheetId(url);
            if (!sheetInfo) {
                alert('Invalid Google Sheets URL. Please use a URL like: https://docs.google.com/spreadsheets/d/SHEET_ID/edit');
                return;
            }

            // Save to settings
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            const urlKey = type === 'riders' ? 'riderGoogleSheetUrl' : 'coachGoogleSheetUrl';
            data.seasonSettings[urlKey] = url;
            saveData();
            
            alert('Google Sheet URL saved!');
        }

        async function syncFromModal() {
            const modal = document.getElementById('google-sheets-modal');
            const type = modal?.dataset.syncType;
            
            if (!type) return;
            
            if (type === 'riders') {
                await syncRidersFromGoogleSheet();
            } else {
                await syncCoachesFromGoogleSheet();
            }
            
            // Close modal after sync
            closeGoogleSheetsModal();
        }

        async function syncRidersFromGoogleSheet() {
            const url = data.seasonSettings?.riderGoogleSheetUrl;
            if (!url) {
                alert('No Google Sheet URL configured. Please enter a URL and click "Save Link" first.');
                return;
            }

            if (!confirm('Sync riders from Google Sheet? This will update existing riders and add new ones, but will preserve fitness, bike skills, photo, and notes.')) {
                return;
            }

            try {
                // Load stored token or initialize OAuth
                loadGoogleToken();
                if (!googleAccessToken && getGoogleClientId()) {
                    initGoogleOAuth();
                }

                // Show loading message
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'google-sheet-loading';
                loadingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #2196F3; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                loadingMsg.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">⏳</div><div>Fetching data from Google Sheet...</div></div>';
                document.body.appendChild(loadingMsg);

                // Fetch CSV from Google Sheet
                let csvText;
                try {
                    csvText = await fetchGoogleSheetCSV(url, true);
                } catch (error) {
                    if (error.message === 'AUTH_REQUIRED') {
                        // Remove loading message
                        document.body.removeChild(loadingMsg);
                        
                        // Request authorization
                        if (confirm('This Google Sheet requires authorization. Click OK to authorize access to your Google account.')) {
                            const authorized = await authorizeGoogle();
                            if (!authorized) {
                                alert('Authorization failed. Please try again or make the sheet publicly viewable.');
                                return;
                            }
                            
                            // Show loading again
                            document.body.appendChild(loadingMsg);
                            csvText = await fetchGoogleSheetCSV(url, true);
                        } else {
                            return;
                        }
                    } else {
                        throw error;
                    }
                }
                
                // Remove loading message
                document.body.removeChild(loadingMsg);

                // Parse CSV to get headers
                const parsed = parseCSV(csvText);
                if (parsed.length < 2) {
                    alert('Google Sheet must contain at least a header row and one data row.');
                    return;
                }
                
                // Store for mapping
                pendingCSVData = csvText;
                pendingCSVType = 'riders';
                pendingCSVHeaders = parsed[0];
                
                // Show mapping modal
                openCSVFieldMappingModal('riders', parsed[0]);
            } catch (error) {
                const loadingMsg = document.getElementById('google-sheet-loading');
                if (loadingMsg) document.body.removeChild(loadingMsg);
                
                console.error('Error syncing from Google Sheet:', error);
                const errorMsg = error.message || 'Unknown error';
                if (errorMsg.includes('AUTH_REQUIRED')) {
                    alert('This Google Sheet requires authorization. Please authorize access or make the sheet publicly viewable (Share > Anyone with the link can view).');
                } else {
                    alert('Error syncing from Google Sheet: ' + errorMsg + '\n\nMake sure:\n1. The Google Sheet URL is correct\n2. You have authorized access (if the sheet is private)\n3. The sheet has a header row');
                }
            }
        }

        async function syncCoachesFromGoogleSheet() {
            const url = data.seasonSettings?.coachGoogleSheetUrl;
            if (!url) {
                alert('No Google Sheet URL configured. Please enter a URL and click "Save Link" first.');
                return;
            }

            if (!confirm('Sync coaches from Google Sheet? This will update existing coaches and add new ones, but will preserve fitness, photo, and notes.')) {
                return;
            }

            try {
                // Load stored token or initialize OAuth
                loadGoogleToken();
                if (!googleAccessToken && getGoogleClientId()) {
                    initGoogleOAuth();
                }

                // Show loading message
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'google-sheet-loading';
                loadingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #2196F3; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                loadingMsg.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">⏳</div><div>Fetching data from Google Sheet...</div></div>';
                document.body.appendChild(loadingMsg);

                // Fetch CSV from Google Sheet
                let csvText;
                try {
                    csvText = await fetchGoogleSheetCSV(url, true);
                } catch (error) {
                    if (error.message === 'AUTH_REQUIRED') {
                        // Remove loading message
                        document.body.removeChild(loadingMsg);
                        
                        // Request authorization
                        if (confirm('This Google Sheet requires authorization. Click OK to authorize access to your Google account.')) {
                            const authorized = await authorizeGoogle();
                            if (!authorized) {
                                alert('Authorization failed. Please try again or make the sheet publicly viewable.');
                                return;
                            }
                            
                            // Show loading again
                            document.body.appendChild(loadingMsg);
                            csvText = await fetchGoogleSheetCSV(url, true);
                        } else {
                            return;
                        }
                    } else {
                        throw error;
                    }
                }
                
                // Remove loading message
                document.body.removeChild(loadingMsg);

                // Parse CSV to get headers
                const parsed = parseCSV(csvText);
                if (parsed.length < 2) {
                    alert('Google Sheet must contain at least a header row and one data row.');
                    return;
                }
                
                // Store for mapping
                pendingCSVData = csvText;
                pendingCSVType = 'coaches';
                pendingCSVHeaders = parsed[0];
                
                // Show mapping modal
                openCSVFieldMappingModal('coaches', parsed[0]);
            } catch (error) {
                const loadingMsg = document.getElementById('google-sheet-loading');
                if (loadingMsg) document.body.removeChild(loadingMsg);
                
                console.error('Error syncing from Google Sheet:', error);
                const errorMsg = error.message || 'Unknown error';
                if (errorMsg.includes('AUTH_REQUIRED')) {
                    alert('This Google Sheet requires authorization. Please authorize access or make the sheet publicly viewable (Share > Anyone with the link can view).');
                } else {
                    alert('Error syncing from Google Sheet: ' + errorMsg + '\n\nMake sure:\n1. The Google Sheet URL is correct\n2. You have authorized access (if the sheet is private)\n3. The sheet has a header row');
                }
            }
        }

        // Store CSV data and headers for mapping
        let pendingCSVData = null;
        let pendingCSVType = null; // 'riders' or 'coaches'
        let pendingCSVHeaders = null;
        let csvFieldMapping = null; // Will store user's field mappings
        let additionalFieldCounter = 0; // Counter for additional fields

        // Update riders from CSV file picker
        function updateRidersFromCSVFile() {
            if (!confirm('This will update existing riders, add new riders from CSV, and remove riders not in CSV. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const ridersText = await readFileAsText(file);
                    // Parse CSV to get headers
                    const parsed = parseCSV(ridersText);
                    if (parsed.length < 2) {
                        alert('CSV file must contain at least a header row and one data row.');
                        return;
                    }
                    
                    // Store for mapping
                    pendingCSVData = ridersText;
                    pendingCSVType = 'riders';
                    pendingCSVHeaders = parsed[0];
                    
                    // Show mapping modal
                    openCSVFieldMappingModal('riders', parsed[0]);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }

        // Update coaches from CSV file picker
        function updateCoachesFromCSVFile() {
            if (!confirm('This will update existing coaches, add new coaches from CSV, and remove coaches not in CSV. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const coachesText = await readFileAsText(file);
                    // Parse CSV to get headers
                    const parsed = parseCSV(coachesText);
                    if (parsed.length < 2) {
                        alert('CSV file must contain at least a header row and one data row.');
                        return;
                    }
                    
                    // Store for mapping
                    pendingCSVData = coachesText;
                    pendingCSVType = 'coaches';
                    pendingCSVHeaders = parsed[0];
                    
                    // Show mapping modal
                    openCSVFieldMappingModal('coaches', parsed[0]);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // Purge all riders
        function purgeRiders() {
            if (!confirm('Are you sure you want to delete ALL riders? This action cannot be undone.')) {
                return;
            }
            
            if (!confirm('This will permanently delete all rider records. Are you absolutely sure?')) {
                return;
            }
            
            data.riders = [];
            saveData();
            renderRiders();
            alert('All riders have been deleted.');
        }
        
        // Purge all coaches
        async function purgeCoaches() {
            if (!confirm('Are you sure you want to delete ALL coaches? This action cannot be undone.')) {
                return;
            }
            
            if (!confirm('This will permanently delete all coach records. Are you absolutely sure?')) {
                return;
            }
            try {
                const client = getSupabaseClient();
                const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
                if (client && currentUser && typeof deleteCoachFromDB === 'function') {
                    for (const coach of data.coaches) {
                        await deleteCoachFromDB(coach.id);
                    }
                }
            } catch (error) {
                console.error('Error deleting coaches from database:', error);
                alert(error.message || 'Failed to delete all coaches.');
                return;
            }
            
            data.coaches = [];
            saveData();
            renderCoaches();
            alert('All coaches have been deleted.');
        }
        
        // Process riders CSV import
        async function processRidersCSVImport(ridersText) {
            try {
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = riders[0];
                const headerMap = getRiderHeaderMap(headers);

                // Import riders
                const importedRiders = [];
                for (let i = 1; i < riders.length; i++) { // Skip header row
                    const row = riders[i];
                    if (!row || row.length === 0) continue; // Skip empty rows

                    // Get name fields using header map
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    const firstName = (row[firstNameIdx] || '').trim();
                    const lastName = (row[lastNameIdx] || '').trim();
                    if (!firstName && !lastName) continue;

                    const name = `${firstName} ${lastName}`.trim();

                    // Get gender and determine default photo
                    const genderIdx = headerMap['gender'];
                    const genderRaw = genderIdx !== undefined ? (row[genderIdx] || '').trim().toUpperCase() : '';
                    let gender = '';
                    if (genderRaw === 'M' || genderRaw === 'MALE' || genderRaw === 'MALE') gender = 'M';
                    else if (genderRaw === 'F' || genderRaw === 'FEMALE' || genderRaw === 'FEMALE') gender = 'F';
                    else if (genderRaw === 'NB' || genderRaw === 'NONBINARY' || genderRaw === 'NON-BINARY') gender = 'NB';

                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    // Helper function to get value from CSV row using header map
                    const getValue = (fieldName) => {
                        const idx = headerMap[fieldName];
                        return idx !== undefined ? (row[idx] || '').trim() : '';
                    };

                    // Helper function to get phone value
                    const getPhoneValue = (fieldName) => {
                        const val = getValue(fieldName);
                        return normalizePhoneNumber(val);
                    };

                    // Get grade
                    const gradeRaw = getValue('grade');
                    const grade = normalizeGradeValue(gradeRaw);

                    const riderData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + i * 1000,
                        name: name,
                        firstName,
                        lastName,
                        photo: defaultPhoto,
                        email: getValue('email'),
                        phone: getPhoneValue('phone'),
                        address: getValue('address'),
                        gender: gender,
                        grade: grade,
                        birthday: getValue('birthday'),
                        primaryParentName: getValue('primaryParentName'),
                        primaryParentPhone: getPhoneValue('primaryParentPhone'),
                        primaryParentEmail: getValue('primaryParentEmail'),
                        primaryParentAddress: getValue('primaryParentAddress'),
                        secondParentName: getValue('secondParentName'),
                        secondParentPhone: getPhoneValue('secondParentPhone'),
                        secondParentEmail: getValue('secondParentEmail'),
                        alternateContactName: getValue('alternateContactName'),
                        alternateContactRelationship: getValue('alternateContactRelationship'),
                        alternateContactPhone: getPhoneValue('alternateContactPhone'),
                        primaryPhysician: getValue('primaryPhysician'),
                        primaryPhysicianPhone: getPhoneValue('primaryPhysicianPhone'),
                        medicalInsuranceCompany: getValue('medicalInsuranceCompany'),
                        medicalInsuranceAccountNumber: getValue('medicalInsuranceAccountNumber'),
                        allergiesOrMedicalNeeds: getValue('allergiesOrMedicalNeeds'),
                        // Default values for fields not in CSV
                        racingGroup: 'Freshman',
                        fitness: String(Math.ceil(getFitnessScale() / 2)),
                        skills: String(Math.ceil(getSkillsScale() / 2)),
                        notes: ''
                    };
                    importedRiders.push(riderData);
                }

                // COMPLETELY REPLACE existing rider data
                data.riders = [];
                data.riders = importedRiders;
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderRiders();

                alert(`Successfully imported ${importedRiders.length} riders from CSV file.\n\nAll existing rider data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Process coaches CSV import
        async function processCoachesCSVImport(coachesText) {
            try {
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = coaches[0];
                const headerMap = getCoachHeaderMap(headers);

                // Import coaches
                const importedCoaches = [];
                for (let i = 1; i < coaches.length; i++) { // Skip header row
                    const row = coaches[i];
                    if (!row || row.length === 0) continue; // Skip empty rows

                    // Get name fields using header map
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    const lastName = (row[lastNameIdx] || '').trim();
                    const firstName = (row[firstNameIdx] || '').trim();
                    if (!firstName && !lastName) continue;

                    const name = `${firstName} ${lastName}`.trim();

                    // Helper function to get value from CSV row using header map
                    const getValue = (fieldName) => {
                        const idx = headerMap[fieldName];
                        if (idx === undefined) {
                            // Debug: log missing header mapping for important fields
                            if (fieldName === 'coachingLicenseLevel') {
                                console.log('Warning: coachingLicenseLevel header not found in CSV. Available headers:', headers);
                                console.log('Normalized headers:', headers.map(h => normalizeHeaderName(h)));
                                console.log('Header map:', headerMap);
                            }
                            return '';
                        }
                        const rawValue = row[idx];
                        const value = (rawValue || '').trim();
                        // Debug for license level
                        if (fieldName === 'coachingLicenseLevel') {
                            console.log(`Coach: ${name}, Column index: ${idx}, Raw CSV value: "${rawValue}", Trimmed: "${value}"`);
                        }
                        return value;
                    };

                    // Helper function to get phone value
                    const getPhoneValue = (fieldName) => {
                        const val = getValue(fieldName);
                        return normalizePhoneNumber(val);
                    };

                    // Get license level - handle various formats
                    const licenseLevelRaw = getValue('coachingLicenseLevel');
                    if (!licenseLevelRaw) {
                        console.log(`No license level value found for coach: ${name} (header map has index: ${headerMap['coachingLicenseLevel']})`);
                    }
                    const licenseLevelNormalized = licenseLevelRaw.trim().toUpperCase();
                    let licenseLevel = 'N/A';
                    
                    // Check for just the number (1, 2, 3) or with "LEVEL" prefix, handle various formats
                    // First check for exact number matches
                    if (licenseLevelNormalized === '1' || licenseLevelNormalized === 'LEVEL 1' || licenseLevelNormalized === 'LEVEL1' || licenseLevelNormalized === 'L1') {
                        licenseLevel = '1';
                    } else if (licenseLevelNormalized === '2' || licenseLevelNormalized === 'LEVEL 2' || licenseLevelNormalized === 'LEVEL2' || licenseLevelNormalized === 'L2') {
                        licenseLevel = '2';
                    } else if (licenseLevelNormalized === '3' || licenseLevelNormalized === 'LEVEL 3' || licenseLevelNormalized === 'LEVEL3' || licenseLevelNormalized === 'L3') {
                        licenseLevel = '3';
                    } else if (licenseLevelNormalized === 'N/A' || licenseLevelNormalized === 'NA' || licenseLevelNormalized === '' || licenseLevelNormalized === 'NULL' || licenseLevelNormalized === 'NONE') {
                        licenseLevel = 'N/A';
                    } else {
                        // Try to extract number from the string (e.g., "Level 1", "1", etc.)
                        const numberMatch = licenseLevelNormalized.match(/\b([123])\b/);
                        if (numberMatch) {
                            licenseLevel = numberMatch[1];
                            console.log(`Extracted license level "${licenseLevel}" from "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}") for coach: ${name}`);
                        } else {
                            // Debug: log unexpected values
                            console.log('Unexpected license level value:', licenseLevelNormalized, '(raw:', licenseLevelRaw, ') for coach:', name);
                        }
                    }

                    // Get gender
                    const genderRaw = getValue('gender').toUpperCase();
                    let gender = '';
                    if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                    else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                    else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                    // Determine default photo based on gender
                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    const coachData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + i * 10000,
                        name: name,
                        firstName,
                        lastName,
                        photo: defaultPhoto,
                        phone: getPhoneValue('phone'),
                        email: getValue('email'),
                        coachingLicenseLevel: licenseLevel,
                        workPhone: getPhoneValue('workPhone'),
                        homePhone: getPhoneValue('homePhone'),
                        gender: gender,
                        registered: getValue('registered'),
                        paid: getValue('paid'),
                        backgroundCheck: getValue('backgroundCheck'),
                        level3ExamCompleted: getValue('level3ExamCompleted'),
                        pduCeuUnits: getValue('pduCeuUnits'),
                        fieldWorkHours: getValue('fieldWorkHours'),
                        firstAidTypeExpires: getValue('firstAidTypeExpires'),
                        cprExpires: getValue('cprExpires'),
                        concussionTrainingCompleted: getValue('concussionTrainingCompleted'),
                        nicaPhilosophyCompleted: getValue('nicaPhilosophyCompleted'),
                        athleteAbuseAwarenessCompleted: getValue('athleteAbuseAwarenessCompleted'),
                        licenseLevel1Completed: getValue('licenseLevel1Completed'),
                        licenseLevel2Completed: getValue('licenseLevel2Completed'),
                        licenseLevel3Completed: getValue('licenseLevel3Completed'),
                        otbSkills101ClassroomCompleted: getValue('otbSkills101ClassroomCompleted'),
                        otbSkills101OutdoorCompleted: getValue('otbSkills101OutdoorCompleted'),
                        nicaLeaderSummitCompleted: getValue('nicaLeaderSummitCompleted'),
                        // Default values for fields not in CSV
                        fitness: String(Math.ceil(getFitnessScale() / 2)),
                        skills: String(Math.ceil(getSkillsScale() / 2)),
                        notes: ''
                    };
                    importedCoaches.push(coachData);
                }

                // COMPLETELY REPLACE existing coach data
                data.coaches = [];
                data.coaches = importedCoaches;
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderCoaches();

                alert(`Successfully imported ${importedCoaches.length} coaches from CSV file.\n\nAll existing coach data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        function parseCSV(text) {
            const lines = [];
            let currentLine = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    currentLine.push(currentField);
                    currentField = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && nextChar === '\n') {
                        i++; // Skip \n after \r
                    }
                    currentLine.push(currentField);
                    lines.push(currentLine);
                    currentLine = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }

            // Add last field and line
            if (currentField || currentLine.length > 0) {
                currentLine.push(currentField);
                lines.push(currentLine);
            }

            return lines;
        }

        // Helper function to normalize CSV header names for matching
        function normalizeHeaderName(header) {
            return header.trim().toLowerCase()
                .replace(/[^a-z0-9]/g, '')
                .replace(/\s+/g, '');
        }

        // Map CSV headers to rider field names
        function getRiderHeaderMap(headers) {
            const map = {};
            headers.forEach((header, index) => {
                const normalized = normalizeHeaderName(header);
                // Map common variations
                if (normalized.includes('firstname') || normalized === 'firstname') {
                    map['firstName'] = index;
                } else if (normalized.includes('lastname') || normalized === 'lastname') {
                    map['lastName'] = index;
                } else if (normalized.includes('rideremail') || normalized.includes('email') && !normalized.includes('parent')) {
                    map['email'] = index;
                } else if (normalized.includes('ridercell') || normalized.includes('cellnumber') || (normalized.includes('phone') && !normalized.includes('parent'))) {
                    map['phone'] = index;
                } else if (normalized.includes('rideraddress') || normalized.includes('address') && !normalized.includes('parent')) {
                    map['address'] = index;
                } else if (normalized.includes('ridergender') || normalized.includes('gender') && !normalized.includes('parent')) {
                    map['gender'] = index;
                } else if (normalized.includes('ridergrade') || normalized.includes('grade') && !normalized.includes('parent')) {
                    map['grade'] = index;
                } else if (normalized.includes('riderbirthday') || normalized.includes('birthday')) {
                    map['birthday'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('cell')) {
                    // Check for "Primary Parent/Guardian Cell Number" - must check cell before name to avoid false matches
                    map['primaryParentPhone'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('email')) {
                    // Check for "Primary Parent/Guardian Email"
                    map['primaryParentEmail'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('address')) {
                    // Check for "Primary Parent/Guardian Address if different"
                    map['primaryParentAddress'] = index;
                } else if (normalized.includes('primaryparentguardian') || (normalized.includes('primaryparent') && normalized.includes('name'))) {
                    // Check for "Primary Parent/Guardian" - must be last to avoid matching other primary parent fields
                    map['primaryParentName'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('name')) {
                    map['secondParentName'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('cell')) {
                    map['secondParentPhone'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('email')) {
                    map['secondParentEmail'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('contact') && normalized.includes('name')) {
                    map['alternateContactName'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('relationship')) {
                    map['alternateContactRelationship'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('cell')) {
                    map['alternateContactPhone'] = index;
                } else if (normalized.includes('primaryphysician') && !normalized.includes('phone')) {
                    map['primaryPhysician'] = index;
                } else if (normalized.includes('primaryphysician') && normalized.includes('phone')) {
                    map['primaryPhysicianPhone'] = index;
                } else if (normalized.includes('medicalinsurance') && normalized.includes('company')) {
                    map['medicalInsuranceCompany'] = index;
                } else if (normalized.includes('medicalinsurance') && (normalized.includes('account') || normalized.includes('number'))) {
                    map['medicalInsuranceAccountNumber'] = index;
                } else if (normalized.includes('allerg') || normalized.includes('medicalneeds')) {
                    map['allergiesOrMedicalNeeds'] = index;
                }
            });
            return map;
        }

        // Map CSV headers to coach field names
        function getCoachHeaderMap(headers) {
            const map = {};
            headers.forEach((header, index) => {
                const normalized = normalizeHeaderName(header);
                if (normalized.includes('lastname') || normalized === 'lastname') {
                    map['lastName'] = index;
                } else if (normalized.includes('firstname') || normalized === 'firstname') {
                    map['firstName'] = index;
                } else if (normalized.includes('coachinglicenselevel') || 
                          (normalized.includes('license') && normalized.includes('level') && !normalized.includes('completed'))) {
                    // Only map if not already mapped (prefer more specific matches)
                    // Match "coaching license level" or "license level" but exclude "license level 1 completed" etc.
                    if (!map['coachingLicenseLevel']) {
                        map['coachingLicenseLevel'] = index;
                    }
                } else if (normalized.includes('email') && !normalized.includes('parent')) {
                    map['email'] = index;
                } else if (normalized.includes('cellphone') || (normalized.includes('phone') && !normalized.includes('work') && !normalized.includes('home'))) {
                    map['phone'] = index;
                } else if (normalized.includes('workphone')) {
                    map['workPhone'] = index;
                } else if (normalized.includes('homephone')) {
                    map['homePhone'] = index;
                } else if (normalized.includes('gender')) {
                    map['gender'] = index;
                } else if (normalized.includes('registered')) {
                    map['registered'] = index;
                } else if (normalized.includes('paid')) {
                    map['paid'] = index;
                } else if (normalized.includes('backgroundcheck')) {
                    map['backgroundCheck'] = index;
                } else if (normalized.includes('level3exam')) {
                    map['level3ExamCompleted'] = index;
                } else if (normalized.includes('pdu') || normalized.includes('ceu')) {
                    map['pduCeuUnits'] = index;
                } else if (normalized.includes('fieldwork')) {
                    map['fieldWorkHours'] = index;
                } else if (normalized.includes('firstaid')) {
                    map['firstAidTypeExpires'] = index;
                } else if (normalized.includes('cpr') && normalized.includes('expires')) {
                    map['cprExpires'] = index;
                } else if (normalized.includes('concussion')) {
                    map['concussionTrainingCompleted'] = index;
                } else if (normalized.includes('nicaphilosophy') || normalized.includes('safetyrisk')) {
                    map['nicaPhilosophyCompleted'] = index;
                } else if (normalized.includes('athleteabuse')) {
                    map['athleteAbuseAwarenessCompleted'] = index;
                } else if (normalized.includes('licenselevel1')) {
                    map['licenseLevel1Completed'] = index;
                } else if (normalized.includes('licenselevel2')) {
                    map['licenseLevel2Completed'] = index;
                } else if (normalized.includes('licenselevel3')) {
                    map['licenseLevel3Completed'] = index;
                } else if (normalized.includes('otbskills101classroom')) {
                    map['otbSkills101ClassroomCompleted'] = index;
                } else if (normalized.includes('otbskills101outdoor') || normalized.includes('otbskills101training')) {
                    map['otbSkills101OutdoorCompleted'] = index;
                } else if (normalized.includes('nicaleadersummit')) {
                    map['nicaLeaderSummitCompleted'] = index;
                }
            });
            return map;
        }

        // Define all possible rider fields
        const RIDER_FIELDS = [
            // Name fields (handled separately based on format)
            { key: 'name', label: 'Name (Full)', required: true },
            // Required/Program-dependent (can be mapped but not unchecked)
            { key: 'firstName', label: 'First Name', required: true },
            { key: 'lastName', label: 'Last Name', required: true },
            { key: 'fitness', label: 'Pace (Relative Pace)', required: true, programDependent: true },
            { key: 'skills', label: 'Bike Skills', required: true, programDependent: true },
            { key: 'racingGroup', label: 'Ride Group', required: true, programDependent: true },
            { key: 'photo', label: 'Photo', required: true, programDependent: true },
            { key: 'notes', label: 'Notes', required: true, programDependent: true },
            // Optional fields
            { key: 'email', label: 'Email', required: false },
            { key: 'phone', label: 'Phone', required: false },
            { key: 'address', label: 'Address', required: false },
            { key: 'gender', label: 'Gender', required: false },
            { key: 'grade', label: 'Grade', required: false },
            { key: 'birthday', label: 'Birthday', required: false },
            { key: 'primaryParentName', label: 'Primary Parent Name', required: false },
            { key: 'primaryParentPhone', label: 'Primary Parent Phone', required: false },
            { key: 'primaryParentEmail', label: 'Primary Parent Email', required: false },
            { key: 'primaryParentAddress', label: 'Primary Parent Address', required: false },
            { key: 'secondParentName', label: 'Second Parent Name', required: false },
            { key: 'secondParentPhone', label: 'Second Parent Phone', required: false },
            { key: 'secondParentEmail', label: 'Second Parent Email', required: false },
            { key: 'alternateContactName', label: 'Alternate Contact Name', required: false },
            { key: 'alternateContactRelationship', label: 'Alternate Contact Relationship', required: false },
            { key: 'alternateContactPhone', label: 'Alternate Contact Phone', required: false },
            { key: 'primaryPhysician', label: 'Primary Physician', required: false },
            { key: 'primaryPhysicianPhone', label: 'Primary Physician Phone', required: false },
            { key: 'medicalInsuranceCompany', label: 'Medical Insurance Company', required: false },
            { key: 'medicalInsuranceAccountNumber', label: 'Medical Insurance Account Number', required: false },
            { key: 'allergiesOrMedicalNeeds', label: 'Allergies or Medical Needs', required: false }
        ];

        // Define all possible coach fields
        const COACH_FIELDS = [
            // Name fields (handled separately based on format)
            { key: 'name', label: 'Name (Full)', required: true },
            // Required/Program-dependent (can be mapped but not unchecked)
            { key: 'firstName', label: 'First Name', required: true },
            { key: 'lastName', label: 'Last Name', required: true },
            { key: 'fitness', label: 'Pace (Relative Pace)', required: true, programDependent: true },
            { key: 'photo', label: 'Photo', required: true, programDependent: true },
            { key: 'notes', label: 'Notes', required: true, programDependent: true },
            // Optional fields
            { key: 'email', label: 'Email', required: false },
            { key: 'phone', label: 'Phone', required: false },
            { key: 'workPhone', label: 'Work Phone', required: false },
            { key: 'homePhone', label: 'Home Phone', required: false },
            { key: 'gender', label: 'Gender', required: false },
            { key: 'coachingLicenseLevel', label: 'Coaching License Level', required: false },
            { key: 'registered', label: 'Registered', required: false },
            { key: 'paid', label: 'Paid', required: false },
            { key: 'backgroundCheck', label: 'Background Check', required: false },
            { key: 'level3ExamCompleted', label: 'Level 3 Exam Completed', required: false },
            { key: 'pduCeuUnits', label: 'PDU/CEU Units', required: false },
            { key: 'fieldWorkHours', label: 'Field Work Hours', required: false },
            { key: 'firstAidTypeExpires', label: 'First Aid Type/Expires', required: false },
            { key: 'cprExpires', label: 'CPR Expires', required: false },
            { key: 'concussionTrainingCompleted', label: 'Concussion Training Completed', required: false },
            { key: 'nicaPhilosophyCompleted', label: 'NICA Philosophy Completed', required: false },
            { key: 'athleteAbuseAwarenessCompleted', label: 'Athlete Abuse Awareness Completed', required: false },
            { key: 'licenseLevel1Completed', label: 'License Level 1 Completed', required: false },
            { key: 'licenseLevel2Completed', label: 'License Level 2 Completed', required: false },
            { key: 'licenseLevel3Completed', label: 'License Level 3 Completed', required: false },
            { key: 'otbSkills101ClassroomCompleted', label: 'OTB Skills 101 Classroom Completed', required: false },
            { key: 'otbSkills101OutdoorCompleted', label: 'OTB Skills 101 Outdoor Completed', required: false },
            { key: 'nicaLeaderSummitCompleted', label: 'NICA Leader Summit Completed', required: false }
        ];

        // Open CSV field mapping modal
        function openCSVFieldMappingModal(type, csvHeaders, isImport = false) {
            const modal = document.getElementById('csv-field-mapping-modal');
            const title = document.getElementById('csv-mapping-modal-title');
            const container = document.getElementById('csv-field-mapping-container');
            
            if (!modal || !container) return;
            
            // Set type
            pendingCSVType = type;
            if (isImport) {
                pendingCSVType = type + '_import'; // Mark as import (replace all)
            }
            
            // Update title
            if (title) {
                const action = isImport ? 'Import' : 'Update';
                const entity = type === 'riders' ? 'Riders' : 'Coaches';
                title.textContent = `Map CSV Fields - ${action} ${entity}`;
            }
            
            // Get field definitions
            const fields = type === 'riders' ? RIDER_FIELDS : COACH_FIELDS;
            
            // Get auto-mapped header map for initial suggestions
            const autoMap = type === 'riders' ? getRiderHeaderMap(csvHeaders) : getCoachHeaderMap(csvHeaders);
            
            // Load saved mapping settings if available
            // Make sure data is loaded first
            if (!data.seasonSettings) {
                console.warn('seasonSettings not loaded yet, attempting to load data');
                // Try to load from localStorage directly
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        if (parsed.seasonSettings) {
                            data.seasonSettings = parsed.seasonSettings;
                        }
                    }
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                }
            }
            
            const savedMapping = data.seasonSettings?.csvFieldMappings?.[type];
            const savedNameFormat = savedMapping?.nameFormat || 'split';
            
            // Debug: Log what we're loading
            console.log('Opening CSV mapping modal for type:', type);
            console.log('Current data.seasonSettings:', data.seasonSettings);
            console.log('Looking for csvFieldMappings:', data.seasonSettings?.csvFieldMappings);
            console.log('Saved mapping for', type, ':', savedMapping);
            
            // Set name format radio button if saved
            const nameFormatRadio = document.getElementById(savedNameFormat === 'single' ? 'name-format-single' : 'name-format-split');
            const otherRadio = document.getElementById(savedNameFormat === 'single' ? 'name-format-split' : 'name-format-single');
            if (savedMapping && nameFormatRadio) {
                nameFormatRadio.checked = true;
                if (otherRadio) {
                    otherRadio.checked = false;
                }
            }
            
            // Clear container and reset additional fields counter
            container.innerHTML = '';
            additionalFieldCounter = 0;
            
            // Clear additional fields list
            const additionalFieldsList = document.getElementById('additional-fields-list');
            if (additionalFieldsList) {
                additionalFieldsList.innerHTML = '';
            }
            
            // Create table header
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.fontSize = '13px';
            
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">
                    <th style="padding: 8px; text-align: left; width: 200px;">Program Field</th>
                    <th style="padding: 8px; text-align: left; width: 80px;">Import?</th>
                    <th style="padding: 8px; text-align: left;">Map to CSV Column</th>
                </tr>
            `;
            table.appendChild(thead);
            
            const tbody = document.createElement('tbody');
            
            // Create dropdown option for "None"
            const noneOption = '<option value="">-- None --</option>';
            
            // Create CSV column options
            const csvOptions = csvHeaders.map((header, idx) => 
                `<option value="${idx}">${escapeHtml(header || `Column ${idx + 1}`)}</option>`
            ).join('');
            
            // Handle name format - show appropriate fields
            // Use the currently selected radio button value, not the saved one (user might be changing it)
            const checkedNameFormatRadio = document.querySelector('input[name="name-format"]:checked');
            const nameFormat = checkedNameFormatRadio ? checkedNameFormatRadio.value : (savedNameFormat || 'split');
            const showNameFields = nameFormat === 'split';
            
            // Add rows for each field
            fields.forEach(field => {
                // Skip firstName/lastName if single name format, or skip name if split format
                if (nameFormat === 'single' && (field.key === 'firstName' || field.key === 'lastName')) {
                    return; // Skip these fields
                }
                if (nameFormat === 'split' && field.key === 'name') {
                    return; // Skip name field if using split format
                }
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                
                // Get saved mapping if available, otherwise use auto-mapped column index
                const savedColumnIdx = savedMapping?.mapping?.[field.key];
                const autoMappedIdx = savedColumnIdx !== undefined ? savedColumnIdx : autoMap[field.key];
                const savedEnabled = savedMapping?.enabledFields?.[field.key];
                
                const isRequired = field.required || field.programDependent;
                const checkboxId = `field-${field.key}-enabled`;
                const selectId = `field-${field.key}-column`;
                
                row.innerHTML = `
                    <td style="padding: 8px;">
                        ${field.programDependent ? '<strong style="color: #f57c00;">' : ''}
                        ${escapeHtml(field.label)}
                        ${field.programDependent ? '</strong>' : ''}
                        ${field.programDependent ? '<br><span style="font-size: 11px; color: #666;">(Program-dependent)</span>' : ''}
                    </td>
                    <td style="padding: 8px; text-align: center;">
                        <input type="checkbox" 
                               id="${checkboxId}" 
                               ${isRequired ? 'checked disabled' : (savedEnabled !== undefined ? (savedEnabled ? 'checked' : '') : 'checked')} 
                               ${isRequired ? 'title="This field cannot be unchecked"' : ''}
                               onchange="updateFieldMappingCheckbox('${field.key}')"
                               style="cursor: ${isRequired ? 'not-allowed' : 'pointer'};">
                    </td>
                    <td style="padding: 8px;">
                        <select id="${selectId}" 
                                onchange="updateFieldMappingSelect('${field.key}')"
                                style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 4px;">
                            ${noneOption}
                            ${csvOptions}
                        </select>
                    </td>
                `;
                
                tbody.appendChild(row);
                
                // Set initial value from saved mapping or auto-mapped
                setTimeout(() => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        if (savedColumnIdx !== undefined && savedColumnIdx !== null) {
                            select.value = savedColumnIdx;
                        } else if (autoMappedIdx !== undefined) {
                            select.value = autoMappedIdx;
                        }
                    }
                }, 10);
            });
            
            // Add name format change handler
            // Remove existing listeners first to avoid duplicates
            const nameFormatRadios = document.querySelectorAll('input[name="name-format"]');
            nameFormatRadios.forEach(radio => {
                // Remove old listener by cloning
                const newRadio = radio.cloneNode(true);
                radio.parentNode.replaceChild(newRadio, radio);
                
                // Add new listener that preserves the selected value
                newRadio.addEventListener('change', (e) => {
                    console.log('Name format changed to:', e.target.value);
                    // Store the new format temporarily so rebuild uses it
                    const newFormat = e.target.value;
                    // Rebuild the table with new name format
                    // Use a small delay to ensure the radio button state is set
                    setTimeout(() => {
                        openCSVFieldMappingModal(type, csvHeaders, isImport);
                    }, 50);
                });
            });
            
            table.appendChild(tbody);
            container.appendChild(table);
            
            // Load saved additional fields if available
            if (savedMapping?.additionalFields && additionalFieldsList) {
                Object.keys(savedMapping.additionalFields).forEach(fieldName => {
                    const columnIdx = savedMapping.additionalFields[fieldName];
                    // Create additional field row
                    const fieldId = `additional-field-${additionalFieldCounter++}`;
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.alignItems = 'center';
                    row.style.padding = '8px';
                    row.style.background = 'white';
                    row.style.border = '1px solid #ddd';
                    row.style.borderRadius = '4px';
                    
                    const csvOptions = csvHeaders.map((header, idx) => 
                        `<option value="${idx}">${escapeHtml(header || `Column ${idx + 1}`)}</option>`
                    ).join('');
                    
                    row.innerHTML = `
                        <input type="text" 
                               id="${fieldId}-name" 
                               placeholder="Field name (e.g., customField1)" 
                               style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               value="${escapeHtml(fieldName)}"
                               onchange="updateAdditionalFieldName('${fieldId}')">
                        <span style="color: #666;">→</span>
                        <select id="${fieldId}-column" 
                                style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">-- Select CSV Column --</option>
                            ${csvOptions}
                        </select>
                        <button type="button" 
                                class="btn-small secondary" 
                                onclick="removeAdditionalFieldMapping('${fieldId}')"
                                style="padding: 6px 12px;">Remove</button>
                    `;
                    
                    additionalFieldsList.appendChild(row);
                    
                    // Set the column value
                    setTimeout(() => {
                        const select = document.getElementById(`${fieldId}-column`);
                        if (select && columnIdx !== null && columnIdx !== undefined) {
                            select.value = columnIdx;
                        }
                    }, 10);
                });
            }
            
            // Show modal
            modal.style.display = 'flex';
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeCSVFieldMappingModal() {
            const modal = document.getElementById('csv-field-mapping-modal');
            if (modal) {
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
            }
            // Clear pending data
            pendingCSVData = null;
            pendingCSVType = null;
            pendingCSVHeaders = null;
            csvFieldMapping = null;
        }

        function updateFieldMappingCheckbox(fieldKey) {
            const checkbox = document.getElementById(`field-${fieldKey}-enabled`);
            const select = document.getElementById(`field-${fieldKey}-column`);
            
            if (checkbox && select) {
                if (!checkbox.checked) {
                    // Unchecked - clear selection
                    select.value = '';
                }
                select.disabled = !checkbox.checked;
            }
        }

        function updateFieldMappingSelect(fieldKey) {
            // Validation can be added here if needed
        }

        // Add additional field mapping
        function addAdditionalFieldMapping() {
            const container = document.getElementById('additional-fields-list');
            if (!container || !pendingCSVHeaders) return;
            
            const fieldId = `additional-field-${additionalFieldCounter++}`;
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.gap = '8px';
            row.style.alignItems = 'center';
            row.style.padding = '8px';
            row.style.background = 'white';
            row.style.border = '1px solid #ddd';
            row.style.borderRadius = '4px';
            
            const csvOptions = pendingCSVHeaders.map((header, idx) => 
                `<option value="${idx}">${escapeHtml(header || `Column ${idx + 1}`)}</option>`
            ).join('');
            
            row.innerHTML = `
                <input type="text" 
                       id="${fieldId}-name" 
                       placeholder="Field name (e.g., customField1)" 
                       style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updateAdditionalFieldName('${fieldId}')">
                <span style="color: #666;">→</span>
                <select id="${fieldId}-column" 
                        style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="">-- Select CSV Column --</option>
                    ${csvOptions}
                </select>
                <button type="button" 
                        class="btn-small secondary" 
                        onclick="removeAdditionalFieldMapping('${fieldId}')"
                        style="padding: 6px 12px;">Remove</button>
            `;
            
            container.appendChild(row);
        }

        function removeAdditionalFieldMapping(fieldId) {
            const field = document.getElementById(`${fieldId}-name`);
            if (field && field.parentElement) {
                field.parentElement.remove();
            }
        }

        function updateAdditionalFieldName(fieldId) {
            // Validation can be added here if needed
        }

        // Apply field mapping and proceed with import
        async function applyCSVFieldMapping() {
            if (!pendingCSVData || !pendingCSVType || !pendingCSVHeaders) {
                alert('No CSV data to import.');
                return;
            }
            
            // Get name format
            const nameFormat = document.querySelector('input[name="name-format"]:checked')?.value || 'split';
            
            // Build field mapping from UI
            const type = pendingCSVType.replace('_import', '');
            const fields = type === 'riders' ? RIDER_FIELDS : COACH_FIELDS;
            const mapping = {};
            const enabledFields = {};
            const additionalFields = {};
            
            // Process standard fields
            fields.forEach(field => {
                // Skip fields based on name format
                if (nameFormat === 'single' && (field.key === 'firstName' || field.key === 'lastName')) {
                    return;
                }
                if (nameFormat === 'split' && field.key === 'name') {
                    return;
                }
                
                const checkbox = document.getElementById(`field-${field.key}-enabled`);
                const select = document.getElementById(`field-${field.key}-column`);
                
                if (checkbox && select) {
                    const isEnabled = checkbox.checked;
                    const columnIdx = select.value !== '' ? parseInt(select.value, 10) : null;
                    
                    enabledFields[field.key] = isEnabled;
                    
                    // Allow "None" to be selected - it means use blank/default value
                    if (isEnabled && columnIdx !== null && !isNaN(columnIdx)) {
                        mapping[field.key] = columnIdx;
                    } else if (isEnabled) {
                        // Field is enabled but no column selected - will use blank/default
                        mapping[field.key] = null;
                    }
                }
            });
            
            // Handle name field based on format
            if (nameFormat === 'single') {
                // Add name field if it exists in fields
                const nameField = fields.find(f => f.key === 'name');
                if (nameField) {
                    const checkbox = document.getElementById(`field-name-enabled`);
                    const select = document.getElementById(`field-name-column`);
                    if (checkbox && select) {
                        const isEnabled = checkbox.checked;
                        const columnIdx = select.value !== '' ? parseInt(select.value, 10) : null;
                        enabledFields['name'] = isEnabled;
                        if (isEnabled && columnIdx !== null && !isNaN(columnIdx)) {
                            mapping['name'] = columnIdx;
                        } else if (isEnabled) {
                            mapping['name'] = null;
                        }
                    }
                }
            }
            
            // Process additional fields
            const additionalFieldsList = document.getElementById('additional-fields-list');
            if (additionalFieldsList) {
                const additionalRows = additionalFieldsList.querySelectorAll('div');
                additionalRows.forEach(row => {
                    const nameInput = row.querySelector('input[type="text"]');
                    const select = row.querySelector('select');
                    if (nameInput && select && nameInput.value.trim()) {
                        const fieldName = nameInput.value.trim();
                        const columnIdx = select.value !== '' ? parseInt(select.value, 10) : null;
                        if (columnIdx !== null && !isNaN(columnIdx)) {
                            additionalFields[fieldName] = columnIdx;
                        }
                    }
                });
            }
            
            // Validate required fields (name must be mapped if enabled)
            const nameFieldRequired = nameFormat === 'single' ? 'name' : (nameFormat === 'split' ? ['firstName', 'lastName'] : []);
            if (nameFormat === 'single') {
                if (!mapping['name'] && mapping['name'] !== null) {
                    alert('Please map the Name field or select "-- None --" to use blank values.');
                    return;
                }
            } else if (nameFormat === 'split') {
                if (!mapping['firstName'] && mapping['firstName'] !== null && !mapping['lastName'] && mapping['lastName'] !== null) {
                    alert('Please map at least First Name or Last Name, or select "-- None --" to use blank values.');
                    return;
                }
            }
            
            // Store mapping with name format and additional fields
            const fieldMapping = { 
                mapping, 
                enabledFields, 
                additionalFields,
                nameFormat 
            };
            
            // Save mapping settings for future use (by type: riders or coaches)
            if (!data.seasonSettings) data.seasonSettings = {};
            if (!data.seasonSettings.csvFieldMappings) data.seasonSettings.csvFieldMappings = {};
            data.seasonSettings.csvFieldMappings[type] = {
                mapping,
                enabledFields,
                additionalFields,
                nameFormat,
                lastUsed: new Date().toISOString()
            };
            
            // Debug: Log what we're saving
            console.log('Saving CSV field mapping for type:', type, {
                mappingKeys: Object.keys(mapping).length,
                enabledFieldsKeys: Object.keys(enabledFields).length,
                additionalFieldsKeys: Object.keys(additionalFields).length,
                nameFormat: nameFormat,
                fullMapping: data.seasonSettings.csvFieldMappings[type]
            });
            
            // Save immediately before closing modal
            saveData();
            
            // Verify it was saved by checking the actual data object
            const saved = data.seasonSettings?.csvFieldMappings?.[type];
            if (saved) {
                console.log('CSV field mapping verified in memory for', type, saved);
            } else {
                console.error('Failed to save CSV field mapping for', type, 'seasonSettings:', data.seasonSettings);
            }
            
            // Also verify in localStorage
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    const storedMapping = parsed?.seasonSettings?.csvFieldMappings?.[type];
                    if (storedMapping) {
                        console.log('CSV field mapping verified in localStorage for', type);
                    } else {
                        console.error('CSV field mapping NOT found in localStorage for', type);
                    }
                }
            } catch (e) {
                console.error('Error checking localStorage:', e);
            }
            
            // Store type before closing modal (which clears the variables)
            const isImport = pendingCSVType && pendingCSVType.includes('_import');
            const csvType = pendingCSVType ? pendingCSVType.replace('_import', '') : type;
            const csvData = pendingCSVData;
            
            // Close modal
            closeCSVFieldMappingModal();
            
            // Proceed with import/update (pass mapping as parameter)
            if (isImport) {
                if (csvType === 'riders') {
                    await processRidersCSVImportWithMapping(csvData, fieldMapping);
                } else {
                    await processCoachesCSVImportWithMapping(csvData, fieldMapping);
                }
            } else {
                if (csvType === 'riders') {
                    await updateRidersFromCSVWithMapping(csvData, fieldMapping);
                } else {
                    await updateCoachesFromCSVWithMapping(csvData, fieldMapping);
                }
            }
        }

        // Helper function to get value from CSV row using custom mapping
        function getValueFromMapping(row, fieldName, mapping) {
            const idx = mapping[fieldName];
            // If mapping is null, it means "None" was selected - return empty string
            if (idx === null) return '';
            // If mapping is undefined, field wasn't mapped - return empty string
            if (idx === undefined) return '';
            // Otherwise, get value from CSV column
            return (row[idx] || '').trim();
        }

        // Process riders CSV import with custom mapping
        async function processRidersCSVImportWithMapping(ridersText, fieldMapping) {
            try {
                if (!fieldMapping) {
                    alert('No field mapping found. Please try again.');
                    return;
                }

                const nameFormat = fieldMapping.nameFormat || 'split';
                const additionalFields = fieldMapping.additionalFields || {};
                const mapping = fieldMapping.mapping;
                const enabledFields = fieldMapping.enabledFields;
                
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Import riders
                const importedRiders = [];
                for (let i = 1; i < riders.length; i++) {
                    const row = riders[i];
                    if (!row || row.length === 0) continue;

                    // Get name fields based on format
                    let name = '';
                    let firstName = '';
                    let lastName = '';
                    
                    if (nameFormat === 'single') {
                        name = getValueFromMapping(row, 'name', mapping);
                        if (!name) continue;
                        // Try to split name into first/last for compatibility
                        const nameParts = name.trim().split(/\s+/);
                        if (nameParts.length > 1) {
                            lastName = nameParts.pop() || '';
                            firstName = nameParts.join(' ') || '';
                        } else {
                            firstName = name;
                        }
                    } else {
                        firstName = getValueFromMapping(row, 'firstName', mapping);
                        lastName = getValueFromMapping(row, 'lastName', mapping);
                        if (!firstName && !lastName) continue;
                        name = `${firstName} ${lastName}`.trim();
                    }

                    // Get gender and determine default photo
                    const gender = normalizeGenderValue(getValueFromMapping(row, 'gender', mapping));

                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    // Build rider object using mapping
                    // Helper to get field value - use mapping if field is enabled OR if it has a mapping (for backwards compatibility)
                    const getFieldValue = (fieldKey, defaultValue = '', transform = null) => {
                        const hasMapping = mapping[fieldKey] !== undefined && mapping[fieldKey] !== null;
                        const isEnabled = enabledFields[fieldKey];
                        if (isEnabled || hasMapping) {
                            const value = getValueFromMapping(row, fieldKey, mapping);
                            return transform ? transform(value) : (value || defaultValue);
                        }
                        return defaultValue;
                    };
                    
                    const riderData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + importedRiders.length * 1000,
                        name: name,
                        firstName: firstName,
                        lastName: lastName,
                        photo: getFieldValue('photo', defaultPhoto),
                        email: getFieldValue('email', ''),
                        phone: getFieldValue('phone', '', normalizePhoneNumber),
                        address: getFieldValue('address', ''),
                        gender: enabledFields.gender ? gender : '',
                        grade: getFieldValue('grade', '', normalizeGradeValue),
                        birthday: getFieldValue('birthday', ''),
                        primaryParentName: getFieldValue('primaryParentName', ''),
                        primaryParentPhone: getFieldValue('primaryParentPhone', '', normalizePhoneNumber),
                        primaryParentEmail: getFieldValue('primaryParentEmail', ''),
                        primaryParentAddress: getFieldValue('primaryParentAddress', ''),
                        secondParentName: getFieldValue('secondParentName', ''),
                        secondParentPhone: getFieldValue('secondParentPhone', '', normalizePhoneNumber),
                        secondParentEmail: getFieldValue('secondParentEmail', ''),
                        alternateContactName: getFieldValue('alternateContactName', ''),
                        alternateContactRelationship: getFieldValue('alternateContactRelationship', ''),
                        alternateContactPhone: getFieldValue('alternateContactPhone', '', normalizePhoneNumber),
                        primaryPhysician: getFieldValue('primaryPhysician', ''),
                        primaryPhysicianPhone: getFieldValue('primaryPhysicianPhone', '', normalizePhoneNumber),
                        medicalInsuranceCompany: getFieldValue('medicalInsuranceCompany', ''),
                        medicalInsuranceAccountNumber: getFieldValue('medicalInsuranceAccountNumber', ''),
                        allergiesOrMedicalNeeds: getFieldValue('allergiesOrMedicalNeeds', ''),
                        fitness: getFieldValue('fitness', String(Math.ceil(getFitnessScale() / 2))),
                        skills: getFieldValue('skills', String(Math.ceil(getSkillsScale() / 2))),
                        racingGroup: getFieldValue('racingGroup', 'Freshman'),
                        notes: getFieldValue('notes', '')
                    };
                    
                    // Add additional fields
                    Object.keys(additionalFields).forEach(fieldName => {
                        const columnIdx = additionalFields[fieldName];
                        if (columnIdx !== null && columnIdx !== undefined) {
                            riderData[fieldName] = (row[columnIdx] || '').trim();
                        }
                    });
                    
                    importedRiders.push(riderData);
                }

                // COMPLETELY REPLACE existing rider data
                data.riders = [];
                data.riders = importedRiders;
                
                // Update name format in season settings if changed
                if (nameFormat && nameFormat !== (data.seasonSettings?.nameFormat || 'split')) {
                    if (!data.seasonSettings) data.seasonSettings = {};
                    data.seasonSettings.nameFormat = nameFormat;
                }
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderRiders();

                alert(`Successfully imported ${importedRiders.length} riders from CSV file.\n\nAll existing rider data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Process coaches CSV import with custom mapping
        async function processCoachesCSVImportWithMapping(coachesText, fieldMapping) {
            try {
                if (!fieldMapping) {
                    alert('No field mapping found. Please try again.');
                    return;
                }

                const nameFormat = fieldMapping.nameFormat || 'split';
                const additionalFields = fieldMapping.additionalFields || {};
                const mapping = fieldMapping.mapping;
                const enabledFields = fieldMapping.enabledFields;
                
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Import coaches
                const importedCoaches = [];
                for (let i = 1; i < coaches.length; i++) {
                    const row = coaches[i];
                    if (!row || row.length === 0) continue;

                    // Get name fields based on format
                    let name = '';
                    let firstName = '';
                    let lastName = '';
                    
                    if (nameFormat === 'single') {
                        name = getValueFromMapping(row, 'name', mapping);
                        if (!name) continue;
                        // Try to split name into first/last for compatibility
                        const nameParts = name.trim().split(/\s+/);
                        if (nameParts.length > 1) {
                            lastName = nameParts.pop() || '';
                            firstName = nameParts.join(' ') || '';
                        } else {
                            firstName = name;
                        }
                    } else {
                        firstName = getValueFromMapping(row, 'firstName', mapping);
                        lastName = getValueFromMapping(row, 'lastName', mapping);
                        if (!firstName && !lastName) continue;
                        name = `${firstName} ${lastName}`.trim();
                    }

                    // Get gender and determine default photo (same as riders)
                    const gender = enabledFields.gender ? normalizeGenderValue(getValueFromMapping(row, 'gender', mapping)) : '';

                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    // Build coach object using mapping
                    const coachData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + importedCoaches.length * 1000,
                        name: name,
                        firstName: firstName,
                        lastName: lastName,
                        photo: enabledFields.photo ? (getValueFromMapping(row, 'photo', mapping) || defaultPhoto) : defaultPhoto,
                        email: enabledFields.email ? getValueFromMapping(row, 'email', mapping) : '',
                        phone: enabledFields.phone ? normalizePhoneNumber(getValueFromMapping(row, 'phone', mapping)) : '',
                        workPhone: enabledFields.workPhone ? normalizePhoneNumber(getValueFromMapping(row, 'workPhone', mapping)) : '',
                        homePhone: enabledFields.homePhone ? normalizePhoneNumber(getValueFromMapping(row, 'homePhone', mapping)) : '',
                        gender: gender,
                        coachingLicenseLevel: enabledFields.coachingLicenseLevel ? getValueFromMapping(row, 'coachingLicenseLevel', mapping) : '1',
                        registered: enabledFields.registered ? getValueFromMapping(row, 'registered', mapping) : '',
                        paid: enabledFields.paid ? getValueFromMapping(row, 'paid', mapping) : '',
                        backgroundCheck: enabledFields.backgroundCheck ? getValueFromMapping(row, 'backgroundCheck', mapping) : '',
                        level3ExamCompleted: enabledFields.level3ExamCompleted ? getValueFromMapping(row, 'level3ExamCompleted', mapping) : '',
                        pduCeuUnits: enabledFields.pduCeuUnits ? getValueFromMapping(row, 'pduCeuUnits', mapping) : '',
                        fieldWorkHours: enabledFields.fieldWorkHours ? getValueFromMapping(row, 'fieldWorkHours', mapping) : '',
                        firstAidTypeExpires: enabledFields.firstAidTypeExpires ? getValueFromMapping(row, 'firstAidTypeExpires', mapping) : '',
                        cprExpires: enabledFields.cprExpires ? getValueFromMapping(row, 'cprExpires', mapping) : '',
                        concussionTrainingCompleted: enabledFields.concussionTrainingCompleted ? getValueFromMapping(row, 'concussionTrainingCompleted', mapping) : '',
                        nicaPhilosophyCompleted: enabledFields.nicaPhilosophyCompleted ? getValueFromMapping(row, 'nicaPhilosophyCompleted', mapping) : '',
                        athleteAbuseAwarenessCompleted: enabledFields.athleteAbuseAwarenessCompleted ? getValueFromMapping(row, 'athleteAbuseAwarenessCompleted', mapping) : '',
                        licenseLevel1Completed: enabledFields.licenseLevel1Completed ? getValueFromMapping(row, 'licenseLevel1Completed', mapping) : '',
                        licenseLevel2Completed: enabledFields.licenseLevel2Completed ? getValueFromMapping(row, 'licenseLevel2Completed', mapping) : '',
                        licenseLevel3Completed: enabledFields.licenseLevel3Completed ? getValueFromMapping(row, 'licenseLevel3Completed', mapping) : '',
                        otbSkills101ClassroomCompleted: enabledFields.otbSkills101ClassroomCompleted ? getValueFromMapping(row, 'otbSkills101ClassroomCompleted', mapping) : '',
                        otbSkills101OutdoorCompleted: enabledFields.otbSkills101OutdoorCompleted ? getValueFromMapping(row, 'otbSkills101OutdoorCompleted', mapping) : '',
                        nicaLeaderSummitCompleted: enabledFields.nicaLeaderSummitCompleted ? getValueFromMapping(row, 'nicaLeaderSummitCompleted', mapping) : '',
                        fitness: enabledFields.fitness ? (getValueFromMapping(row, 'fitness', mapping) || String(Math.ceil(getFitnessScale() / 2))) : String(Math.ceil(getFitnessScale() / 2)),
                        notes: enabledFields.notes ? getValueFromMapping(row, 'notes', mapping) : ''
                    };
                    
                    // Add additional fields
                    Object.keys(additionalFields).forEach(fieldName => {
                        const columnIdx = additionalFields[fieldName];
                        if (columnIdx !== null && columnIdx !== undefined) {
                            coachData[fieldName] = (row[columnIdx] || '').trim();
                        }
                    });
                    
                    importedCoaches.push(coachData);
                }

                // COMPLETELY REPLACE existing coach data
                data.coaches = [];
                data.coaches = importedCoaches;
                
                // Update name format in season settings if changed
                if (nameFormat && nameFormat !== (data.seasonSettings?.nameFormat || 'split')) {
                    if (!data.seasonSettings) data.seasonSettings = {};
                    data.seasonSettings.nameFormat = nameFormat;
                }
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderCoaches();

                alert(`Successfully imported ${importedCoaches.length} coaches from CSV file.\n\nAll existing coach data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Update riders from CSV with custom mapping
        async function updateRidersFromCSVWithMapping(ridersText, fieldMapping) {
            try {
                if (!fieldMapping) {
                    alert('No field mapping found. Please try again.');
                    return;
                }

                const nameFormat = fieldMapping.nameFormat || 'split';
                const additionalFields = fieldMapping.additionalFields || {};
                const mapping = fieldMapping.mapping;
                const enabledFields = fieldMapping.enabledFields;
                
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Helper function to get value from CSV row using custom mapping
                const getValue = (row, fieldName) => {
                    if (!enabledFields[fieldName]) return '';
                    const value = getValueFromMapping(row, fieldName, mapping);
                    if (fieldName === 'gender') {
                        return normalizeGenderValue(value);
                    }
                    return value;
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV riders by name
                const csvRidersMap = new Map();
                for (let i = 1; i < riders.length; i++) {
                    const row = riders[i];
                    if (!row || row.length === 0) continue;

                    let firstName = '';
                    let lastName = '';
                    let name = '';
                    
                    if (nameFormat === 'single') {
                        name = getValue(row, 'name');
                        if (!name) continue;
                        const nameParts = name.trim().split(/\s+/);
                        if (nameParts.length > 1) {
                            lastName = nameParts.pop() || '';
                            firstName = nameParts.join(' ') || '';
                        } else {
                            firstName = name;
                        }
                    } else {
                        firstName = getValue(row, 'firstName');
                        lastName = getValue(row, 'lastName');
                        if (!firstName && !lastName) continue;
                        name = `${firstName} ${lastName}`.trim();
                    }

                    // Normalize names for matching
                    const firstNameNorm = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    const lastNameNorm = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    const nameKey = `${firstNameNorm}|${lastNameNorm}`;
                    csvRidersMap.set(nameKey, row);
                }

                // Helper function to extract firstName and lastName from rider object
                const getRiderNames = (rider) => {
                    let firstName = (rider.firstName || '').trim();
                    let lastName = (rider.lastName || '').trim();
                    
                    if (!firstName && !lastName && rider.name) {
                        const parts = rider.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = rider.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'skills', 'notes', 'photo', 'id', 'racingGroup'];

                const originalRiders = Array.isArray(data.riders) ? [...data.riders] : [];
                
                // Update existing riders and track which ones were found in CSV
                const updatedRiders = [];
                const addedRiders = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;

                for (const rider of data.riders) {
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    if (!firstName && !lastName) {
                        console.warn('Rider has no name:', rider);
                        continue;
                    }
                    
                    if (csvRidersMap.has(nameKey)) {
                        // Rider found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvRidersMap.get(nameKey);
                        const updatedRider = { ...rider };
                        
                        // Update only enabled fields (except preserved fields)
                        Object.keys(enabledFields).forEach(fieldKey => {
                            if (enabledFields[fieldKey] && !preserveFields.includes(fieldKey)) {
                                const oldValue = String(rider[fieldKey] || '');
                                let newValue = '';
                                
                                if (fieldKey === 'phone' || fieldKey.includes('Phone')) {
                                    newValue = getPhoneValue(csvRow, fieldKey);
                                } else if (fieldKey === 'grade') {
                                    newValue = normalizeGradeValue(getValue(csvRow, fieldKey));
                                } else if (fieldKey === 'gender') {
                                    newValue = normalizeGenderValue(getValue(csvRow, fieldKey));
                                } else {
                                    newValue = getValue(csvRow, fieldKey);
                                }
                                
                                if (oldValue !== newValue) {
                                    updatedRider[fieldKey] = newValue;
                                    totalFieldsUpdated++;
                                }
                            }
                        });
                        
                        // Add/update additional fields
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                updatedRider[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                        
                        updatedRiders.push(updatedRider);
                    } else {
                        // Rider not found in CSV - remove them
                        removedCount++;
                    }
                }

                // Add new riders from CSV
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvRidersMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        addedCount++;
                        const firstName = getValue(csvRow, 'firstName');
                        const lastName = getValue(csvRow, 'lastName');
                        const name = `${firstName} ${lastName}`.trim();

                        // Get gender and determine default photo
                        const gender = normalizeGenderValue(getValue(csvRow, 'gender'));

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const gradeRaw = getValue(csvRow, 'grade');
                        const grade = normalizeGradeValue(gradeRaw);

                        const newRider = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 1000,
                            name: name,
                            firstName,
                            lastName,
                            photo: enabledFields.photo ? (getValue(csvRow, 'photo') || defaultPhoto) : defaultPhoto,
                            email: getValue(csvRow, 'email'),
                            phone: getPhoneValue(csvRow, 'phone'),
                            address: getValue(csvRow, 'address'),
                            gender: gender,
                            grade: grade,
                            birthday: getValue(csvRow, 'birthday'),
                            primaryParentName: getValue(csvRow, 'primaryParentName'),
                            primaryParentPhone: getPhoneValue(csvRow, 'primaryParentPhone'),
                            primaryParentEmail: getValue(csvRow, 'primaryParentEmail'),
                            primaryParentAddress: getValue(csvRow, 'primaryParentAddress'),
                            secondParentName: getValue(csvRow, 'secondParentName'),
                            secondParentPhone: getPhoneValue(csvRow, 'secondParentPhone'),
                            secondParentEmail: getValue(csvRow, 'secondParentEmail'),
                            alternateContactName: getValue(csvRow, 'alternateContactName'),
                            alternateContactRelationship: getValue(csvRow, 'alternateContactRelationship'),
                            alternateContactPhone: getPhoneValue(csvRow, 'alternateContactPhone'),
                            primaryPhysician: getValue(csvRow, 'primaryPhysician'),
                            primaryPhysicianPhone: getPhoneValue(csvRow, 'primaryPhysicianPhone'),
                            medicalInsuranceCompany: getValue(csvRow, 'medicalInsuranceCompany'),
                            medicalInsuranceAccountNumber: getValue(csvRow, 'medicalInsuranceAccountNumber'),
                            allergiesOrMedicalNeeds: getValue(csvRow, 'allergiesOrMedicalNeeds'),
                            fitness: enabledFields.fitness ? (getValue(csvRow, 'fitness') || String(Math.ceil(getFitnessScale() / 2))) : String(Math.ceil(getFitnessScale() / 2)),
                            skills: enabledFields.skills ? (getValue(csvRow, 'skills') || String(Math.ceil(getSkillsScale() / 2))) : String(Math.ceil(getSkillsScale() / 2)),
                            racingGroup: enabledFields.racingGroup ? (getValue(csvRow, 'racingGroup') || 'Freshman') : 'Freshman',
                            notes: enabledFields.notes ? getValue(csvRow, 'notes') : ''
                        };
                        
                        // Add additional fields
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                newRider[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                        
                        updatedRiders.push(newRider);
                        addedRiders.push(newRider);
                    }
                }
                
                // Also add additional fields to updated riders
                for (let i = 0; i < updatedRiders.length; i++) {
                    const rider = updatedRiders[i];
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName.toLowerCase().replace(/\s+/g, ' ').trim()}|${lastName.toLowerCase().replace(/\s+/g, ' ').trim()}`;
                    if (csvRidersMap.has(nameKey)) {
                        const csvRow = csvRidersMap.get(nameKey);
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                rider[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                    }
                }

                // Update name format in season settings if changed
                if (nameFormat && nameFormat !== (data.seasonSettings?.nameFormat || 'split')) {
                    if (!data.seasonSettings) data.seasonSettings = {};
                    data.seasonSettings.nameFormat = nameFormat;
                }

                // Update data
                data.riders = updatedRiders;
                saveData();
                
                await syncRidersToSupabase(originalRiders, updatedRiders, addedRiders);
                renderRiders();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new rider(s)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} rider(s) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Update coaches from CSV with custom mapping
        async function updateCoachesFromCSVWithMapping(coachesText, fieldMapping) {
            try {
                if (!fieldMapping) {
                    alert('No field mapping found. Please try again.');
                    return;
                }

                const nameFormat = fieldMapping.nameFormat || 'split';
                const additionalFields = fieldMapping.additionalFields || {};
                const mapping = fieldMapping.mapping;
                const enabledFields = fieldMapping.enabledFields;
                
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Helper function to get value from CSV row using custom mapping
                const getValue = (row, fieldName) => {
                    if (!enabledFields[fieldName]) return '';
                    return getValueFromMapping(row, fieldName, mapping);
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV coaches by name
                const csvCoachesMap = new Map();
                for (let i = 1; i < coaches.length; i++) {
                    const row = coaches[i];
                    if (!row || row.length === 0) continue;

                    let firstName = '';
                    let lastName = '';
                    let name = '';
                    
                    if (nameFormat === 'single') {
                        name = getValue(row, 'name');
                        if (!name) continue;
                        const nameParts = name.trim().split(/\s+/);
                        if (nameParts.length > 1) {
                            lastName = nameParts.pop() || '';
                            firstName = nameParts.join(' ') || '';
                        } else {
                            firstName = name;
                        }
                    } else {
                        firstName = getValue(row, 'firstName');
                        lastName = getValue(row, 'lastName');
                        if (!firstName && !lastName) continue;
                        name = `${firstName} ${lastName}`.trim();
                    }

                    // Normalize names for matching
                    const firstNameNorm = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    const lastNameNorm = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    const nameKey = `${firstNameNorm}|${lastNameNorm}`;
                    csvCoachesMap.set(nameKey, row);
                }

                // Helper function to extract firstName and lastName from coach object
                const getCoachNames = (coach) => {
                    let firstName = (coach.firstName || '').trim();
                    let lastName = (coach.lastName || '').trim();
                    
                    if (!firstName && !lastName && coach.name) {
                        const parts = coach.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = coach.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'notes', 'photo', 'id'];

                const originalCoaches = Array.isArray(data.coaches) ? [...data.coaches] : [];
                
                // Update existing coaches and track which ones were found in CSV
                const updatedCoaches = [];
                const addedCoaches = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;

                for (const coach of data.coaches) {
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    if (!firstName && !lastName) {
                        console.warn('Coach has no name:', coach);
                        continue;
                    }
                    
                    if (csvCoachesMap.has(nameKey)) {
                        // Coach found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvCoachesMap.get(nameKey);
                        const updatedCoach = { ...coach };
                        
                        // Update only enabled fields (except preserved fields)
                        Object.keys(enabledFields).forEach(fieldKey => {
                            if (enabledFields[fieldKey] && !preserveFields.includes(fieldKey)) {
                                const oldValue = String(coach[fieldKey] || '');
                                let newValue = '';
                                
                                if (fieldKey.includes('Phone')) {
                                    newValue = getPhoneValue(csvRow, fieldKey);
                                } else {
                                    newValue = getValue(csvRow, fieldKey);
                                }
                                
                                if (oldValue !== newValue) {
                                    updatedCoach[fieldKey] = newValue;
                                    totalFieldsUpdated++;
                                }
                            }
                        });
                        
                        // Add/update additional fields
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                updatedCoach[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                        
                        updatedCoaches.push(updatedCoach);
                    } else {
                        // Coach not found in CSV - remove them
                        removedCount++;
                    }
                }

                // Add new coaches from CSV
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvCoachesMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        addedCount++;
                        
                        // Get name fields based on format
                        let firstName = '';
                        let lastName = '';
                        let name = '';
                        
                        if (nameFormat === 'single') {
                            name = getValue(csvRow, 'name');
                            if (!name) continue;
                            const nameParts = name.trim().split(/\s+/);
                            if (nameParts.length > 1) {
                                lastName = nameParts.pop() || '';
                                firstName = nameParts.join(' ') || '';
                            } else {
                                firstName = name;
                            }
                        } else {
                            firstName = getValue(csvRow, 'firstName');
                            lastName = getValue(csvRow, 'lastName');
                            if (!firstName && !lastName) continue;
                            name = `${firstName} ${lastName}`.trim();
                        }

                        // Get gender and determine default photo (same as riders)
                        const gender = normalizeGenderValue(getValue(csvRow, 'gender'));

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const newCoach = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 1000,
                            name: name,
                            firstName,
                            lastName,
                            photo: enabledFields.photo ? (getValue(csvRow, 'photo') || defaultPhoto) : defaultPhoto,
                            email: getValue(csvRow, 'email'),
                            phone: getPhoneValue(csvRow, 'phone'),
                            workPhone: getPhoneValue(csvRow, 'workPhone'),
                            homePhone: getPhoneValue(csvRow, 'homePhone'),
                            gender: gender,
                            coachingLicenseLevel: getValue(csvRow, 'coachingLicenseLevel') || '1',
                            registered: getValue(csvRow, 'registered'),
                            paid: getValue(csvRow, 'paid'),
                            backgroundCheck: getValue(csvRow, 'backgroundCheck'),
                            level3ExamCompleted: getValue(csvRow, 'level3ExamCompleted'),
                            pduCeuUnits: getValue(csvRow, 'pduCeuUnits'),
                            fieldWorkHours: getValue(csvRow, 'fieldWorkHours'),
                            firstAidTypeExpires: getValue(csvRow, 'firstAidTypeExpires'),
                            cprExpires: getValue(csvRow, 'cprExpires'),
                            concussionTrainingCompleted: getValue(csvRow, 'concussionTrainingCompleted'),
                            nicaPhilosophyCompleted: getValue(csvRow, 'nicaPhilosophyCompleted'),
                            athleteAbuseAwarenessCompleted: getValue(csvRow, 'athleteAbuseAwarenessCompleted'),
                            licenseLevel1Completed: getValue(csvRow, 'licenseLevel1Completed'),
                            licenseLevel2Completed: getValue(csvRow, 'licenseLevel2Completed'),
                            licenseLevel3Completed: getValue(csvRow, 'licenseLevel3Completed'),
                            otbSkills101ClassroomCompleted: getValue(csvRow, 'otbSkills101ClassroomCompleted'),
                            otbSkills101OutdoorCompleted: getValue(csvRow, 'otbSkills101OutdoorCompleted'),
                            nicaLeaderSummitCompleted: getValue(csvRow, 'nicaLeaderSummitCompleted'),
                            fitness: enabledFields.fitness ? (getValue(csvRow, 'fitness') || String(Math.ceil(getFitnessScale() / 2))) : String(Math.ceil(getFitnessScale() / 2)),
                            notes: enabledFields.notes ? getValue(csvRow, 'notes') : ''
                        };
                        
                        // Add additional fields
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                newCoach[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                        
                        updatedCoaches.push(newCoach);
                        addedCoaches.push(newCoach);
                    }
                }
                
                // Also add additional fields to updated coaches
                for (let i = 0; i < updatedCoaches.length; i++) {
                    const coach = updatedCoaches[i];
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    if (csvCoachesMap.has(nameKey)) {
                        const csvRow = csvCoachesMap.get(nameKey);
                        Object.keys(additionalFields).forEach(fieldName => {
                            const columnIdx = additionalFields[fieldName];
                            if (columnIdx !== null && columnIdx !== undefined) {
                                coach[fieldName] = (csvRow[columnIdx] || '').trim();
                            }
                        });
                    }
                }

                // Update name format in season settings if changed
                if (nameFormat && nameFormat !== (data.seasonSettings?.nameFormat || 'split')) {
                    if (!data.seasonSettings) data.seasonSettings = {};
                    data.seasonSettings.nameFormat = nameFormat;
                }

                // Update data
                data.coaches = updatedCoaches;
                saveData();
                
                await syncCoachesToSupabase(originalCoaches, updatedCoaches, addedCoaches);
                renderCoaches();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new coach(es)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} coach(es) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        async function syncRidersToSupabase(originalRiders, updatedRiders, addedRiders) {
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            const debugEnabled = typeof DEBUG_LOGS !== 'undefined' && DEBUG_LOGS;
            if (!client || !currentUser || typeof updateRider === 'undefined' || typeof createRider === 'undefined') {
                if (debugEnabled) {
                    console.warn('CSV sync riders skipped - missing auth or database helpers', {
                        hasClient: !!client,
                        hasUser: !!currentUser,
                        hasUpdate: typeof updateRider !== 'undefined',
                        hasCreate: typeof createRider !== 'undefined'
                    });
                }
                return;
            }
            
            const updatedIdSet = new Set(updatedRiders.map(r => r.id));
            const addedIdSet = new Set(addedRiders.map(r => r.id));
            const removedIds = originalRiders
                .map(r => r.id)
                .filter(id => !updatedIdSet.has(id));
            
            if (debugEnabled) {
                console.log('CSV sync riders starting', {
                    total: updatedRiders.length,
                    added: addedRiders.length,
                    removed: removedIds.length
                });
            }
            
            for (const rider of updatedRiders) {
                const isNew = addedIdSet.has(rider.id);
                try {
                    if (isNew) {
                        const created = await createRider(rider);
                        const oldId = rider.id;
                        const index = data.riders.findIndex(r => r.id === oldId);
                        if (index !== -1) {
                            data.riders[index] = { ...rider, ...created };
                        } else {
                            data.riders.push({ ...rider, ...created });
                        }
                        
                        if (created?.id && created.id !== oldId) {
                            data.rides.forEach(ride => {
                                if (Array.isArray(ride.availableRiders)) {
                                    ride.availableRiders = ride.availableRiders.map(id => (id === oldId ? created.id : id));
                                }
                                if (Array.isArray(ride.groups)) {
                                    ride.groups.forEach(group => {
                                        if (Array.isArray(group.riders)) {
                                            group.riders = group.riders.map(id => (id === oldId ? created.id : id));
                                        }
                                    });
                                }
                            });
                        }
                    } else {
                        try {
                            const updated = await updateRider(rider.id, { ...rider, extra_data: rider });
                            const index = data.riders.findIndex(r => r.id === rider.id);
                            if (index !== -1) {
                                data.riders[index] = { ...rider, ...updated };
                            }
                        } catch (error) {
                            const missingRow = error?.code === 'PGRST116' || (error?.message || '').includes('No rows');
                            if (missingRow) {
                                const created = await createRider(rider);
                                const index = data.riders.findIndex(r => r.id === rider.id);
                                if (index !== -1) {
                                    data.riders[index] = { ...rider, ...created };
                                } else {
                                    data.riders.push({ ...rider, ...created });
                                }
                            } else {
                                throw error;
                            }
                        }
                    }
                } catch (error) {
                    showSaveError(
                        'Failed to Save Rider',
                        `An error occurred while saving ${rider.name || 'a rider'}.`,
                        error
                    );
                }
            }
            
            if (typeof deleteRiderFromDB === 'function') {
                for (const id of removedIds) {
                    try {
                        await deleteRiderFromDB(id);
                    } catch (error) {
                        showSaveError(
                            'Failed to Delete Rider',
                            `An error occurred while deleting rider ID ${id}.`,
                            error
                        );
                    }
                }
            }
        }

        async function syncCoachesToSupabase(originalCoaches, updatedCoaches, addedCoaches) {
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            const debugEnabled = typeof DEBUG_LOGS !== 'undefined' && DEBUG_LOGS;
            if (!client || !currentUser || typeof updateCoach === 'undefined' || typeof createCoach === 'undefined') {
                if (debugEnabled) {
                    console.warn('CSV sync coaches skipped - missing auth or database helpers', {
                        hasClient: !!client,
                        hasUser: !!currentUser,
                        hasUpdate: typeof updateCoach !== 'undefined',
                        hasCreate: typeof createCoach !== 'undefined'
                    });
                }
                return;
            }
            
            const updatedIdSet = new Set(updatedCoaches.map(c => c.id));
            const addedIdSet = new Set(addedCoaches.map(c => c.id));
            const removedIds = originalCoaches
                .map(c => c.id)
                .filter(id => !updatedIdSet.has(id));
            
            if (debugEnabled) {
                console.log('CSV sync coaches starting', {
                    total: updatedCoaches.length,
                    added: addedCoaches.length,
                    removed: removedIds.length
                });
            }
            
            for (const coach of updatedCoaches) {
                const isNew = addedIdSet.has(coach.id);
                try {
                    if (isNew) {
                        const created = await createCoach(coach);
                        const oldId = coach.id;
                        const index = data.coaches.findIndex(c => c.id === oldId);
                        if (index !== -1) {
                            data.coaches[index] = { ...coach, ...created };
                        } else {
                            data.coaches.push({ ...coach, ...created });
                        }
                        
                        if (created?.id && created.id !== oldId) {
                            data.rides.forEach(ride => {
                                if (Array.isArray(ride.availableCoaches)) {
                                    ride.availableCoaches = ride.availableCoaches.map(id => (id === oldId ? created.id : id));
                                }
                                if (Array.isArray(ride.groups)) {
                                    ride.groups.forEach(group => {
                                        if (group.coaches) {
                                            if (group.coaches.leader === oldId) group.coaches.leader = created.id;
                                            if (group.coaches.sweep === oldId) group.coaches.sweep = created.id;
                                            if (group.coaches.roam === oldId) group.coaches.roam = created.id;
                                            if (Array.isArray(group.coaches.extraRoam)) {
                                                group.coaches.extraRoam = group.coaches.extraRoam.map(id => (id === oldId ? created.id : id));
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    } else {
                        try {
                            const updated = await updateCoach(coach.id, { ...coach, extra_data: coach });
                            const index = data.coaches.findIndex(c => c.id === coach.id);
                            if (index !== -1) {
                                data.coaches[index] = { ...coach, ...updated };
                            }
                        } catch (error) {
                            const missingRow = error?.code === 'PGRST116' || (error?.message || '').includes('No rows');
                            if (missingRow) {
                                const created = await createCoach(coach);
                                const index = data.coaches.findIndex(c => c.id === coach.id);
                                if (index !== -1) {
                                    data.coaches[index] = { ...coach, ...created };
                                } else {
                                    data.coaches.push({ ...coach, ...created });
                                }
                            } else {
                                throw error;
                            }
                        }
                    }
                } catch (error) {
                    showSaveError(
                        'Failed to Save Coach',
                        `An error occurred while saving ${coach.name || 'a coach'}.`,
                        error
                    );
                }
            }
            
            if (typeof deleteCoachFromDB === 'function') {
                for (const id of removedIds) {
                    try {
                        await deleteCoachFromDB(id);
                    } catch (error) {
                        showSaveError(
                            'Failed to Delete Coach',
                            `An error occurred while deleting coach ID ${id}.`,
                            error
                        );
                    }
                }
            }
        }

        // Update riders from CSV (matches by name, updates fields, adds new, removes missing)
        async function updateRidersFromCSV(ridersText) {
            try {
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = riders[0];
                const headerMap = getRiderHeaderMap(headers);

                // Helper function to get value from CSV row using header map
                const getValue = (row, fieldName) => {
                    const idx = headerMap[fieldName];
                    return idx !== undefined ? (row[idx] || '').trim() : '';
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV riders by name (firstName + lastName)
                const csvRidersMap = new Map();
                for (let i = 1; i < riders.length; i++) {
                    const row = riders[i];
                    if (!row || row.length === 0) continue;

                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    let firstName = (row[firstNameIdx] || '').trim();
                    let lastName = (row[lastNameIdx] || '').trim();
                    
                    // Handle cases where name might be in a single field
                    if (!firstName && !lastName) continue;
                    if (!lastName && firstName) {
                        // Try to split if only one name field has data
                        const parts = firstName.split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    const nameKey = `${firstName}|${lastName}`;
                    csvRidersMap.set(nameKey, row);
                }

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'skills', 'notes', 'racingGroup', 'photo', 'id'];

                // Helper function to extract firstName and lastName from rider object
                const getRiderNames = (rider) => {
                    let firstName = (rider.firstName || '').trim();
                    let lastName = (rider.lastName || '').trim();
                    
                    // If firstName/lastName don't exist, try to split the name field
                    if (!firstName && !lastName && rider.name) {
                        const parts = rider.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = rider.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };

                // Debug output
                const debugOutput = [];
                debugOutput.push('=== CSV UPDATE DEBUG ===');
                debugOutput.push(`CSV Riders in file: ${csvRidersMap.size}`);
                debugOutput.push(`Existing Riders in roster: ${data.riders.length}`);
                debugOutput.push('');
                
                // Debug: Show sample rider object structure
                if (data.riders.length > 0) {
                    const sampleRider = data.riders[0];
                    debugOutput.push('Sample Rider Object Fields:');
                    const riderFields = Object.keys(sampleRider).sort();
                    riderFields.forEach(field => {
                        const value = sampleRider[field];
                        const displayValue = (value === undefined || value === null) ? 'undefined/null' : (value === '' ? '""' : String(value).substring(0, 50));
                        debugOutput.push(`  ${field}: ${displayValue}`);
                    });
                    debugOutput.push('');
                }
                
                // Debug: Show header mapping
                debugOutput.push('Header Mapping:');
                Object.keys(headerMap).sort().forEach(fieldName => {
                    const colIndex = headerMap[fieldName];
                    const headerName = headers[colIndex] || 'UNKNOWN';
                    debugOutput.push(`  ${fieldName} -> Column ${colIndex}: "${headerName}"`);
                });
                debugOutput.push('');
                
                debugOutput.push('CSV Name Keys:');
                for (const [key, row] of csvRidersMap.entries()) {
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    const firstName = (row[firstNameIdx] || '').trim();
                    const lastName = (row[lastNameIdx] || '').trim();
                    debugOutput.push(`  "${key}" -> "${firstName} ${lastName}"`);
                }
                debugOutput.push('');
                debugOutput.push('Roster Name Keys:');
                for (const rider of data.riders) {
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName}|${lastName}`;
                    debugOutput.push(`  "${nameKey}" -> "${rider.name || 'NO NAME'}" (ID: ${rider.id})`);
                }
                debugOutput.push('');

                // Update existing riders and track which ones were found in CSV
                const updatedRiders = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;
                const changedFields = [];

                for (const rider of data.riders) {
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    // Debug: log if name key is empty or malformed
                    if (!firstName && !lastName) {
                        console.warn('Rider has no name:', rider);
                        continue; // Skip riders with no name
                    }
                    
                    if (csvRidersMap.has(nameKey)) {
                        // Rider found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvRidersMap.get(nameKey);
                        
                        // Create updated rider object, preserving non-CSV fields
                        const updatedRider = { ...rider };
                        let fieldsChanged = 0;
                        const riderChangedFields = [];
                        
                        // Helper to compare and update field
                        const updateField = (fieldName, newVal) => {
                            // Get the actual current value from the original rider object
                            // Check if property exists using 'in' operator to handle undefined vs missing property
                            const oldVal = (fieldName in rider) ? rider[fieldName] : undefined;
                            // Normalize for comparison: treat undefined, null, and empty string as equivalent
                            const normalizedOld = (oldVal === undefined || oldVal === null || oldVal === '') ? '' : String(oldVal).trim();
                            const normalizedNew = (newVal === undefined || newVal === null || newVal === '') ? '' : String(newVal).trim();
                            
                            // Only update if values are actually different
                            if (normalizedOld !== normalizedNew) {
                                updatedRider[fieldName] = newVal;
                                fieldsChanged++;
                                riderChangedFields.push(`${fieldName}: "${normalizedOld}" -> "${normalizedNew}"`);
                                return true;
                            }
                            return false;
                        };
                        
                        // Update fields from CSV (only if they exist in CSV)
                        if (headerMap['phone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'phone');
                            updateField('phone', newVal);
                        }
                        if (headerMap['address'] !== undefined) {
                            const newVal = getValue(csvRow, 'address');
                            updateField('address', newVal);
                        }
                        if (headerMap['gender'] !== undefined) {
                            const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                            let newGender = '';
                            if (genderRaw === 'M' || genderRaw === 'MALE') newGender = 'M';
                            else if (genderRaw === 'F' || genderRaw === 'FEMALE') newGender = 'F';
                            else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') newGender = 'NB';
                            updateField('gender', newGender);
                        }
                        if (headerMap['grade'] !== undefined) {
                            const gradeRaw = getValue(csvRow, 'grade');
                            const newGrade = normalizeGradeValue(gradeRaw);
                            updateField('grade', newGrade);
                        }
                        if (headerMap['birthday'] !== undefined) {
                            const newVal = getValue(csvRow, 'birthday');
                            updateField('birthday', newVal);
                        }
                        if (headerMap['primaryParentName'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentName');
                            updateField('primaryParentName', newVal);
                        }
                        if (headerMap['primaryParentPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'primaryParentPhone');
                            updateField('primaryParentPhone', newVal);
                        }
                        if (headerMap['primaryParentEmail'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentEmail');
                            updateField('primaryParentEmail', newVal);
                        }
                        if (headerMap['primaryParentAddress'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentAddress');
                            updateField('primaryParentAddress', newVal);
                        }
                        if (headerMap['secondParentName'] !== undefined) {
                            const newVal = getValue(csvRow, 'secondParentName');
                            updateField('secondParentName', newVal);
                        }
                        if (headerMap['secondParentPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'secondParentPhone');
                            updateField('secondParentPhone', newVal);
                        }
                        if (headerMap['secondParentEmail'] !== undefined) {
                            const newVal = getValue(csvRow, 'secondParentEmail');
                            updateField('secondParentEmail', newVal);
                        }
                        if (headerMap['alternateContactName'] !== undefined) {
                            const newVal = getValue(csvRow, 'alternateContactName');
                            updateField('alternateContactName', newVal);
                        }
                        if (headerMap['alternateContactRelationship'] !== undefined) {
                            const newVal = getValue(csvRow, 'alternateContactRelationship');
                            updateField('alternateContactRelationship', newVal);
                        }
                        if (headerMap['alternateContactPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'alternateContactPhone');
                            updateField('alternateContactPhone', newVal);
                        }
                        if (headerMap['primaryPhysician'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryPhysician');
                            updateField('primaryPhysician', newVal);
                        }
                        if (headerMap['primaryPhysicianPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'primaryPhysicianPhone');
                            updateField('primaryPhysicianPhone', newVal);
                        }
                        if (headerMap['medicalInsuranceCompany'] !== undefined) {
                            const newVal = getValue(csvRow, 'medicalInsuranceCompany');
                            updateField('medicalInsuranceCompany', newVal);
                        }
                        if (headerMap['medicalInsuranceAccountNumber'] !== undefined) {
                            const newVal = getValue(csvRow, 'medicalInsuranceAccountNumber');
                            updateField('medicalInsuranceAccountNumber', newVal);
                        }
                        if (headerMap['allergiesOrMedicalNeeds'] !== undefined) {
                            const newVal = getValue(csvRow, 'allergiesOrMedicalNeeds');
                            updateField('allergiesOrMedicalNeeds', newVal);
                        }
                        
                        // Update name fields (use original case from CSV)
                        const csvFirstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                        const csvLastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                        const csvFirstName = (csvRow[csvFirstNameIdx] || '').trim();
                        const csvLastName = (csvRow[csvLastNameIdx] || '').trim();
                        const newName = `${csvFirstName} ${csvLastName}`.trim();
                        updateField('firstName', csvFirstName);
                        updateField('lastName', csvLastName);
                        updateField('name', newName);
                        
                        totalFieldsUpdated += fieldsChanged;
                        if (fieldsChanged > 0) {
                            debugOutput.push(`✓ MATCHED: "${nameKey}" (${rider.name || 'NO NAME'}) - ${fieldsChanged} field(s) changed:`);
                            riderChangedFields.forEach(f => debugOutput.push(`    ${f}`));
                        } else {
                            debugOutput.push(`✓ MATCHED: "${nameKey}" (${rider.name || 'NO NAME'}) - No changes`);
                        }
                        updatedRiders.push(updatedRider);
                    } else {
                        // Rider not in CSV - remove them (don't add to updatedRiders)
                        removedCount++;
                        debugOutput.push(`✗ NOT IN CSV: "${nameKey}" (${rider.name || 'NO NAME'}) - Will be REMOVED`);
                    }
                }

                // Add new riders from CSV that weren't in the roster
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvRidersMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        // New rider from CSV
                        const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                        const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                        const firstName = (csvRow[firstNameIdx] || '').trim();
                        const lastName = (csvRow[lastNameIdx] || '').trim();
                        const name = `${firstName} ${lastName}`.trim();
                        debugOutput.push(`+ NEW IN CSV: "${nameKey}" (${firstName} ${lastName}) - Will be ADDED`);

                        // Get gender for default photo
                        const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                        let gender = '';
                        if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                        else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                        else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const gradeRaw = getValue(csvRow, 'grade');
                        const grade = normalizeGradeValue(gradeRaw);

                        const newRider = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 1000,
                            name: name,
                            firstName,
                            lastName,
                            photo: defaultPhoto,
                            email: getValue(csvRow, 'email'),
                            phone: getPhoneValue(csvRow, 'phone'),
                            address: getValue(csvRow, 'address'),
                            gender: gender,
                            grade: grade,
                            birthday: getValue(csvRow, 'birthday'),
                            primaryParentName: getValue(csvRow, 'primaryParentName'),
                            primaryParentPhone: getPhoneValue(csvRow, 'primaryParentPhone'),
                            primaryParentEmail: getValue(csvRow, 'primaryParentEmail'),
                            primaryParentAddress: getValue(csvRow, 'primaryParentAddress'),
                            secondParentName: getValue(csvRow, 'secondParentName'),
                            secondParentPhone: getPhoneValue(csvRow, 'secondParentPhone'),
                            secondParentEmail: getValue(csvRow, 'secondParentEmail'),
                            alternateContactName: getValue(csvRow, 'alternateContactName'),
                            alternateContactRelationship: getValue(csvRow, 'alternateContactRelationship'),
                            alternateContactPhone: getPhoneValue(csvRow, 'alternateContactPhone'),
                            primaryPhysician: getValue(csvRow, 'primaryPhysician'),
                            primaryPhysicianPhone: getPhoneValue(csvRow, 'primaryPhysicianPhone'),
                            medicalInsuranceCompany: getValue(csvRow, 'medicalInsuranceCompany'),
                            medicalInsuranceAccountNumber: getValue(csvRow, 'medicalInsuranceAccountNumber'),
                            allergiesOrMedicalNeeds: getValue(csvRow, 'allergiesOrMedicalNeeds'),
                            racingGroup: 'Freshman',
                            fitness: String(Math.ceil(getFitnessScale() / 2)),
                            skills: String(Math.ceil(getSkillsScale() / 2)),
                            notes: ''
                        };
                        updatedRiders.push(newRider);
                        addedCount++;
                    }
                }

                // Update data
                data.riders = updatedRiders;
                saveData();
                renderRiders();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new rider(s)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} rider(s) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                // Add summary to debug output
                debugOutput.push('');
                debugOutput.push('=== SUMMARY ===');
                debugOutput.push(`Total fields updated: ${totalFieldsUpdated}`);
                debugOutput.push(`Riders matched and updated: ${updatedCount}`);
                debugOutput.push(`New riders added: ${addedCount}`);
                debugOutput.push(`Riders removed: ${removedCount}`);
                
                // Display debug output
                const debugDiv = document.getElementById('rider-update-debug');
                if (debugDiv) {
                    debugDiv.innerHTML = debugOutput.join('<br>');
                    debugDiv.style.display = 'block';
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Update coaches from CSV (matches by name, updates fields, adds new, removes missing)
        async function updateCoachesFromCSV(coachesText) {
            try {
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = coaches[0];
                const headerMap = getCoachHeaderMap(headers);

                // Debug output
                const debugOutput = [];
                debugOutput.push('=== CSV UPDATE DEBUG ===');
                debugOutput.push(`CSV Coaches in file: ${coaches.length - 1}`);
                debugOutput.push(`Existing Coaches in roster: ${data.coaches.length}`);
                debugOutput.push('');
                
                // Debug: Show sample coach object structure
                if (data.coaches.length > 0) {
                    const sampleCoach = data.coaches[0];
                    debugOutput.push('Sample Coach Object Fields:');
                    const coachFields = Object.keys(sampleCoach).sort();
                    coachFields.forEach(field => {
                        const value = sampleCoach[field];
                        const displayValue = (value === undefined || value === null) ? 'undefined/null' : (value === '' ? '""' : String(value).substring(0, 50));
                        debugOutput.push(`  ${field}: ${displayValue}`);
                    });
                    debugOutput.push('');
                }
                
                // Debug: Show header mapping
                debugOutput.push('Header Mapping:');
                Object.keys(headerMap).sort().forEach(fieldName => {
                    const colIndex = headerMap[fieldName];
                    const headerName = headers[colIndex] || 'UNKNOWN';
                    debugOutput.push(`  ${fieldName} -> Column ${colIndex}: "${headerName}"`);
                });
                debugOutput.push('');
                
                // Debug: Check if coachingLicenseLevel is mapped
                if (!headerMap['coachingLicenseLevel']) {
                    debugOutput.push('WARNING: coachingLicenseLevel not found in header map!');
                    debugOutput.push('Available headers:', headers.join(', '));
                }

                // Helper function to get value from CSV row using header map
                const getValue = (row, fieldName) => {
                    const idx = headerMap[fieldName];
                    if (idx === undefined) {
                        // Debug: log missing header mapping for important fields
                        if (fieldName === 'coachingLicenseLevel') {
                            console.log('Warning: coachingLicenseLevel header not found in CSV. Available headers:', headers);
                            console.log('Header map:', headerMap);
                            debugOutput.push(`ERROR: ${fieldName} header not found!`);
                        }
                        return '';
                    }
                    const value = (row[idx] || '').trim();
                    return value;
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV coaches by name (firstName + lastName)
                const csvCoachesMap = new Map();
                for (let i = 1; i < coaches.length; i++) {
                    const row = coaches[i];
                    if (!row || row.length === 0) continue;

                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    let lastName = (row[lastNameIdx] || '').trim();
                    let firstName = (row[firstNameIdx] || '').trim();
                    
                    // Handle cases where name might be in a single field
                    if (!firstName && !lastName) continue;
                    if (!lastName && firstName) {
                        // Try to split if only one name field has data
                        const parts = firstName.split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    const nameKey = `${firstName}|${lastName}`;
                    csvCoachesMap.set(nameKey, row);
                }
                
                // Helper function to extract firstName and lastName from coach object
                const getCoachNames = (coach) => {
                    let firstName = (coach.firstName || '').trim();
                    let lastName = (coach.lastName || '').trim();
                    
                    // If firstName/lastName don't exist, try to split the name field
                    if (!firstName && !lastName && coach.name) {
                        const parts = coach.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = coach.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };
                
                debugOutput.push('CSV Name Keys:');
                for (const [key, row] of csvCoachesMap.entries()) {
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    const lastName = (row[lastNameIdx] || '').trim();
                    const firstName = (row[firstNameIdx] || '').trim();
                    debugOutput.push(`  "${key}" -> "${firstName} ${lastName}"`);
                }
                debugOutput.push('');
                debugOutput.push('Roster Name Keys:');
                for (const coach of data.coaches) {
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    debugOutput.push(`  "${nameKey}" -> "${coach.name || 'NO NAME'}" (ID: ${coach.id})`);
                }
                debugOutput.push('');

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'notes', 'photo', 'id'];

                // Update existing coaches and track which ones were found in CSV
                const updatedCoaches = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;

                for (const coach of data.coaches) {
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    // Debug: log if name key is empty or malformed
                    if (!firstName && !lastName) {
                        console.warn('Coach has no name:', coach);
                        continue; // Skip coaches with no name
                    }
                    
                    if (csvCoachesMap.has(nameKey)) {
                        // Coach found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvCoachesMap.get(nameKey);
                        
                        // Create updated coach object, preserving non-CSV fields
                        const updatedCoach = { ...coach };
                        let fieldsChanged = 0;
                        const coachChangedFields = [];
                        
                        // Helper to compare and update field
                        const updateField = (fieldName, newVal) => {
                            // Get the actual current value from the original coach object
                            // Use 'in' operator to check if property exists (handles undefined vs missing property)
                            const oldVal = (fieldName in coach) ? coach[fieldName] : undefined;
                            // Normalize for comparison: treat undefined, null, and empty string as equivalent
                            const normalizedOld = (oldVal === undefined || oldVal === null || oldVal === '') ? '' : String(oldVal).trim();
                            const normalizedNew = (newVal === undefined || newVal === null || newVal === '') ? '' : String(newVal).trim();
                            
                            // Only update if values are actually different
                            if (normalizedOld !== normalizedNew) {
                                updatedCoach[fieldName] = newVal;
                                fieldsChanged++;
                                coachChangedFields.push(`${fieldName}: "${normalizedOld}" -> "${normalizedNew}"`);
                                return true;
                            }
                            return false;
                        };
                        
                        // Update fields from CSV (only if they exist in CSV)
                        if (headerMap['email'] !== undefined) {
                            const newVal = getValue(csvRow, 'email');
                            updateField('email', newVal);
                        }
                        if (headerMap['phone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'phone');
                            updateField('phone', newVal);
                        }
                        if (headerMap['workPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'workPhone');
                            updateField('workPhone', newVal);
                        }
                        if (headerMap['homePhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'homePhone');
                            updateField('homePhone', newVal);
                        }
                        if (headerMap['coachingLicenseLevel'] !== undefined) {
                            const licenseLevelRaw = getValue(csvRow, 'coachingLicenseLevel');
                            const licenseLevelNormalized = licenseLevelRaw.trim().toUpperCase();
                            let newLevel = 'N/A';
                            
                            // Check for just the number (1, 2, 3) or with "LEVEL" prefix
                            if (licenseLevelNormalized === '1' || licenseLevelNormalized === 'LEVEL 1' || licenseLevelNormalized === 'LEVEL1' || licenseLevelNormalized === 'L1') {
                                newLevel = '1';
                            } else if (licenseLevelNormalized === '2' || licenseLevelNormalized === 'LEVEL 2' || licenseLevelNormalized === 'LEVEL2' || licenseLevelNormalized === 'L2') {
                                newLevel = '2';
                            } else if (licenseLevelNormalized === '3' || licenseLevelNormalized === 'LEVEL 3' || licenseLevelNormalized === 'LEVEL3' || licenseLevelNormalized === 'L3') {
                                newLevel = '3';
                            } else if (licenseLevelNormalized === 'N/A' || licenseLevelNormalized === 'NA' || licenseLevelNormalized === '' || licenseLevelNormalized === 'NULL' || licenseLevelNormalized === 'NONE') {
                                newLevel = 'N/A';
                            } else {
                                // Try to extract number from the string (e.g., "Level 1", "1", etc.)
                                const numberMatch = licenseLevelNormalized.match(/\b([123])\b/);
                                if (numberMatch) {
                                    newLevel = numberMatch[1];
                                    debugOutput.push(`  Extracted license level "${newLevel}" from "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}")`);
                                } else {
                                    debugOutput.push(`  Warning: Unexpected license level value: "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}") - defaulting to N/A`);
                                }
                            }
                            updateField('coachingLicenseLevel', newLevel);
                        }
                        if (headerMap['gender'] !== undefined) {
                            const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                            let newGender = '';
                            if (genderRaw === 'M' || genderRaw === 'MALE') newGender = 'M';
                            else if (genderRaw === 'F' || genderRaw === 'FEMALE') newGender = 'F';
                            else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') newGender = 'NB';
                            updateField('gender', newGender);
                        }
                        if (headerMap['registered'] !== undefined) {
                            const newVal = getValue(csvRow, 'registered');
                            updateField('registered', newVal);
                        }
                        if (headerMap['paid'] !== undefined) {
                            const newVal = getValue(csvRow, 'paid');
                            updateField('paid', newVal);
                        }
                        if (headerMap['backgroundCheck'] !== undefined) {
                            const newVal = getValue(csvRow, 'backgroundCheck');
                            updateField('backgroundCheck', newVal);
                        }
                        if (headerMap['level3ExamCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'level3ExamCompleted');
                            updateField('level3ExamCompleted', newVal);
                        }
                        if (headerMap['pduCeuUnits'] !== undefined) {
                            const newVal = getValue(csvRow, 'pduCeuUnits');
                            updateField('pduCeuUnits', newVal);
                        }
                        if (headerMap['fieldWorkHours'] !== undefined) {
                            const newVal = getValue(csvRow, 'fieldWorkHours');
                            updateField('fieldWorkHours', newVal);
                        }
                        if (headerMap['firstAidTypeExpires'] !== undefined) {
                            const newVal = getValue(csvRow, 'firstAidTypeExpires');
                            updateField('firstAidTypeExpires', newVal);
                        }
                        if (headerMap['cprExpires'] !== undefined) {
                            const newVal = getValue(csvRow, 'cprExpires');
                            updateField('cprExpires', newVal);
                        }
                        if (headerMap['concussionTrainingCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'concussionTrainingCompleted');
                            updateField('concussionTrainingCompleted', newVal);
                        }
                        if (headerMap['nicaPhilosophyCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'nicaPhilosophyCompleted');
                            updateField('nicaPhilosophyCompleted', newVal);
                        }
                        if (headerMap['athleteAbuseAwarenessCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'athleteAbuseAwarenessCompleted');
                            updateField('athleteAbuseAwarenessCompleted', newVal);
                        }
                        if (headerMap['licenseLevel1Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel1Completed');
                            updateField('licenseLevel1Completed', newVal);
                        }
                        if (headerMap['licenseLevel2Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel2Completed');
                            updateField('licenseLevel2Completed', newVal);
                        }
                        if (headerMap['licenseLevel3Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel3Completed');
                            updateField('licenseLevel3Completed', newVal);
                        }
                        if (headerMap['otbSkills101ClassroomCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'otbSkills101ClassroomCompleted');
                            updateField('otbSkills101ClassroomCompleted', newVal);
                        }
                        if (headerMap['otbSkills101OutdoorCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'otbSkills101OutdoorCompleted');
                            updateField('otbSkills101OutdoorCompleted', newVal);
                        }
                        if (headerMap['nicaLeaderSummitCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'nicaLeaderSummitCompleted');
                            updateField('nicaLeaderSummitCompleted', newVal);
                        }
                        
                        // Update name fields (use original case from CSV)
                        const csvLastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                        const csvFirstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                        const csvLastName = (csvRow[csvLastNameIdx] || '').trim();
                        const csvFirstName = (csvRow[csvFirstNameIdx] || '').trim();
                        const newName = `${csvFirstName} ${csvLastName}`.trim();
                        updateField('firstName', csvFirstName);
                        updateField('lastName', csvLastName);
                        updateField('name', newName);
                        
                        totalFieldsUpdated += fieldsChanged;
                        if (fieldsChanged > 0) {
                            debugOutput.push(`✓ MATCHED: "${nameKey}" (${coach.name || 'NO NAME'}) - ${fieldsChanged} field(s) changed:`);
                            coachChangedFields.forEach(f => debugOutput.push(`    ${f}`));
                        } else {
                            debugOutput.push(`✓ MATCHED: "${nameKey}" (${coach.name || 'NO NAME'}) - No changes`);
                        }
                        updatedCoaches.push(updatedCoach);
                    } else {
                        // Coach not in CSV - remove them (don't add to updatedCoaches)
                        removedCount++;
                        debugOutput.push(`✗ NOT IN CSV: "${nameKey}" (${coach.name || 'NO NAME'}) - Will be REMOVED`);
                    }
                }

                // Add new coaches from CSV that weren't in the roster
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvCoachesMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        // New coach from CSV
                        const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                        const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                        const lastName = (csvRow[lastNameIdx] || '').trim();
                        const firstName = (csvRow[firstNameIdx] || '').trim();
                        const name = `${firstName} ${lastName}`.trim();
                        debugOutput.push(`+ NEW IN CSV: "${nameKey}" (${firstName} ${lastName}) - Will be ADDED`);

                        // Get gender for default photo
                        const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                        let gender = '';
                        if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                        else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                        else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const licenseLevelRaw = getValue(csvRow, 'coachingLicenseLevel').trim().toUpperCase();
                        let licenseLevel = 'N/A';
                        // Check for just the number (1, 2, 3) or with "LEVEL" prefix
                        if (licenseLevelRaw === '1' || licenseLevelRaw === 'LEVEL 1' || licenseLevelRaw === 'LEVEL1') licenseLevel = '1';
                        else if (licenseLevelRaw === '2' || licenseLevelRaw === 'LEVEL 2' || licenseLevelRaw === 'LEVEL2') licenseLevel = '2';
                        else if (licenseLevelRaw === '3' || licenseLevelRaw === 'LEVEL 3' || licenseLevelRaw === 'LEVEL3') licenseLevel = '3';
                        else if (licenseLevelRaw === 'N/A' || licenseLevelRaw === 'NA' || licenseLevelRaw === '') licenseLevel = 'N/A';

                        const newCoach = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 10000,
                            name: name,
                            firstName,
                            lastName,
                            photo: defaultPhoto,
                            phone: getPhoneValue(csvRow, 'phone'),
                            email: getValue(csvRow, 'email'),
                            coachingLicenseLevel: licenseLevel,
                            workPhone: getPhoneValue(csvRow, 'workPhone'),
                            homePhone: getPhoneValue(csvRow, 'homePhone'),
                            gender: gender,
                            registered: getValue(csvRow, 'registered'),
                            paid: getValue(csvRow, 'paid'),
                            backgroundCheck: getValue(csvRow, 'backgroundCheck'),
                            level3ExamCompleted: getValue(csvRow, 'level3ExamCompleted'),
                            pduCeuUnits: getValue(csvRow, 'pduCeuUnits'),
                            fieldWorkHours: getValue(csvRow, 'fieldWorkHours'),
                            firstAidTypeExpires: getValue(csvRow, 'firstAidTypeExpires'),
                            cprExpires: getValue(csvRow, 'cprExpires'),
                            concussionTrainingCompleted: getValue(csvRow, 'concussionTrainingCompleted'),
                            nicaPhilosophyCompleted: getValue(csvRow, 'nicaPhilosophyCompleted'),
                            athleteAbuseAwarenessCompleted: getValue(csvRow, 'athleteAbuseAwarenessCompleted'),
                            licenseLevel1Completed: getValue(csvRow, 'licenseLevel1Completed'),
                            licenseLevel2Completed: getValue(csvRow, 'licenseLevel2Completed'),
                            licenseLevel3Completed: getValue(csvRow, 'licenseLevel3Completed'),
                            otbSkills101ClassroomCompleted: getValue(csvRow, 'otbSkills101ClassroomCompleted'),
                            otbSkills101OutdoorCompleted: getValue(csvRow, 'otbSkills101OutdoorCompleted'),
                            nicaLeaderSummitCompleted: getValue(csvRow, 'nicaLeaderSummitCompleted'),
                            fitness: String(Math.ceil(getFitnessScale() / 2)),
                            skills: String(Math.ceil(getSkillsScale() / 2)),
                            notes: ''
                        };
                        updatedCoaches.push(newCoach);
                        addedCount++;
                    }
                }

                // Update data
                data.coaches = updatedCoaches;
                saveData();
                renderCoaches();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new coach(es)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} coach(es) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                // Add summary to debug output
                debugOutput.push('');
                debugOutput.push('=== SUMMARY ===');
                debugOutput.push(`Total fields updated: ${totalFieldsUpdated}`);
                debugOutput.push(`Coaches matched and updated: ${updatedCount}`);
                debugOutput.push(`New coaches added: ${addedCount}`);
                debugOutput.push(`Coaches removed: ${removedCount}`);
                
                // Display debug output
                const debugDiv = document.getElementById('coach-update-debug');
                if (debugDiv) {
                    debugDiv.innerHTML = debugOutput.join('<br>');
                    debugDiv.style.display = 'block';
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Helper function to let user select and read a CSV file
        function selectAndReadCSVFile(type) {
            return new Promise((resolve) => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.csv';
                input.style.display = 'none';
                
                let resolved = false;
                
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) {
                        if (!resolved) {
                            resolved = true;
                            resolve(null);
                        }
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(e.target.result);
                        }
                    };
                    reader.onerror = () => {
                        if (!resolved) {
                            resolved = true;
                            resolve(null);
                        }
                    };
                    reader.readAsText(file);
                };
                
                // Trigger file selection
                document.body.appendChild(input);
                input.click();
                
                // Clean up and timeout
                setTimeout(() => {
                    if (document.body.contains(input)) {
                        document.body.removeChild(input);
                    }
                    if (!resolved) {
                        resolved = true;
                        resolve(null);
                    }
                }, 60000); // 60 second timeout
            });
        }

        function normalizePhoneNumber(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return digits;
            } else if (digits.length === 11 && digits[0] === '1') {
                return digits.substring(1);
            }
            return '';
        }

        function openAddSinglePracticeModal() {
            // Add a single practice row with date field (not a separate modal)
            addSinglePracticeRow();
        }

        // Location map modal functions
        let currentPracticeIdForLocation = null;
        let map = null;
        let mapMarker = null;

        function openLocationMap(practiceId) {
            currentPracticeIdForLocation = practiceId;
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;

            const modal = document.getElementById('location-map-modal');
            if (!modal) return;

            // Load Leaflet CSS and JS if not already loaded
            if (!document.querySelector('link[href*="leaflet"]')) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                leafletCSS.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';
                leafletCSS.crossOrigin = '';
                document.head.appendChild(leafletCSS);
            }

            if (!window.L) {
                const leafletJS = document.createElement('script');
                leafletJS.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletJS.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';
                leafletJS.crossOrigin = '';
                leafletJS.onload = () => {
                    setTimeout(() => initializeMap(practice), 100);
                };
                document.head.appendChild(leafletJS);
            } else {
                setTimeout(() => initializeMap(practice), 100);
            }

            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            const addressInput = document.getElementById('location-address');
            const searchInput = document.getElementById('location-search');
            const previousSelect = document.getElementById('location-previous');

            if (latInput) latInput.value = practice.locationLat || '';
            if (lngInput) lngInput.value = practice.locationLng || '';
            if (addressInput) addressInput.value = practice.meetLocation || '';
            if (searchInput) searchInput.value = '';
            
            // Populate previous locations dropdown
            if (previousSelect) {
                populatePreviousLocations(previousSelect);
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }
        
        function populatePreviousLocations(selectElement) {
            if (!selectElement) return;
            
            // Get all unique meet locations from all practices (including saved ones)
            const locations = new Map();
            
            // Get from season settings practices
            if (data.seasonSettings && Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices.forEach(practice => {
                    if (practice.meetLocation && practice.locationLat && practice.locationLng) {
                        const key = `${practice.locationLat},${practice.locationLng}`;
                        if (!locations.has(key)) {
                            locations.set(key, {
                                address: practice.meetLocation,
                                lat: practice.locationLat,
                                lng: practice.locationLng
                            });
                        }
                    }
                });
            }
            
            // Get from all rides (practices)
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.meetLocation && ride.locationLat && ride.locationLng) {
                        const key = `${ride.locationLat},${ride.locationLng}`;
                        if (!locations.has(key)) {
                            locations.set(key, {
                                address: ride.meetLocation,
                                lat: ride.locationLat,
                                lng: ride.locationLng
                            });
                        }
                    }
                });
            }
            
            // Clear and populate dropdown
            selectElement.innerHTML = '<option value="">-- Select from previous locations --</option>';
            locations.forEach((location, key) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = location.address;
                selectElement.appendChild(option);
            });
        }
        
        function selectPreviousLocation(value) {
            if (!value) return;
            
            const [latStr, lngStr] = value.split(',');
            const lat = parseFloat(latStr);
            const lng = parseFloat(lngStr);
            
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
            
            // Update inputs
            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            const addressInput = document.getElementById('location-address');
            
            if (latInput) latInput.value = lat;
            if (lngInput) lngInput.value = lng;
            
            // Find the address from the location
            const locations = new Map();
            if (data.seasonSettings && Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices.forEach(practice => {
                    if (practice.meetLocation && practice.locationLat && practice.locationLng) {
                        const key = `${practice.locationLat},${practice.locationLng}`;
                        if (!locations.has(key)) {
                            locations.set(key, practice.meetLocation);
                        }
                    }
                });
            }
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.meetLocation && ride.locationLat && ride.locationLng) {
                        const key = `${ride.locationLat},${ride.locationLng}`;
                        if (!locations.has(key)) {
                            locations.set(key, ride.meetLocation);
                        }
                    }
                });
            }
            
            const address = locations.has(value) ? locations.get(value) : '';
            
            if (addressInput) {
                addressInput.value = address;
            }
            
            // If we have a practice ID, update the practice draft and the practice row input field
            if (currentPracticeIdForLocation !== null && address) {
                ensureSeasonDraft();
                if (seasonSettingsDraft) {
                    const practiceIndex = seasonSettingsDraft.practices.findIndex(
                        p => String(p.id) === String(currentPracticeIdForLocation)
                    );
                    if (practiceIndex !== -1) {
                        // Update practice draft with location
                        seasonSettingsDraft.practices[practiceIndex].meetLocation = address;
                        seasonSettingsDraft.practices[practiceIndex].locationLat = lat;
                        seasonSettingsDraft.practices[practiceIndex].locationLng = lng;
                        
                        // Update the practice row input field directly in both containers
                        const practiceRows = document.querySelectorAll(`.practice-row[data-practice-id="${currentPracticeIdForLocation}"]`);
                        practiceRows.forEach(practiceRow => {
                            const meetLocationInput = practiceRow.querySelector('input[onchange*="meetLocation"]');
                            if (meetLocationInput) {
                                meetLocationInput.value = address;
                            }
                        });
                    }
                }
            } else if (!address) {
                // Reverse geocode to get address if not found in saved locations
                reverseGeocode(lat, lng);
            }
            
            // Update map if it exists
            if (map) {
                map.setView([lat, lng], 15);
                if (mapMarker) {
                    mapMarker.setLatLng([lat, lng]);
                } else {
                    mapMarker = L.marker([lat, lng]).addTo(map);
                }
            }
        }

        function initializeMap(practice) {
            const mapContainer = document.getElementById('map-container');
            if (!mapContainer || !window.L) {
                setTimeout(() => initializeMap(practice), 100);
                return;
            }

            // Clear existing map
            if (map) {
                map.remove();
                map = null;
                mapMarker = null;
            }

            // Remove placeholder if it exists
            const placeholder = document.getElementById('map-placeholder');
            if (placeholder) {
                placeholder.remove();
            }

            // Default to Tamalpais High School area (Mill Valley, CA)
            const defaultLat = 37.9069;
            const defaultLng = -122.5446;
            
            const lat = practice.locationLat && Number.isFinite(practice.locationLat) ? practice.locationLat : defaultLat;
            const lng = practice.locationLng && Number.isFinite(practice.locationLng) ? practice.locationLng : defaultLng;
            // Zoom level: ~5 miles view = zoom level 12-13 (higher number = more zoomed in)
            // 10 = ~50 miles, 12 = ~10 miles, 13 = ~5 miles, 15 = ~1 mile
            const zoom = practice.locationLat && practice.locationLng ? 15 : 13;

            try {
                map = L.map('map-container').setView([lat, lng], zoom);

                // Use Google Maps tiles via Leaflet
                // Google Maps tile layer (roadmap style)
                // Note: For production, you should use a Google Maps API key
                // This uses Google Maps tiles directly - may have usage limits
                L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                    attribution: '© Google Maps',
                    maxZoom: 20,
                    subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                }).addTo(map);

                if (practice.locationLat && practice.locationLng && Number.isFinite(practice.locationLat) && Number.isFinite(practice.locationLng)) {
                    mapMarker = L.marker([practice.locationLat, practice.locationLng]).addTo(map);
                }

                map.on('click', function(e) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;

                    if (mapMarker) {
                        mapMarker.setLatLng([lat, lng]);
                    } else {
                        mapMarker = L.marker([lat, lng]).addTo(map);
                    }

                    updateLocationInputs(lat, lng);
                    reverseGeocode(lat, lng);
                });

                // Update inputs when manually changed
                const latInput = document.getElementById('location-latitude');
                const lngInput = document.getElementById('location-longitude');
                
                const updateMapFromInputs = () => {
                    const lat = parseFloat(latInput.value);
                    const lng = parseFloat(lngInput.value);
                    if (Number.isFinite(lat) && Number.isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        map.setView([lat, lng], 15);
                        if (mapMarker) {
                            mapMarker.setLatLng([lat, lng]);
                        } else {
                            mapMarker = L.marker([lat, lng]).addTo(map);
                        }
                        reverseGeocode(lat, lng);
                    }
                };

                if (latInput) {
                    latInput.addEventListener('change', updateMapFromInputs);
                    latInput.addEventListener('blur', updateMapFromInputs);
                }
                if (lngInput) {
                    lngInput.addEventListener('change', updateMapFromInputs);
                    lngInput.addEventListener('blur', updateMapFromInputs);
                }
            } catch (error) {
                console.error('Map initialization error:', error);
                mapContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Error loading map. Please refresh and try again.</div>';
            }
        }

        function updateLocationInputs(lat, lng) {
            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            if (latInput) latInput.value = lat.toFixed(6);
            if (lngInput) lngInput.value = lng.toFixed(6);
        }

        function reverseGeocode(lat, lng) {
            // Use Nominatim (OpenStreetMap geocoding service) with delay to respect rate limits
            // Only update address field if it's empty (don't overwrite user-entered text)
            setTimeout(() => {
                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`, {
                    headers: {
                        'User-Agent': 'MTB Team Practice Manager'
                    }
                })
                    .then(response => response.json())
                    .then(data => {
                        const addressInput = document.getElementById('location-address');
                        // Only update if field is empty - preserve user-entered text
                        if (addressInput && data.display_name && !addressInput.value.trim()) {
                            addressInput.value = data.display_name;
                        }
                    })
                    .catch(error => {
                        console.error('Geocoding error:', error);
                    });
            }, 500);
        }

        function searchLocation() {
            const searchInput = document.getElementById('location-search');
            if (!searchInput || !searchInput.value.trim()) {
                alert('Please enter a location to search');
                return;
            }

            if (!map) {
                alert('Map is not loaded yet. Please wait a moment and try again.');
                return;
            }

            const query = encodeURIComponent(searchInput.value.trim());
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=1`, {
                headers: {
                    'User-Agent': 'MTB Team Practice Manager'
                }
            })
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const result = data[0];
                        const lat = parseFloat(result.lat);
                        const lng = parseFloat(result.lon);

                        if (Number.isFinite(lat) && Number.isFinite(lng)) {
                            map.setView([lat, lng], 15);
                            if (mapMarker) {
                                mapMarker.setLatLng([lat, lng]);
                            } else {
                                mapMarker = L.marker([lat, lng]).addTo(map);
                            }
                            updateLocationInputs(lat, lng);
                            
                            const addressInput = document.getElementById('location-address');
                            // Only update if field is empty - preserve user-entered text
                            if (addressInput && (!addressInput.value.trim())) {
                                addressInput.value = result.display_name;
                            }
                        }
                    } else {
                        alert('Location not found. Please try a different search.');
                    }
                })
                .catch(error => {
                    console.error('Search error:', error);
                    alert('Error searching for location. Please try again.');
                });
        }

        function saveLocation() {
            if (currentPracticeIdForLocation === null) return;

            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            const addressInput = document.getElementById('location-address');

            const lat = latInput ? parseFloat(latInput.value) : null;
            const lng = lngInput ? parseFloat(lngInput.value) : null;
            const address = addressInput ? addressInput.value.trim() : '';

            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(
                p => String(p.id) === String(currentPracticeIdForLocation)
            );
            if (practiceIndex === -1) return;

            if (Number.isFinite(lat) && Number.isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                seasonSettingsDraft.practices[practiceIndex].locationLat = lat;
                seasonSettingsDraft.practices[practiceIndex].locationLng = lng;
            } else {
                seasonSettingsDraft.practices[practiceIndex].locationLat = null;
                seasonSettingsDraft.practices[practiceIndex].locationLng = null;
            }

            if (address) {
                seasonSettingsDraft.practices[practiceIndex].meetLocation = address;
            }

            closeLocationMapModal();
            renderPracticeRows();
            // Check for changes after location is saved
            checkPracticeChanges(currentPracticeIdForLocation);
        }

        function closeLocationMapModal() {
            const modal = document.getElementById('location-map-modal');
            if (!modal) return;

            if (map) {
                try {
                    map.remove();
                } catch (e) {
                    console.error('Error removing map:', e);
                }
                map = null;
                mapMarker = null;
            }

            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentPracticeIdForLocation = null;
        }

        // Roster Refinement Functions
        let currentPracticeIdForRoster = null;
        let rosterFilterSettings = {
            filterType: '',
            grade: { '9th': true, '10th': true, '11th': true, '12th': true },
            gender: { 'M': true, 'F': true, 'NB': true },
            racingGroup: {}
        };

        // Helper function to get filtered riders based on practice roster filter
        function getRosterFilterDescription(practice) {
            if (!practice || !practice.rosterFilter) {
                return 'All';
            }
            
            const filter = practice.rosterFilter;
            const filterType = filter.filterType || '';
            
            if (filterType === 'grade') {
                const selectedGrades = [];
                const grades = ['9th', '10th', '11th', '12th'];
                grades.forEach(grade => {
                    if (filter.grade && filter.grade[grade] !== false) {
                        selectedGrades.push(grade);
                    }
                });
                if (selectedGrades.length === 0) return 'All';
                if (selectedGrades.length === 1) return `${selectedGrades[0]} Only`;
                if (selectedGrades.length === 4) return 'All Grades';
                return selectedGrades.join(', ');
            } else if (filterType === 'gender') {
                const selectedGenders = [];
                if (filter.gender && filter.gender['M'] !== false) selectedGenders.push('Male');
                if (filter.gender && filter.gender['F'] !== false) selectedGenders.push('Female');
                if (filter.gender && filter.gender['NB'] !== false) selectedGenders.push('Nonbinary');
                if (selectedGenders.length === 0) return 'All';
                if (selectedGenders.length === 1) return `${selectedGenders[0]} Only`;
                if (selectedGenders.length === 3) return 'All';
                return selectedGenders.join(', ');
            } else if (filterType === 'racingGroup') {
                const selectedGroups = [];
                if (filter.racingGroup) {
                    Object.keys(filter.racingGroup).forEach(group => {
                        if (filter.racingGroup[group] !== false) {
                            selectedGroups.push(group);
                        }
                    });
                }
                if (selectedGroups.length === 0) return 'All';
                if (selectedGroups.length === 1) return `${selectedGroups[0]} Only`;
                return selectedGroups.join(', ');
            }
            
            return 'All';
        }

        function getFilteredRidersForPractice(practice) {
            if (!practice || !practice.rosterFilter) {
                // No filter - return all riders
                return data.riders || [];
            }
            
            const filter = practice.rosterFilter;
            return (data.riders || []).filter(rider => {
                // Filter by grade
                if (filter.filterType === 'grade' || filter.filterType === '') {
                    const riderGrade = normalizeGradeValue(rider.grade || '9th');
                    if (!filter.grade[riderGrade]) {
                        return false;
                    }
                }
                
                // Filter by gender
                if (filter.filterType === 'gender' || filter.filterType === '') {
                    const riderGender = (rider.gender || '').toString().toUpperCase();
                    let genderKey = '';
                    if (riderGender === 'M' || riderGender === 'MALE') {
                        genderKey = 'M';
                    } else if (riderGender === 'F' || riderGender === 'FEMALE') {
                        genderKey = 'F';
                    } else if (riderGender === 'NB' || riderGender === 'NONBINARY') {
                        genderKey = 'NB';
                    }
                    if (genderKey && !filter.gender[genderKey]) {
                        return false;
                    }
                }
                
                // Filter by racing group
                if (filter.filterType === 'racingGroup' || filter.filterType === '') {
                    const riderGroup = rider.racingGroup || '';
                    if (riderGroup && !filter.racingGroup[riderGroup]) {
                        return false;
                    }
                }
                
                return true;
            });
        }

        // Get practice settings for a ride date
        function getPracticeSettingsForRide(ride) {
            if (!ride || !ride.date) return null;
            
            const settings = data.seasonSettings || {};
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            const rideDate = parseISODate(ride.date);
            if (!rideDate) return null;
            
            // Check for specific date match first
            const dateKey = formatDateToISO(rideDate);
            const specificPractice = practices.find(p => p.specificDate === dateKey);
            if (specificPractice) return specificPractice;
            
            // Check for day of week match
            const weekday = rideDate.getDay();
            const recurringPractice = practices.find(p => p.dayOfWeek === weekday);
            return recurringPractice || null;
        }

        function openRosterRefinement(practiceId) {
            currentPracticeIdForRoster = practiceId;
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;
            
            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;
            
            // Load existing filter settings or use defaults
            if (practice.rosterFilter) {
                rosterFilterSettings = JSON.parse(JSON.stringify(practice.rosterFilter));
            } else {
                // Reset to defaults
                rosterFilterSettings = {
                    filterType: '',
                    grade: { '9th': true, '10th': true, '11th': true, '12th': true },
                    gender: { 'M': true, 'F': true, 'NB': true },
                    racingGroup: {}
                };
                // Get all unique racing groups from riders
                const allRacingGroups = new Set();
                (data.riders || []).forEach(rider => {
                    if (rider.racingGroup) {
                        allRacingGroups.add(rider.racingGroup);
                    }
                });
                allRacingGroups.forEach(group => {
                    rosterFilterSettings.racingGroup[group] = true;
                });
            }
            
            // Set filter type dropdown
            const filterTypeSelect = document.getElementById('roster-filter-type');
            if (filterTypeSelect) {
                filterTypeSelect.value = rosterFilterSettings.filterType || '';
            }
            
            updateRosterFilterOptions();
            renderFilteredRoster();
            
            const modal = document.getElementById('roster-refinement-modal');
            if (modal) {
                modal.classList.add('visible');
                modal.setAttribute('aria-hidden', 'false');
            }
        }

        function updateRosterFilterOptions() {
            const filterTypeSelect = document.getElementById('roster-filter-type');
            const filterOptionsDiv = document.getElementById('roster-filter-options');
            if (!filterTypeSelect || !filterOptionsDiv) return;
            
            const filterType = filterTypeSelect.value;
            rosterFilterSettings.filterType = filterType;
            
            if (!filterType) {
                filterOptionsDiv.style.display = 'none';
                renderFilteredRoster();
                return;
            }
            
            filterOptionsDiv.style.display = 'block';
            let optionsHtml = '<div style="display: flex; flex-wrap: wrap; gap: 12px;">';
            
            if (filterType === 'grade') {
                const grades = ['9th', '10th', '11th', '12th'];
                grades.forEach(grade => {
                    const checked = rosterFilterSettings.grade[grade] !== false;
                    optionsHtml += `
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" value="${grade}" ${checked ? 'checked' : ''} onchange="toggleRosterFilterOption('grade', '${grade}', this.checked)">
                            <span>${grade}</span>
                        </label>
                    `;
                });
            } else if (filterType === 'gender') {
                const genders = [
                    { value: 'M', label: 'Male' },
                    { value: 'F', label: 'Female' },
                    { value: 'NB', label: 'Nonbinary' }
                ];
                genders.forEach(g => {
                    const checked = rosterFilterSettings.gender[g.value] !== false;
                    optionsHtml += `
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" value="${g.value}" ${checked ? 'checked' : ''} onchange="toggleRosterFilterOption('gender', '${g.value}', this.checked)">
                            <span>${g.label}</span>
                        </label>
                    `;
                });
            } else if (filterType === 'racingGroup') {
                // Get all unique racing groups from riders
                const allRacingGroups = new Set();
                (data.riders || []).forEach(rider => {
                    if (rider.racingGroup) {
                        allRacingGroups.add(rider.racingGroup);
                    }
                });
                const sortedGroups = Array.from(allRacingGroups).sort();
                sortedGroups.forEach(group => {
                    if (!rosterFilterSettings.racingGroup.hasOwnProperty(group)) {
                        rosterFilterSettings.racingGroup[group] = true;
                    }
                    const checked = rosterFilterSettings.racingGroup[group] !== false;
                    optionsHtml += `
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                            <input type="checkbox" value="${escapeHtml(group)}" ${checked ? 'checked' : ''} onchange="toggleRosterFilterOption('racingGroup', '${escapeHtml(group)}', this.checked)">
                            <span>${escapeHtml(group)}</span>
                        </label>
                    `;
                });
            }
            
            optionsHtml += '</div>';
            filterOptionsDiv.innerHTML = optionsHtml;
            
            renderFilteredRoster();
        }

        function toggleRosterFilterOption(type, value, checked) {
            if (type === 'grade') {
                rosterFilterSettings.grade[value] = checked;
            } else if (type === 'gender') {
                rosterFilterSettings.gender[value] = checked;
            } else if (type === 'racingGroup') {
                rosterFilterSettings.racingGroup[value] = checked;
            }
            renderFilteredRoster();
        }

        function renderFilteredRoster() {
            const tbody = document.getElementById('roster-filtered-list');
            const countSpan = document.getElementById('roster-filtered-count');
            if (!tbody) return;
            
            let filteredRiders = (data.riders || []).filter(rider => {
                // Filter by grade
                if (rosterFilterSettings.filterType === 'grade' || rosterFilterSettings.filterType === '') {
                    const riderGrade = normalizeGradeValue(rider.grade || '9th');
                    if (!rosterFilterSettings.grade[riderGrade]) {
                        return false;
                    }
                }
                
                // Filter by gender
                if (rosterFilterSettings.filterType === 'gender' || rosterFilterSettings.filterType === '') {
                    const riderGender = (rider.gender || '').toString().toUpperCase();
                    let genderKey = '';
                    if (riderGender === 'M' || riderGender === 'MALE') {
                        genderKey = 'M';
                    } else if (riderGender === 'F' || riderGender === 'FEMALE') {
                        genderKey = 'F';
                    } else if (riderGender === 'NB' || riderGender === 'NONBINARY') {
                        genderKey = 'NB';
                    }
                    if (genderKey && !rosterFilterSettings.gender[genderKey]) {
                        return false;
                    }
                }
                
                // Filter by racing group
                if (rosterFilterSettings.filterType === 'racingGroup' || rosterFilterSettings.filterType === '') {
                    const riderGroup = rider.racingGroup || '';
                    if (riderGroup && !rosterFilterSettings.racingGroup[riderGroup]) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Sort by name
            filteredRiders.sort((a, b) => {
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            let html = '';
            filteredRiders.forEach(rider => {
                const grade = normalizeGradeValue(rider.grade || '9th');
                const gender = (rider.gender || '').toString().toUpperCase();
                let genderLabel = '';
                if (gender === 'M' || gender === 'MALE') {
                    genderLabel = 'Male';
                } else if (gender === 'F' || gender === 'FEMALE') {
                    genderLabel = 'Female';
                } else if (gender === 'NB' || gender === 'NONBINARY') {
                    genderLabel = 'Nonbinary';
                } else {
                    genderLabel = gender || '';
                }
                const racingGroup = rider.racingGroup || '';
                
                html += `
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid #eee;">✓</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee;">${escapeHtml(rider.name || '')}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee;">${escapeHtml(grade)}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee;">${escapeHtml(genderLabel)}</td>
                        <td style="padding: 8px; border-bottom: 1px solid #eee;">${escapeHtml(racingGroup)}</td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            if (countSpan) {
                countSpan.textContent = filteredRiders.length;
            }
        }

        function saveRosterRefinement() {
            if (currentPracticeIdForRoster === null) return;
            
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;
            
            const practiceIndex = seasonSettingsDraft.practices.findIndex(
                p => String(p.id) === String(currentPracticeIdForRoster)
            );
            if (practiceIndex === -1) return;
            
            // Save filter settings to practice in draft
            const savedRosterFilter = JSON.parse(JSON.stringify(rosterFilterSettings));
            seasonSettingsDraft.practices[practiceIndex].rosterFilter = savedRosterFilter;
            
            // Also immediately save to data.seasonSettings.practices and persist to Supabase
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            if (!Array.isArray(data.seasonSettings.practices)) {
                data.seasonSettings.practices = [];
            }
            
            const settingsPracticeIndex = data.seasonSettings.practices.findIndex(
                p => String(p.id) === String(currentPracticeIdForRoster)
            );
            if (settingsPracticeIndex >= 0) {
                data.seasonSettings.practices[settingsPracticeIndex].rosterFilter = savedRosterFilter;
            } else {
                // Practice not found in data.seasonSettings - add it
                const practice = seasonSettingsDraft.practices[practiceIndex];
                data.seasonSettings.practices.push({
                    ...practice,
                    rosterFilter: savedRosterFilter
                });
            }
            
            // Persist to Supabase
            saveData();
            
            closeRosterRefinement();
            renderPracticeRows();
            
            // Update original state to reflect saved changes
            const key = String(currentPracticeIdForRoster);
            originalPracticeStates.set(key, JSON.parse(JSON.stringify(seasonSettingsDraft.practices[practiceIndex])));
            
            // Check for changes - should show no changes now since we saved
            checkPracticeChanges(currentPracticeIdForRoster);
        }

        function closeRosterRefinement() {
            const modal = document.getElementById('roster-refinement-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
            currentPracticeIdForRoster = null;
        }

        function formatDateToISO(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function parseISODate(dateString) {
            if (!dateString) return null;
            // Parse date string (YYYY-MM-DD) in local time to avoid timezone issues
            const parts = dateString.split('-');
            if (parts.length !== 3) {
                // Fallback to standard parsing if format is unexpected
                const parsed = new Date(dateString);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            }
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
            const day = parseInt(parts[2], 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return null;
            }
            const parsed = new Date(year, month, day);
            return Number.isNaN(parsed.getTime()) ? null : parsed;
        }

        function openAddPracticeModal() {
            const modal = document.getElementById('add-practice-modal');
            if (!modal) return;

            const dateInput = document.getElementById('practice-date');
            const timeInput = document.getElementById('practice-time');
            
            if (dateInput) dateInput.value = '';
            if (timeInput) timeInput.value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');

            if (dateInput) {
                setTimeout(() => dateInput.focus(), 0);
            }
        }

        function closeAddPracticeModal() {
            const modal = document.getElementById('add-practice-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        function saveAddPractice() {
            const dateInput = document.getElementById('practice-date');
            const timeInput = document.getElementById('practice-time');
            
            const dateValue = dateInput ? dateInput.value : '';
            const timeValue = timeInput ? timeInput.value : '';

            if (!dateValue) {
                alert('Please select a date');
                return;
            }

            if (!timeValue) {
                alert('Please select a time');
                return;
            }

            const existingRide = data.rides.find(ride => ride.date === dateValue);
            let rideId;

            if (existingRide) {
                rideId = existingRide.id;
            } else {
                const ride = {
                    id: generateId(),
                    date: dateValue,
                    time: timeValue,
                    availableCoaches: [],
                    availableRiders: [],
                    assignments: {},
                    groups: []
                };
                data.rides.push(ride);
                rideId = ride.id;
            }

            data.currentRide = rideId;
            saveData();
            closeAddPracticeModal();
            renderRides();
            loadCurrentRide();
        }

        function formatTimeForDisplay(time) {
            if (!time) return '';
            const [hourStr, minuteStr = '00'] = time.split(':');
            const hour = parseInt(hourStr, 10);
            const minute = parseInt(minuteStr, 10) || 0;
            if (!Number.isFinite(hour)) return time;
            const period = hour >= 12 ? 'PM' : 'AM';
            const hour12 = ((hour + 11) % 12) + 1;
            return `${hour12}:${minute.toString().padStart(2, '0')} ${period}`;
        }

        function renderSeasonCalendar() {
            // Render to rides tab calendar if it exists
            const ridesContainer = document.getElementById('season-calendar');
            if (ridesContainer) {
                renderSeasonCalendarToContainer(ridesContainer);
            }
        }

        function renderSeasonCalendarForSettings() {
            // Render to settings tab calendar if it exists
            const settingsContainer = document.getElementById('season-calendar-settings');
            if (settingsContainer) {
                renderSeasonCalendarToContainer(settingsContainer);
            }
        }

        // Debounce calendar rendering to prevent multiple rapid updates
        let calendarRenderTimeout = null;
        function renderAllCalendars() {
            console.log('📅 CALENDAR: renderAllCalendars() called');
            // Clear any pending render
            if (calendarRenderTimeout) {
                clearTimeout(calendarRenderTimeout);
            }
            
            // Debounce the render to ensure all updates are complete
            calendarRenderTimeout = setTimeout(() => {
                console.log('📅 CALENDAR: Executing calendar render (debounced)');
                // Force complete rebuild by clearing both containers first
                const ridesContainer = document.getElementById('season-calendar');
                const settingsContainer = document.getElementById('season-calendar-settings');
                
                if (ridesContainer) {
                    ridesContainer.innerHTML = '';
                    ridesContainer.className = '';
                }
                if (settingsContainer) {
                    settingsContainer.innerHTML = '';
                    settingsContainer.className = '';
                }
                
                // Use requestAnimationFrame to ensure DOM is ready
                requestAnimationFrame(() => {
            // Render to both calendars if they exist
            renderSeasonCalendar();
            renderSeasonCalendarForSettings();
                    calendarRenderTimeout = null;
                });
            }, 50); // Small delay to batch multiple updates
        }

        function renderSeasonCalendarToContainer(container) {
            if (!container) return;

            // Clear container first to ensure fresh render (prevents old practice days from persisting)
            container.innerHTML = '';
            container.className = '';

            // Use draft settings if available (for live preview of changes), otherwise use saved settings
            // Merge draft with base settings to preserve all fields (fitnessScale, skillsScale, etc.)
            const baseSettings = data.seasonSettings || buildDefaultSeasonSettings();
            let settings, practices;
            if (seasonSettingsDraft) {
                // Use draft settings, but preserve other fields from base (fitnessScale, skillsScale, etc.)
                settings = { ...baseSettings, ...seasonSettingsDraft };
                // Explicitly use draft practices to ensure we see the latest changes
                practices = Array.isArray(seasonSettingsDraft.practices) ? seasonSettingsDraft.practices : [];
                console.log('📅 CALENDAR: Using draft practices, count:', practices.length, 'practices:', practices.map(p => ({ id: p.id, dayOfWeek: p.dayOfWeek, specificDate: p.specificDate })));
            } else {
                settings = baseSettings;
                practices = Array.isArray(settings.practices) ? settings.practices : [];
                console.log('📅 CALENDAR: Using saved practices, count:', practices.length);
            }
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);

            const practiceDateMap = new Map();
            let seasonStart = null;
            let seasonEnd = null;

            // If season dates are set, use them; otherwise determine from individual rides
            if (startDate && endDate && startDate <= endDate) {
                seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

                // Add regular practices based on day of week
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    // Ensure type-safe comparison (dayOfWeek might be string or number)
                    // IMPORTANT: Filter out practices that have specificDate (single practices should not appear on recurring days)
                    const matchedPractices = practices.filter(practice => {
                        const practiceDay = Number(practice.dayOfWeek);
                        const hasSpecificDate = practice.specificDate != null && practice.specificDate !== undefined && practice.specificDate !== '';
                        return Number.isFinite(practiceDay) && practiceDay === weekday && !hasSpecificDate;
                    });
                    if (matchedPractices.length > 0) {
                        practiceDateMap.set(dateKey, matchedPractices.map(practice => practice.time || ''));
                        console.log('📅 CALENDAR: Added practice for', dateKey, 'weekday', weekday, 'from practices:', matchedPractices.map(p => p.id));
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
                
                // Add single practices (with specificDate) to the calendar
                practices.forEach(practice => {
                    if (practice.specificDate && !practice.dayOfWeek) {
                        const practiceDate = parseISODate(practice.specificDate);
                        if (practiceDate && practiceDate >= seasonStart && practiceDate <= seasonEnd) {
                            const dateKey = formatDateToISO(practiceDate);
                            const existingTimes = practiceDateMap.get(dateKey) || [];
                            const practiceTime = practice.time || '';
                            if (practiceTime && !existingTimes.includes(practiceTime)) {
                                existingTimes.push(practiceTime);
                            }
                            if (existingTimes.length > 0) {
                                practiceDateMap.set(dateKey, existingTimes);
            } else {
                                // Even if no time, mark as practice date
                                practiceDateMap.set(dateKey, []);
                            }
                        }
                    }
                });
            } else {
                // No season dates set - try to determine range from practices or rides
                const practiceDates = [];
                const rideDates = [];
                
                // Collect dates from single practices
                practices.forEach(practice => {
                    if (practice.specificDate) {
                        const practiceDate = parseISODate(practice.specificDate);
                        if (practiceDate) practiceDates.push(practiceDate);
                    }
                });
                
                // Collect dates from rides
                if (Array.isArray(data.rides)) {
                    data.rides.forEach(ride => {
                        if (!ride.date) return;
                        const rideDate = parseISODate(ride.date);
                        if (rideDate) rideDates.push(rideDate);
                    });
                }
                
                // Use practice dates if available, otherwise use ride dates
                const allDates = practiceDates.length > 0 ? practiceDates : rideDates;
                
                if (allDates.length === 0) {
                    container.className = 'season-calendar-empty';
                    container.innerHTML = `
                        Set your season dates and practices to populate the calendar.
                    `;
                    return;
                }

                allDates.sort((a, b) => a - b);
                seasonStart = new Date(allDates[0].getFullYear(), allDates[0].getMonth(), 1);
                const lastDate = allDates[allDates.length - 1];
                seasonEnd = new Date(lastDate.getFullYear(), lastDate.getMonth() + 1, 0);
                
                // Add recurring practices to the calendar even without season dates
                if (practices.length > 0) {
                    const cursor = new Date(seasonStart.getTime());
                    while (cursor <= seasonEnd) {
                        const dateKey = formatDateToISO(cursor);
                        const weekday = cursor.getDay();
                        // Ensure type-safe comparison (dayOfWeek might be string or number)
                        const matchedPractices = practices.filter(practice => {
                            const practiceDay = Number(practice.dayOfWeek);
                            return Number.isFinite(practiceDay) && practiceDay === weekday && !practice.specificDate;
                        });
                        if (matchedPractices.length > 0) {
                            practiceDateMap.set(dateKey, matchedPractices.map(practice => practice.time || ''));
                        }
                        cursor.setDate(cursor.getDate() + 1);
                    }
                    
                    // Add single practices
                    practices.forEach(practice => {
                        if (practice.specificDate && !practice.dayOfWeek) {
                            const practiceDate = parseISODate(practice.specificDate);
                            if (practiceDate && practiceDate >= seasonStart && practiceDate <= seasonEnd) {
                                const dateKey = formatDateToISO(practiceDate);
                                const existingTimes = practiceDateMap.get(dateKey) || [];
                                const practiceTime = practice.time || '';
                                if (practiceTime && !existingTimes.includes(practiceTime)) {
                                    existingTimes.push(practiceTime);
                                }
                                if (existingTimes.length > 0) {
                                    practiceDateMap.set(dateKey, existingTimes);
                                } else {
                                    practiceDateMap.set(dateKey, []);
                                }
                            }
                        }
                    });
                }
            }

            // Track practice states: cancelled, deleted, rescheduled
            const cancelledDates = new Set();
            const deletedDates = new Set();
            const rescheduledDates = new Map(); // dateKey -> { originalDate, newDate }
            const rescheduledOriginalDates = new Set(); // Track original dates of rescheduled practices
            
            // Track race dates
            const raceDates = new Map(); // dateKey -> { name, location, isPreRide: boolean }
            if (Array.isArray(data.races)) {
                data.races.forEach(race => {
                    if (race.raceDate) {
                        const raceDate = parseISODate(race.raceDate);
                        if (raceDate && raceDate >= seasonStart && raceDate <= seasonEnd) {
                            const dateKey = formatDateToISO(raceDate);
                            const existing = raceDates.get(dateKey) || { names: [], locations: [], isPreRide: false };
                            existing.names.push(race.name || 'Race');
                            existing.locations.push(race.location || '');
                            existing.isPreRide = false;
                            raceDates.set(dateKey, existing);
                        }
                    }
                    if (race.preRideDate && race.preRideDate !== race.raceDate) {
                        const preRideDate = parseISODate(race.preRideDate);
                        if (preRideDate && preRideDate >= seasonStart && preRideDate <= seasonEnd) {
                            const dateKey = formatDateToISO(preRideDate);
                            const existing = raceDates.get(dateKey) || { names: [], locations: [], isPreRide: true };
                            existing.names.push(race.name || 'Race');
                            existing.locations.push(race.location || '');
                            existing.isPreRide = true;
                            raceDates.set(dateKey, existing);
                        }
                    }
                });
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Find current/next practice
            let currentPracticeDate = null;
            const upcomingRides = (data.rides || [])
                .filter(ride => {
                    if (!ride.date || ride.deleted || ride.cancelled) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    return rideDate >= today;
                })
                .sort((a, b) => {
                    const dateA = parseISODate(a.date);
                    const dateB = parseISODate(b.date);
                    if (!dateA || !dateB) return 0;
                    return dateA - dateB;
                });
            if (upcomingRides.length > 0) {
                const nextRideDate = parseISODate(upcomingRides[0].date);
                if (nextRideDate) {
                    nextRideDate.setHours(0, 0, 0, 0);
                    currentPracticeDate = nextRideDate;
                }
            }
            
            // IMPORTANT: Only use data.rides for tracking cancelled/deleted/rescheduled states
            // Do NOT add new practice dates from data.rides - only use practices array
            // This prevents old ride dates from showing when practice schedules change
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (!ride.date) return;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return;
                    
                    // Skip deleted practices
                    if (ride.deleted) {
                        const dateKey = formatDateToISO(rideDate);
                        deletedDates.add(dateKey);
                        console.log('🗑️ CALENDAR: Found deleted ride for date:', dateKey, 'ride id:', ride.id);
                        return;
                    }
                    
                    // Track rescheduled practices: hide original date, show new date
                    if (ride.rescheduledFrom) {
                        const originalDate = parseISODate(ride.rescheduledFrom);
                        if (originalDate) {
                            const originalKey = formatDateToISO(originalDate);
                            const newKey = formatDateToISO(rideDate);
                            rescheduledDates.set(originalKey, { originalDate, newDate: rideDate });
                            rescheduledOriginalDates.add(originalKey);
                            // Treat original date as deleted so it does not render
                            deletedDates.add(originalKey);
                        }
                    }
                    
                    // Check if ride date is within season range
                    if (rideDate >= seasonStart && rideDate <= seasonEnd) {
                        const dateKey = formatDateToISO(rideDate);
                        
                        // Track cancelled practices
                        if (ride.cancelled) {
                            cancelledDates.add(dateKey);
                        }
                        
                        // ONLY add to practiceDateMap if the date is NOT already there from practices array
                        // This ensures we don't add old ride dates that no longer match current practices
                        // Only update times if the date already exists in practiceDateMap (from practices array)
                        if (practiceDateMap.has(dateKey)) {
                        const existingTimes = practiceDateMap.get(dateKey) || [];
                        const rideTime = ride.time || '';
                        if (rideTime && !existingTimes.includes(rideTime)) {
                            existingTimes.push(rideTime);
                            practiceDateMap.set(dateKey, existingTimes);
                        }
                        }
                        // Do NOT add new dates from rides - only use practices array for new dates
                    }
                });
            }
            
            console.log('📅 CALENDAR: Before removing deleted dates - practiceDateMap size:', practiceDateMap.size, 'deletedDates size:', deletedDates.size, 'deleted dates:', Array.from(deletedDates).slice(0, 10));
            
            // Remove deleted dates from practice map so they don't render
            deletedDates.forEach(dateKey => {
                const wasRemoved = practiceDateMap.delete(dateKey);
                if (wasRemoved) {
                    console.log('🗑️ CALENDAR: Removed deleted date from practiceDateMap:', dateKey);
                } else {
                    console.log('⚠️ CALENDAR: Deleted date not found in practiceDateMap (might not be in schedule):', dateKey);
                }
            });
            
            console.log('📅 CALENDAR: Final practiceDateMap size:', practiceDateMap.size, 'dates:', Array.from(practiceDateMap.keys()).slice(0, 10));

            if (practiceDateMap.size === 0) {
                container.className = 'season-calendar-empty';
                container.innerHTML = `
                    None of the saved practices fall within the chosen season dates.
                `;
                return;
            }

            const firstMonth = new Date(seasonStart.getFullYear(), seasonStart.getMonth(), 1);
            const lastMonth = new Date(seasonEnd.getFullYear(), seasonEnd.getMonth(), 1);

            const months = [];
            const monthCursor = new Date(firstMonth.getTime());
            while (monthCursor <= lastMonth) {
                months.push({
                    year: monthCursor.getFullYear(),
                    month: monthCursor.getMonth()
                });
                monthCursor.setMonth(monthCursor.getMonth() + 1);
            }

            const weekdaysHeader = DAYS_OF_WEEK.map(day => day.slice(0, 3));

            const monthsHtml = months.map(({ year, month }) => {
                const monthStart = new Date(year, month, 1);
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const firstWeekday = monthStart.getDay();

                let cellsHtml = weekdaysHeader.map(day => `<div class="weekday">${day}</div>`).join('');

                for (let i = 0; i < firstWeekday; i++) {
                    cellsHtml += '<div class="month-cell empty"></div>';
                }

                for (let day = 1; day <= daysInMonth; day++) {
                    const currentDate = new Date(year, month, day);
                    const dateKey = formatDateToISO(currentDate);
                    const practiceTimes = practiceDateMap.get(dateKey);
                    const isPractice = Array.isArray(practiceTimes);
                    const isRescheduledOriginal = rescheduledOriginalDates.has(dateKey);
                    const isRescheduledNew = Array.from(rescheduledDates.values()).some(entry => formatDateToISO(entry.newDate) === dateKey);
                    const raceInfo = raceDates.get(dateKey);
                    const isRace = !!raceInfo;
                    
                    // Also check if this is a rescheduled original date (even if not in practice map)
                    const isPracticeOrRescheduled = isPractice || isRescheduledOriginal || isRescheduledNew;
                    
                    const tooltip = isPractice && practiceTimes.length > 0 ? practiceTimes.map(formatTimeForDisplay).join(', ') : '';
                    let titleText = '';
                    if (isRace) {
                        const raceNames = raceInfo.names.join(', ');
                        const raceType = raceInfo.isPreRide ? 'Pre-Ride' : 'Race';
                        titleText = `${raceType}: ${raceNames}`;
                        if (raceInfo.locations.some(loc => loc)) {
                            titleText += ` (${raceInfo.locations.filter(loc => loc).join(', ')})`;
                        }
                    } else if (tooltip) {
                        titleText = `Practice at ${tooltip}`;
                    } else if (isPracticeOrRescheduled) {
                        titleText = 'Practice';
                    }
                    const titleAttr = titleText ? ` title="${escapeHtml(titleText)}"` : '';
                    
                    let ariaLabel = '';
                    if (isRace) {
                        const raceNames = raceInfo.names.join(', ');
                        const raceType = raceInfo.isPreRide ? 'Pre-Ride' : 'Race';
                        ariaLabel = `${raceType} on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}: ${raceNames}`;
                    } else if (tooltip) {
                        ariaLabel = `Practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })} at ${tooltip}`;
                    } else if (isPracticeOrRescheduled) {
                        ariaLabel = `Practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
                    } else {
                        ariaLabel = `No practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
                    }
                    const ariaAttr = ` aria-label="${escapeHtml(ariaLabel)}"`;

                    if (isPracticeOrRescheduled || isRace) {
                        const isCancelled = cancelledDates.has(dateKey);
                        const isDeleted = deletedDates.has(dateKey);
                        
                        // Determine if past, current (next), or future
                        currentDate.setHours(0, 0, 0, 0);
                        const isPast = currentDate < today;
                        const isNext = currentPracticeDate && formatDateToISO(currentDate) === formatDateToISO(currentPracticeDate);
                        
                        if (isDeleted && !isRace) {
                            // Don't show deleted practices (but still show races)
                            cellsHtml += `
                                <div class="month-cell"${ariaAttr}>
                                    <div class="day-number">${day}</div>
                                </div>
                            `;
                            continue;
                        }
                        
                        let cellClass = isRace ? 'race' : 'practice';
                        let cellStyle = '';
                        
                        if (isRace) {
                            // Different green shades for races vs prerides
                            if (raceInfo.isPreRide) {
                                // Lighter green for preride dates
                                cellClass += ' race preride';
                                cellStyle = 'background: #81C784; color: white;';
                            } else {
                                // Regular green for race dates
                                cellClass += ' race';
                                cellStyle = 'background: #4CAF50; color: white;';
                            }
                        } else if (isCancelled) {
                            // Light blue with red slash for cancelled
                            cellClass += ' cancelled';
                            cellStyle = 'background: #B3E5FC; position: relative;';
                        } else if (isRescheduledOriginal || isRescheduledNew) {
                            // Light blue for rescheduled
                            cellClass += ' rescheduled';
                            cellStyle = 'background: #B3E5FC;';
                        } else if (isNext) {
                            // Orange for next practice
                            cellClass += ' next';
                            cellStyle = 'background: #FF9800; color: white;';
                        } else if (isPast) {
                            // Grey for past practices
                            cellClass += ' past';
                            cellStyle = 'background: #E0E0E0; color: #757575;';
                        }
                        
                        const slashStyle = isCancelled ? '<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center;"><div style="width: 100%; height: 2px; background: #f44336; transform: rotate(-45deg);"></div></div>' : '';
                        
                        cellsHtml += `
                            <div class="month-cell ${cellClass}"${titleAttr}${ariaAttr} data-date="${dateKey}" onclick="handlePracticeDateClick('${dateKey}', event)" style="${cellStyle}">
                                <div class="day-number">${day}</div>
                                ${slashStyle}
                            </div>
                        `;
                    } else {
                        cellsHtml += `
                            <div class="month-cell"${ariaAttr}>
                                <div class="day-number">${day}</div>
                            </div>
                        `;
                    }
                }

                return `
                    <div class="season-month">
                        <div class="month-header">${monthStart.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</div>
                        <div class="month-grid">
                            ${cellsHtml}
                        </div>
                    </div>
                `;
            }).join('');
            
            container.className = 'season-calendar';
            container.innerHTML = monthsHtml;
        }

        let contextMenuDate = null;
        let contextMenuTimeout = null;
        let contextMenuCloseHandler = null;

        function handlePracticeDateClick(dateString, event) {
            if (!dateString) return;
            
            const contextMenu = document.getElementById('practice-context-menu');
            if (!contextMenu) return;
            
            // If clicking the same date that's already open, close it
            if (contextMenuDate === dateString && contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                if (contextMenuTimeout) {
                    clearTimeout(contextMenuTimeout);
                    contextMenuTimeout = null;
                }
                if (contextMenuCloseHandler) {
                    document.removeEventListener('click', contextMenuCloseHandler);
                    contextMenuCloseHandler = null;
                }
                contextMenuDate = null;
                return;
            }
            
            // Close any existing menu and clear its timeout/handler
            if (contextMenuTimeout) {
                clearTimeout(contextMenuTimeout);
                contextMenuTimeout = null;
            }
            if (contextMenuCloseHandler) {
                document.removeEventListener('click', contextMenuCloseHandler);
                contextMenuCloseHandler = null;
            }
            contextMenu.style.display = 'none';
            
            // Store the date for context menu actions
            contextMenuDate = dateString;
            
            // Determine if this date is cancelled
            const cancelledRide = (data.rides || []).find(r => r.date === dateString && !r.deleted && r.cancelled);
            const restoreBtn = document.getElementById('restore-practice-btn');
            if (restoreBtn) {
                restoreBtn.style.display = cancelledRide ? 'block' : 'none';
            }
            
            // Position menu to the right of the clicked calendar cell
            if (event) {
                // Find the actual calendar cell element (might be event.target or its parent)
                let cellElement = event.target;
                while (cellElement && !cellElement.hasAttribute('data-date')) {
                    cellElement = cellElement.parentElement;
                }
                
                if (cellElement) {
                    // Use the cell's bounding rect for accurate positioning
                    const cellRect = cellElement.getBoundingClientRect();
                    
                    // Position menu to the right of the cell, with top-left corner aligned to top of cell
                    // Add small offset (5px) to prevent overlap with the cell
                    contextMenu.style.left = `${cellRect.right + 5}px`;
                    contextMenu.style.top = `${cellRect.top}px`;
                    
                    // Show the menu first so we can measure it
                    contextMenu.style.display = 'block';
                    contextMenu.style.visibility = 'visible';
                    
                    // Ensure menu stays within viewport
                    requestAnimationFrame(() => {
                        const menuRect = contextMenu.getBoundingClientRect();
                        // Adjust horizontally if menu goes off right edge - show to the left of cell instead
                        if (menuRect.right > window.innerWidth) {
                            contextMenu.style.left = `${cellRect.left - menuRect.width - 5}px`;
                        }
                        // Adjust vertically if menu goes off bottom edge - align to bottom of cell
                        if (menuRect.bottom > window.innerHeight) {
                            contextMenu.style.top = `${cellRect.bottom - menuRect.height}px`;
                        }
                        // Ensure menu doesn't go off left edge
                        if (menuRect.left < 0) {
                            contextMenu.style.left = '10px';
                        }
                        // Ensure menu doesn't go off top edge
                        if (menuRect.top < 0) {
                            contextMenu.style.top = '10px';
                        }
                    });
                } else {
                    // Fallback to click coordinates if cell not found
                const x = event.clientX || (event.touches && event.touches[0].clientX);
                const y = event.clientY || (event.touches && event.touches[0].clientY);
                    contextMenu.style.left = `${x + 10}px`;
                contextMenu.style.top = `${y}px`;
                    contextMenu.style.display = 'block';
                    contextMenu.style.visibility = 'visible';
                }
            } else {
                // Fallback positioning
                contextMenu.style.left = '50%';
                contextMenu.style.top = '50%';
                contextMenu.style.display = 'block';
                contextMenu.style.visibility = 'visible';
            }
            
            // Auto-close menu after 5 seconds
            contextMenuTimeout = setTimeout(() => {
                if (contextMenuDate === dateString) { // Only close if this is still the active menu
                    contextMenu.style.display = 'none';
                    contextMenuDate = null;
                    if (contextMenuCloseHandler) {
                        document.removeEventListener('click', contextMenuCloseHandler);
                        contextMenuCloseHandler = null;
                    }
                }
                contextMenuTimeout = null;
            }, 5000);
            
            // Close menu when clicking outside or on a different date
            setTimeout(() => {
                contextMenuCloseHandler = function closeMenu(e) {
                    // Check if click is on a calendar date cell
                    const clickedCell = e.target.closest('[data-date]');
                    const clickedDate = clickedCell ? clickedCell.getAttribute('data-date') : null;
                    
                    // If clicking on a different date, the handlePracticeDateClick will handle closing/opening
                    // So we only need to close if clicking outside the menu and not on any date cell
                    if (!contextMenu.contains(e.target) && !clickedCell) {
                        // Clicking outside menu and not on any date - close the menu
                        if (contextMenuDate === dateString) { // Only close if this is still the active menu
                        contextMenu.style.display = 'none';
                            contextMenuDate = null;
                            if (contextMenuTimeout) {
                                clearTimeout(contextMenuTimeout);
                                contextMenuTimeout = null;
                            }
                            document.removeEventListener('click', contextMenuCloseHandler);
                            contextMenuCloseHandler = null;
                        }
                    } else if (clickedDate && clickedDate !== dateString) {
                        // Clicking on a different date - close this menu (new menu will open via handlePracticeDateClick)
                        if (contextMenuDate === dateString) { // Only close if this is still the active menu
                            contextMenu.style.display = 'none';
                            contextMenuDate = null;
                            if (contextMenuTimeout) {
                                clearTimeout(contextMenuTimeout);
                                contextMenuTimeout = null;
                            }
                            document.removeEventListener('click', contextMenuCloseHandler);
                            contextMenuCloseHandler = null;
                        }
                    }
                };
                document.addEventListener('click', contextMenuCloseHandler);
            }, 10);
        }

        async function deletePracticeFromContext() {
            if (!contextMenuDate) return;
            
            if (!confirm(`Are you sure you want to delete the practice on ${contextMenuDate}? This action cannot be undone.`)) {
                document.getElementById('practice-context-menu').style.display = 'none';
                return;
            }
            
            // Find existing ride or create a new one to mark as deleted
            let ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            console.log('🗑️ deletePracticeFromContext: Looking for ride with date', contextMenuDate, 'found:', !!ride);
            if (!ride) {
                // No ride exists yet - create one marked as deleted so deletion persists
                // This ensures deleted dates from recurring schedule are saved
                ride = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    date: contextMenuDate,
                    time: '',
                    endTime: '',
                    description: '',
                    meetLocation: '',
                    locationLat: null,
                    locationLng: null,
                    goals: '',
                    groups: [],
                    availableRiders: [],
                    availableCoaches: [],
                    assignments: {},
                    cancelled: false,
                    deleted: true,
                    publishedGroups: false
                };
                data.rides.push(ride);
                console.log('🗑️ deletePracticeFromContext: Created new deleted ride with id', ride.id, 'date', contextMenuDate);
            } else {
                ride.deleted = true;
                console.log('🗑️ deletePracticeFromContext: Marked existing ride as deleted, id', ride.id, 'date', contextMenuDate);
                // If this ride was rescheduled from another date, ensure original date stays hidden
                if (ride.rescheduledFrom) {
                    const originalDate = formatDateToISO(parseISODate(ride.rescheduledFrom));
                    // Mark any ride on original date as deleted too
                    const originalRide = data.rides.find(r => r.date === originalDate && !r.deleted);
                    if (originalRide) {
                        originalRide.deleted = true;
                        await saveRideToDB(originalRide);
                    }
                }
            }
            
            // If this is a single practice (with specificDate), also delete it from seasonSettings
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            const singlePractice = practices.find(p => p.specificDate === contextMenuDate);
            if (singlePractice) {
                console.log('🗑️ Deleting single practice:', singlePractice.id, 'for date:', contextMenuDate);
                // Remove from seasonSettings
                settings.practices = practices.filter(p => String(p.id) !== String(singlePractice.id));
                // Remove from seasonSettingsDraft if it exists
                if (seasonSettingsDraft) {
                    seasonSettingsDraft.practices = seasonSettingsDraft.practices.filter(p => String(p.id) !== String(singlePractice.id));
                }
                // Remove from original states
                originalPracticeStates.delete(String(singlePractice.id));
                // Re-render practice rows to reflect deletion
                renderPracticeRows('practice-rows');
                renderPracticeRows('practice-rows-modal');
                // Save season settings to persist single practice deletion
                saveData();
            }
            
            // Save ride deletion to Supabase (will create if new, update if existing)
            console.log('🗑️ deletePracticeFromContext: Saving deleted ride to Supabase, id', ride.id, 'date', contextMenuDate, 'deleted:', ride.deleted);
            await saveRideToDB(ride);
            console.log('🗑️ deletePracticeFromContext: Saved deleted ride to Supabase, id', ride.id);
            
            renderAllCalendars();
            document.getElementById('practice-context-menu').style.display = 'none';
        }

        function cancelPracticeFromContext() {
            if (!contextMenuDate) return;
            
            const modal = document.getElementById('cancel-practice-modal');
            if (modal) {
                modal.classList.add('visible');
                modal.setAttribute('aria-hidden', 'false');
                document.getElementById('practice-context-menu').style.display = 'none';
            }
        }

        function closeCancelPracticeModal() {
            const modal = document.getElementById('cancel-practice-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        function openClonePracticeModal() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }
            if (ride.cancelled) {
                alert('Cannot clone to a cancelled practice.');
                return;
            }
            if (ride.groups && ride.groups.length > 0) {
                alert('Cannot clone when groups are already assigned. Please clear assignments first.');
                return;
            }

            const modal = document.getElementById('clone-practice-modal');
            const listContainer = document.getElementById('clone-practice-list');
            if (!modal || !listContainer) return;

            const currentDate = parseISODate(ride.date);
            if (!currentDate) {
                alert('Invalid practice date.');
                return;
            }

            // Get all practices with groups assigned (excluding current practice)
            const allRides = (data.rides || [])
                .filter(r => {
                    if (!r.date || r.deleted || r.cancelled) return false;
                    if (r.id === ride.id) return false; // Exclude current practice
                    if (!r.groups || r.groups.length === 0) return false; // Only practices with groups
                    return true;
                })
                .map(r => ({
                    ride: r,
                    date: parseISODate(r.date)
                }))
                .filter(r => r.date)
                .sort((a, b) => b.date - a.date); // Most recent first

            if (allRides.length === 0) {
                listContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No other practices with group assignments found.</p>';
            } else {
                listContainer.innerHTML = allRides.map(({ ride: sourceRide, date: sourceDate }) => {
                    const dateStr = sourceDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                    const groupCount = sourceRide.groups ? sourceRide.groups.length : 0;
                    const riderCount = sourceRide.availableRiders ? sourceRide.availableRiders.length : 0;
                    const coachCount = sourceRide.availableCoaches ? sourceRide.availableCoaches.length : 0;
                    return `
                        <button class="btn-small" onclick="cloneEntirePractice(${sourceRide.id})" style="text-align: left; padding: 12px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; transition: background 0.2s;">
                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${dateStr}</div>
                            <div style="font-size: 12px; color: #666;">${groupCount} group${groupCount !== 1 ? 's' : ''}, ${riderCount} rider${riderCount !== 1 ? 's' : ''}, ${coachCount} coach${coachCount !== 1 ? 'es' : ''}</div>
                        </button>
                    `;
                }).join('');
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeClonePracticeModal() {
            const modal = document.getElementById('clone-practice-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        function cloneEntirePractice(sourceRideId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }
            if (ride.cancelled) {
                alert('Cannot clone to a cancelled practice.');
                return;
            }
            if (ride.groups && ride.groups.length > 0) {
                alert('Cannot clone when groups are already assigned. Please clear assignments first.');
                return;
            }

            const sourceRide = data.rides.find(r => r.id === sourceRideId);
            if (!sourceRide || !sourceRide.groups || sourceRide.groups.length === 0) {
                alert('Source practice not found or has no groups assigned.');
                return;
            }

            // Confirm with user
            const sourceDate = parseISODate(sourceRide.date);
            const sourceDateStr = sourceDate ? sourceDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : sourceRide.date;
            const currentDate = parseISODate(ride.date);
            const currentDateStr = currentDate ? currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            
            if (!confirm(`Clone entire practice from ${sourceDateStr} to ${currentDateStr}?\n\nThis will:\n- Copy all groups and assignments\n- Override attendance settings (riders and coaches) from the source practice\n- Copy routes from the source practice`)) {
                return;
            }

            // Clone attendance settings (override current practice's attendance)
            ride.availableCoaches = sourceRide.availableCoaches ? [...sourceRide.availableCoaches] : [];
            ride.availableRiders = sourceRide.availableRiders ? [...sourceRide.availableRiders] : [];

            // Deep clone groups (create new group objects to avoid reference issues)
            ride.groups = sourceRide.groups.map(sourceGroup => {
                const newGroup = createGroup(sourceGroup.label);
                
                // Copy riders (use all riders from source group)
                newGroup.riders = sourceGroup.riders ? [...sourceGroup.riders] : [];
                
                // Copy coaches
                if (sourceGroup.coaches) {
                    if (sourceGroup.coaches.leader) {
                        newGroup.coaches.leader = sourceGroup.coaches.leader;
                    }
                    if (sourceGroup.coaches.sweep) {
                        newGroup.coaches.sweep = sourceGroup.coaches.sweep;
                    }
                    if (sourceGroup.coaches.roam) {
                        newGroup.coaches.roam = sourceGroup.coaches.roam;
                    }
                    if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                        newGroup.coaches.extraRoam = [...sourceGroup.coaches.extraRoam];
                    }
                }
                
                // Copy other group properties including routeId
                newGroup.routeId = sourceGroup.routeId || null;
                newGroup.sortBy = sourceGroup.sortBy;
                
                return newGroup;
            });

            // Close modal
            closeClonePracticeModal();

            // Save and render
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();

            // Show the More/Fewer Groups buttons
            const moreGroupsBtn = document.getElementById('more-groups-btn');
            const fewerGroupsBtn = document.getElementById('fewer-groups-btn');
            if (moreGroupsBtn) moreGroupsBtn.style.display = '';
            if (fewerGroupsBtn) fewerGroupsBtn.style.display = '';
        }

        async function confirmCancelPractice() {
            if (!contextMenuDate) return;
            
            const reason = document.getElementById('cancel-reason').value;
            if (!reason) return;
            
            // Find or create ride
            let ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            if (!ride) {
                ride = {
                    id: generateId(),
                    date: contextMenuDate,
                    availableCoaches: [],
                    availableRiders: [],
                    assignments: {},
                    groups: []
                };
                data.rides.push(ride);
            }
            
            ride.cancelled = true;
            ride.cancellationReason = reason;
            
            // Save ride state to Supabase
            await saveRideToDB(ride);
            
            closeCancelPracticeModal();
            renderAllCalendars();
        }

        function getDefaultPracticeForDate(dateStr) {
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            const date = parseISODate(dateStr);
            if (!date) return {};
            const iso = formatDateToISO(date);
            // Specific date takes priority
            const specific = practices.find(p => p.specificDate === iso);
            if (specific) return { time: specific.time || '', endTime: specific.endTime || '', meetLocation: specific.meetLocation || '' };
            // Fallback to day-of-week recurring
            const dow = date.getDay();
            const recurring = practices.find(p => p.dayOfWeek === dow);
            if (recurring) return { time: recurring.time || '', endTime: recurring.endTime || '', meetLocation: recurring.meetLocation || '' };
            return {};
        }

        function reschedulePracticeFromContext() {
            if (!contextMenuDate) return;
            
            // Find existing ride to get current values (include cancelled), or the original if rescheduled
            let ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            if (!ride) {
                ride = data.rides.find(r => r.rescheduledFrom === contextMenuDate && !r.deleted);
            }
            const defaults = getDefaultPracticeForDate(contextMenuDate);
            
            const modal = document.getElementById('reschedule-practice-modal');
            if (modal) {
                // Pre-fill with current values
                document.getElementById('reschedule-date').value = contextMenuDate;
                document.getElementById('reschedule-time').value = ride ? (ride.time || defaults.time || '') : (defaults.time || '');
                document.getElementById('reschedule-end-time').value = ride ? (ride.endTime || defaults.endTime || '') : (defaults.endTime || '');
                document.getElementById('reschedule-location').value = ride ? (ride.meetLocation || defaults.meetLocation || '') : (defaults.meetLocation || '');
                
                modal.classList.add('visible');
                modal.setAttribute('aria-hidden', 'false');
                document.getElementById('practice-context-menu').style.display = 'none';
            }
        }

        function closeReschedulePracticeModal() {
            const modal = document.getElementById('reschedule-practice-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        async function confirmReschedulePractice() {
            if (!contextMenuDate) return;
            
            const newDate = document.getElementById('reschedule-date').value;
            const newTime = document.getElementById('reschedule-time').value;
            const newEndTime = document.getElementById('reschedule-end-time').value;
            const newLocation = document.getElementById('reschedule-location').value;
            
            if (!newDate) {
                alert('Please select a new date.');
                return;
            }
            
            // Parse contextMenuDate - it might be in ISO format already or a date string
            const originalDateParsed = parseISODate(contextMenuDate) || new Date(contextMenuDate);
            const originalDateKey = formatDateToISO(originalDateParsed);
            const newDateParsed = parseISODate(newDate);
            if (!newDateParsed) {
                alert('Invalid date selected.');
                return;
            }
            const newDateKey = formatDateToISO(newDateParsed);
            
            // Find existing ride on the original date (including those already rescheduled from this date)
            let ride = data.rides.find(r => r.date === originalDateKey && !r.deleted);
            
            // Also check if there's already a ride rescheduled from this date
            if (!ride) {
                ride = data.rides.find(r => r.rescheduledFrom === originalDateKey && !r.deleted);
            }
            
            if (!ride) {
                // If no ride exists, try to find one on a scheduled practice day for this date
                // This handles cases where we're rescheduling a practice that was auto-generated
                const originalDateObj = parseISODate(originalDateKey);
                if (originalDateObj) {
                    const weekday = originalDateObj.getDay();
                    const settings = data.seasonSettings || {};
                    const practices = Array.isArray(settings.practices) ? settings.practices : [];
                    const hasScheduledPractice = practices.some(p => p.dayOfWeek === weekday);
                    
                    if (hasScheduledPractice) {
                        // Create a new ride for rescheduling
                        ride = {
                            id: generateId(),
                            date: originalDateKey,
                            availableCoaches: [],
                            availableRiders: [],
                            assignments: {},
                            groups: [],
                            goals: '',
                            cancelled: false
                        };
                        data.rides.push(ride);
                    } else {
                        alert('No practice found on this date to reschedule.');
                        return;
                    }
                } else {
                    alert('Invalid date selected.');
                    return;
                }
            }
            
            // Check if there's already a ride on the new date
            const existingRideOnNewDate = data.rides.find(r => r.date === newDateKey && !r.deleted && r.id !== ride.id);
            if (existingRideOnNewDate) {
                // Merge data into existing ride
                existingRideOnNewDate.rescheduledFrom = originalDateKey;
                if (newTime) existingRideOnNewDate.time = newTime;
                if (newEndTime) existingRideOnNewDate.endTime = newEndTime;
                if (newLocation) existingRideOnNewDate.meetLocation = newLocation;
                // Preserve other fields from the original ride
                if (ride.availableCoaches) existingRideOnNewDate.availableCoaches = ride.availableCoaches;
                if (ride.availableRiders) existingRideOnNewDate.availableRiders = ride.availableRiders;
                if (ride.groups) existingRideOnNewDate.groups = ride.groups;
                if (ride.goals) existingRideOnNewDate.goals = ride.goals;
                
                // Mark original ride as deleted
                ride.deleted = true;
                ride = existingRideOnNewDate;
            } else {
                // Store original date for tracking
                ride.rescheduledFrom = originalDateKey;
                
                // Update to new date and values
                ride.date = newDateKey;
                if (newTime) ride.time = newTime;
                if (newEndTime) ride.endTime = newEndTime;
                if (newLocation) ride.meetLocation = newLocation;
            }
            
            // Mark any other rides on the original date as deleted
            const ridesToUpdate = [];
            data.rides.forEach(r => {
                if (r.date === originalDateKey && !r.deleted && r.id !== ride.id) {
                    r.deleted = true;
                    ridesToUpdate.push(r);
                }
            });
            
            // Save all modified rides to Supabase
            await saveRideToDB(ride);
            if (existingRideOnNewDate) {
                await saveRideToDB(existingRideOnNewDate);
            }
            for (const r of ridesToUpdate) {
                await saveRideToDB(r);
            }
            
            closeReschedulePracticeModal();
            document.activeElement?.blur(); // Fix aria-hidden warning
            renderAllCalendars();
            renderRides();
            
            // Update current ride if we just rescheduled it
            if (data.currentRide && data.rides.find(r => r.id === data.currentRide && !r.deleted)) {
                loadCurrentRide();
            }
        }

        async function restoreCancelledPractice() {
            if (!contextMenuDate) return;
            const ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted && r.cancelled);
            if (ride) {
                ride.cancelled = false;
                ride.cancellationReason = '';
                
                // Save ride restoration to Supabase
                await saveRideToDB(ride);
                
                renderAllCalendars();
            }
            document.getElementById('practice-context-menu').style.display = 'none';
        }

        function updatePracticeNavigation() {
            const navButtons = document.getElementById('practice-navigation-buttons');
            const priorBtn = document.getElementById('prior-practice-btn');
            const nextBtn = document.getElementById('next-practice-btn');
            
            if (!navButtons || !priorBtn || !nextBtn) return;
            
            const currentRide = data.rides.find(r => r.id === data.currentRide);
            if (!currentRide) {
                navButtons.style.display = 'none';
                return;
            }
            
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            // Get all rides sorted by date (excluding deleted and rescheduled original dates)
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            
            // Show navigation buttons if there are multiple practices
            if (allRides.length > 1) {
                navButtons.style.display = 'flex';
            } else {
                navButtons.style.display = 'none';
            }
            
            // Enable/disable prior button
            if (currentIndex > 0) {
                priorBtn.disabled = false;
                priorBtn.style.opacity = '1';
                priorBtn.style.cursor = 'pointer';
            } else {
                priorBtn.disabled = true;
                priorBtn.style.opacity = '0.5';
                priorBtn.style.cursor = 'not-allowed';
            }
            
            // Enable/disable next button
            if (currentIndex >= 0 && currentIndex < allRides.length - 1) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                nextBtn.style.cursor = 'pointer';
            } else {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
                nextBtn.style.cursor = 'not-allowed';
            }
        }
        
        function toggleGroupAssignments() {
            const content = document.getElementById('group-assignments-content');
            const arrow = document.getElementById('group-assignments-arrow');
            if (!content || !arrow) return;
            
            const isVisible = content.style.display !== 'none';
            content.style.display = isVisible ? 'none' : 'block';
            arrow.textContent = isVisible ? '▶' : '▼';
        }

        function navigateToPriorPractice() {
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            if (currentIndex > 0) {
                data.currentRide = allRides[currentIndex - 1].id;
                saveData();
                loadCurrentRide();
            }
        }

        function navigateToNextPractice() {
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            if (currentIndex >= 0 && currentIndex < allRides.length - 1) {
                data.currentRide = allRides[currentIndex + 1].id;
                saveData();
                loadCurrentRide();
            }
        }

        function loadCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                document.getElementById('current-ride').style.display = 'none';
                const navSection = document.getElementById('practice-navigation');
                if (navSection) navSection.style.display = 'none';
                // Clear history when no ride is selected
                clearAssignmentHistory();
                return;
            }
            
            // Clear undo/redo history when loading a new ride
            clearAssignmentHistory();
            
            // Save initial state so first undo works
            saveAssignmentState(ride);
            
            // Ensure default attendance selection for this practice
            ensureRideAttendanceDefaults(ride);
            
            document.getElementById('current-ride').style.display = 'block';
            const rideDate = parseISODate(ride.date);
            const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            document.getElementById('ride-title').textContent = `Practice: ${dateDisplay}`;
            
            // Sync meetLocation from practice settings if not set on ride
            // This ensures location is shown even if ride was created before location was set
            if (!ride.meetLocation && ride.date) {
                const settings = data.seasonSettings || {};
                const practices = Array.isArray(settings.practices) ? settings.practices : [];
                const rideDateObj = parseISODate(ride.date);
                if (rideDateObj) {
                    const weekday = rideDateObj.getDay();
                    const matchedPractice = practices.find(p => p.dayOfWeek === weekday);
                    if (matchedPractice && matchedPractice.meetLocation) {
                        ride.meetLocation = matchedPractice.meetLocation;
                        ride.locationLat = matchedPractice.locationLat || null;
                        ride.locationLng = matchedPractice.locationLng || null;
                        saveRideToDB(ride);
                    }
                }
            }
            
            // Display practice time and location
            const rideDetails = document.getElementById('ride-details');
            if (rideDetails) {
                const details = [];
                
                // Add time
                const startTime = ride.startTime || ride.time || '';
                const endTime = ride.endTime || '';
                if (startTime) {
                    const formattedStart = formatTimeForDisplay(startTime);
                    if (endTime) {
                        const formattedEnd = formatTimeForDisplay(endTime);
                        details.push(`Time: ${formattedStart} - ${formattedEnd}`);
                    } else {
                        details.push(`Time: ${formattedStart}`);
                    }
                }
                
                // Add location (textContent is safe from XSS, no need to escape)
                const meetLocation = ride.meetLocation || '';
                if (meetLocation.trim()) {
                    details.push(`Location: ${meetLocation}`);
                }
                
                rideDetails.textContent = details.length > 0 ? details.join(' • ') : '';
            }
            
            // Set default section states based on whether groups are assigned
            const hasGroups = ride.groups && ride.groups.length > 0;
            const attendanceContent = document.getElementById('practice-attendance-content');
            const attendanceArrow = document.getElementById('practice-attendance-arrow');
            const groupContent = document.getElementById('group-assignments-content');
            const groupArrow = document.getElementById('group-assignments-arrow');
            
            if (hasGroups) {
                // If groups are assigned: collapse attendance, expand groups
                if (attendanceContent) {
                    attendanceContent.style.display = 'none';
                }
                if (attendanceArrow) {
                    attendanceArrow.textContent = '▼';
                }
                if (groupContent) {
                    groupContent.style.display = 'block';
                }
                if (groupArrow) {
                    groupArrow.textContent = '▼';
                }
            } else {
                // If no groups: default behavior (attendance expanded, groups collapsed)
                if (attendanceContent && attendanceContent.style.display !== 'none') {
                    renderPracticeAttendanceLists();
                }
            }
            
            // Render practice attendance lists if section is open
            if (attendanceContent && attendanceContent.style.display !== 'none') {
                renderPracticeAttendanceLists();
            }
            
            // Update navigation buttons
            updatePracticeNavigation();
            
            // Load practice goals
            const goalsInput = document.getElementById('practice-goals');
            if (goalsInput) {
                goalsInput.value = ride.goals || '';
            }
            
            // Update button based on cancellation status
            const cancelButton = document.getElementById('cancel-practice-btn');
            if (cancelButton) {
                if (ride.cancelled) {
                    cancelButton.textContent = 'Reinstate Practice';
                    cancelButton.className = 'btn-small';
                    cancelButton.style.backgroundColor = '#4CAF50';
                    cancelButton.style.color = '#ffffff';
                    cancelButton.style.borderColor = '#4CAF50';
                    cancelButton.onclick = reinstatePractice;
                } else {
                    cancelButton.textContent = 'Cancel Practice';
                    cancelButton.className = 'danger btn-small';
                    cancelButton.style.backgroundColor = '';
                    cancelButton.style.color = '';
                    cancelButton.style.borderColor = '';
                    cancelButton.onclick = deleteCurrentRide;
                }
            }
            
            // Disable assignment buttons if cancelled
            const autoAssignButton = document.querySelector('#current-ride .action-bar button:first-child');
            const clearAssignmentsButton = document.querySelector('#current-ride .action-bar button.secondary');
            if (ride.cancelled) {
                if (autoAssignButton) {
                    autoAssignButton.disabled = true;
                    autoAssignButton.style.opacity = '0.5';
                    autoAssignButton.style.cursor = 'not-allowed';
                }
                if (clearAssignmentsButton) {
                    clearAssignmentsButton.disabled = true;
                    clearAssignmentsButton.style.opacity = '0.5';
                    clearAssignmentsButton.style.cursor = 'not-allowed';
                }
            } else {
                if (autoAssignButton) {
                    autoAssignButton.disabled = false;
                    autoAssignButton.style.opacity = '';
                    autoAssignButton.style.cursor = '';
                }
                if (clearAssignmentsButton) {
                    clearAssignmentsButton.disabled = false;
                    clearAssignmentsButton.style.opacity = '';
                    clearAssignmentsButton.style.cursor = '';
                }
            }
            
            if (!ride.cancelled) {
            renderAssignments(ride);
            } else {
                // Show message that practice is cancelled
                const assignmentsContainer = document.getElementById('assignments');
                if (assignmentsContainer) {
                    assignmentsContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #757575;"><p style="font-size: 16px; margin: 0;">This practice has been cancelled.</p><p style="font-size: 14px; margin: 10px 0 0 0;">Assignments are not available for cancelled practices.</p></div>';
                }
                // Update buttons even for cancelled rides
                updatePublishButtons();
            }
        }

        function setAllCoaches(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            if (selectAll) {
                ride.availableCoaches = Array.from(new Set(data.coaches.map(coach => coach.id)));
            } else {
                ride.availableCoaches = [];
                if (!Array.isArray(ride.groups)) {
                    ride.groups = [];
                }
                ride.groups.forEach(group => {
                    group.coaches.leader = null;
                    group.coaches.sweep = null;
                    group.coaches.roam = null;
                    group.coaches.extraRoam = [];
                    group.riders = [];
                    group.fitnessTag = null;
                });
            }

            saveData();
            renderAssignments(ride);
        }

        function setAllRiders(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            if (selectAll) {
                // For refined rides, only select filtered riders; for regular rides, select all
                const isRefined = isRideRefined(ride);
                if (isRefined) {
                    ride.availableRiders = getFilteredRiderIdsForRide(ride);
                } else {
                    ride.availableRiders = data.riders ? data.riders.map(r => r.id) : [];
                }
            } else {
                ride.availableRiders = [];
                if (!Array.isArray(ride.groups)) {
                    ride.groups = [];
                }
                ride.groups.forEach(group => {
                    group.riders = [];
                    group.fitnessTag = null;
                });
            }

            saveData();
            renderAssignments(ride);
        }

        // This function is deprecated - use toggleCoachAvailability(coachId, isAvailable) instead

        // Old toggleRiderAvailability function removed - using the newer version below that doesn't remove riders from groups

        function deleteCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            ride.cancelled = true;
            saveData();
            renderRides();
            loadCurrentRide();
        }

        function reinstatePractice() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            ride.cancelled = false;
            saveData();
            renderRides();
            loadCurrentRide();
        }

        function permanentlyDeleteCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected to delete.');
                return;
            }
            
            const rideDate = ride.date ? parseISODate(ride.date) : null;
            const dateDisplay = rideDate 
                ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })
                : 'this practice';
            
            if (!confirm(`Are you sure you want to permanently delete the practice on ${dateDisplay}?\n\nThis will remove it from the calendar and cannot be undone.`)) {
                return;
            }
            
            // Mark the ride as deleted instead of removing it (so it stays in exception list)
            ride.deleted = true;
            
            // Clear current ride selection
            data.currentRide = null;
            
            saveData();
            renderRides();
            renderAllCalendars();
            
            // Hide the current ride section
            const currentRideSection = document.getElementById('current-ride');
            if (currentRideSection) {
                currentRideSection.style.display = 'none';
            }
        }

        // Helper function to validate requirements
        function validateRequirements(availableCoaches, availableRiders, debugLines) {
            const requirements = getRequirements();
            
            for (const req of requirements) {
                if (req.id === 'ridersPerCoach') {
                    const ridersPerCoach = req.value || 6;
                    const totalCapacity = availableCoaches.length * ridersPerCoach;
                    if (availableRiders.length > totalCapacity) {
                        const errorMsg = `Not enough coaches to meet requirement: ${availableRiders.length} riders need ${Math.ceil(availableRiders.length / ridersPerCoach)} coaches (at ${ridersPerCoach} riders per coach), but only ${availableCoaches.length} coaches available.`;
                        debugLines.push(`❌ Requirement validation failed: ${errorMsg}`);
                        alert(errorMsg);
                        return false;
                    }
                    debugLines.push(`✓ Requirement 1 (Riders per Coach): ${availableRiders.length} riders can be accommodated by ${availableCoaches.length} coaches (capacity: ${totalCapacity})`);
                } else if (req.id === 'minLeaderLevel') {
                    const minLeaderLevel = req.value || 2;
                    const leaders = availableCoaches.filter(coach => {
                        const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                        const level = parseInt(levelRaw, 10);
                        return Number.isFinite(level) && level >= minLeaderLevel;
                    });
                    if (leaders.length === 0) {
                        const errorMsg = `Not enough qualifying coaches to meet minimum requirements: Need at least one Level ${minLeaderLevel}+ coach, but none available.`;
                        debugLines.push(`❌ Requirement validation failed: ${errorMsg}`);
                        alert(errorMsg);
                        return false;
                    }
                    const ridersPerLeader = Math.ceil(availableRiders.length / leaders.length);
                    const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
                    if (ridersPerLeader > ridersPerCoach * 2) { // Allow some flexibility, but warn if way over
                        debugLines.push(`⚠️ Warning: Dividing ${availableRiders.length} riders among ${leaders.length} Level ${minLeaderLevel}+ leaders results in ~${ridersPerLeader} riders per leader, which may exceed capacity.`);
                    }
                    debugLines.push(`✓ Requirement 2 (Minimum Leader Level): ${leaders.length} Level ${minLeaderLevel}+ coaches available for ${availableRiders.length} riders (~${ridersPerLeader} riders per leader)`);
                }
            }
            return true;
        }
        
        // Auto-assignment algorithm - SEQUENTIAL REQUIREMENT-BASED VERSION
        function autoAssign(targetNumGroups = null) {
            try {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (!ride) {
                    alert('No practice selected.');
                    return;
                }
                if (ride.cancelled) {
                    alert('Cannot assign riders and coaches to a cancelled practice.');
                    return;
                }

                // Save state before autofill (allows undo of autofill)
                saveAssignmentState(ride);
                
                // Clear history after autofill (autofill is a major operation, start fresh history)
                // But first save the state above so autofill itself can be undone

                const debugLines = [];
                debugLines.push(`=== AUTO-ASSIGN RUN AT ${new Date().toLocaleString()} ===`);
                debugLines.push('');

                // CRITICAL: Re-read the ride object from data.rides to ensure we have the latest state
                // This is important because saveRideToDB is async and might have updated data.rides
                const rideId = data.currentRide;
                const currentRide = data.rides.find(r => r.id === rideId);
                if (currentRide && currentRide !== ride) {
                    console.log('🔴 AUTO-ASSIGN: Found updated ride object in data.rides, using it instead');
                    Object.assign(ride, currentRide); // Merge latest state into our ride reference
                }

                // STEP 1 & 2: For refined rides, select only riders that qualify under the filter
                // For regular rides, default to all riders selected
                const totalRidersInRoster = data.riders ? data.riders.length : 0;
                const isRefined = isRideRefined(ride);
                console.log('🔴 AUTO-ASSIGN: Initial check - ride.availableRiders:', {
                    isArray: Array.isArray(ride.availableRiders),
                    length: ride.availableRiders?.length,
                    totalRidersInRoster,
                    rideId: ride.id,
                    isRefined: isRefined
                });
                
                // Ensure availableRiders is an array
                if (!Array.isArray(ride.availableRiders)) {
                    ride.availableRiders = [];
                }
                
                // Auto-initialize empty arrays based on whether refined
                if (ride.availableRiders.length === 0) {
                    if (isRefined) {
                        // STEP 2: For refined rides, select all riders that qualify under the filter
                        const filteredRiderIds = getFilteredRiderIdsForRide(ride);
                        console.log('🔴 AUTO-ASSIGN: ride.availableRiders is empty on REFINED ride - initializing with', filteredRiderIds.length, 'filtered riders');
                        debugLines.push(`⚠️ Refined ride with empty availableRiders - initialized with ${filteredRiderIds.length} filtered riders`);
                        ride.availableRiders = filteredRiderIds;
                        // CRITICAL: Update both the ride reference AND the ride in data.rides array
                        const rideIndex = data.rides.findIndex(r => r.id === rideId);
                        if (rideIndex !== -1) {
                            data.rides[rideIndex].availableRiders = ride.availableRiders;
                        }
                        // Save the reset to persist it
                        saveRideToDB(ride);
                    } else if (totalRidersInRoster > 0) {
                        // Regular ride - initialize with all riders
                        console.log('🔴 AUTO-ASSIGN: ride.availableRiders is empty on regular ride - initializing with all', totalRidersInRoster, 'riders');
                        debugLines.push(`⚠️ ride.availableRiders was empty on regular ride - initialized with all ${totalRidersInRoster} riders`);
                        ride.availableRiders = data.riders.map(r => r.id);
                        // CRITICAL: Update both the ride reference AND the ride in data.rides array
                        const rideIndex = data.rides.findIndex(r => r.id === rideId);
                        if (rideIndex !== -1) {
                            data.rides[rideIndex].availableRiders = ride.availableRiders;
                        }
                        // Save the reset to persist it
                        saveRideToDB(ride);
                    }
                    console.log('🔴 AUTO-ASSIGN: After initialization - ride.availableRiders:', {
                        length: ride.availableRiders.length,
                        first10: ride.availableRiders.slice(0, 10)
                    });
                } else {
                    console.log('🔴 AUTO-ASSIGN: ride.availableRiders already has', ride.availableRiders.length, 'riders, skipping initialization');
                }

                // Get available coaches and riders
                // IMPORTANT: Only use coaches explicitly marked as available in attendance list
                // Filter out coaches with "N/A" level as they are not eligible
                debugLines.push('=== DEBUG: COACH ATTENDANCE CHECK ===');
                debugLines.push(`ride.availableCoaches array length: ${ride.availableCoaches ? ride.availableCoaches.length : 0}`);
                debugLines.push(`ride.availableCoaches IDs: ${ride.availableCoaches ? ride.availableCoaches.join(', ') : 'none'}`);
                debugLines.push('');

                // First, get all coaches from the availableCoaches list
                console.log('🔴 AUTO-ASSIGN: ride.availableCoaches:', ride.availableCoaches, 'Types:', ride.availableCoaches?.map(id => typeof id));
                const allAvailableCoaches = ride.availableCoaches
                    .map(id => {
                        const coach = getCoachById(id);
                        if (!coach) {
                            console.warn('🔴 AUTO-ASSIGN: Coach ID not found:', id, 'Type:', typeof id);
                            debugLines.push(`  ⚠️ Coach ID ${id} not found in database`);
                            return null;
                        }
                        console.log('🔴 AUTO-ASSIGN: Found coach:', coach.name, 'ID:', coach.id, 'ID Type:', typeof coach.id, 'Lookup ID:', id, 'Lookup ID Type:', typeof id);
                        return coach;
                    })
                    .filter(Boolean);
                console.log('🔴 AUTO-ASSIGN: allAvailableCoaches count:', allAvailableCoaches.length);

                // Filter out coaches with "N/A" level - these should not be in attendance list
                const availableCoaches = allAvailableCoaches.filter(coach => {
                    const levelRaw = coach.coachingLicenseLevel || coach.level || 'N/A';
                    const level = levelRaw.toString().toUpperCase();
                    // Exclude coaches with N/A, NA, or empty level
                    const isValid = level !== 'N/A' && level !== 'NA' && level !== '' && level !== 'NULL' && level !== 'UNDEFINED';
                    if (!isValid) {
                        debugLines.push(`  ⚠️ Excluding ${coach.name || 'Coach'} (ID: ${coach.id}) - Level is ${levelRaw} (not eligible)`);
                    }
                    return isValid;
                });
                
                // Normalize IDs for consistency
                console.log('🔴 AUTO-ASSIGN: ride.availableRiders BEFORE normalization:', {
                    length: ride.availableRiders.length,
                    first10: ride.availableRiders.slice(0, 10),
                    allTypes: ride.availableRiders.slice(0, 10).map(id => typeof id)
                });
                console.log('🔴 AUTO-ASSIGN: Sample rider IDs from data.riders:', data.riders?.slice(0, 5).map(r => ({ id: r.id, idType: typeof r.id, name: r.name })));
                
                debugLines.push(`=== DEBUG: RIDER ATTENDANCE CHECK ===`);
                debugLines.push(`ride.availableRiders before normalization: ${JSON.stringify(ride.availableRiders?.slice(0, 10))} (showing first 10, total: ${ride.availableRiders?.length || 0})`);
                debugLines.push(`Sample rider IDs from data.riders: ${data.riders?.slice(0, 5).map(r => ({ id: r.id, idType: typeof r.id })).map(r => `${r.id}(${r.idType})`).join(', ') || 'none'}`);
                
                ride.availableRiders = ride.availableRiders.map(id => {
                    const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                    return Number.isFinite(normalized) ? normalized : id;
                });
                
                console.log('🔴 AUTO-ASSIGN: ride.availableRiders AFTER normalization:', {
                    length: ride.availableRiders.length,
                    first10: ride.availableRiders.slice(0, 10),
                    allTypes: ride.availableRiders.slice(0, 10).map(id => typeof id)
                });
                debugLines.push(`ride.availableRiders after normalization: ${JSON.stringify(ride.availableRiders?.slice(0, 10))} (showing first 10)`);
                
                // For refined practices, use filtered riders instead of all availableRiders
                // This ensures autofill only considers the riders that qualify under the refinement filter
                // Note: isRefined was already checked earlier, so we check again here
                let ridersToUse = ride.availableRiders;
                if (isRefined) {
                    const filteredRiderIds = getFilteredRiderIdsForRide(ride);
                    console.log('🔴 AUTO-ASSIGN: Refined practice detected - using filtered riders:', {
                        filteredCount: filteredRiderIds.length,
                        availableRidersCount: ride.availableRiders.length,
                        filteredIds: filteredRiderIds.slice(0, 10)
                    });
                    debugLines.push(`⚠️ Refined practice: Using ${filteredRiderIds.length} filtered riders instead of ${ride.availableRiders.length} available riders`);
                    ridersToUse = filteredRiderIds;
                }
                
                // Use filtered riders for refined practices, or all available riders for regular practices
                console.log('🔴 AUTO-ASSIGN: Looking up riders...');
                const availableRiders = ridersToUse
                    .map(id => {
                        const rider = getRiderById(id);
                        if (!rider) {
                            console.warn(`🔴 AUTO-ASSIGN: Rider ID ${id} (type: ${typeof id}) NOT FOUND in data.riders`);
                            debugLines.push(`  ⚠️ Rider ID ${id} (type: ${typeof id}) not found in data.riders`);
                        } else {
                            console.log(`🔴 AUTO-ASSIGN: Found rider: ${rider.name || 'Unknown'} (ID: ${rider.id}, type: ${typeof rider.id}, lookup ID: ${id}, lookup type: ${typeof id})`);
                        }
                        return rider;
                    })
                    .filter(Boolean);

                console.log('🔴 AUTO-ASSIGN: Final results:', {
                    rideAvailableRidersLength: ride.availableRiders.length,
                    availableRidersAfterLookup: availableRiders.length,
                    totalRidersInRoster: data.riders ? data.riders.length : 0,
                    foundRiders: availableRiders.map(r => ({ id: r.id, name: r.name }))
                });

                debugLines.push(`Available Coaches (before filtering): ${allAvailableCoaches.length}`);
                debugLines.push(`Available Coaches (after filtering out N/A level): ${availableCoaches.length}`);
                debugLines.push(`Available Riders (ride.availableRiders.length): ${ride.availableRiders.length}`);
                debugLines.push(`Riders to use for autofill${isRefined ? ' (refined practice - filtered)' : ''}: ${ridersToUse.length}`);
                debugLines.push(`Available Riders (after lookup): ${availableRiders.length}`);
                debugLines.push(`Total Riders in Roster: ${data.riders ? data.riders.length : 0}`);
                
                // List all eligible available coaches with their details
                debugLines.push('Eligible Available Coaches Details:');
                availableCoaches.forEach((coach, idx) => {
                    const level = coach.coachingLicenseLevel || coach.level || 'N/A';
                    const fitness = getCoachFitnessValue(coach);
                    debugLines.push(`  ${idx + 1}. ${coach.name || 'Coach'} - Level ${level}, Pace ${fitness}, ID: ${coach.id}`);
                });
                debugLines.push('');

                if (availableCoaches.length === 0) {
                    alert('Please select available coaches first');
                    autoAssignDebugLog = debugLines.concat('❌ Aborted: no coaches selected.').join('\n');
                    updateDebugOutput();
                    return;
                }

                if (availableRiders.length === 0) {
                    alert('Please select available riders first');
                    autoAssignDebugLog = debugLines.concat('❌ Aborted: no riders selected.').join('\n');
                    updateDebugOutput();
                    return;
                }

                // Get settings
                const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                const preferredCoachesPerGroup = getAutoAssignSetting('preferredCoachesPerGroup', 3);
                const preferredGroupSizeMin = getAutoAssignSettingMin('preferredGroupSize', 4);
                const preferredGroupSizeMax = getAutoAssignSettingMax('preferredGroupSize', 8);
                // These are hardcoded preferences based on the PDF logic
                const avoidOneLeaderGroups = true; // Priority: Avoid 1 Leader Groups
                const noOneLeaderOneRider = true; // Requirement: No 1 Leader group may have only one rider

                debugLines.push('=== SETTINGS ===');
                debugLines.push(`Riders per Coach: ${ridersPerCoach}`);
                debugLines.push(`Minimum Leader Level: ${minLeaderLevel}`);
                debugLines.push(`Preferred Coaches per Group: ${preferredCoachesPerGroup}`);
                debugLines.push(`Preferred Group Size Range: ${preferredGroupSizeMin}-${preferredGroupSizeMax}`);
                debugLines.push(`Avoid 1 Leader Groups: ${avoidOneLeaderGroups}`);
                debugLines.push(`No 1 Leader + 1 Rider: ${noOneLeaderOneRider}`);
                debugLines.push('');

                // STEP 1: Validate Requirements
                debugLines.push('=== STEP 1: VALIDATE REQUIREMENTS ===');
                
                // Get Level 2/3 coaches (eligible leaders)
                const eligibleLeaders = availableCoaches.filter(coach => {
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    const level = parseInt(levelRaw, 10);
                    return Number.isFinite(level) && level >= minLeaderLevel;
                });

                debugLines.push(`Level ${minLeaderLevel}+ Coaches (Eligible Leaders): ${eligibleLeaders.length}`);
                
                if (eligibleLeaders.length === 0) {
                    const errorMsg = `Not enough qualifying coaches: Need at least one Level ${minLeaderLevel}+ coach, but none available.`;
                    debugLines.push(`❌ ${errorMsg}`);
                    alert(errorMsg);
                    autoAssignDebugLog = debugLines.join('\n');
                    updateDebugOutput();
                    return;
                }

                // Check rider/coach ratio
                const maxGroups = eligibleLeaders.length;
                const totalCapacity = availableCoaches.length * ridersPerCoach;
                const ridersPerGroup = availableRiders.length / maxGroups;

                debugLines.push(`Max Groups (based on L${minLeaderLevel}+ coaches): ${maxGroups}`);
                debugLines.push(`Total Capacity (${availableCoaches.length} coaches × ${ridersPerCoach}): ${totalCapacity}`);
                debugLines.push(`Riders per Group (if evenly distributed): ${ridersPerGroup.toFixed(1)}`);

                if (availableRiders.length > totalCapacity) {
                    const errorMsg = `Not enough coaches: ${availableRiders.length} riders need ${Math.ceil(availableRiders.length / ridersPerCoach)} coaches (at ${ridersPerCoach} riders per coach), but only ${availableCoaches.length} coaches available.`;
                    debugLines.push(`❌ ${errorMsg}`);
                    alert(errorMsg);
                    autoAssignDebugLog = debugLines.join('\n');
                    updateDebugOutput();
                    return;
                }

                if (ridersPerGroup > ridersPerCoach) {
                    const warningMsg = `⚠️ Warning: Average ${ridersPerGroup.toFixed(1)} riders per group exceeds ${ridersPerCoach} riders per coach. Consider adding more coaches or reducing riders.`;
                    debugLines.push(warningMsg);
                } else {
                    debugLines.push(`✓ Requirements met: ${ridersPerGroup.toFixed(1)} riders/group < ${ridersPerCoach} riders/coach`);
                }
                debugLines.push('');

                // STEP 2: Calculate Possible Group Configurations
                debugLines.push('=== STEP 2: CALCULATE POSSIBLE GROUP CONFIGURATIONS ===');
                
                // Step 2A: Find group counts within preferred size range
                debugLines.push('Step 2A: Testing group counts within preferred size range:');
                const validGroupCounts = [];
                
                for (let numGroups = 1; numGroups <= maxGroups; numGroups++) {
                    const avgRidersPerGroup = availableRiders.length / numGroups;
                    if (avgRidersPerGroup >= preferredGroupSizeMin && avgRidersPerGroup <= preferredGroupSizeMax) {
                        validGroupCounts.push(numGroups);
                        debugLines.push(`  ✓ ${numGroups} groups = ${avgRidersPerGroup.toFixed(1)} riders/group (WITHIN RANGE)`);
                    } else {
                        debugLines.push(`  ✗ ${numGroups} groups = ${avgRidersPerGroup.toFixed(1)} riders/group (OUTSIDE RANGE)`);
                    }
                }

                if (validGroupCounts.length === 0) {
                    debugLines.push(`⚠️ No group counts within preferred range. Using max groups (${maxGroups}).`);
                    validGroupCounts.push(maxGroups);
                }

                debugLines.push(`Valid group counts: ${validGroupCounts.join(', ')}`);
                debugLines.push('');

                // If targetNumGroups is specified, use it (but validate it's in range)
                if (targetNumGroups !== null) {
                    const avgRidersPerGroup = availableRiders.length / targetNumGroups;
                    if (targetNumGroups > maxGroups) {
                        alert(`Cannot create ${targetNumGroups} groups: Only ${maxGroups} Level ${minLeaderLevel}+ coaches available.`);
                        return;
                    }
                    if (avgRidersPerGroup < preferredGroupSizeMin || avgRidersPerGroup > preferredGroupSizeMax) {
                        alert(`Cannot create ${targetNumGroups} groups: Would result in ${avgRidersPerGroup.toFixed(1)} riders per group, which is outside the preferred range of ${preferredGroupSizeMin}-${preferredGroupSizeMax}.`);
                        return;
                    }
                    // Force this group count to be used
                    validGroupCounts.length = 0;
                    validGroupCounts.push(targetNumGroups);
                    debugLines.push(`Using target number of groups: ${targetNumGroups}`);
                    debugLines.push('');
                }

                // Step 2B: Calculate coach distributions for each valid group count
                debugLines.push('Step 2B: Calculate coach distributions:');
                const totalCoaches = availableCoaches.length;
                
                // Smart function to generate candidate coach distributions (limited set)
                function generateCoachDistributions(numGroups, totalCoaches, targetCoachesPerGroup) {
                    const distributions = [];
                    const maxDistributions = 100; // Limit to prevent memory issues
                    
                    // Strategy 1: Start with even distribution, then vary
                    const baseCoaches = Math.floor(totalCoaches / numGroups);
                    const remainder = totalCoaches % numGroups;
                    
                    // Create base distribution
                    const baseDist = Array(numGroups).fill(baseCoaches);
                    for (let i = 0; i < remainder; i++) {
                        baseDist[i]++;
                    }
                    distributions.push([...baseDist]);
                    
                    // Strategy 2: Try distributions around targetCoachesPerGroup
                    if (targetCoachesPerGroup > 0) {
                        const targetTotal = targetCoachesPerGroup * numGroups;
                        if (targetTotal <= totalCoaches) {
                            const targetDist = Array(numGroups).fill(targetCoachesPerGroup);
                            const extra = totalCoaches - targetTotal;
                            for (let i = 0; i < extra && i < numGroups; i++) {
                                targetDist[i]++;
                            }
                            distributions.push([...targetDist]);
                        }
                    }
                    
                    // Strategy 3: Generate variations by redistributing coaches
                    // Limit to reasonable variations to prevent explosion
                    const variations = [];
                    for (let attempt = 0; attempt < 50 && variations.length < maxDistributions; attempt++) {
                        const dist = Array(numGroups).fill(1); // Start with 1 coach per group (minimum)
                        let remaining = totalCoaches - numGroups;
                        
                        // Distribute remaining coaches, preferring groups that need more
                        while (remaining > 0) {
                            // Find groups that could use more coaches (below target)
                            const candidates = [];
                            for (let i = 0; i < numGroups; i++) {
                                if (dist[i] < targetCoachesPerGroup + 2) { // Allow some flexibility
                                    candidates.push(i);
                                }
                            }
                            
                            if (candidates.length === 0) {
                                // All groups are at or above target, distribute evenly
                                for (let i = 0; i < numGroups && remaining > 0; i++) {
                                    dist[i]++;
                                    remaining--;
                                }
                            } else {
                                // Add to random candidate
                                const idx = candidates[Math.floor(Math.random() * candidates.length)];
                                dist[idx]++;
                                remaining--;
                            }
                        }
                        
                        // Check if this is a new unique distribution
                        const distStr = [...dist].sort((a, b) => b - a).join(',');
                        if (!variations.some(v => v.join(',') === distStr)) {
                            variations.push([...dist]);
                        }
                    }
                    
                    distributions.push(...variations);
                    
                    // Strategy 4: Try to minimize 1-coach groups
                    if (avoidOneLeaderGroups) {
                        const minOneLeaderDist = Array(numGroups).fill(2); // Start with 2 coaches per group
                        let remaining = totalCoaches - (numGroups * 2);
                        
                        if (remaining >= 0) {
                            // Distribute remaining coaches
                            while (remaining > 0) {
                                for (let i = 0; i < numGroups && remaining > 0; i++) {
                                    minOneLeaderDist[i]++;
                                    remaining--;
                                }
                            }
                            const distStr = [...minOneLeaderDist].sort((a, b) => b - a).join(',');
                            if (!distributions.some(d => [...d].sort((a, b) => b - a).join(',') === distStr)) {
                                distributions.push([...minOneLeaderDist]);
                            }
                        }
                    }
                    
                    // Remove duplicates and limit total
                    const unique = [];
                    const seen = new Set();
                    for (const dist of distributions) {
                        const sorted = [...dist].sort((a, b) => b - a);
                        const key = sorted.join(',');
                        if (!seen.has(key) && unique.length < maxDistributions) {
                            seen.add(key);
                            unique.push(sorted);
                        }
                    }
                    
                    return unique;
                }

                let bestConfig = null;
                let bestScore = -Infinity;

                for (const numGroups of validGroupCounts) {
                    debugLines.push(`  Testing ${numGroups} groups with ${totalCoaches} coaches:`);
                    
                    const distributions = generateCoachDistributions(numGroups, totalCoaches, preferredCoachesPerGroup);
                    debugLines.push(`    Generated ${distributions.length} candidate distributions`);
                    
                    for (const sortedDist of distributions) {
                        const oneLeaderGroups = sortedDist.filter(c => c === 1).length;
                        const avgCoaches = sortedDist.reduce((a, b) => a + b, 0) / sortedDist.length;
                        const deviationFromPreferred = Math.abs(avgCoaches - preferredCoachesPerGroup);
                        
                        // Score: prefer fewer 1-leader groups, then closer to preferred coaches per group
                        // Bonus: add points for each group with exactly preferred number of coaches
                        let score = 1000;
                        if (avoidOneLeaderGroups && oneLeaderGroups > 0) {
                            score -= oneLeaderGroups * 500; // Heavy penalty for 1-leader groups
                        }
                        score -= deviationFromPreferred * 10; // Prefer closer to preferred
                        
                        // Bonus for groups with exactly preferred number of coaches (breaks ties)
                        const groupsWithPreferred = sortedDist.filter(c => c === preferredCoachesPerGroup).length;
                        score += groupsWithPreferred * 5; // Bonus for each group with exactly preferred coaches
                        
                        const distStr = sortedDist.join(',');
                        debugLines.push(`    Distribution [${distStr}]: ${oneLeaderGroups} one-leader groups, avg ${avgCoaches.toFixed(1)} coaches/group (score: ${score.toFixed(0)})`);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestConfig = {
                                numGroups,
                                coachDistribution: sortedDist,
                                oneLeaderGroups,
                                avgCoaches
                            };
                        }
                    }
                }

                if (!bestConfig) {
                    debugLines.push('❌ ERROR: Could not find valid configuration');
                    autoAssignDebugLog = debugLines.join('\n');
                    updateDebugOutput();
                    return;
                }

                // Calculate expected rider distribution
                const totalRiders = availableRiders.length;
                const avgRidersPerGroup = totalRiders / bestConfig.numGroups;
                const baseRidersPerGroup = Math.floor(avgRidersPerGroup);
                const remainder = totalRiders % bestConfig.numGroups;
                const riderDistribution = Array(bestConfig.numGroups).fill(baseRidersPerGroup);
                for (let i = 0; i < remainder; i++) {
                    riderDistribution[i]++;
                }
                riderDistribution.sort((a, b) => b - a); // Sort descending for display

                debugLines.push('');
                debugLines.push(`✓ SELECTED CONFIGURATION: ${bestConfig.numGroups} groups`);
                debugLines.push(`  Coach Distribution: [${bestConfig.coachDistribution.join(', ')}]`);
                debugLines.push(`  One-Leader Groups: ${bestConfig.oneLeaderGroups}`);
                debugLines.push(`  Average Coaches per Group: ${bestConfig.avgCoaches.toFixed(1)}`);
                debugLines.push(`  Average Riders per Group: ${avgRidersPerGroup.toFixed(1)}`);
                debugLines.push(`  Rider Distribution: [${riderDistribution.join(',')}]`);
                debugLines.push('');

                // STEP 3: Distribute Riders
                debugLines.push('=== STEP 3: DISTRIBUTE RIDERS ===');
                
                // Step 3: Rank riders by fitness (fastest to slowest)
                const sortedRiders = [...availableRiders].sort((a, b) => {
                    const aFitness = parseInt(a.fitness || '5', 10);
                    const bFitness = parseInt(b.fitness || '5', 10);
                    const aRelative = getRelativePaceValue(aFitness);
                    const bRelative = getRelativePaceValue(bFitness);
                    return bRelative - aRelative; // Fastest first (relative to pace sorting)
                });

                debugLines.push('Riders ranked by pace (fastest to slowest):');
                sortedRiders.forEach((rider, idx) => {
                    const fitness = parseInt(rider.fitness || '5', 10);
                    debugLines.push(`  ${idx + 1}. ${rider.name || 'Rider'} - Pace ${fitness}`);
                });
                debugLines.push('');

                // Step 3A: Distribute riders evenly as possible into groups (fill each group sequentially)
                debugLines.push('Step 3A: Initial even distribution:');
                ride.groups = [];
                
                for (let i = 0; i < bestConfig.numGroups; i++) {
                    const group = createGroup(`Group ${i + 1}`);
                    ride.groups.push(group);
                }

                // Fill each group sequentially using the riderDistribution calculated earlier
                // Group 1 gets first N riders, Group 2 gets next N, etc.
                // Make last/slowest group smallest if numbers don't divide evenly
                let riderIndex = 0;
                for (let groupIdx = 0; groupIdx < ride.groups.length; groupIdx++) {
                    // Get how many riders this group should get from the distribution
                    // Note: riderDistribution is sorted descending, but we want to fill groups in order
                    // So we need to use the unsorted distribution
                    const ridersForThisGroup = baseRidersPerGroup + (groupIdx < remainder ? 1 : 0);
                    
                    // Add riders sequentially to this group
                    for (let i = 0; i < ridersForThisGroup && riderIndex < sortedRiders.length; i++) {
                        ride.groups[groupIdx].riders.push(sortedRiders[riderIndex].id);
                        riderIndex++;
                    }
                }
                debugLines.push('');

                // Log initial distribution with full details
                ride.groups.forEach((group, idx) => {
                    const riders = group.riders.map(id => getRiderById(id)).filter(Boolean);
                    const fitnessValues = riders.map(r => parseInt(r.fitness || '5', 10));
                    const avgFitness = fitnessValues.length > 0 
                        ? (fitnessValues.reduce((a, b) => a + b, 0) / fitnessValues.length).toFixed(1)
                        : 'N/A';
                    
                    // Group riders by fitness for detailed output
                    const ridersByFitness = {};
                    riders.forEach(rider => {
                        const fitness = parseInt(rider.fitness || '5', 10);
                        if (!ridersByFitness[fitness]) {
                            ridersByFitness[fitness] = [];
                        }
                        ridersByFitness[fitness].push(rider);
                    });
                    
                    debugLines.push(`  ${group.label}: ${riders.length} riders, avg fitness ${avgFitness}`);
                    // List all riders with their fitness
                    riders.forEach((rider, riderIdx) => {
                        const fitness = parseInt(rider.fitness || '5', 10);
                        debugLines.push(`    ${riderIdx + 1}. ${rider.name || 'Rider'} - Pace ${fitness}`);
                    });
                });
                debugLines.push('');

                // Step 3B: Optimize - group riders with same fitness together (if within size constraints)
                debugLines.push('Step 3B: Optimize rider distribution (group same fitness together):');
                
                let optimizationRound = 0;
                const maxOptimizationRounds = 50;
                let madeChanges = true;

                while (madeChanges && optimizationRound < maxOptimizationRounds) {
                    optimizationRound++;
                    madeChanges = false;
                    debugLines.push(`  Round ${optimizationRound}:`);

                    for (let i = 0; i < ride.groups.length; i++) {
                        const sourceGroup = ride.groups[i];
                        const sourceRiders = sourceGroup.riders.map(id => getRiderById(id)).filter(Boolean);
                        
                        if (sourceRiders.length === 0) continue;

                        // Get fitness distribution in this group
                        const fitnessCounts = {};
                        sourceRiders.forEach(rider => {
                            const fitness = parseInt(rider.fitness || '5', 10);
                            fitnessCounts[fitness] = (fitnessCounts[fitness] || 0) + 1;
                        });

                        // Find riders that are in minority fitness levels
                        for (const rider of sourceRiders) {
                            const riderFitness = parseInt(rider.fitness || '5', 10);
                            const sameFitnessInGroup = fitnessCounts[riderFitness] || 0;
                            
                            // If this rider is alone or in small minority, try to move them
                            if (sameFitnessInGroup <= 1 && sourceRiders.length > 1) {
                                // Find a target group with riders of same fitness
                                for (let j = 0; j < ride.groups.length; j++) {
                                    if (i === j) continue;
                                    
                                    const targetGroup = ride.groups[j];
                                    const targetRiders = targetGroup.riders.map(id => getRiderById(id)).filter(Boolean);
                                    
                                    // Check if target has riders with same fitness
                                    const hasSameFitness = targetRiders.some(r => 
                                        parseInt(r.fitness || '5', 10) === riderFitness
                                    );
                                    
                                    if (hasSameFitness) {
                                        // Check if move would keep both groups within size constraints
                                        const sourceNewSize = sourceRiders.length - 1;
                                        const targetNewSize = targetRiders.length + 1;
                                        
                                        const sourceValid = sourceNewSize >= preferredGroupSizeMin && sourceNewSize <= preferredGroupSizeMax;
                                        const targetValid = targetNewSize >= preferredGroupSizeMin && targetNewSize <= preferredGroupSizeMax;
                                        
                                        // Allow slight flexibility if it helps group same fitness
                                        const sourceFlexible = sourceNewSize >= preferredGroupSizeMin - 1 && sourceNewSize <= preferredGroupSizeMax + 1;
                                        const targetFlexible = targetNewSize >= preferredGroupSizeMin - 1 && targetNewSize <= preferredGroupSizeMax + 1;
                                        
                                        if ((sourceValid && targetValid) || (sourceFlexible && targetFlexible && sourceNewSize >= 2 && targetNewSize <= preferredGroupSizeMax + 1)) {
                                            // Move rider
                                            sourceGroup.riders = sourceGroup.riders.filter(id => id !== rider.id);
                                            targetGroup.riders.push(rider.id);
                                            
                                            debugLines.push(`    ✓ Moved ${rider.name || 'Rider'} (Pace ${riderFitness}) from ${sourceGroup.label} to ${targetGroup.label}`);
                                            debugLines.push(`      ${sourceGroup.label}: ${sourceNewSize} riders, ${targetGroup.label}: ${targetNewSize} riders`);
                                            madeChanges = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (!madeChanges && optimizationRound === 1) {
                        debugLines.push('    No optimizations needed');
                    }
                }

                if (optimizationRound >= maxOptimizationRounds) {
                    debugLines.push(`  ⚠️ Optimization stopped after ${maxOptimizationRounds} rounds (safety limit)`);
                } else if (madeChanges) {
                    debugLines.push(`  ✓ Optimization completed in ${optimizationRound} rounds`);
                } else {
                    debugLines.push(`  ✓ Optimization completed in ${optimizationRound} rounds (no changes needed)`);
                }
                debugLines.push('');

                // Log final rider distribution
                debugLines.push('Final Rider Distribution:');
                ride.groups.forEach((group, idx) => {
                    const riders = group.riders.map(id => getRiderById(id)).filter(Boolean);
                    const fitnessValues = riders.map(r => parseInt(r.fitness || '5', 10));
                    const fitnessCounts = {};
                    fitnessValues.forEach(f => fitnessCounts[f] = (fitnessCounts[f] || 0) + 1);
                    const fitnessStr = Object.entries(fitnessCounts)
                        .sort((a, b) => b[0] - a[0])
                        .map(([f, c]) => `${c}x Pace ${f}`)
                        .join(', ');
                    
                    debugLines.push(`  ${group.label}: ${riders.length} riders [${fitnessStr}]`);
                });
                debugLines.push('');

                // STEP 4: Assign Coaches
                debugLines.push('=== STEP 4: ASSIGN COACHES ===');
                
                // Step 4: Determine which groups get which number of coaches
                debugLines.push('Step 4: Assigning coach counts to groups:');
                
                // Sort groups by size (largest first), then by fitness variance
                const groupInfo = ride.groups.map((group, idx) => {
                    const riders = group.riders.map(id => getRiderById(id)).filter(Boolean);
                    const fitnessValues = riders.map(r => parseInt(r.fitness || '5', 10));
                    const uniqueFitness = new Set(fitnessValues);
                    const variance = uniqueFitness.size > 1 ? uniqueFitness.size : 0;
                    const avgFitness = fitnessValues.length > 0 
                        ? fitnessValues.reduce((a, b) => a + b, 0) / fitnessValues.length
                        : 0;
                    
                    return {
                        group,
                        index: idx,
                        size: riders.length,
                        variance,
                        avgFitness
                    };
                });

                // Sort: largest first, then by variance (more variance = slower), then by avg fitness (slower first)
                groupInfo.sort((a, b) => {
                    if (b.size !== a.size) return b.size - a.size;
                    if (b.variance !== a.variance) return b.variance - a.variance;
                    return a.avgFitness - b.avgFitness;
                });

                // Assign coach counts based on sorted order
                const coachDistribution = [...bestConfig.coachDistribution].sort((a, b) => b - a);
                groupInfo.forEach((info, idx) => {
                    info.coachCount = coachDistribution[idx] || 1;
                    debugLines.push(`  ${info.group.label}: ${info.size} riders, ${info.variance} fitness levels, ${info.coachCount} coaches`);
                });
                debugLines.push('');

                // Step 4A: Rank L2/3 coaches by fitness
                debugLines.push('Step 4A: Ranking L2/3 coaches by fitness:');
                const sortedLeaders = [...eligibleLeaders].sort((a, b) => {
                    const aFitness = getCoachFitnessValue(a);
                    const bFitness = getCoachFitnessValue(b);
                    return bFitness - aFitness; // Highest fitness first
                });

                sortedLeaders.forEach((coach, idx) => {
                    const fitness = getCoachFitnessValue(coach);
                    const level = coach.coachingLicenseLevel || coach.level || '1';
                    debugLines.push(`  ${idx + 1}. ${coach.name || 'Coach'} - Level ${level}, Pace ${fitness}`);
                });
                debugLines.push('');

                // Step 4B: Assign Leaders
                debugLines.push('Step 4B: Assigning ride leaders:');
                let leaderIndex = 0;
                groupInfo.forEach((info) => {
                    if (leaderIndex < sortedLeaders.length) {
                        info.group.coaches.leader = sortedLeaders[leaderIndex].id;
                        debugLines.push(`  ${info.group.label} Leader: ${sortedLeaders[leaderIndex].name || 'Coach'}`);
                        leaderIndex++;
                    }
                });
                debugLines.push('');

                // Step 4C: Get remaining coaches (L1 + unassigned L2/3)
                debugLines.push('Step 4C: Remaining coaches (L1 + unassigned L2/3):');
                const remainingCoaches = availableCoaches
                    .filter(coach => {
                        // Not already assigned as leader
                        return !groupInfo.some(info => info.group.coaches.leader === coach.id);
                    })
                    .sort((a, b) => {
                        const aFitness = getCoachFitnessValue(a);
                        const bFitness = getCoachFitnessValue(b);
                        return bFitness - aFitness; // Highest fitness first
                    });

                remainingCoaches.forEach((coach, idx) => {
                    const fitness = getCoachFitnessValue(coach);
                    const level = coach.coachingLicenseLevel || coach.level || '1';
                    debugLines.push(`  ${idx + 1}. ${coach.name || 'Coach'} - Level ${level}, Pace ${fitness}`);
                });
                debugLines.push('');

                // Step 4D: Assign additional coaches (Sweep, Roam)
                debugLines.push('Step 4D: Assigning additional coaches:');
                let remainingCoachIndex = 0;

                // Sort groups by coach count needed (most first)
                const groupsNeedingCoaches = groupInfo
                    .filter(info => info.coachCount > 1)
                    .sort((a, b) => b.coachCount - a.coachCount);

                for (const info of groupsNeedingCoaches) {
                    const coachesNeeded = info.coachCount - 1; // Already has leader
                    let coachesAssigned = 0;

                    while (coachesAssigned < coachesNeeded && remainingCoachIndex < remainingCoaches.length) {
                        const coach = remainingCoaches[remainingCoachIndex];
                        
                        if (!info.group.coaches.sweep) {
                            info.group.coaches.sweep = coach.id;
                            debugLines.push(`  ${info.group.label} Sweep: ${coach.name || 'Coach'}`);
                            coachesAssigned++;
                        } else if (!info.group.coaches.roam) {
                            info.group.coaches.roam = coach.id;
                            debugLines.push(`  ${info.group.label} Roam: ${coach.name || 'Coach'}`);
                            coachesAssigned++;
                        } else {
                            // Add as extraRoam
                            if (!Array.isArray(info.group.coaches.extraRoam)) {
                                info.group.coaches.extraRoam = [];
                            }
                            info.group.coaches.extraRoam.push(coach.id);
                            debugLines.push(`  ${info.group.label} Extra Roam: ${coach.name || 'Coach'}`);
                            coachesAssigned++;
                        }
                        
                        remainingCoachIndex++;
                    }
                }
                debugLines.push('');

                // Validate no 1-leader + 1-rider groups if required
                if (noOneLeaderOneRider) {
                    debugLines.push('Validating: No 1-leader + 1-rider groups:');
                    let violations = 0;
                    ride.groups.forEach(group => {
                        const coachCount = countGroupCoaches(group);
                        if (coachCount === 1 && group.riders.length === 1) {
                            violations++;
                            debugLines.push(`  ❌ ${group.label}: 1 coach + 1 rider (VIOLATION)`);
                        }
                    });
                    if (violations > 0) {
                        debugLines.push(`  ⚠️ Warning: ${violations} group(s) violate the "No 1 Leader + 1 Rider" requirement`);
                    } else {
                        debugLines.push(`  ✓ All groups meet requirement`);
                    }
                    debugLines.push('');
                }

                // Final summary
                debugLines.push('=== FINAL SUMMARY ===');
                ride.groups.forEach((group, idx) => {
                    const riders = group.riders.map(id => getRiderById(id)).filter(Boolean);
                    const leader = getCoachById(group.coaches.leader);
                    const sweep = getCoachById(group.coaches.sweep);
                    const roam = getCoachById(group.coaches.roam);
                    const extraRoam = Array.isArray(group.coaches.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    debugLines.push(`${group.label}:`);
                    debugLines.push(`  Riders: ${riders.length}`);
                    debugLines.push(`  Leader: ${leader ? leader.name || 'Coach' : 'None'}`);
                    debugLines.push(`  Sweep: ${sweep ? sweep.name || 'Coach' : 'None'}`);
                    debugLines.push(`  Roam: ${roam ? roam.name || 'Coach' : 'None'}`);
                    if (extraRoam.length > 0) {
                        debugLines.push(`  Extra Roam: ${extraRoam.map(c => c.name || 'Coach').join(', ')}`);
                    }
                });

                // Clear new attendees when autofill runs (they're now assigned)
                ride.newAttendees = null;

                // Save and render
                saveRideToDB(ride);
                renderAssignments(ride);
                renderPracticeAttendanceLists();

                // Show the More/Fewer Groups buttons after successful autofill
                const moreGroupsBtn = document.getElementById('more-groups-btn');
                const fewerGroupsBtn = document.getElementById('fewer-groups-btn');
                if (moreGroupsBtn) moreGroupsBtn.style.display = '';
                if (fewerGroupsBtn) fewerGroupsBtn.style.display = '';

                autoAssignDebugLog = debugLines.join('\n');
                updateDebugOutput();

            } catch (error) {
                console.error('Error in autoAssign:', error);
                alert(`Error during auto-assignment: ${error.message}\n\nCheck the browser console and debug output for details.`);
                autoAssignDebugLog = `Error: ${error.message}\n\nStack trace:\n${error.stack}`;
                updateDebugOutput();
            }
        }

        function addGroupsFromLastPractice() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }
            if (ride.cancelled) {
                alert('Cannot assign riders and coaches to a cancelled practice.');
                return;
            }

            // Save state before change
            saveAssignmentState(ride);

            // Find the most recent practice before this one
            const currentDate = parseISODate(ride.date);
            if (!currentDate) {
                alert('Invalid practice date.');
                return;
            }

            // Get all rides sorted by date (descending - most recent first)
            const allRides = (data.rides || [])
                .filter(r => {
                    if (!r.date || r.deleted || r.cancelled) return false;
                    const rDate = parseISODate(r.date);
                    if (!rDate) return false;
                    return rDate < currentDate; // Only practices before current
                })
                .map(r => ({
                    ride: r,
                    date: parseISODate(r.date)
                }))
                .filter(r => r.date)
                .sort((a, b) => b.date - a.date); // Most recent first

            // Find first practice with group assignments
            let sourceRide = null;
            for (const { ride: candidateRide } of allRides) {
                if (candidateRide.groups && candidateRide.groups.length > 0) {
                    sourceRide = candidateRide;
                    break;
                }
            }

            if (!sourceRide || !sourceRide.groups || sourceRide.groups.length === 0) {
                alert('No previous practice with group assignments found.');
                return;
            }

            // Confirm with user
            const sourceDate = parseISODate(sourceRide.date);
            const sourceDateStr = sourceDate ? sourceDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : sourceRide.date;
            if (!confirm(`Copy group assignments from practice on ${sourceDateStr}?\n\nThis will recreate the same group structure and assignments for the current practice.`)) {
                return;
            }

            // Get current practice's available coaches and riders
            const currentAvailableCoaches = new Set(ride.availableCoaches || []);
            const currentAvailableRiders = new Set(ride.availableRiders || []);

            // Get source practice's available coaches and riders
            const sourceAvailableCoaches = new Set(sourceRide.availableCoaches || []);
            const sourceAvailableRiders = new Set(sourceRide.availableRiders || []);

            // Find new attendees (attending current but not source)
            const newCoaches = Array.from(currentAvailableCoaches).filter(id => !sourceAvailableCoaches.has(id));
            const newRiders = Array.from(currentAvailableRiders).filter(id => !sourceAvailableRiders.has(id));

            // Find missing attendees (were in source but not attending current)
            const missingCoaches = Array.from(sourceAvailableCoaches).filter(id => !currentAvailableCoaches.has(id));
            const missingRiders = Array.from(sourceAvailableRiders).filter(id => !currentAvailableRiders.has(id));

            // Copy groups from source practice
            ride.groups = sourceRide.groups.map(sourceGroup => {
                const newGroup = createGroup(sourceGroup.label);
                
                // Copy riders (only those available in current practice)
                newGroup.riders = sourceGroup.riders.filter(riderId => currentAvailableRiders.has(riderId));
                
                // Copy coaches (only those available in current practice)
                if (sourceGroup.coaches.leader && currentAvailableCoaches.has(sourceGroup.coaches.leader)) {
                    newGroup.coaches.leader = sourceGroup.coaches.leader;
                }
                if (sourceGroup.coaches.sweep && currentAvailableCoaches.has(sourceGroup.coaches.sweep)) {
                    newGroup.coaches.sweep = sourceGroup.coaches.sweep;
                }
                if (sourceGroup.coaches.roam && currentAvailableCoaches.has(sourceGroup.coaches.roam)) {
                    newGroup.coaches.roam = sourceGroup.coaches.roam;
                }
                if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                    newGroup.coaches.extraRoam = sourceGroup.coaches.extraRoam.filter(id => currentAvailableCoaches.has(id));
                }
                
                // Auto-promote qualified L2/L3 coach to leader if original leader is absent
                if (!newGroup.coaches.leader) {
                    // Check for qualified coaches in the group (sweep, roam, extraRoam)
                    const qualifiedCoaches = [];
                    
                    // Check sweep
                    if (newGroup.coaches.sweep) {
                        const coach = getCoachById(newGroup.coaches.sweep);
                        if (coach) {
                            const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                            const level = parseInt(levelRaw, 10);
                            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                            if (Number.isFinite(level) && level >= minLeaderLevel) {
                                qualifiedCoaches.push({ id: coach.id, role: 'sweep', level });
                            }
                        }
                    }
                    
                    // Check roam
                    if (newGroup.coaches.roam) {
                        const coach = getCoachById(newGroup.coaches.roam);
                        if (coach) {
                            const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                            const level = parseInt(levelRaw, 10);
                            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                            if (Number.isFinite(level) && level >= minLeaderLevel) {
                                qualifiedCoaches.push({ id: coach.id, role: 'roam', level });
                            }
                        }
                    }
                    
                    // Check extraRoam
                    if (Array.isArray(newGroup.coaches.extraRoam)) {
                        newGroup.coaches.extraRoam.forEach(coachId => {
                            const coach = getCoachById(coachId);
                            if (coach) {
                                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                                const level = parseInt(levelRaw, 10);
                                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                                if (Number.isFinite(level) && level >= minLeaderLevel) {
                                    qualifiedCoaches.push({ id: coach.id, role: 'extraRoam', level });
                                }
                            }
                        });
                    }
                    
                    // If we found qualified coaches, promote the highest level one (prefer L3 over L2)
                    if (qualifiedCoaches.length > 0) {
                        // Sort by level (descending) to prefer L3 over L2
                        qualifiedCoaches.sort((a, b) => b.level - a.level);
                        const promotedCoach = qualifiedCoaches[0];
                        
                        // Promote to leader
                        newGroup.coaches.leader = promotedCoach.id;
                        
                        // Remove from original role
                        if (promotedCoach.role === 'sweep') {
                            newGroup.coaches.sweep = null;
                        } else if (promotedCoach.role === 'roam') {
                            newGroup.coaches.roam = null;
                        } else if (promotedCoach.role === 'extraRoam') {
                            newGroup.coaches.extraRoam = newGroup.coaches.extraRoam.filter(id => id !== promotedCoach.id);
                        }
                    }
                    // If no qualified coach found, group will be marked red by checkGroupCompliance
                }
                
                // Copy other group properties (but not routeId - routes must be chosen fresh for each practice)
                newGroup.routeId = null; // Routes are not copied - must be chosen fresh for each practice
                newGroup.sortBy = sourceGroup.sortBy;
                
                return newGroup;
            });

            // Store new attendees for display
            ride.newAttendees = {
                coaches: newCoaches,
                riders: newRiders
            };

            // Save and render
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();

            // Show the More/Fewer Groups buttons
            const moreGroupsBtn = document.getElementById('more-groups-btn');
            const fewerGroupsBtn = document.getElementById('fewer-groups-btn');
            if (moreGroupsBtn) moreGroupsBtn.style.display = '';
            if (fewerGroupsBtn) fewerGroupsBtn.style.display = '';
        }

        function tryMoreGroups() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }

            // Get current number of groups
            const currentNumGroups = ride.groups ? ride.groups.length : 0;
            if (currentNumGroups === 0) {
                alert('Please run Autofill Group Assignments first to establish a baseline.');
                return;
            }

            // Get settings to calculate valid group counts
            const availableCoaches = ride.availableCoaches
                .map(id => getCoachById(id))
                .filter(Boolean)
                .filter(coach => {
                    const levelRaw = coach.coachingLicenseLevel || coach.level || 'N/A';
                    const level = levelRaw.toString().toUpperCase();
                    return level !== 'N/A' && level !== 'NA' && level !== '' && level !== 'NULL' && level !== 'UNDEFINED';
                });

            const availableRiders = ride.availableRiders
                .map(id => getRiderById(id))
                .filter(Boolean);

            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const preferredGroupSizeMin = getAutoAssignSettingMin('preferredGroupSize', 4);
            const preferredGroupSizeMax = getAutoAssignSettingMax('preferredGroupSize', 8);

            const eligibleLeaders = availableCoaches.filter(coach => {
                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                const level = parseInt(levelRaw, 10);
                return Number.isFinite(level) && level >= minLeaderLevel;
            });

            const maxGroups = eligibleLeaders.length;

            // Find next larger valid group count
            let nextNumGroups = currentNumGroups + 1;
            while (nextNumGroups <= maxGroups) {
                const avgRidersPerGroup = availableRiders.length / nextNumGroups;
                if (avgRidersPerGroup >= preferredGroupSizeMin && avgRidersPerGroup <= preferredGroupSizeMax) {
                    // Found a valid larger group count
                    autoAssign(nextNumGroups);
                    return;
                }
                nextNumGroups++;
            }

            // No valid larger group count found
            alert(`Cannot create more groups: The next larger group count (${currentNumGroups + 1}) would result in ${(availableRiders.length / (currentNumGroups + 1)).toFixed(1)} riders per group, which is outside the preferred range of ${preferredGroupSizeMin}-${preferredGroupSizeMax}.`);
        }

        function tryFewerGroups() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }

            // Get current number of groups
            const currentNumGroups = ride.groups ? ride.groups.length : 0;
            if (currentNumGroups === 0) {
                alert('Please run Autofill Group Assignments first to establish a baseline.');
                return;
            }

            // Get settings to calculate valid group counts
            const availableCoaches = ride.availableCoaches
                .map(id => getCoachById(id))
                .filter(Boolean)
                .filter(coach => {
                    const levelRaw = coach.coachingLicenseLevel || coach.level || 'N/A';
                    const level = levelRaw.toString().toUpperCase();
                    return level !== 'N/A' && level !== 'NA' && level !== '' && level !== 'NULL' && level !== 'UNDEFINED';
                });

            const availableRiders = ride.availableRiders
                .map(id => getRiderById(id))
                .filter(Boolean);

            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const preferredGroupSizeMin = getAutoAssignSettingMin('preferredGroupSize', 4);
            const preferredGroupSizeMax = getAutoAssignSettingMax('preferredGroupSize', 8);

            const eligibleLeaders = availableCoaches.filter(coach => {
                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                const level = parseInt(levelRaw, 10);
                return Number.isFinite(level) && level >= minLeaderLevel;
            });

            // Find next smaller valid group count
            let nextNumGroups = currentNumGroups - 1;
            while (nextNumGroups >= 1) {
                const avgRidersPerGroup = availableRiders.length / nextNumGroups;
                if (avgRidersPerGroup >= preferredGroupSizeMin && avgRidersPerGroup <= preferredGroupSizeMax) {
                    // Found a valid smaller group count
                    autoAssign(nextNumGroups);
                    return;
                }
                nextNumGroups--;
            }

            // No valid smaller group count found
            alert(`Cannot create fewer groups: The next smaller group count (${currentNumGroups - 1}) would result in ${(availableRiders.length / (currentNumGroups - 1)).toFixed(1)} riders per group, which is outside the preferred range of ${preferredGroupSizeMin}-${preferredGroupSizeMax}.`);
        }

        function toggleGroupSection(section) {
            // Toggle the state
            groupSectionsState[section] = !groupSectionsState[section];
            
            // Find all sections of this type across all groups
            const sections = document.querySelectorAll(`[data-section="${section}"]`);
            sections.forEach(el => {
                el.style.display = groupSectionsState[section] ? '' : 'none';
            });
            
            // Update all header indicators - find headers by checking onclick attribute
            const allHeaders = document.querySelectorAll('[onclick*="toggleGroupSection"]');
            allHeaders.forEach(header => {
                const onclickAttr = header.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${section}'`)) {
                    const spans = header.querySelectorAll('span');
                    if (spans.length >= 2) {
                        const indicator = spans[spans.length - 1];
                        indicator.textContent = groupSectionsState[section] ? '▼' : '▶';
                    }
                }
            });
        }

        function clearAssignments() {
            if (!confirm('Clear all assignments? This will delete all groups and remove all rider and coach assignments.')) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Clear undo/redo history when clearing assignments
            clearAssignmentHistory();
            
            // Delete all groups
            ride.groups = [];
            ride.assignments = {};
            ride.newAttendees = null; // Clear new attendees when clearing assignments
            ride.publishedGroups = false; // Reset published status when clearing
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
            
            // Hide the More/Fewer Groups buttons after clearing
            const moreGroupsBtn = document.getElementById('more-groups-btn');
            const fewerGroupsBtn = document.getElementById('fewer-groups-btn');
            if (moreGroupsBtn) moreGroupsBtn.style.display = 'none';
            if (fewerGroupsBtn) fewerGroupsBtn.style.display = 'none';
            
            autoAssignDebugLog = `Assignments cleared at ${new Date().toLocaleString()}.`;
            updateDebugOutput();
        }

        async function publishGroupAssignments() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No ride selected. Please select a ride first.');
                return;
            }

            if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                alert('No groups to publish. Please create groups first.');
                return;
            }

            if (!confirm('Publish group assignments? This will make the groups visible to coaches and riders.')) {
                return;
            }

            try {
                // Mark groups as published
                ride.publishedGroups = true;
                
                // Save to database
                saveRideToDB(ride);
                
                // Also save to Supabase if available
                if (typeof updateRide === 'function') {
                    try {
                        await updateRide(ride.id, {
                            publishedGroups: true,
                            groups: ride.groups
                        });
                    } catch (error) {
                        console.warn('Could not save to Supabase:', error);
                        // Continue anyway - local save succeeded
                    }
                }
                
                // Refresh views
                renderAssignments(ride);
                renderRideAssignments();
                renderCoachAssignments();
                
                alert('Group assignments published successfully!');
            } catch (error) {
                console.error('Error publishing group assignments:', error);
                alert('Error publishing group assignments. Please try again.');
            }
        }

        async function unpublishGroupAssignments() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No ride selected. Please select a ride first.');
                return;
            }

            if (!confirm('Unpublish group assignments? This will hide the groups from coaches and riders until they are published again.')) {
                return;
            }

            try {
                // Mark groups as unpublished
                ride.publishedGroups = false;
                
                // Save to database
                saveRideToDB(ride);
                
                // Also save to Supabase if available
                if (typeof updateRide === 'function') {
                    try {
                        await updateRide(ride.id, {
                            publishedGroups: false,
                            groups: ride.groups
                        });
                    } catch (error) {
                        console.warn('Could not save to Supabase:', error);
                        // Continue anyway - local save succeeded
                    }
                }
                
                // Refresh views
                renderAssignments(ride);
                renderRideAssignments();
                renderCoachAssignments();
                
                alert('Group assignments unpublished successfully.');
            } catch (error) {
                console.error('Error unpublishing group assignments:', error);
                alert('Error unpublishing group assignments. Please try again.');
            }
        }

        async function sendGroupAssignmentNotification() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No ride selected. Please select a ride first.');
                return;
            }

            if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                alert('No groups to notify about. Please create groups first.');
                return;
            }

            if (!ride.publishedGroups) {
                if (!confirm('Groups are not yet published. Do you want to publish them and send the notification?')) {
                    return;
                }
                // Publish first
                ride.publishedGroups = true;
                saveRideToDB(ride);
                if (typeof updateRide === 'function') {
                    try {
                        await updateRide(ride.id, {
                            publishedGroups: true,
                            groups: ride.groups
                        });
                    } catch (error) {
                        console.warn('Could not save to Supabase:', error);
                    }
                }
                renderAssignments(ride);
                renderRideAssignments();
                renderCoachAssignments();
            }

            try {
                // Send SMS notification
                await sendSMSNotification('4153597951', 'Ride Group Assignments are ready!');
                alert('Notification sent successfully!');
            } catch (error) {
                console.error('Error sending notification:', error);
                alert('Error sending notification. Please try again.');
            }
        }

        // Helper function to format date as short format (e.g., "1-14" for January 14)
        function formatShortDate(dateString) {
            const rideDate = parseISODate(dateString);
            if (!rideDate) return '';
            const month = rideDate.getMonth() + 1; // 1-12
            const day = rideDate.getDate(); // 1-31
            return `${month}-${day}`;
        }

        function printGroupAssignments() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No ride selected. Please select a ride first.');
                return;
            }

            if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                alert('No groups to print. Please create groups first.');
                return;
            }

            try {
                // Check if jsPDF is available
                if (typeof window.jspdf === 'undefined') {
                    alert('PDF library not loaded. Please refresh the page and try again.');
                    return;
                }

                // Generate both PDFs and HTML export
                generateMobileFriendlyPDF(ride);
                generateDesktopPrintFriendlyPDF(ride);
                generateHTMLExport(ride);
                
            } catch (error) {
                console.error('Error generating exports:', error);
                alert('Error generating exports. Please try again.');
            }
        }

        function generateHTMLExport(ride) {
            try {
                const rideDate = parseISODate(ride.date);
                const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                }) : ride.date;
                
                const practice = getPracticeSettingsForRide(ride);
                const practiceTime = ride.startTime || ride.time || (practice ? practice.time : '');
                const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
                const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
                const goals = (ride.goals || '').trim();

                // Format time display
                let timeDisplay = '';
                if (practiceTime) {
                    const formattedStart = formatTimeForDisplay(practiceTime);
                    if (practiceEndTime) {
                        const formattedEnd = formatTimeForDisplay(practiceEndTime);
                        timeDisplay = `${formattedStart} - ${formattedEnd}`;
                    } else {
                        timeDisplay = formattedStart;
                    }
                }

                // Sort groups sequentially
                const sortedGroups = [...ride.groups].sort((a, b) => {
                    const labelA = a.label || '';
                    const labelB = b.label || '';
                    const numA = parseInt(labelA.replace(/\D/g, '')) || 0;
                    const numB = parseInt(labelB.replace(/\D/g, '')) || 0;
                    return numA - numB;
                });

                // Generate groups HTML with collapsible functionality matching the tab
                let groupsHtmlWithCollapse = '';
                sortedGroups.forEach((group, index) => {
                    const groupId = `group-${group.id || index}`;
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;
                    
                    // Build coaches with their roles
                    const coachesWithRoles = [];
                    if (leader) coachesWithRoles.push({ coach: leader, role: 'Leader' });
                    if (sweep) coachesWithRoles.push({ coach: sweep, role: 'Sweep' });
                    if (roam) coachesWithRoles.push({ coach: roam, role: 'Roam' });
                    extraRoam.forEach(coach => {
                        coachesWithRoles.push({ coach, role: 'Roam+' });
                    });

                    // Get Strava URL if available
                    let stravaUrl = null;
                    if (route) {
                        stravaUrl = route.stravaUrl;
                        if (!stravaUrl && route.stravaEmbedCode) {
                            const urlMatch = route.stravaEmbedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
                            if (urlMatch) {
                                stravaUrl = urlMatch[0];
                            }
                        }
                    }

                    // Render rider cards (without badges)
                    const riderCardsHtml = riders.map(rider => {
                        const name = rider.name || 'Rider';
                        const safeName = escapeHtml(name);
                        const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                        // Only use photos if they're data URLs (base64 embedded), otherwise omit to avoid broken links
                        const photoSrc = rider.photo && rider.photo.startsWith('data:') ? rider.photo : null;
                        const photo = photoSrc ? escapeHtml(photoSrc) : '';
                        return '<div class="rider-card compact" style="display: flex; align-items: center; gap: 12px; padding: 8px; background: #f9f9f9; border-radius: 4px;">' +
                            '<div class="avatar-circle" style="width: 40px; height: 40px; border-radius: 50%; overflow: hidden; flex-shrink: 0; background: #e0e0e0; display: flex; align-items: center; justify-content: center;">' +
                            (photo ? '<img src="' + photo + '" alt="' + safeName + '" style="width: 100%; height: 100%; object-fit: cover;">' : '<span style="font-size: 18px; color: #666;">' + initial + '</span>') +
                            '</div>' +
                            '<div style="flex: 1; min-width: 0;">' +
                            '<strong style="font-size: 14px;">' + safeName + '</strong>' +
                            '</div>' +
                            '</div>';
                    }).join('');

                    groupsHtmlWithCollapse += `
                        <div class="mobile-group-card" style="margin-bottom: 0; border: 1px solid #ddd; border-radius: 0; overflow: hidden; background: white; border-top: ${index === 0 ? '1px solid #ddd' : 'none'};">
                            <button class="mobile-group-header" onclick="toggleMobileGroup('${groupId}')" style="width: 100%; padding: 8px 16px; background: #f5f5f5; border: none; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 600; color: #333;">
                                <span>${escapeHtml(group.label || ('Group ' + (index + 1)))}</span>
                                <span class="mobile-group-toggle" id="toggle-${groupId}" style="font-size: 20px; transition: transform 0.2s;">▲</span>
                            </button>
                            <div class="mobile-group-content" id="${groupId}" style="display: block; padding: 16px;">
                                ${riders.length > 0 ? `
                                    <div style="margin-bottom: ${coachesWithRoles.length > 0 ? '20px' : '0'};">
                                        <div style="display: flex; flex-direction: column; gap: 2px;">
                                            ${riderCardsHtml}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${coachesWithRoles.length > 0 ? `
                                    <div style="margin-top: ${riders.length > 0 ? '20px' : '0'}; margin-bottom: 16px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Ride Leaders</h3>
                                        <div style="display: flex; flex-direction: column; gap: 2px;">
                                            ${coachesWithRoles.map(({ coach, role }) => {
                                                const name = coach.name || 'Coach';
                                                const safeName = escapeHtml(name);
                                                const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                                                // Only use photos if they're data URLs (base64 embedded), otherwise omit to avoid broken links
                                                const photoSrc = coach.photo && coach.photo.startsWith('data:') ? coach.photo : null;
                                                const photo = photoSrc ? escapeHtml(photoSrc) : '';
                                                return `
                                                    <div style="display: flex; align-items: center; gap: 12px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
                                                        <div class="avatar-circle" style="width: 40px; height: 40px; border-radius: 50%; overflow: hidden; flex-shrink: 0; background: #e0e0e0; display: flex; align-items: center; justify-content: center;">
                                                            ${photo ? '<img src="' + photo + '" alt="' + safeName + '" style="width: 100%; height: 100%; object-fit: cover;">' : '<span style="font-size: 18px; color: #666;">' + initial + '</span>'}
                                                        </div>
                                                        <div style="flex: 1; min-width: 0;">
                                                            <strong style="font-size: 14px;">${safeName}</strong>
                                                            <span style="margin-left: 8px; padding: 2px 8px; background: #e3f2fd; color: #1976D2; border-radius: 12px; font-size: 11px; font-weight: 500;">${escapeHtml(role)}</span>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${route ? `
                                    <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                                        <h4 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #666;">Route</h4>
                                        <div style="font-size: 14px; color: #333;">
                                            <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                                            ${route.distance || route.elevation || route.estimatedTime ? `
                                                <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                    ${route.distance ? '<span>' + escapeHtml(route.distance) + '</span>' : ''}
                                                    ${route.distance && (route.elevation || route.estimatedTime) ? ' · ' : ''}
                                                    ${route.elevation ? '<span>' + escapeHtml(route.elevation) + '</span>' : ''}
                                                    ${route.elevation && route.estimatedTime ? ' · ' : ''}
                                                    ${route.estimatedTime ? '<span>' + escapeHtml(route.estimatedTime) + '</span>' : ''}
                                                </div>
                                            ` : ''}
                                            ${stravaUrl ? `
                                                <a href="${escapeHtml(stravaUrl)}" target="_blank" rel="noopener noreferrer" style="display: inline-block; margin-top: 6px; font-size: 12px; color: #FC4C02; text-decoration: none; font-weight: 500;">
                                                    View Full Map on Strava →
                                                </a>
                                            ` : ''}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });

                const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Assignments - ${escapeHtml(dateDisplay)}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            margin: 0;
            padding: 0;
        }
        .container {
            width: 100%;
            margin: 0;
            background: white;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 8px;
            color: #333;
        }
        h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #666;
        }
        .info-section {
            margin-bottom: 24px;
            padding: 16px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .goals-section {
            padding: 12px;
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
            margin-bottom: 24px;
        }
        .goals-section strong {
            display: block;
            margin-bottom: 4px;
            color: #1976D2;
        }
        .mobile-group-header {
            transition: background-color 0.2s;
        }
        .mobile-group-header:hover {
            background-color: #e8e8e8 !important;
        }
        .mobile-group-content {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tam High MTB Team</h1>
        <h2>Group Assignments</h2>
        
        <div class="info-section">
            <div style="margin-bottom: 6px;"><strong>Date:</strong> ${escapeHtml(dateDisplay)}</div>
            ${timeDisplay ? `<div style="margin-bottom: 6px;"><strong>Time:</strong> ${escapeHtml(timeDisplay)}</div>` : ''}
            ${practiceLocation ? `<div><strong>Location:</strong> ${escapeHtml(practiceLocation)}</div>` : ''}
        </div>
        
        ${goals ? `
            <div class="goals-section">
                <strong>Practice Goals:</strong>
                <span>${escapeHtml(goals)}</span>
            </div>
        ` : ''}
        
        <div class="mobile-assignment-groups">
            ${groupsHtmlWithCollapse}
        </div>
    </div>
    
    <script>
        function toggleMobileGroup(groupId) {
            const content = document.getElementById(groupId);
            const toggle = document.getElementById('toggle-' + groupId);
            
            if (!content || !toggle) return;
            
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            toggle.textContent = isHidden ? '▲' : '▼';
            toggle.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(180deg)';
        }
    <\/script>
</body>
</html>`;

                // Create blob and download
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const shortDate = formatShortDate(ride.date);
                const filename = `Groups for ${shortDate}.html`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating HTML export:', error);
                alert('Error generating HTML export. Please try again.');
            }
        }

        // Generate mobile-friendly PDF (existing format)
        function generateMobileFriendlyPDF(ride) {
            try {
                const { jsPDF } = window.jspdf;
                
                // Calculate exact height needed based on actual content
                // Count total riders and coaches across all groups
                let totalRiders = 0;
                let totalCoaches = 0;
                ride.groups.forEach(group => {
                    if (Array.isArray(group.riders)) {
                        totalRiders += group.riders.length;
                    }
                    // Count coaches (leader, sweep, roam, extraRoam)
                    if (group.coaches?.leader) totalCoaches++;
                    if (group.coaches?.sweep) totalCoaches++;
                    if (group.coaches?.roam) totalCoaches++;
                    if (Array.isArray(group.coaches?.extraRoam)) {
                        totalCoaches += group.coaches.extraRoam.length;
                    }
                });
                
                // Calculate height based on actual content with generous spacing:
                // - Header section: ~80mm (title, date, time, location, goals with wrapping)
                // - Per group header: ~10mm (with spacing)
                // - Per coach: ~6mm (with spacing)
                // - Per rider: ~6mm (with spacing)
                // - Per route: ~15mm (with spacing)
                // - Spacing between groups: ~12mm
                const headerHeight = 80;
                const groupHeadersHeight = ride.groups.length * 10;
                const coachesHeight = totalCoaches * 6;
                const ridersHeight = totalRiders * 6;
                const routesHeight = ride.groups.filter(g => g.routeId).length * 15;
                const groupSpacing = ride.groups.length * 12;
                
                const calculatedHeight = headerHeight + groupHeadersHeight + coachesHeight + ridersHeight + routesHeight + groupSpacing;
                // Add minimal 5% buffer and ensure minimum 400mm
                const customPageHeight = Math.max(calculatedHeight * 1.05, 400);
                
                // Use very tall custom format to avoid page breaks (single continuous page)
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: [90, customPageHeight] // Single continuous page - no page breaks
                });

                // Get ride information
                const rideDate = parseISODate(ride.date);
                const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                }) : ride.date;
                
                const practice = getPracticeSettingsForRide(ride);
                const practiceTime = ride.startTime || ride.time || (practice ? practice.time : '');
                const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
                const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
                const goals = (ride.goals || '').trim();

                // Format time display
                let timeDisplay = '';
                if (practiceTime) {
                    const formattedStart = formatTimeForDisplay(practiceTime);
                    if (practiceEndTime) {
                        const formattedEnd = formatTimeForDisplay(practiceEndTime);
                        timeDisplay = `${formattedStart} - ${formattedEnd}`;
                    } else {
                        timeDisplay = formattedStart;
                    }
                }

                // Set up page dimensions
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 8; // Smaller margin for mobile format
                const maxWidth = pageWidth - (margin * 2);
                let yPos = margin;

                // Header - smaller fonts for mobile
                doc.setFontSize(16);
                doc.setFont(undefined, 'bold');
                doc.text('Tam High MTB Team', margin, yPos);
                yPos += 6;

                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text('Group Assignments', margin, yPos);
                yPos += 7;

                // Ride information - smaller fonts for mobile
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`Date: ${dateDisplay}`, margin, yPos);
                yPos += 5;

                if (timeDisplay) {
                    doc.text(`Time: ${timeDisplay}`, margin, yPos);
                    yPos += 5;
                }

                if (practiceLocation) {
                    doc.text(`Location: ${practiceLocation}`, margin, yPos);
                    yPos += 5;
                }

                if (goals) {
                    yPos += 3;
                    doc.setFont(undefined, 'bold');
                    doc.text('Practice Goals:', margin, yPos);
                    yPos += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    const goalsLines = doc.splitTextToSize(goals, maxWidth);
                    doc.text(goalsLines, margin, yPos);
                    yPos += goalsLines.length * 5;
                    doc.setFontSize(10); // Reset font size
                }

                yPos += 5;

                // Sort groups sequentially
                const sortedGroups = [...ride.groups].sort((a, b) => {
                    const labelA = a.label || '';
                    const labelB = b.label || '';
                    const numA = parseInt(labelA.replace(/\D/g, '')) || 0;
                    const numB = parseInt(labelB.replace(/\D/g, '')) || 0;
                    return numA - numB;
                });

                // Create bookmarks for each group
                const bookmarks = [];

                // Add groups with bookmarks (no page breaks - single continuous page)
                sortedGroups.forEach((group, index) => {
                    // No page breaks - content flows continuously

                    const groupLabel = group.label || `Group ${index + 1}`;
                    
                    // Bookmark target (current position)
                    const bookmarkY = yPos;

                    // Group header - smaller for mobile
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(33, 150, 243); // Blue color
                    doc.text(groupLabel, margin, yPos);
                    yPos += 6;

                    // Get group details
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;

                    // Coaches section - smaller fonts for mobile
                    doc.setFontSize(9);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(0, 0, 0); // Black
                    doc.text('Ride Leaders:', margin, yPos);
                    yPos += 5;

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(11); // Larger font for coach names (larger than Date/Time/Location which is 10px)
                    const coachesList = [];
                    if (leader) coachesList.push(`${leader.name || 'Coach'} (Leader)`);
                    if (sweep) coachesList.push(`${sweep.name || 'Coach'} (Sweep)`);
                    if (roam) coachesList.push(`${roam.name || 'Coach'} (Roam)`);
                    extraRoam.forEach(coach => {
                        coachesList.push(`${coach.name || 'Coach'} (Roam+)`);
                    });

                    if (coachesList.length > 0) {
                        coachesList.forEach(coachText => {
                            doc.text(coachText, margin, yPos);
                            yPos += 5;
                        });
                    } else {
                        doc.text('No coaches assigned', margin, yPos);
                        yPos += 5;
                    }

                    yPos += 2;

                    // Riders section - render as list (similar to Ride Leaders)
                    doc.setFontSize(9);
                    doc.setFont(undefined, 'bold');
                    doc.text(`Riders (${riders.length}):`, margin, yPos);
                    yPos += 5;

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(11); // Larger font for rider names (larger than Date/Time/Location which is 10px)
                    if (riders.length > 0) {
                        // Render riders as a simple list (not a table) - similar to Ride Leaders
                        riders.forEach(rider => {
                            // No page breaks - content flows continuously
                            doc.text(`${rider.name || 'Rider'}`, margin, yPos);
                            yPos += 5;
                        });
                    } else {
                        doc.text('No riders assigned', margin, yPos);
                        yPos += 5;
                    }

                    // Route information with "View Route" button
                    if (route) {
                        yPos += 2;
                        doc.setFontSize(9);
                        doc.setFont(undefined, 'bold');
                        doc.text('Route:', margin, yPos);
                        yPos += 5;
                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(8);
                        
                        // Try to get Strava URL from stored field or extract from embed code
                        let stravaUrl = route.stravaUrl;
                        
                        // Debug: Log what we have
                        console.log('🔍 Extracting Strava URL for route:', {
                            routeId: route.id,
                            routeName: route.name,
                            hasStravaUrl: !!route.stravaUrl,
                            stravaUrlValue: route.stravaUrl,
                            hasEmbedCode: !!route.stravaEmbedCode,
                            embedCodeLength: route.stravaEmbedCode ? route.stravaEmbedCode.length : 0,
                            embedCodePreview: route.stravaEmbedCode ? route.stravaEmbedCode.substring(0, 300) : null
                        });
                        
                        if (!stravaUrl && route.stravaEmbedCode) {
                            // First try: Use the extractRouteUrlFromEmbed function if available
                            if (typeof extractRouteUrlFromEmbed === 'function') {
                                try {
                                    stravaUrl = extractRouteUrlFromEmbed(route.stravaEmbedCode);
                                    console.log('📋 extractRouteUrlFromEmbed returned:', stravaUrl);
                                    if (stravaUrl) {
                                        stravaUrl = stravaUrl.split('?')[0]; // Remove query parameters
                                    }
                                } catch (error) {
                                    console.error('Error calling extractRouteUrlFromEmbed:', error);
                                }
                            }
                            
                            // If still no URL, try inline extraction methods
                            if (!stravaUrl) {
                                // Method 1: Extract route ID from data-embed-id attribute (new Strava embed format)
                                const routeIdMatch = route.stravaEmbedCode.match(/data-embed-id\s*=\s*["']?(\d+)["']?/i);
                                if (routeIdMatch) {
                                    stravaUrl = `https://www.strava.com/routes/${routeIdMatch[1]}`;
                                    console.log('✅ Extracted route ID from data-embed-id:', routeIdMatch[1], '→', stravaUrl);
                                } else {
                                    // Method 2: Look for URL in iframe src (old format)
                                    const iframeSrcMatch = route.stravaEmbedCode.match(/src\s*=\s*["']([^"']*strava\.com[^"']*)["']/i);
                                    if (iframeSrcMatch) {
                                        stravaUrl = iframeSrcMatch[1].split('?')[0];
                                        console.log('✅ Extracted URL from iframe src:', stravaUrl);
                                    } else {
                                        // Method 3: Look for route ID patterns in any URL
                                        const routeIdPatterns = [
                                            /routes\/(\d+)/i,
                                            /route\/(\d+)/i,
                                            /\/r\/(\d+)/i
                                        ];
                                        for (const pattern of routeIdPatterns) {
                                            const match = route.stravaEmbedCode.match(pattern);
                                            if (match) {
                                                stravaUrl = `https://www.strava.com/routes/${match[1]}`;
                                                console.log('✅ Extracted route ID from pattern:', match[1], '→', stravaUrl);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        console.log('🎯 Final stravaUrl:', stravaUrl);
                        
                        // Display route name as clickable link (blue, underlined, same size as names)
                        const routeName = route.name || 'Unnamed Route';
                        
                        // Set font size to match rider/leader names (11px)
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'normal');
                        
                        // Wrap route name if it's too long
                        const routeNameLines = doc.splitTextToSize(routeName, maxWidth);
                        const initialYPos = yPos;
                        let maxRouteNameWidth = 0;
                        
                        // Calculate max width of all lines for link area
                        routeNameLines.forEach(line => {
                            const lineWidth = doc.getTextWidth(line);
                            maxRouteNameWidth = Math.max(maxRouteNameWidth, lineWidth);
                        });
                        
                        // Try using textWithLink if available (makes text itself clickable like normal hypertext)
                        if (stravaUrl && typeof doc.textWithLink === 'function') {
                            // Use textWithLink for proper hypertext behavior - text itself is clickable
                            // textWithLink requires a string, not an array, so handle each line separately
                            doc.setTextColor(0, 0, 255); // Blue color for links
                            let currentY = yPos;
                            
                            routeNameLines.forEach((line, lineIndex) => {
                                // textWithLink expects a string, not an array
                                doc.textWithLink(line, margin, currentY, { url: stravaUrl });
                                
                                // Draw underline for this line to indicate it's a link
                                const lineWidth = doc.getTextWidth(line);
                                const underlineY = currentY + 1.5; // Position underline below text baseline
                                doc.setDrawColor(0, 0, 255); // Blue underline
                                doc.setLineWidth(0.3);
                                doc.line(margin, underlineY, margin + lineWidth, underlineY);
                                
                                // Move to next line
                                currentY += doc.getFontSize() * 0.4;
                            });
                            
                            yPos = currentY;
                            
                            console.log('✅ Added Strava link using textWithLink (wrapped):', stravaUrl);
                        } else if (stravaUrl) {
                            // Fallback: Draw text in blue, add underline, then add link area covering entire text
                            doc.setTextColor(0, 0, 255); // Blue color for links
                            doc.text(routeNameLines, margin, yPos);
                            
                            // Draw underline for each line
                            routeNameLines.forEach((line, lineIndex) => {
                                const lineWidth = doc.getTextWidth(line);
                                const lineY = yPos + (lineIndex * (doc.getFontSize() * 0.4));
                                const underlineY = lineY + 1.5; // Position underline below text baseline
                                doc.setDrawColor(0, 0, 255); // Blue underline
                                doc.setLineWidth(0.3);
                                doc.line(margin, underlineY, margin + lineWidth, underlineY);
                            });
                            
                            // Add clickable link area covering the ENTIRE text block (all lines)
                            const fontSize = doc.getFontSize();
                            const lineHeight = fontSize * 0.4; // Line height in mm
                            const totalTextHeight = routeNameLines.length * lineHeight;
                            
                            // Convert yPos (from top) to bottom coordinates for link()
                            // yPos is the text baseline from top
                            const textBaselineFromBottom = pageHeight - yPos;
                            
                            // Position link to cover the entire text block
                            // Link y coordinate is from bottom, representing the bottom edge of the link
                            const linkBottom = textBaselineFromBottom - totalTextHeight - lineHeight * 0.3; // Bottom of link area
                            const linkHeight = totalTextHeight + lineHeight * 0.6; // Height to fully cover all lines and underlines
                            
                            yPos += totalTextHeight;
                            
                            try {
                                // Add link annotation covering the full text width and height
                                doc.link(margin, linkBottom, maxRouteNameWidth, linkHeight, { url: stravaUrl });
                                
                                console.log('✅ Added Strava link to route name (wrapped):', { 
                                    url: stravaUrl,
                                    x: margin, 
                                    y: linkBottom, 
                                    width: maxRouteNameWidth, 
                                    height: linkHeight,
                                    lines: routeNameLines.length
                                });
                            } catch (error) {
                                console.error('❌ Error adding link to PDF:', error, error.stack);
                            }
                        } else {
                            // No URL - just show route name in normal text (wrapped)
                            doc.setTextColor(0, 0, 0); // Black
                            doc.text(routeNameLines, margin, yPos);
                            yPos += routeNameLines.length * (doc.getFontSize() * 0.4);
                            console.warn('⚠️ No Strava URL found for route - route name shown but not clickable:', {
                                routeId: route.id,
                                routeName: route.name
                            });
                        }
                        
                        // Reset formatting
                        doc.setTextColor(0, 0, 0); // Reset to black
                        doc.setDrawColor(0, 0, 0); // Reset draw color
                        doc.setFontSize(8); // Reset to default size
                        
                        yPos += 6; // Space after route name
                        
                        // Reset formatting
                        doc.setTextColor(0, 0, 0); // Reset to black
                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(8);
                        
                        yPos += 7; // Space after button
                        
                        if (route.distance || route.elevation) {
                            const routeDetails = [];
                            if (route.distance) routeDetails.push(route.distance);
                            if (route.elevation) routeDetails.push(route.elevation);
                            doc.text(routeDetails.join(' / '), margin + 5, yPos);
                            yPos += 5;
                        }
                    }

                    yPos += 8;

                    // Add bookmark for this group
                    bookmarks.push({
                        title: groupLabel,
                        top: bookmarkY,
                        left: margin,
                        level: 0
                    });
                });

                // Add bookmarks/outline to PDF
                if (bookmarks.length > 0 && doc.outline) {
                    bookmarks.forEach(bookmark => {
                        doc.outline.add(null, bookmark.title, {
                            top: bookmark.top,
                            left: bookmark.left
                        });
                    });
                }

                // Footer removed per user request

                // Generate filename with short date format
                const shortDate = formatShortDate(ride.date);
                const filename = `Groups for ${shortDate}_mobile-friendly.pdf`;

                // Set PDF to open with 100% zoom level (instead of fit width)
                // This ensures the PDF opens at a readable size on computer viewers
                try {
                    // Use jsPDF's put method to modify the catalog directly
                    if (doc.internal && doc.internal.put) {
                        // Set OpenAction to zoom at 100% (XYZ view mode: x, y, zoom)
                        // Format: [page_num /XYZ left top zoom] where zoom=null means 100%
                        // We use /XYZ with null values to keep current position but set zoom to 100%
                        const pageWidth = doc.internal.pageSize.getWidth();
                        const pageHeight = doc.internal.pageSize.getHeight();
                        // Calculate zoom to show page at 100% (1.0 = 100%)
                        // For custom pages, we want the zoom to be reasonable
                        const zoom = 1.0; // 100% zoom
                        // Set OpenAction: [0 /XYZ null null 1.0] means page 0, current position, 100% zoom
                        doc.internal.put('/OpenAction', `[0 /XYZ null null ${zoom}]`);
                    }
                } catch (e) {
                    console.log('Note: PDF zoom setting may require manual viewer adjustment:', e);
                    // Continue with normal save - this is expected behavior
                }

                // Save the PDF
                doc.save(filename);

            } catch (error) {
                console.error('Error generating mobile-friendly PDF:', error);
                throw error;
            }
        }

        // Generate desktop/print-friendly PDF (letter-sized with boxes around groups)
        function generateDesktopPrintFriendlyPDF(ride) {
            try {
                const { jsPDF } = window.jspdf;
                
                // Use letter-sized paper (8.5" x 11" = 215.9mm x 279.4mm)
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'letter' // Standard US letter size
                });

                // Get ride information
                const rideDate = parseISODate(ride.date);
                const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric',
                    year: 'numeric'
                }) : ride.date;
                
                const practice = getPracticeSettingsForRide(ride);
                const practiceTime = ride.startTime || ride.time || (practice ? practice.time : '');
                const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
                const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
                const goals = (ride.goals || '').trim();

                // Format time display
                let timeDisplay = '';
                if (practiceTime) {
                    const formattedStart = formatTimeForDisplay(practiceTime);
                    if (practiceEndTime) {
                        const formattedEnd = formatTimeForDisplay(practiceEndTime);
                        timeDisplay = `${formattedStart} - ${formattedEnd}`;
                    } else {
                        timeDisplay = formattedStart;
                    }
                }

                // Set up page dimensions for letter size
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 10; // Reduced margin for more space
                const maxWidth = pageWidth - (margin * 2);
                let yPos = margin;

                // Header section - increased fonts for better readability
                doc.setFontSize(20);
                doc.setFont(undefined, 'bold');
                doc.text('Tam High MTB Team', margin, yPos);
                yPos += 7;

                doc.setFontSize(16);
                doc.setFont(undefined, 'bold');
                doc.text('Group Assignments', margin, yPos);
                yPos += 8;

                // Ride information - increased fonts for better readability
                doc.setFontSize(11);
                doc.setFont(undefined, 'normal');
                doc.text(`Date: ${dateDisplay}`, margin, yPos);
                yPos += 6;

                if (timeDisplay) {
                    doc.text(`Time: ${timeDisplay}`, margin, yPos);
                    yPos += 6;
                }

                if (practiceLocation) {
                    doc.text(`Location: ${practiceLocation}`, margin, yPos);
                    yPos += 6;
                }

                if (goals) {
                    yPos += 3;
                    doc.setFont(undefined, 'bold');
                    doc.text('Practice Goals:', margin, yPos);
                    yPos += 6;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(10);
                    const goalsLines = doc.splitTextToSize(goals, maxWidth);
                    doc.text(goalsLines, margin, yPos);
                    yPos += goalsLines.length * 4.5;
                    doc.setFontSize(11); // Reset font size
                }

                yPos += 4; // Space before groups

                // Sort groups sequentially
                const sortedGroups = [...ride.groups].sort((a, b) => {
                    const labelA = a.label || '';
                    const labelB = b.label || '';
                    const numA = parseInt(labelA.replace(/\D/g, '')) || 0;
                    const numB = parseInt(labelB.replace(/\D/g, '')) || 0;
                    return numA - numB;
                });

                // Calculate 3-column layout with tighter spacing
                const numColumns = 3;
                const columnGap = 3; // Reduced gap between columns
                const columnWidth = (maxWidth - (numColumns - 1) * columnGap) / numColumns;
                const rowGap = 4; // Gap between rows
                const startY = yPos;
                
                // First pass: Calculate heights for all groups
                const groupHeights = sortedGroups.map((group) => {
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;
                    
                    const coachesList = [];
                    if (leader) coachesList.push(`${leader.name || 'Coach'} (Leader)`);
                    if (sweep) coachesList.push(`${sweep.name || 'Coach'} (Sweep)`);
                    if (roam) coachesList.push(`${roam.name || 'Coach'} (Roam)`);
                    extraRoam.forEach(coach => {
                        coachesList.push(`${coach.name || 'Coach'} (Roam+)`);
                    });
                    
                    // Estimate height (with increased font sizes)
                    let height = 4; // Top padding (space above title)
                    height += 5; // Group header (title height)
                    height += 4; // "Ride Leaders:" label
                    height += coachesList.length * 4.5; // Coaches (increased line height)
                    height += 3; // Space before riders
                    height += 4; // "Riders:" label
                    height += riders.length * 4.5; // Riders (increased line height)
                    if (route) {
                        height += 3; // Space before route
                        height += 4; // "Route:" label
                        const routeName = route.name || 'Unnamed Route';
                        const routeNameLines = doc.splitTextToSize(routeName, columnWidth - 4);
                        height += routeNameLines.length * 4.5; // Route name lines (increased line height)
                    }
                    height += 4; // Bottom padding
                    
                    return { group, height };
                });
                
                // Organize groups into rows (3 per row, aligned at top)
                let currentY = startY;
                
                for (let rowIndex = 0; rowIndex < groupHeights.length; rowIndex += numColumns) {
                    const rowGroups = groupHeights.slice(rowIndex, rowIndex + numColumns);
                    // Add title height (5mm) to the max height since title is now above the box
                    const maxHeightInRow = Math.max(...rowGroups.map(g => g.height)) + 5;
                    
                    // Render all groups in this row (aligned at top)
                    rowGroups.forEach((groupData, colIndex) => {
                        const group = groupData.group;
                        const boxX = margin + colIndex * (columnWidth + columnGap);
                        
                        const groupLabel = group.label || `Group ${rowIndex + colIndex + 1}`;
                        
                        // Get group details
                        const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                        const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                        const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                        const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                            ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                            : [];
                        
                        const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                        const route = group.routeId ? getRouteById(group.routeId) : null;
                        
                        // Build coaches list
                        const coachesList = [];
                        if (leader) coachesList.push(`${leader.name || 'Coach'} (Leader)`);
                        if (sweep) coachesList.push(`${sweep.name || 'Coach'} (Sweep)`);
                        if (roam) coachesList.push(`${roam.name || 'Coach'} (Roam)`);
                        extraRoam.forEach(coach => {
                            coachesList.push(`${coach.name || 'Coach'} (Roam+)`);
                        });
                        
                        // Render group title first (above the box)
                        let contentY = currentY;
                        doc.setFontSize(12);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(33, 150, 243); // Blue color
                        doc.text(groupLabel, boxX + 2, contentY);
                        contentY += 5; // Space after title
                        
                        // Now draw box starting below the title
                        const boxY = contentY;
                        doc.setDrawColor(200, 200, 200); // Light gray border
                        doc.setLineWidth(0.3); // Thinner border
                        // Adjust box height to account for title being outside
                        const boxHeight = groupData.height - 4; // Subtract the top padding that was for title space
                        doc.rect(boxX, boxY, columnWidth, boxHeight);
                        
                        // Continue rendering content inside box
                        contentY = boxY + 3; // Padding inside box

                        // Coaches section (increased size)
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(0, 0, 0); // Black
                        doc.text('Ride Leaders:', boxX + 3, contentY);
                        contentY += 4.5;

                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(10);
                        if (coachesList.length > 0) {
                            coachesList.forEach(coachText => {
                                // Wrap text if needed for narrow columns
                                const wrappedLines = doc.splitTextToSize(coachText, columnWidth - 6);
                                doc.text(wrappedLines, boxX + 3, contentY);
                                contentY += wrappedLines.length * 4.5;
                            });
                        } else {
                            doc.text('No coaches assigned', boxX + 3, contentY);
                            contentY += 4.5;
                        }

                        contentY += 3;

                        // Riders section (increased size)
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.text(`Riders (${riders.length}):`, boxX + 3, contentY);
                        contentY += 4.5;

                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(10);
                        if (riders.length > 0) {
                            riders.forEach(rider => {
                                // Wrap text if needed for narrow columns
                                const wrappedLines = doc.splitTextToSize(`${rider.name || 'Rider'}`, columnWidth - 6);
                                doc.text(wrappedLines, boxX + 3, contentY);
                                contentY += wrappedLines.length * 4.5;
                            });
                        } else {
                            doc.text('No riders assigned', boxX + 3, contentY);
                            contentY += 4.5;
                        }

                        // Route information (increased size)
                        if (route) {
                            contentY += 3;
                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.text('Route:', boxX + 3, contentY);
                            contentY += 4.5;
                            doc.setFont(undefined, 'normal');
                            doc.setFontSize(10);
                        
                            const routeName = route.name || 'Unnamed Route';
                            
                            // Try to get Strava URL
                            let stravaUrl = route.stravaUrl;
                            if (!stravaUrl && route.stravaEmbedCode) {
                                if (typeof extractRouteUrlFromEmbed === 'function') {
                                    try {
                                        stravaUrl = extractRouteUrlFromEmbed(route.stravaEmbedCode);
                                        if (stravaUrl) {
                                            stravaUrl = stravaUrl.split('?')[0];
                                        }
                                    } catch (error) {
                                        console.error('Error calling extractRouteUrlFromEmbed:', error);
                                    }
                                }
                                
                                if (!stravaUrl) {
                                    const routeIdMatch = route.stravaEmbedCode.match(/data-embed-id\s*=\s*["']?(\d+)["']?/i);
                                    if (routeIdMatch) {
                                        stravaUrl = `https://www.strava.com/routes/${routeIdMatch[1]}`;
                                    } else {
                                        const iframeSrcMatch = route.stravaEmbedCode.match(/src\s*=\s*["']([^"']*strava\.com[^"']*)["']/i);
                                        if (iframeSrcMatch) {
                                            stravaUrl = iframeSrcMatch[1].split('?')[0];
                                        }
                                    }
                                }
                            }
                            
                            // Wrap route name if needed (for narrow columns)
                            const routeNameLines = doc.splitTextToSize(routeName, columnWidth - 6);
                            
                            if (stravaUrl && typeof doc.textWithLink === 'function') {
                                doc.setTextColor(0, 0, 255); // Blue color for links
                                let currentY = contentY;
                                routeNameLines.forEach((line) => {
                                    doc.textWithLink(line, boxX + 3, currentY, { url: stravaUrl });
                                    const lineWidth = doc.getTextWidth(line);
                                    const underlineY = currentY + 1.5;
                                    doc.setDrawColor(0, 0, 255);
                                    doc.setLineWidth(0.3);
                                    doc.line(boxX + 3, underlineY, boxX + 3 + lineWidth, underlineY);
                                    currentY += 4.5; // Increased line height
                                });
                                contentY = currentY;
                            } else if (stravaUrl) {
                                doc.setTextColor(0, 0, 255);
                                doc.text(routeNameLines, boxX + 3, contentY);
                                routeNameLines.forEach((line, lineIndex) => {
                                    const lineWidth = doc.getTextWidth(line);
                                    const lineY = contentY + (lineIndex * 4.5);
                                    const underlineY = lineY + 1.5;
                                    doc.setDrawColor(0, 0, 255);
                                    doc.setLineWidth(0.3);
                                    doc.line(boxX + 3, underlineY, boxX + 3 + lineWidth, underlineY);
                                });
                                contentY += routeNameLines.length * 4.5;
                                
                                // Add clickable link area
                                const lineHeight = 4.5;
                                const totalTextHeight = routeNameLines.length * lineHeight;
                                const textBaselineFromBottom = pageHeight - contentY;
                                const linkBottom = textBaselineFromBottom - totalTextHeight - lineHeight * 0.3;
                                const linkHeight = totalTextHeight + lineHeight * 0.6;
                                try {
                                    doc.link(boxX + 3, linkBottom, columnWidth - 6, linkHeight, { url: stravaUrl });
                                } catch (error) {
                                    console.error('Error adding link to PDF:', error);
                                }
                            } else {
                                doc.setTextColor(0, 0, 0);
                                doc.text(routeNameLines, boxX + 3, contentY);
                                contentY += routeNameLines.length * 4.5;
                            }
                            
                            doc.setTextColor(0, 0, 0);
                            doc.setDrawColor(0, 0, 0);
                        }
                    });
                    
                    // Move to next row based on tallest group in current row
                    currentY += maxHeightInRow + rowGap;
                }

                // Generate filename with short date format
                const shortDate = formatShortDate(ride.date);
                const filename = `Groups for ${shortDate}.pdf`;

                // Save the PDF
                doc.save(filename);

            } catch (error) {
                console.error('Error generating desktop/print-friendly PDF:', error);
                throw error;
            }
        }

        async function checkAndAutoUnpublish(ride) {
            if (!ride || !ride.publishedGroups) return false; // Only check if published
            
            // Get practice end time
            const practice = getPracticeSettingsForRide(ride);
            const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
            
            if (!practiceEndTime) return false; // Can't check without end time
            
            // Get ride date
            const rideDate = parseISODate(ride.date);
            if (!rideDate) return false;
            
            // Parse end time (format: "HH:MM" or "HH:MM:SS")
            const timeParts = practiceEndTime.split(':');
            if (timeParts.length < 2) return false;
            
            const endHour = parseInt(timeParts[0], 10);
            const endMinute = parseInt(timeParts[1], 10);
            
            if (!Number.isFinite(endHour) || !Number.isFinite(endMinute)) return false;
            
            // Create practice end datetime
            const practiceEndDateTime = new Date(rideDate);
            practiceEndDateTime.setHours(endHour, endMinute, 0, 0);
            
            // Add 12 hours to get the unpublish time
            const unpublishDateTime = new Date(practiceEndDateTime);
            unpublishDateTime.setHours(unpublishDateTime.getHours() + 12);
            
            // Check if current time is past the unpublish time
            const now = new Date();
            if (now >= unpublishDateTime) {
                // Auto-unpublish
                ride.publishedGroups = false;
                saveRideToDB(ride);
                
                // Also save to Supabase if available
                if (typeof updateRide === 'function') {
                    try {
                        await updateRide(ride.id, {
                            publishedGroups: false,
                            groups: ride.groups
                        });
                    } catch (error) {
                        console.warn('Could not save auto-unpublish to Supabase:', error);
                    }
                }
                
                return true; // Indicates unpublish happened
            }
            
            return false; // No unpublish needed
        }

        function updatePublishButtons() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            const publishBtn = document.getElementById('publish-groups-btn');
            const unpublishBtn = document.getElementById('unpublish-groups-btn');
            const notificationBtn = document.getElementById('send-notification-btn');
            const printBtn = document.getElementById('print-groups-btn');
            
            if (!publishBtn || !unpublishBtn || !notificationBtn || !printBtn) return;
            
            if (!ride) {
                publishBtn.style.display = 'none';
                unpublishBtn.style.display = 'none';
                notificationBtn.style.display = 'none';
                printBtn.style.display = 'none';
                return;
            }
            
            const hasGroups = Array.isArray(ride.groups) && ride.groups.length > 0;
            const isPublished = ride.publishedGroups === true;
            
            if (hasGroups) {
                // Print button shows whenever there are groups (published or not)
                printBtn.style.display = 'block';
                
                if (isPublished) {
                    publishBtn.style.display = 'none';
                    unpublishBtn.style.display = 'block';
                    notificationBtn.style.display = 'block';
                } else {
                    publishBtn.style.display = 'block';
                    unpublishBtn.style.display = 'none';
                    notificationBtn.style.display = 'none';
                }
            } else {
                publishBtn.style.display = 'none';
                unpublishBtn.style.display = 'none';
                notificationBtn.style.display = 'none';
                printBtn.style.display = 'none';
            }
        }

        async function sendSMSNotification(phoneNumber, message) {
            // Remove any non-digit characters from phone number
            const cleanPhone = phoneNumber.replace(/\D/g, '');
            
            // Format phone number for SMS (add +1 for US numbers if not present)
            let formattedPhone = cleanPhone;
            if (formattedPhone.length === 10) {
                formattedPhone = '+1' + formattedPhone;
            } else if (!formattedPhone.startsWith('+')) {
                formattedPhone = '+' + formattedPhone;
            }
            
            try {
                // Try to use Supabase Edge Function for SMS if available
                const client = getSupabaseClient();
                if (client) {
                    try {
                        const { error } = await client.functions.invoke('send-sms', {
                            body: {
                                to: formattedPhone,
                                message: message
                            }
                        });
                        
                        if (error) {
                            console.warn('SMS Edge Function not available or failed:', error);
                            // Fall through to alternative method
                        } else {
                            console.log('SMS sent via Edge Function');
                            return;
                        }
                    } catch (error) {
                        console.warn('SMS Edge Function not available:', error);
                        // Fall through to alternative method
                    }
                }
                
                // Alternative: Use a simple HTTP endpoint if available
                // This would need to be configured on your server
                // For now, we'll log it and the user can set up SMS service later
                console.log('SMS notification requested:', {
                    to: formattedPhone,
                    message: message
                });
                
                // If you have a server endpoint for SMS, uncomment and configure:
                /*
                const response = await fetch('/api/send-sms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        to: formattedPhone,
                        message: message
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to send SMS');
                }
                */
                
                // For now, we'll just log it - user can set up SMS service (Twilio, etc.) later
                console.warn('SMS service not configured. Please set up SMS service to send notifications.');
                
            } catch (error) {
                console.error('Error sending SMS:', error);
                // Don't throw - SMS failure shouldn't block publishing
            }
        }

        // Assignment rendering and drag-drop
        async function renderAssignments(ride) {
            const container = document.getElementById('assignments');
            if (!container) return;
            
            // Check and auto-unpublish if 12 hours have passed
            if (ride) {
                await checkAndAutoUnpublish(ride);
            }
            
            // Update publish/unpublish button visibility
            updatePublishButtons();
            
            // Update undo/redo button states
            updateUndoRedoButtons();

            const groupPaceOrder = getGroupPaceOrderForRide(ride);
            ride.groupPaceOrder = groupPaceOrder;
            const groupPaceSelect = document.getElementById('group-pace-order');
            if (groupPaceSelect) {
                groupPaceSelect.value = groupPaceOrder;
            }

            // Sort groups by fitness based on pace order setting
            ride.groups.sort(getGroupPaceComparator(ride));
            
            renumberGroups(ride);

            const coachAssignmentMap = getCoachAssignmentMap(ride);
            const assignedCoachIds = new Set(
                Object.keys(coachAssignmentMap)
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id))
            );

            const totalAssignedRiders = ride.groups.reduce((sum, group) => sum + group.riders.length, 0);
            const riderAssignmentMap = {};
            const groupLabelMap = {};
            ride.groups.forEach(group => {
                groupLabelMap[group.id] = group.label;
                group.riders.forEach(riderId => {
                    riderAssignmentMap[riderId] = group.id;
                });
            });
            
            // Get sort preference for unassigned riders (default to 'pace')
            const unassignedRidersSort = ride.unassignedRidersSort || 'pace';
            
            // For refined practices, use filtered riders instead of all availableRiders
            const isRefined = isRideRefined(ride);
            const ridersToCheck = isRefined ? getFilteredRiderIdsForRide(ride) : ride.availableRiders;
            
            const unassignedRiders = data.riders
                .filter(rider => !riderAssignmentMap[rider.id])
                .map(rider => {
                    const isAvailable = ridersToCheck.includes(rider.id);
                    return {
                        rider,
                        isAvailable,
                        fitness: (() => {
                            const fitnessScale = getFitnessScale();
                            return Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
                        })(),
                        skills: (() => {
                            const skillsScale = getSkillsScale();
                            return Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
                        })(),
                        grade: parseInt(rider.grade || '0', 10) || 0,
                        gender: (rider.gender || 'M').toUpperCase(),
                        lastName: getSortableLastName(rider.name || ''),
                        name: (rider.name || '').toLowerCase()
                    };
                }).sort((a, b) => {
                    if (a.isAvailable !== b.isAvailable) return a.isAvailable ? -1 : 1;
                    
                    if (unassignedRidersSort === 'pace') {
                        const aPace = getRelativePaceValue(a.fitness);
                        const bPace = getRelativePaceValue(b.fitness);
                        if (bPace !== aPace) return bPace - aPace;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'skills') {
                        if (b.skills !== a.skills) return b.skills - a.skills;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'grade') {
                        if (b.grade !== a.grade) return b.grade - a.grade;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'gender') {
                        if (a.gender !== b.gender) return a.gender.localeCompare(b.gender);
                        return a.lastName.localeCompare(b.lastName);
                    } else { // name
                        return a.lastName.localeCompare(b.lastName) || a.name.localeCompare(b.name);
                    }
                });

            const riderCardsHtml = unassignedRiders
                .map(({ rider, isAvailable }) => renderRiderCardHtml(rider, {
                    draggable: true,
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel: isAvailable ? '' : 'Unavailable',
                    checkboxHandler: `toggleRiderAvailability(${rider.id})`,
                    compact: true,
                    sortBy: unassignedRidersSort
                }))
                .join('');

            // Get sort preference for unassigned coaches (default to 'pace')
            const unassignedCoachesSort = ride.unassignedCoachesSort || 'pace';
            
            const unassignedCoaches = data.coaches
                .filter(coach => !coachAssignmentMap[coach.id])
                .map(coach => {
                const isAvailable = ride.availableCoaches.includes(coach.id);
                const fitness = getCoachFitnessValue(coach);
                const level = parseInt(coach.level || '1', 10);
                return {
                    coach,
                    isAvailable,
                    fitness,
                    level,
                    lastName: getSortableLastName(coach.name || ''),
                    name: (coach.name || '').toLowerCase()
                };
            }).sort((a, b) => {
                if (a.isAvailable !== b.isAvailable) return a.isAvailable ? -1 : 1;
                
                if (unassignedCoachesSort === 'pace') {
                    const fitnessDiff = b.fitness - a.fitness;
                    if (fitnessDiff !== 0) return fitnessDiff;
                    return a.lastName.localeCompare(b.lastName);
                } else if (unassignedCoachesSort === 'level') {
                    const levelDiff = b.level - a.level;
                    if (levelDiff !== 0) return levelDiff;
                    return a.lastName.localeCompare(b.lastName);
                } else { // name
                    return a.lastName.localeCompare(b.lastName) || a.name.localeCompare(b.name);
                }
            });

            const coachCardsHtml = unassignedCoaches
                .map(({ coach, isAvailable }) => renderCoachCardHtml(coach, null, 'unassigned', {
                    draggable: true,
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel: isAvailable ? '' : 'Unavailable',
                    checkboxHandler: `toggleCoachAvailability(${coach.id}, event.target.checked)`,
                    compact: true,
                    sortBy: unassignedCoachesSort
                }))
                .join('');

            const renderGroupCard = (group) => {
                const coachCount = countGroupCoaches(group);
                const capacity = groupCapacity(group);
                const warnings = [];

                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                if (!group.coaches.leader) {
                    warnings.push(`Assign a leader (Level ${minLeaderLevel}+)`);
                } else {
                    const leader = getCoachById(group.coaches.leader);
                    const leaderLevel = leader ? parseInt(leader.coachingLicenseLevel || leader.level || '1', 10) : 0;
                    if (!Number.isFinite(leaderLevel) || leaderLevel < minLeaderLevel) {
                        warnings.push(`Leader must be Level ${minLeaderLevel}+`);
                    }
                }

                if (coachCount === 0) {
                    warnings.push('Add at least one coach to this group');
                }

                if (coachCount > 0 && group.riders.length > capacity) {
                    warnings.push('Group is over capacity');
                }

                const riderFitnesses = group.riders
                    .map(id => getRiderById(id))
                    .filter(Boolean)
                    .map(r => String(Math.max(1, Math.min(10, parseInt(r.fitness || '5', 10)))));

                if (riderFitnesses.length === 0) {
                    group.fitnessTag = null;
                } else {
                    const uniqueFitnesses = Array.from(new Set(riderFitnesses));
                    if (uniqueFitnesses.length === 1) {
                        group.fitnessTag = uniqueFitnesses[0];
                    } else if (!group.fitnessTag) {
                        group.fitnessTag = uniqueFitnesses[0];
                    }
                }

                // Get sort preference for this group (default to 'pace')
                const sortBy = group.sortBy || 'pace';
                
                const riderObjects = group.riders
                    .map(id => getRiderById(id))
                    .filter(Boolean)
                    .sort((a, b) => {
                        if (sortBy === 'pace') {
                            const aPace = getRelativePaceValue(parseInt(a.fitness || '5', 10));
                            const bPace = getRelativePaceValue(parseInt(b.fitness || '5', 10));
                            if (bPace !== aPace) return bPace - aPace; // Descending (fastest first)
                            // If pace is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'skills') {
                            const aSkills = parseInt(a.skills || '2', 10);
                            const bSkills = parseInt(b.skills || '2', 10);
                            if (bSkills !== aSkills) return bSkills - aSkills; // Descending (higher skills first)
                            // If skills is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'grade') {
                            const aGrade = parseInt(a.grade || '0', 10) || 0;
                            const bGrade = parseInt(b.grade || '0', 10) || 0;
                            if (bGrade !== aGrade) return bGrade - aGrade; // Descending (higher grade first)
                            // If grade is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'gender') {
                            const aGender = (a.gender || 'M').toUpperCase();
                            const bGender = (b.gender || 'M').toUpperCase();
                            if (aGender !== bGender) return aGender.localeCompare(bGender);
                            // If gender is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'firstName') {
                            const aFirstName = (a.firstName || a.name || '').toLowerCase();
                            const bFirstName = (b.firstName || b.name || '').toLowerCase();
                            if (aFirstName !== bFirstName) return aFirstName.localeCompare(bFirstName);
                            // If first name is equal, sort by last name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'lastName') {
                            const aLastName = getSortableLastName(a.name || '');
                            const bLastName = getSortableLastName(b.name || '');
                            if (aLastName !== bLastName) return aLastName.localeCompare(bLastName);
                            // If last name is equal, sort by first name
                            const aFirstName = (a.firstName || a.name || '').toLowerCase();
                            const bFirstName = (b.firstName || b.name || '').toLowerCase();
                            return aFirstName.localeCompare(bFirstName);
                        } else { // name (default)
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || '')) || (a.name || '').localeCompare(b.name || '');
                        }
                    });

                // Get groups sorted by fitness to determine if we can move up/down
                const sortedGroups = ride.groups.slice().sort(getGroupPaceComparator(ride));
                const currentGroupIndex = sortedGroups.findIndex(g => g.id === group.id);
                const canMoveUp = currentGroupIndex > 0;
                const canMoveDown = currentGroupIndex >= 0 && currentGroupIndex < sortedGroups.length - 1;

                // Filter to get only attending riders for count (normalize IDs for comparison)
                const normalizedAvailableRiderIds = new Set(ride.availableRiders.map(id => {
                    const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                    return Number.isFinite(normalized) ? normalized : id;
                }));
                
                const attendingRiders = riderObjects.filter(rider => {
                    const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                    const normalizedId = Number.isFinite(riderId) ? riderId : rider.id;
                    return normalizedAvailableRiderIds.has(normalizedId);
                });
                const attendingCount = attendingRiders.length;
                const totalAssigned = riderObjects.length;

                const ridersHtml = riderObjects
                    .map((rider, index) => {
                        // Normalize IDs for consistent comparison
                        const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                        const normalizedId = Number.isFinite(riderId) ? riderId : rider.id;
                        const isAvailable = normalizedAvailableRiderIds.has(normalizedId);
                        
                        return renderRiderCardHtml(rider, {
                            draggable: isAvailable, // Only draggable if available
                            showAttendance: true,
                            isAvailable,
                            assignmentLabel: '', // No label in groups
                            checkboxHandler: null, // Using event delegation instead
                            compact: true,
                            showMoveControls: false, // Removed - dragging works better
                            groupId: group.id,
                            canMoveUp: canMoveUp,
                            canMoveDown: canMoveDown,
                            sortBy: sortBy,
                            inGroup: true, // Flag to indicate we're in a group context
                            showUnavailableStyle: !isAvailable // Show unavailable styling
                        });
                    })
                    .join('') || '<div class="empty-message">No riders assigned</div>';

                const warningsHtml = warnings.length ? `<div class="warning-text">${warnings.join(' • ')}</div>` : '';
                
                // Get coach names for header
                const coachNames = getCoachFirstNames(group);
                
                // Get route name for header
                const route = group.routeId ? getRouteById(group.routeId) : null;
                const routeName = route ? escapeHtml(route.name || 'Unnamed Route') : '';
                
                // Check if group is compliant
                const isCompliant = checkGroupCompliance(group);
                const headerColor = isCompliant ? '#2196F3' : '#d32f2f'; // Blue if compliant, red if not
                
                // Get validation warnings to show in header if non-compliant
                const validationWarnings = validateGroupRequirements(group, ride);
                const headerWarning = !isCompliant && validationWarnings.length > 0 
                    ? ` - ${validationWarnings[0]}` 
                    : '';
                
                // If group has red header, make the entire group border red too
                const groupBorderColor = isCompliant ? '#ddd' : '#d32f2f';
                const groupBorderWidth = isCompliant ? '1px' : '2px';
                
                return `
                    <div class="coach-group" style="border: ${groupBorderWidth} solid ${groupBorderColor}; border-radius: 8px; background: ${isCompliant ? 'white' : '#ffebee'}; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 0; margin: 0; overflow: hidden;">
                        <div class="coach-group-header" style="background-color: ${headerColor}; color: white; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; border: none !important;">
                            <span style="font-weight: 600; font-size: 16px; color: white;">${group.label}${headerWarning}</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <select class="group-sort-select" onchange="changeGroupSort(${group.id}, this.value)" title="Sort by" style="padding: 4px 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; font-size: 13px; background: rgba(255,255,255,0.2); color: white; cursor: pointer;">
                                    <option value="pace" ${sortBy === 'pace' ? 'selected' : ''} style="background: #2196F3; color: white;">Sort by: Pace</option>
                                    <option value="skills" ${sortBy === 'skills' ? 'selected' : ''} style="background: #2196F3; color: white;">Sort by: Bike Skills</option>
                                    <option value="grade" ${sortBy === 'grade' ? 'selected' : ''} style="background: #2196F3; color: white;">Sort by: Grade</option>
                                    <option value="gender" ${sortBy === 'gender' ? 'selected' : ''} style="background: #2196F3; color: white;">Sort by: Gender</option>
                                    <option value="name" ${sortBy === 'name' ? 'selected' : ''} style="background: #2196F3; color: white;">Sort by: Name</option>
                                </select>
                                <button class="danger btn-small" onclick="deleteGroup(${group.id})" style="background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); color: white;">Remove</button>
                            </div>
                        </div>
                        <div style="padding: 16px;">
                        <div class="group-body" style="display: flex; flex-direction: column; border: none !important; border-style: none !important;">
                            <!-- Coaches Section -->
                            <div style="margin-bottom: 12px;">
                                <div onclick="toggleGroupSection('coaches')" style="cursor: pointer; padding: 8px 12px; background: #f5f5f5; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; user-select: none;">
                                    <span style="font-weight: 600; font-size: 14px; color: #333;">Coaches${coachNames ? `: ${coachNames}` : ''}</span>
                                    <span style="font-size: 12px; color: #666;">${groupSectionsState.coaches ? '▼' : '▶'}</span>
                                </div>
                                <div class="group-coaches" 
                                     data-group-id="${group.id}"
                                     data-section="coaches"
                                     style="width: 100%; margin-top: 8px; min-height: 40px; ${groupSectionsState.coaches ? '' : 'display: none;'}">
                                    ${renderGroupCoachesInline(group, ride)}
                                </div>
                            </div>
                            
                            <!-- Riders Section -->
                            <div style="margin-bottom: 12px;">
                                <div onclick="toggleGroupSection('riders')" style="cursor: pointer; padding: 8px 12px; background: #f5f5f5; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; user-select: none;">
                                    <span style="font-weight: 600; font-size: 14px; color: #333;">Riders (${attendingCount}${totalAssigned > attendingCount ? `/${totalAssigned}` : ''}): ${getRiderFitnessRange(group)}</span>
                                    <span style="font-size: 12px; color: #666;">${groupSectionsState.riders ? '▼' : '▶'}</span>
                                </div>
                                <div class="group-riders"
                                     data-drop-type="rider"
                                     data-group-id="${group.id}"
                                     data-section="riders"
                                     ondrop="drop(event)"
                                     ondragover="allowDrop(event)"
                                     ondragleave="dragLeave(event)"
                                     style="width: 100%; margin-top: 8px; ${groupSectionsState.riders ? '' : 'display: none;'}">
                                    ${ridersHtml}
                                </div>
                            </div>
                        </div>
                        
                        <!-- Route Section -->
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
                            <div onclick="toggleGroupSection('route')" style="cursor: pointer; padding: 8px 12px; background: #f5f5f5; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; user-select: none; margin-bottom: 8px;">
                                <span style="font-weight: 600; font-size: 14px; color: #333;">Route${routeName ? `: ${routeName}` : ''}</span>
                                <span style="font-size: 12px; color: #666;">${groupSectionsState.route ? '▼' : '▶'}</span>
                            </div>
                            <div data-section="route" style="${groupSectionsState.route ? '' : 'display: none;'}">
                                <select onchange="updateGroupRoute(${group.id}, this.value)" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    <option value="">-- Select Route --</option>
                                    ${renderRouteOptions(group.routeId, group, ride)}
                                </select>
                                ${group.routeId ? `<div class="route-preview-container" data-route-id="${group.routeId}" style="margin-top: 12px; width: 100%; border: 1px solid #e0e0e0; border-radius: 4px; overflow: hidden;"></div>` : ''}
                            </div>
                        </div>
                        ${warningsHtml}
                        </div>
                    </div>
                `;
            };

            const groupsHtml = ride.groups.length
                ? ride.groups.slice().sort((a, b) => {
                    // Extract numeric value from group label (e.g., "Group 1" -> 1)
                    const getGroupNumber = (group) => {
                        const label = group.label || `Group ${group.id}`;
                        const match = label.match(/\d+/);
                        return match ? parseInt(match[0], 10) : group.id;
                    };
                    return getGroupNumber(a) - getGroupNumber(b);
                }).map(renderGroupCard).join('')
                : renderEmptyGroupCard();

            // Render unassigned attendees (available but not assigned)
            let newAttendeesHtml = '';
            const assignedRiderIds = new Set(Object.keys(riderAssignmentMap).map(id => parseInt(id, 10)).filter(id => Number.isFinite(id)));
            const availableCoachIds = new Set((ride.availableCoaches || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => Number.isFinite(id)));
            
            // For refined practices, use filtered riders instead of all availableRiders
            const isRefinedForUnassigned = isRideRefined(ride);
            const ridersToCheckForUnassigned = isRefinedForUnassigned ? getFilteredRiderIdsForRide(ride) : (ride.availableRiders || []);
            const availableRiderIds = new Set(ridersToCheckForUnassigned.map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => Number.isFinite(id)));
            
            const unassignedAvailableCoaches = (data.coaches || [])
                .filter(coach => {
                    const coachId = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                    return Number.isFinite(coachId) && availableCoachIds.has(coachId);
                })
                .filter(coach => {
                    const coachId = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                    return Number.isFinite(coachId) && !assignedCoachIds.has(coachId);
                })
                .filter(coach => {
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    const levelVal = String(levelRaw).toUpperCase();
                    return levelVal !== 'N/A' && levelVal !== 'NA' && levelVal !== 'NULL' && levelVal !== 'UNDEFINED';
                });
            const unassignedAvailableRiders = (data.riders || [])
                .filter(rider => {
                    const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                    return Number.isFinite(riderId) && availableRiderIds.has(riderId);
                })
                .filter(rider => {
                    const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                    return Number.isFinite(riderId) && !assignedRiderIds.has(riderId);
                });
            
            const hasUnassigned = unassignedAvailableCoaches.length > 0 || unassignedAvailableRiders.length > 0;
            const shouldShowUnassignedPalette = ride.groups.length > 0 && (
                unassignedPaletteVisibility === 'show' ||
                (unassignedPaletteVisibility !== 'hide' && hasUnassigned)
            );
            if (shouldShowUnassignedPalette) {
                const coachesHtml = unassignedAvailableCoaches.map(coach => 
                    renderCoachCardHtml(coach, null, 'unassigned', {
                        draggable: true,
                        showAttendance: true,
                        isAvailable: true,
                        compact: true
                    })
                ).join('');
                
                const ridersHtml = unassignedAvailableRiders.map(rider => 
                    renderRiderCardHtml(rider, {
                        draggable: true,
                        showAttendance: true,
                        isAvailable: true,
                        compact: true,
                        noPhoto: false // Show photos to match coach styling
                    })
                ).join('');
                
                newAttendeesHtml = `
                    <div id="new-attendees-sticky" style="margin-bottom: 20px; padding: 16px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; position: sticky; top: 0; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #856404;">Unassigned Attendees - Drag to Assign</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div>
                                <strong style="display: block; margin-bottom: 8px; color: #856404;">Riders (${unassignedAvailableRiders.length})</strong>
                                <div class="rider-drop-list" data-drop-type="rider" data-group-id="unassigned" data-unassigned-list="true" ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)" style="min-height: 100px; height: ${unassignedPaletteHeight}px; max-height: ${unassignedPaletteHeight}px; overflow-y: auto; padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                    ${ridersHtml || '<div class="empty-message">No unassigned riders</div>'}
                                </div>
                            </div>
                            <div>
                                <strong style="display: block; margin-bottom: 8px; color: #856404;">Coaches (${unassignedAvailableCoaches.length})</strong>
                                <div class="rider-drop-list" data-drop-type="coach" data-group-id="unassigned" data-unassigned-list="true" ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)" style="min-height: 100px; height: ${unassignedPaletteHeight}px; max-height: ${unassignedPaletteHeight}px; overflow-y: auto; padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                    ${coachesHtml || '<div class="empty-message">No unassigned coaches</div>'}
                                </div>
                            </div>
                        </div>
                        <div class="unassigned-resize-handle" onmousedown="startUnassignedPaletteResize(event)" style="margin-top: 10px; height: 8px; cursor: ns-resize; background: #ffe8a1; border-radius: 4px;"></div>
                    </div>
                `;
            }
            
            // Add "Clone Entire Practice" button at bottom if no groups assigned
            const cloneButtonHtml = ride.groups.length === 0
                ? `<div style="grid-column: 1 / -1; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; text-align: center;">
                    <button class="btn-small" onclick="openClonePracticeModal()" style="padding: 12px 24px; font-size: 16px; font-weight: 600;">
                        Clone Entire Practice
                    </button>
                </div>`
                : '';
            
            const centerColumnHtml = `
                ${newAttendeesHtml}
                <div class="assignment-column groups-column" style="width: 100%; display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 16px; max-width: 100%; padding: 0; border: none;">
                    ${groupsHtml}
                    ${cloneButtonHtml}
                </div>
            `;

            container.innerHTML = centerColumnHtml;
            updateUnassignedPaletteToggleButton(shouldShowUnassignedPalette);
            updateDebugOutput();
            
            // Add event delegation for checkboxes in group riders containers
            // This allows checkboxes in groups to toggle rider availability
            // Use a single delegated listener on the assignments container for better performance
            const assignmentsContainer = document.getElementById('assignments');
            if (assignmentsContainer) {
                // Remove any existing listener by cloning (but keep content)
                const existingHandler = assignmentsContainer._groupCheckboxHandler;
                if (existingHandler) {
                    assignmentsContainer.removeEventListener('click', existingHandler);
                }
                
                // Create new handler function
                const groupCheckboxHandler = function handleGroupCheckboxClick(e) {
                    // Handle clicks on checkboxes (both riders and coaches) within group containers
                    if (e.target.type !== 'checkbox' || !e.target.classList.contains('attendance-checkbox-input')) {
                        return;
                    }
                    
                    const attendanceType = e.target.dataset.attendanceType;
                    if (attendanceType !== 'rider' && attendanceType !== 'coach') {
                        return;
                    }
                    
                    // Check if the checkbox is inside a group container (.group-riders or .group-coaches)
                    const groupRidersContainer = e.target.closest('.group-riders');
                    const groupCoachesContainer = e.target.closest('.group-coaches');
                    const coachInlineItem = e.target.closest('.coach-inline-item');
                    
                    if (attendanceType === 'rider' && groupRidersContainer) {
                        // Handle rider checkbox in group
                        console.log('🔵 Group rider checkbox clicked:', {
                            riderId: e.target.dataset.riderId,
                            checked: e.target.checked,
                            groupId: groupRidersContainer.getAttribute('data-group-id')
                        });
                        
                        setTimeout(() => {
                            const riderId = parseInt(e.target.dataset.riderId, 10);
                            const isAvailable = e.target.checked;
                            
                            if (Number.isFinite(riderId)) {
                                console.log('🔵 Calling toggleRiderAvailability from group checkbox:', { riderId, isAvailable });
                                toggleRiderAvailability(riderId, isAvailable);
                            } else {
                                console.error('🔴 Invalid riderId in group checkbox:', e.target.dataset.riderId);
                            }
                        }, 0);
                    } else if (attendanceType === 'coach' && (groupCoachesContainer || coachInlineItem)) {
                        // Handle coach checkbox in group
                        const groupId = groupCoachesContainer 
                            ? groupCoachesContainer.getAttribute('data-group-id')
                            : (coachInlineItem ? coachInlineItem.getAttribute('data-group-id') : null);
                        
                        console.log('🔵 Group coach checkbox clicked:', {
                            coachId: e.target.dataset.coachId,
                            checked: e.target.checked,
                            groupId: groupId
                        });
                        
                        setTimeout(() => {
                            const coachId = parseInt(e.target.dataset.coachId, 10);
                            const isAvailable = e.target.checked;
                            
                            if (Number.isFinite(coachId)) {
                                console.log('🔵 Calling toggleCoachAvailability from group checkbox:', { coachId, isAvailable });
                                toggleCoachAvailability(coachId, isAvailable);
                            } else {
                                console.error('🔴 Invalid coachId in group checkbox:', e.target.dataset.coachId);
                            }
                        }, 0);
                    } else {
                        // Not in a group container, let attendance list handler deal with it
                        return;
                    }
                };
                
                // Store reference to handler for future removal
                assignmentsContainer._groupCheckboxHandler = groupCheckboxHandler;
                assignmentsContainer.addEventListener('click', groupCheckboxHandler);
                console.log('🔵 Attached event delegation listener to assignments container for group checkboxes');
            }
            
            // Allow clicking names in assignment cards to toggle attendance checkboxes
            if (assignmentsContainer) {
                const existingNameHandler = assignmentsContainer._attendanceNameHandler;
                if (existingNameHandler) {
                    assignmentsContainer.removeEventListener('click', existingNameHandler);
                }
                
                const attendanceNameHandler = function handleAssignmentNameClick(e) {
                    const nameTarget = e.target.closest('.attendance-name');
                    if (!nameTarget) return;
                    
                    const card = nameTarget.closest('.rider-card, .coach-card');
                    const checkbox = card ? card.querySelector('.attendance-checkbox-input') : null;
                    if (!checkbox) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    checkbox.click();
                };
                
                assignmentsContainer._attendanceNameHandler = attendanceNameHandler;
                assignmentsContainer.addEventListener('click', attendanceNameHandler);
            }
            
            // Update route previews after rendering
            updateRoutePreviews();
            
            // Re-render practice attendance lists if open to show updated assignments
            const attendanceContent = document.getElementById('practice-attendance-content');
            if (attendanceContent && attendanceContent.style.display !== 'none') {
                renderPracticeAttendanceLists();
            }
        }

        function updatePracticeGoals() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const goalsInput = document.getElementById('practice-goals');
            if (goalsInput) {
                ride.goals = goalsInput.value.trim();
                saveRideToDB(ride);
            }
        }
        
        function togglePracticeAttendance() {
            console.log('🟣 togglePracticeAttendance called');
            const content = document.getElementById('practice-attendance-content');
            const arrow = document.getElementById('practice-attendance-arrow');
            if (!content || !arrow) {
                console.error('❌ Content or arrow not found');
                return;
            }
            
            const isVisible = content.style.display !== 'none';
            const ride = data.rides.find(r => r.id === data.currentRide);
            console.log('🟣 Toggling attendance:', {
                isVisible,
                willBeVisible: !isVisible,
                rideId: ride?.id,
                availableCoachesBefore: ride ? [...ride.availableCoaches] : null
            });
            
            content.style.display = isVisible ? 'none' : 'block';
            arrow.textContent = isVisible ? '▼' : '▲';
            
            // Always render lists when opening to ensure they're up to date
            if (!isVisible) {
                console.log('🟣 Rendering lists after expand');
                renderPracticeAttendanceLists();
                if (ride) {
                    console.log('🟣 After render, availableCoaches:', ride.availableCoaches);
                }
            } else {
                console.log('🟣 Collapsed - not rendering lists');
                if (ride) {
                    console.log('🟣 After collapse, availableCoaches:', ride.availableCoaches);
                }
            }
        }
        
        function ensureRideAttendanceDefaults(ride) {
            if (!ride) return;
            
            const hasArray = Array.isArray(ride.availableRiders);
            const hasValues = hasArray && ride.availableRiders.length > 0;
            const isInitialized = ride.attendanceInitialized === true;
            
            if (hasValues) {
                ride.attendanceInitialized = true;
                return;
            }
            
            if (isInitialized && hasArray) {
                return;
            }
            
            const isRefined = isRideRefined(ride);
            let defaultAvailableRiders = [];
            if (isRefined) {
                defaultAvailableRiders = getFilteredRiderIdsForRide(ride);
            } else {
                defaultAvailableRiders = (data.riders || []).map(r => r.id);
            }
            
            ride.availableRiders = defaultAvailableRiders;
            ride.attendanceInitialized = true;
            saveRideToDB(ride);
        }
        
        function renderPracticeAttendanceLists() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                console.error('❌ No ride found in renderPracticeAttendanceLists');
                return;
            }
            
            console.log('🔵 renderPracticeAttendanceLists: Starting for ride ID:', ride.id);
            console.log('🔵 renderPracticeAttendanceLists: ride.availableRiders BEFORE initialization:', {
                isArray: Array.isArray(ride.availableRiders),
                length: ride.availableRiders?.length,
                value: ride.availableRiders,
                first10: ride.availableRiders?.slice(0, 10)
            });
            
            // Ensure default attendance is set (all riders for regular practices, filtered for refined)
            const isRefined = isRideRefined(ride);
            ensureRideAttendanceDefaults(ride);
            
            console.log('🔵 renderPracticeAttendanceLists: ride.availableRiders BEFORE normalization:', {
                length: ride.availableRiders.length,
                first10: ride.availableRiders.slice(0, 10),
                types: ride.availableRiders.slice(0, 10).map(id => typeof id)
            });
            
            // Normalize availableRiders IDs for consistency
            ride.availableRiders = ride.availableRiders.map(id => {
                const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                return Number.isFinite(normalized) ? normalized : id;
            });
            
            console.log('🔵 renderPracticeAttendanceLists: ride.availableRiders AFTER normalization:', {
                length: ride.availableRiders.length,
                first10: ride.availableRiders.slice(0, 10),
                types: ride.availableRiders.slice(0, 10).map(id => typeof id)
            });
            if (!Array.isArray(ride.availableCoaches)) {
                ride.availableCoaches = []; // No coaches available by default
            } else {
                const validCoachIds = new Set((data.coaches || []).map(coach => {
                    const id = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                    return Number.isFinite(id) ? id : coach.id;
                }));
                const hasRoster = validCoachIds.size > 0;
                // Normalize IDs to numbers for consistent comparison
                ride.availableCoaches = ride.availableCoaches
                    .map(id => typeof id === 'string' ? parseInt(id, 10) : id)
                    .filter(id => Number.isFinite(id) && (!hasRoster || validCoachIds.has(id)));
                ride.availableCoaches = Array.from(new Set(ride.availableCoaches)); // Deduplicate
            }
            
            // Build rider assignment map
            const riderAssignmentMap = {};
            const groupLabelMap = {};
            ride.groups.forEach(group => {
                groupLabelMap[group.id] = group.label;
                group.riders.forEach(riderId => {
                    riderAssignmentMap[riderId] = group.id;
                });
            });
            
            // Build coach assignment map
            const coachAssignmentMap = getCoachAssignmentMap(ride);
            
            // Get sort preferences
            const ridersSort = ride.practiceRidersSort || 'pace';
            const coachesSort = ride.practiceCoachesSort || 'pace';
            const ridersSortDirection = ride.practiceRidersSortDirection || 'asc';
            const coachesSortDirection = ride.practiceCoachesSortDirection || 'asc';
            
            // Process and sort riders (show all riders)
            // Normalize availableRiders IDs for comparison
            const normalizedAvailableRiderIds = new Set(ride.availableRiders.map(id => {
                const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                return Number.isFinite(normalized) ? normalized : id;
            }));
            
            // FINAL STEP: For refined practices, filter to only show qualifying riders
            let ridersToShow = data.riders || [];
            if (isRefined) {
                const practice = getPracticeForRide(ride);
                if (practice) {
                    const filteredRiders = getFilteredRidersForPractice(practice);
                    // Normalize IDs for consistent comparison
                    const qualifyingRiderIds = new Set(filteredRiders.map(r => {
                        const id = typeof r.id === 'string' ? parseInt(r.id, 10) : r.id;
                        return Number.isFinite(id) ? id : r.id;
                    }));
                    ridersToShow = ridersToShow.filter(rider => {
                        const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                        const normalizedId = Number.isFinite(riderId) ? riderId : rider.id;
                        return qualifyingRiderIds.has(normalizedId);
                    });
                    console.log('🔵 renderPracticeAttendanceLists: Refined practice - showing', ridersToShow.length, 'qualifying riders out of', (data.riders || []).length, 'total riders');
                }
            }
            
            const ridersData = ridersToShow.map(rider => {
                // Normalize rider ID for comparison
                const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                const isAvailable = Number.isFinite(riderId) ? normalizedAvailableRiderIds.has(riderId) : ride.availableRiders.includes(rider.id);
                const assignedGroupId = riderAssignmentMap[rider.id];
                const assignedGroupLabel = assignedGroupId ? groupLabelMap[assignedGroupId] : null;
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                
                // Extract firstName and lastName
                let firstName = rider.firstName || '';
                let lastName = rider.lastName || '';
                if (!firstName && !lastName && rider.name) {
                    const nameParts = rider.name.trim().split(' ');
                    if (nameParts.length > 1) {
                        lastName = nameParts.pop() || '';
                        firstName = nameParts.join(' ') || '';
                    } else {
                        firstName = nameParts[0] || '';
                    }
                }
                
                return {
                    rider,
                    isAvailable,
                    assignedGroupId,
                    assignedGroupLabel,
                    fitness: Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10))),
                    skills: Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10))),
                    grade: parseInt(rider.grade || '0', 10) || 0,
                    gender: (rider.gender || 'M').toUpperCase(),
                    firstName: (firstName || '').toLowerCase(),
                    lastName: (lastName || getSortableLastName(rider.name || '')).toLowerCase(),
                    name: (rider.name || '').toLowerCase()
                };
            });
            
            // Separate attending (available) and non-attending riders, then sort each group
            const attendingRiders = ridersData.filter(r => r.isAvailable);
            const nonAttendingRiders = ridersData.filter(r => !r.isAvailable);
            
            // STEP 3: For refined practices, sort so available riders are at the top
            // For regular practices, use normal sorting
            // Reuse isRefined variable already declared above
            
            // Helper function to sort riders by the selected criteria
            const sortRidersByCriteria = (a, b) => {
                let compare = 0;
                if (ridersSort === 'assignedGroup') {
                    // Sort by assigned group - unassigned first, then by group label
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        compare = a.assignedGroupId !== null ? 1 : -1; // Unassigned first
                    } else if (a.assignedGroupId && b.assignedGroupId) {
                        compare = (a.assignedGroupLabel || '').localeCompare(b.assignedGroupLabel || '');
                        if (compare === 0) {
                            compare = a.lastName.localeCompare(b.lastName);
                        }
                    } else {
                        compare = a.lastName.localeCompare(b.lastName);
                    }
                } else if (ridersSort === 'availability') {
                    // Sort by availability - available first
                    if (a.isAvailable !== b.isAvailable) {
                        compare = a.isAvailable ? -1 : 1;
                    } else if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        compare = a.assignedGroupId !== null ? 1 : -1;
                    } else {
                        compare = a.lastName.localeCompare(b.lastName);
                    }
                } else {
                    // For other sorts, keep existing logic but apply to all riders
                    if (ridersSort === 'pace') {
                        compare = b.fitness !== a.fitness ? b.fitness - a.fitness : a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'skills') {
                        compare = b.skills !== a.skills ? b.skills - a.skills : a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'grade') {
                        compare = b.grade !== a.grade ? b.grade - a.grade : a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'gender') {
                        compare = a.gender !== b.gender ? a.gender.localeCompare(b.gender) : a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'firstName') {
                        const firstNameCompare = a.firstName.localeCompare(b.firstName);
                        compare = firstNameCompare !== 0 ? firstNameCompare : a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'lastName') {
                        const lastNameCompare = a.lastName.localeCompare(b.lastName);
                        compare = lastNameCompare !== 0 ? lastNameCompare : a.firstName.localeCompare(b.firstName);
                    } else { // fallback
                        compare = a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName);
                    }
                }
                return ridersSortDirection === 'asc' ? compare : -compare;
            };
            
            // NEW SORTING STRUCTURE:
            // 1. Unassigned attending riders (at top)
            // 2. Divider
            // 3. Assigned attending riders
            // 4. Divider  
            // 5. Not attending riders
            const unassignedAttending = attendingRiders.filter(r => !r.assignedGroupId);
            const assignedAttending = attendingRiders.filter(r => r.assignedGroupId);
            const notAttending = nonAttendingRiders;
            
            // Sort each group by the selected criteria
            const unassignedAttendingSorted = [...unassignedAttending].sort(sortRidersByCriteria);
            const assignedAttendingSorted = [...assignedAttending].sort(sortRidersByCriteria);
            const notAttendingSorted = [...notAttending].sort(sortRidersByCriteria);
            
            // Combine with divider markers
            let sortedRiders = [];
            if (unassignedAttendingSorted.length > 0) {
                sortedRiders.push(...unassignedAttendingSorted);
            }
            if (unassignedAttendingSorted.length > 0 && (assignedAttendingSorted.length > 0 || notAttendingSorted.length > 0)) {
                sortedRiders.push({ isDivider: true, type: 'unassigned-to-assigned' });
            }
            if (assignedAttendingSorted.length > 0) {
                sortedRiders.push(...assignedAttendingSorted);
            }
            if (assignedAttendingSorted.length > 0 && notAttendingSorted.length > 0) {
                sortedRiders.push({ isDivider: true, type: 'assigned-to-unavailable' });
            }
            if (notAttendingSorted.length > 0) {
                sortedRiders.push(...notAttendingSorted);
            }
            
            // Render riders list
            const ridersList = document.getElementById('practice-riders-list');
            // Save scroll position before re-rendering
            let ridersScrollTop = 0;
            if (ridersList) {
                // Find the scrollable content area (the div with overflow-y: auto)
                const ridersScrollable = ridersList.querySelector('.attendance-list, .drop-list') || ridersList.querySelector('div[style*="overflow"]') || ridersList;
                ridersScrollTop = ridersScrollable.scrollTop || 0;
            }
            if (ridersList) {
                const riderCardsHtml = sortedRiders.map((item) => {
                    // Handle divider items
                    if (item.isDivider) {
                        return '<div class="attendance-divider" style="height: 2px; background: #ccc; margin: 12px 0; width: 100%; border-top: 1px solid #999; border-bottom: 1px solid #999;"></div>';
                    }
                    
                    const { rider, isAvailable, assignedGroupLabel, assignedGroupId } = item;
                    const assignmentLabel = assignedGroupLabel 
                        ? `(Group ${assignedGroupLabel.replace('Group ', '')})` 
                        : (assignedGroupId === null ? '(Unassigned)' : '');
                    return renderRiderCardHtml(rider, {
                        draggable: isAvailable,
                        showAttendance: true,
                        isAvailable,
                        assignmentLabel,
                        checkboxHandler: null, // Using event delegation instead
                        compact: true,
                        sortBy: ridersSort,
                        noPhoto: true, // Remove headshots from practice attendance list
                        inGroup: false, // Not in group, but may be unavailable in attendance list
                        showUnavailableStyle: !isAvailable && assignedGroupId !== null // Show styling if unavailable and assigned to group
                    });
                }).join('');
                
                // For refined practices, show count of qualifying riders; for regular, show all riders
                const totalRiders = isRefined ? ridersData.length : (data.riders ? data.riders.length : 0);
                const attendingRidersCount = attendingRiders.length;
                
                // Create header outside scrollable area
                const ridersHeader = document.createElement('div');
                ridersHeader.style.cssText = 'background: #fff; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #e0e0e0;';
                ridersHeader.innerHTML = `
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: space-between;">
                        <h3 style="margin: 0;">Riders <span style="font-weight: normal; font-size: 14px; color: #666;">(${attendingRidersCount} of ${totalRiders}${isRefined ? ' qualifying' : ''})</span></h3>
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <button class="btn-small" onclick="togglePracticeRidersSortDirection()" title="Reverse sort order" aria-label="Reverse sort order" style="padding: 4px 6px; min-width: 28px;">
                                ${ridersSortDirection === 'asc' ? '↑' : '↓'}
                            </button>
                            <select class="group-sort-select" onchange="changePracticeRidersSort(this.value)" title="Sort by" style="font-size: 12px; padding: 4px 8px;">
                                <option value="pace" ${ridersSort === 'pace' ? 'selected' : ''}>Sort by: Pace</option>
                                <option value="skills" ${ridersSort === 'skills' ? 'selected' : ''}>Sort by: Bike Skills</option>
                                <option value="grade" ${ridersSort === 'grade' ? 'selected' : ''}>Sort by: Grade</option>
                                <option value="gender" ${ridersSort === 'gender' ? 'selected' : ''}>Sort by: Gender</option>
                                <option value="firstName" ${ridersSort === 'firstName' ? 'selected' : ''}>Sort by: First Name</option>
                                <option value="lastName" ${ridersSort === 'lastName' ? 'selected' : ''}>Sort by: Last Name</option>
                                <option value="assignedGroup" ${ridersSort === 'assignedGroup' ? 'selected' : ''}>Sort by: Assigned Group</option>
                                <option value="availability" ${ridersSort === 'availability' ? 'selected' : ''}>Sort by: Availability</option>
                            </select>
                            <div class="checkbox-actions">
                                <button class="btn-small" onclick="setAllPracticeRiders(true)">Select All</button>
                                <button class="btn-small secondary" onclick="setAllPracticeRiders(false)">Clear All</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create scrollable content area
                const ridersContent = document.createElement('div');
                ridersContent.className = 'rider-drop-list attendance-list';
                ridersContent.setAttribute('data-drop-type', 'rider');
                ridersContent.setAttribute('data-group-id', 'unassigned');
                ridersContent.setAttribute('ondrop', 'drop(event)');
                ridersContent.setAttribute('ondragover', 'allowDrop(event)');
                ridersContent.setAttribute('ondragleave', 'dragLeave(event)');
                ridersContent.style.cssText = 'overflow-y: auto; flex: 1; min-height: 0; border: none;';
                ridersContent.innerHTML = riderCardsHtml || '<div class="empty-message">No riders in roster.</div>';
                
                // Clear and rebuild structure
                ridersList.innerHTML = '';
                ridersList.appendChild(ridersHeader);
                ridersList.appendChild(ridersContent);
                
                // Attach event listeners to checkboxes using event delegation
                // Use 'click' event instead of 'change' to catch the state after it changes
                ridersContent.addEventListener('click', function handleRiderCheckboxClick(e) {
                    // Only handle clicks on checkboxes
                    if (e.target.type !== 'checkbox' || !e.target.classList.contains('attendance-checkbox-input') || e.target.dataset.attendanceType !== 'rider') {
                        return;
                    }
                    
                    // Use setTimeout to read the checkbox state after it's been updated by the browser
                    setTimeout(() => {
                        const riderId = parseInt(e.target.dataset.riderId, 10);
                        const isAvailable = e.target.checked;
                        
                        if (Number.isFinite(riderId)) {
                            toggleRiderAvailability(riderId, isAvailable);
                        } else {
                            console.error('🔴 Invalid riderId:', e.target.dataset.riderId);
                        }
                    }, 0);
                });
                
                // Allow clicking rider names to toggle their attendance checkbox
                ridersContent.addEventListener('click', function handleRiderNameClick(e) {
                    const nameTarget = e.target.closest('.attendance-name');
                    if (!nameTarget) return;
                    
                    const card = nameTarget.closest('.rider-card');
                    const checkbox = card ? card.querySelector('.attendance-checkbox-input') : null;
                    if (!checkbox) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    checkbox.click();
                });
                
                // Restore scroll position after re-rendering
                if (ridersScrollTop > 0) {
                    // Use requestAnimationFrame to ensure DOM is updated
                    requestAnimationFrame(() => {
                        const newScrollable = ridersList.querySelector('.attendance-list') || ridersList.querySelector('.drop-list');
                        if (newScrollable) {
                            newScrollable.scrollTop = ridersScrollTop;
                        }
                    });
                }
            }
            
            // Process and sort coaches - exclude N/A level coaches
            const coachesData = data.coaches
                .filter(coach => {
                    // Exclude coaches with N/A coaching level
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    return levelRaw !== 'N/A' && levelRaw !== 'N/a' && levelRaw !== 'n/a';
                })
                .map((coach, index) => {
                // Normalize IDs for comparison (handle both string and number IDs)
                const coachId = typeof coach.id === 'string' ? parseInt(coach.id, 10) : coach.id;
                const isAvailable = Number.isFinite(coachId) && ride.availableCoaches.includes(coachId);
                
                // Debug first few coaches
                if (index < 3) {
                }
                
                let assignedGroupId = null;
                let assignedGroupLabel = null;
                
                // Check if coach is assigned to any group using the assignment map
                const assignment = coachAssignmentMap[coach.id];
                if (assignment) {
                    assignedGroupId = assignment.groupId;
                    assignedGroupLabel = groupLabelMap[assignment.groupId];
                }
                
                // Extract firstName and lastName
                let firstName = coach.firstName || '';
                let lastName = coach.lastName || '';
                if (!firstName && !lastName && coach.name) {
                    const nameParts = coach.name.trim().split(' ');
                    if (nameParts.length > 1) {
                        lastName = nameParts.pop() || '';
                        firstName = nameParts.join(' ') || '';
                    } else {
                        firstName = nameParts[0] || '';
                    }
                }
                
                return {
                    coach,
                    isAvailable,
                    assignedGroupId,
                    assignedGroupLabel,
                    fitness: getCoachFitnessValue(coach),
                    level: (() => {
                        const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                        if (levelRaw === 'N/A' || levelRaw === 'N/a' || levelRaw === 'n/a') return 0;
                        return parseInt(levelRaw, 10) || 0;
                    })(),
                    firstName: (firstName || '').toLowerCase(),
                    lastName: (lastName || getSortableLastName(coach.name || '')).toLowerCase(),
                    name: (coach.name || '').toLowerCase()
                };
            });
            
            // Separate attending and non-attending coaches
            const attendingCoaches = coachesData.filter(c => c.isAvailable);
            const nonAttendingCoaches = coachesData.filter(c => !c.isAvailable);
            
            // NEW SORTING STRUCTURE (same as riders):
            // 1. Unassigned attending coaches (at top)
            // 2. Divider
            // 3. Assigned attending coaches
            // 4. Divider  
            // 5. Not attending coaches
            const unassignedAttendingCoaches = attendingCoaches.filter(c => !c.assignedGroupId);
            const assignedAttendingCoaches = attendingCoaches.filter(c => c.assignedGroupId);
            const notAttendingCoaches = nonAttendingCoaches;
            
            // Helper function to sort coaches by the selected criteria
            const sortCoachesByCriteria = (a, b) => {
                let compare = 0;
                if (coachesSort === 'assignedGroup') {
                    // Sort by assigned group - unassigned first, then by group label
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        compare = a.assignedGroupId !== null ? 1 : -1; // Unassigned first
                    } else if (a.assignedGroupId && b.assignedGroupId) {
                        compare = (a.assignedGroupLabel || '').localeCompare(b.assignedGroupLabel || '');
                        if (compare === 0) {
                            compare = a.lastName.localeCompare(b.lastName);
                        }
                    } else {
                        compare = a.lastName.localeCompare(b.lastName);
                    }
                } else if (coachesSort === 'availability') {
                    // Sort by availability - available first
                    if (a.isAvailable !== b.isAvailable) {
                        compare = a.isAvailable ? -1 : 1;
                    } else if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        compare = a.assignedGroupId !== null ? 1 : -1;
                    } else {
                        compare = a.lastName.localeCompare(b.lastName);
                    }
                } else {
                    // For other sorts, apply to all coaches
                    if (coachesSort === 'pace') {
                        const fitnessDiff = b.fitness - a.fitness;
                        compare = fitnessDiff !== 0 ? fitnessDiff : a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'level') {
                        const levelDiff = b.level - a.level;
                        compare = levelDiff !== 0 ? levelDiff : a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'firstName') {
                        const firstNameCompare = a.firstName.localeCompare(b.firstName);
                        compare = firstNameCompare !== 0 ? firstNameCompare : a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'lastName') {
                        const lastNameCompare = a.lastName.localeCompare(b.lastName);
                        compare = lastNameCompare !== 0 ? lastNameCompare : a.firstName.localeCompare(b.firstName);
                    } else { // fallback
                        compare = a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName);
                    }
                }
                return coachesSortDirection === 'asc' ? compare : -compare;
            };
            
            // Sort each group by the selected criteria
            const unassignedAttendingCoachesSorted = [...unassignedAttendingCoaches].sort(sortCoachesByCriteria);
            const assignedAttendingCoachesSorted = [...assignedAttendingCoaches].sort(sortCoachesByCriteria);
            const notAttendingCoachesSorted = [...notAttendingCoaches].sort(sortCoachesByCriteria);
            
            // Combine with divider markers
            let sortedCoaches = [];
            if (unassignedAttendingCoachesSorted.length > 0) {
                sortedCoaches.push(...unassignedAttendingCoachesSorted);
            }
            if (unassignedAttendingCoachesSorted.length > 0 && (assignedAttendingCoachesSorted.length > 0 || notAttendingCoachesSorted.length > 0)) {
                sortedCoaches.push({ isDivider: true, type: 'unassigned-to-assigned' });
            }
            if (assignedAttendingCoachesSorted.length > 0) {
                sortedCoaches.push(...assignedAttendingCoachesSorted);
            }
            if (assignedAttendingCoachesSorted.length > 0 && notAttendingCoachesSorted.length > 0) {
                sortedCoaches.push({ isDivider: true, type: 'assigned-to-unavailable' });
            }
            if (notAttendingCoachesSorted.length > 0) {
                sortedCoaches.push(...notAttendingCoachesSorted);
            }
            
            // Render coaches list
            const coachesList = document.getElementById('practice-coaches-list');
            // Save scroll position before re-rendering
            let coachesScrollTop = 0;
            if (coachesList) {
                // Find the scrollable content area (the div with overflow-y: auto)
                const coachesScrollable = coachesList.querySelector('.attendance-list') || coachesList.querySelector('.drop-list') || coachesList.querySelector('div[style*="overflow"]');
                if (coachesScrollable) {
                    coachesScrollTop = coachesScrollable.scrollTop || 0;
                }
            }
            if (coachesList) {
                const coachCardsHtml = sortedCoaches.map((item) => {
                    // Handle divider items
                    if (item.isDivider) {
                        return '<div class="attendance-divider" style="height: 2px; background: #ccc; margin: 12px 0; width: 100%; border-top: 1px solid #999; border-bottom: 1px solid #999;"></div>';
                    }
                    
                    const { coach, isAvailable, assignedGroupLabel, assignedGroupId } = item;
                    const assignmentLabel = assignedGroupLabel 
                        ? `(Group ${assignedGroupLabel.replace('Group ', '')})` 
                        : (assignedGroupId === null ? '(Unassigned)' : '');
                    return renderCoachCardHtml(coach, null, 'unassigned', {
                        draggable: isAvailable,
                        showAttendance: true,
                        isAvailable,
                        assignmentLabel,
                        checkboxHandler: null, // Using event delegation instead
                        compact: true,
                        sortBy: coachesSort,
                        noPhoto: true // Remove headshots from practice attendance list
                    });
                }).join('');
                
                const totalCoaches = data.coaches.length;
                const attendingCoachesCount = attendingCoaches.length;
                
                // Create header outside scrollable area
                const coachesHeader = document.createElement('div');
                coachesHeader.style.cssText = 'background: #fff; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #e0e0e0;';
                coachesHeader.innerHTML = `
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: space-between;">
                        <h3 style="margin: 0;">Coaches <span style="font-weight: normal; font-size: 14px; color: #666;">(${attendingCoachesCount} of ${totalCoaches})</span></h3>
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <button class="btn-small" onclick="togglePracticeCoachesSortDirection()" title="Reverse sort order" aria-label="Reverse sort order" style="padding: 4px 6px; min-width: 28px;">
                                ${coachesSortDirection === 'asc' ? '↑' : '↓'}
                            </button>
                            <select class="group-sort-select" onchange="changePracticeCoachesSort(this.value)" title="Sort by" style="font-size: 12px; padding: 4px 8px;">
                                <option value="pace" ${coachesSort === 'pace' ? 'selected' : ''}>Sort by: Pace</option>
                                <option value="level" ${coachesSort === 'level' ? 'selected' : ''}>Sort by: Level</option>
                                <option value="firstName" ${coachesSort === 'firstName' ? 'selected' : ''}>Sort by: First Name</option>
                                <option value="lastName" ${coachesSort === 'lastName' ? 'selected' : ''}>Sort by: Last Name</option>
                                <option value="assignedGroup" ${coachesSort === 'assignedGroup' ? 'selected' : ''}>Sort by: Assigned Group</option>
                                <option value="availability" ${coachesSort === 'availability' ? 'selected' : ''}>Sort by: Availability</option>
                            </select>
                            <div class="checkbox-actions">
                                <button class="btn-small" onclick="setAllPracticeCoaches(true)">Select All</button>
                                <button class="btn-small secondary" onclick="setAllPracticeCoaches(false)">Clear All</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create scrollable content area
                const coachesContent = document.createElement('div');
                coachesContent.className = 'coach-drop-list attendance-list';
                coachesContent.setAttribute('data-drop-type', 'coach');
                coachesContent.setAttribute('data-role', 'unassigned');
                coachesContent.setAttribute('data-group-id', 'unassigned');
                coachesContent.setAttribute('ondrop', 'drop(event)');
                coachesContent.setAttribute('ondragover', 'allowDrop(event)');
                coachesContent.setAttribute('ondragleave', 'dragLeave(event)');
                coachesContent.style.cssText = 'overflow-y: auto; flex: 1; min-height: 0; border: none;';
                coachesContent.innerHTML = coachCardsHtml || '<div class="empty-message">No coaches in roster.</div>';
                
                // Clear and rebuild structure
                coachesList.innerHTML = '';
                coachesList.appendChild(coachesHeader);
                coachesList.appendChild(coachesContent);
                
                // Attach event listeners to checkboxes using event delegation
                // Use 'click' event instead of 'change' to catch the state after it changes
                coachesContent.addEventListener('click', function handleCoachCheckboxClick(e) {
                    // Only handle clicks on checkboxes
                    if (e.target.type !== 'checkbox' || !e.target.classList.contains('attendance-checkbox-input') || e.target.dataset.attendanceType !== 'coach') {
                        return;
                    }
                    
                    // Use setTimeout to read the checkbox state after it's been updated by the browser
                    setTimeout(() => {
                        const coachId = parseInt(e.target.dataset.coachId, 10);
                        const isAvailable = e.target.checked;
                        
                        if (Number.isFinite(coachId)) {
                            toggleCoachAvailability(coachId, isAvailable);
                        } else {
                            console.error('🔴 Invalid coachId:', e.target.dataset.coachId);
                        }
                    }, 0);
                });
                
                // Allow clicking coach names to toggle their attendance checkbox
                coachesContent.addEventListener('click', function handleCoachNameClick(e) {
                    const nameTarget = e.target.closest('.attendance-name');
                    if (!nameTarget) return;
                    
                    const card = nameTarget.closest('.coach-card');
                    const checkbox = card ? card.querySelector('.attendance-checkbox-input') : null;
                    if (!checkbox) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    checkbox.click();
                });
                
                // Restore scroll position after re-rendering
                if (coachesScrollTop > 0) {
                    // Use requestAnimationFrame to ensure DOM is updated
                    requestAnimationFrame(() => {
                        const newScrollable = coachesList.querySelector('.attendance-list') || coachesList.querySelector('.drop-list');
                        if (newScrollable) {
                            newScrollable.scrollTop = coachesScrollTop;
                        }
                    });
                }
            }
        }
        
        function toggleRiderAvailability(riderId, isAvailable) {
            try {
            const ride = data.rides.find(r => r.id === data.currentRide);
                if (!ride) {
                    console.warn('toggleRiderAvailability: No current ride found');
                    return;
                }
                
                // Save state before change
                saveAssignmentState(ride);
                
                console.log('🔵 toggleRiderAvailability called:', { riderId, isAvailable, rideId: ride.id });
                console.log('🔵 toggleRiderAvailability: ride.availableRiders BEFORE:', {
                    length: ride.availableRiders?.length,
                    isArray: Array.isArray(ride.availableRiders),
                    first10: ride.availableRiders?.slice(0, 10)
                });
                
                // Normalize riderId to handle string/number mismatches
                const normalizedRiderId = typeof riderId === 'string' ? parseInt(riderId, 10) : riderId;
                if (!Number.isFinite(normalizedRiderId)) {
                    console.warn('toggleRiderAvailability: Invalid riderId:', riderId);
                    return;
                }
                
                // If isAvailable is not provided, determine from current state
                if (isAvailable === undefined || isAvailable === null) {
            if (!Array.isArray(ride.availableRiders)) {
                ride.availableRiders = [];
                    }
                    const normalizedAvailableRiders = ride.availableRiders.map(id => {
                        const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                        return Number.isFinite(normalized) ? normalized : id;
                    });
                    isAvailable = !normalizedAvailableRiders.includes(normalizedRiderId);
                }
                
                
                if (!Array.isArray(ride.availableRiders)) {
                    ride.availableRiders = [];
                }
                
                // Normalize IDs in availableRiders for comparison
                let normalizedAvailableRiders = ride.availableRiders.map(id => {
                    const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                    return Number.isFinite(normalized) ? normalized : id;
                });
            
            if (isAvailable) {
                    if (!normalizedAvailableRiders.includes(normalizedRiderId)) {
                        normalizedAvailableRiders.push(normalizedRiderId);
                }
            } else {
                    // When unchecked, remove from availableRiders
                    normalizedAvailableRiders = normalizedAvailableRiders.filter(id => id !== normalizedRiderId);
                    
                    // Check if practice is in the future or past
                    const practiceDate = parseISODate(ride.date);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Reset time to compare dates only
                    
                    if (practiceDate) {
                        practiceDate.setHours(0, 0, 0, 0);
                        const isFuturePractice = practiceDate >= today;
                        
                        if (isFuturePractice) {
                            // For future practices: Remove rider completely from all groups
                            ride.groups.forEach(group => {
                                group.riders = group.riders.filter(id => {
                                    const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                                    return Number.isFinite(normalized) ? normalized !== normalizedRiderId : id !== normalizedRiderId;
                                });
                            });
                        } else {
                            // For past practices: KEEP rider in groups (they will show as greyed/unavailable)
                            // This preserves historical assignment data
                        }
                    }
                }
                
                // Update ride.availableRiders with the normalized array
                ride.availableRiders = normalizedAvailableRiders;
                ride.attendanceInitialized = true;
                
                console.log('🔵 toggleRiderAvailability: ride.availableRiders AFTER update:', {
                    length: ride.availableRiders.length,
                    first10: ride.availableRiders.slice(0, 10),
                    isAvailable,
                    normalizedRiderId
                });
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
            } catch (error) {
                console.error('Error in toggleRiderAvailability:', error);
                alert('Error toggling rider availability: ' + error.message);
            }
        }
        
        function toggleCoachAvailability(coachId, isAvailable) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                console.error('❌ No ride found');
                return;
            }
            
            ride.attendanceInitialized = true;
            
            // Debug: Check riders before modifying coaches
            if (!Array.isArray(ride.availableCoaches)) {
                ride.availableCoaches = [];
            }
            
            
            // Normalize coachId to number for consistent comparison
            const normalizedCoachId = typeof coachId === 'string' ? parseInt(coachId, 10) : coachId;
            if (!Number.isFinite(normalizedCoachId)) {
                console.error('❌ Invalid coachId:', coachId, 'normalized:', normalizedCoachId);
                return;
            }
            
            // Normalize ALL existing IDs in array first to ensure consistency
            const beforeNormalize = [...ride.availableCoaches];
            ride.availableCoaches = ride.availableCoaches.map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => Number.isFinite(id));
            
            // Deduplicate (in case normalization created duplicates)
            ride.availableCoaches = Array.from(new Set(ride.availableCoaches));
            
            
            if (isAvailable) {
                if (!ride.availableCoaches.includes(normalizedCoachId)) {
                    ride.availableCoaches.push(normalizedCoachId);
                }
            } else {
                // Coach unchecked - remove from available coaches and from all groups
                // This is allowed even if it makes groups non-compliant (groups will show red with warning)
                ride.availableCoaches = ride.availableCoaches.filter(id => id !== normalizedCoachId);
                
                // Remove coach from all groups (leader, sweep, roam, extraRoam)
                // Then optimize roles (e.g., if sweep removed and roam exists, promote roam to sweep)
                ride.groups.forEach(group => {
                    const leaderId = typeof group.coaches.leader === 'string' ? parseInt(group.coaches.leader, 10) : group.coaches.leader;
                    const sweepId = typeof group.coaches.sweep === 'string' ? parseInt(group.coaches.sweep, 10) : group.coaches.sweep;
                    const roamId = typeof group.coaches.roam === 'string' ? parseInt(group.coaches.roam, 10) : group.coaches.roam;
                    
                    // Track which role was removed
                    let removedRole = null;
                    if (leaderId === normalizedCoachId) {
                        group.coaches.leader = null;
                        removedRole = 'leader';
                    }
                    if (sweepId === normalizedCoachId) {
                        group.coaches.sweep = null;
                        removedRole = 'sweep';
                    }
                    if (roamId === normalizedCoachId) {
                        group.coaches.roam = null;
                        removedRole = 'roam';
                    }
                    if (Array.isArray(group.coaches.extraRoam)) {
                        const hadExtraRoam = group.coaches.extraRoam.includes(normalizedCoachId);
                        group.coaches.extraRoam = group.coaches.extraRoam
                            .map(id => typeof id === 'string' ? parseInt(id, 10) : id)
                            .filter(id => Number.isFinite(id) && id !== normalizedCoachId);
                        if (hadExtraRoam && group.coaches.extraRoam.length === 0) {
                            removedRole = 'extraRoam';
                    }
                    }
                    
                    // Optimize coach roles after removal
                    optimizeGroupCoachRoles(group);
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        function changePracticeRidersSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'firstName', 'lastName', 'assignedGroup', 'availability'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace';
            }
            
            ride.practiceRidersSort = sortBy;
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }

        function togglePracticeRidersSortDirection() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            const current = ride.practiceRidersSortDirection || 'asc';
            ride.practiceRidersSortDirection = current === 'asc' ? 'desc' : 'asc';
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }

        function getPracticeReportingRides() {
            const rides = Array.isArray(data.rides) ? data.rides.filter(r => r && !r.deleted && r.date) : [];
            const mapped = rides.map(ride => {
                const dateObj = parseISODate(ride.date);
                return Number.isNaN(dateObj?.getTime?.()) ? null : { ride, dateObj };
            }).filter(Boolean);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const completed = mapped.filter(entry => entry.dateObj <= today);
            const list = (completed.length > 0 ? completed : mapped).sort((a, b) => a.dateObj - b.dateObj);
            return list.map(entry => entry.ride);
        }

        function renderPracticeReporting() {
            const dateEl = document.getElementById('practice-reporting-date');
            const summaryEl = document.getElementById('practice-reporting-summary');
            const prevBtn = document.getElementById('practice-reporting-prev');
            const nextBtn = document.getElementById('practice-reporting-next');
            const titleEl = document.getElementById('practice-reporting-title');
            const sortIndicator = document.getElementById('practice-reporting-sort-indicator');
            const tableBody = document.getElementById('practice-reporting-table-body');
            if (!tableBody || !dateEl || !summaryEl || !prevBtn || !nextBtn || !titleEl || !sortIndicator) return;

            const rides = getPracticeReportingRides();
            if (rides.length === 0) {
                practiceReportingRideIndex = null;
                dateEl.textContent = 'No practices found';
                summaryEl.textContent = '';
                titleEl.textContent = 'Practice Reporting';
                sortIndicator.textContent = practiceReportingSortDirection === 'asc' ? '↑' : '↓';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                tableBody.innerHTML = '<tr><td colspan="2" style="padding: 12px; color: #666;">No practice data yet.</td></tr>';
                return;
            }

            if (practiceReportingRideIndex === null || practiceReportingRideIndex < 0 || practiceReportingRideIndex >= rides.length) {
                practiceReportingRideIndex = rides.length - 1;
            }

            const ride = rides[practiceReportingRideIndex];
            const rideDate = ride?.date ? parseISODate(ride.date) : null;
            const dateLabel = rideDate ? rideDate.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' }) : 'Unknown Date';
            dateEl.textContent = dateLabel;
            titleEl.textContent = `Practice Reporting: ${dateLabel}`;
            sortIndicator.textContent = practiceReportingSortDirection === 'asc' ? '↑' : '↓';

            prevBtn.disabled = practiceReportingRideIndex <= 0;
            nextBtn.disabled = practiceReportingRideIndex >= rides.length - 1;

            const availableIds = Array.isArray(ride.availableRiders) ? ride.availableRiders : [];
            const availableSet = new Set(availableIds.map(id => {
                const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                return Number.isFinite(normalized) ? normalized : id;
            }));

            const sortedRiders = [...(data.riders || [])].sort((a, b) => {
                const aLast = getSortableLastName(a.name || '');
                const bLast = getSortableLastName(b.name || '');
                if (aLast !== bLast) return aLast.localeCompare(bLast);
                const aFirst = (a.name || '').toLowerCase();
                const bFirst = (b.name || '').toLowerCase();
                return aFirst.localeCompare(bFirst);
            });
            if (practiceReportingSortDirection === 'desc') {
                sortedRiders.reverse();
            }

            let attendedCount = 0;
            let absentCount = 0;
            const rows = sortedRiders.map(rider => {
                const riderId = typeof rider.id === 'string' ? parseInt(rider.id, 10) : rider.id;
                const attended = availableSet.has(riderId);
                if (attended) attendedCount++;
                else absentCount++;
                const status = attended ? 'Attended' : 'Absent';
                const statusColor = attended ? '#2e7d32' : '#c62828';
                const nameColor = attended ? '#333' : '#c62828';
                return `
                    <tr>
                        <td style="padding: 10px; border-top: 1px solid #eee; color: ${nameColor};">${escapeHtml(rider.name || 'Unnamed Rider')}</td>
                        <td onclick="togglePracticeReportingStatus(${ride.id}, ${riderId})" style="padding: 10px; border-top: 1px solid #eee; color: ${statusColor}; font-weight: 600; cursor: pointer;">${status}</td>
                    </tr>
                `;
            });

            summaryEl.textContent = `${attendedCount} attended, ${absentCount} absent`;
            tableBody.innerHTML = rows.join('') || '<tr><td colspan="2" style="padding: 12px; color: #666;">No riders found.</td></tr>';
        }

        function navigatePracticeReporting(offset) {
            const rides = getPracticeReportingRides();
            if (rides.length === 0) return;
            if (practiceReportingRideIndex === null) {
                practiceReportingRideIndex = rides.length - 1;
            } else {
                practiceReportingRideIndex = Math.max(0, Math.min(rides.length - 1, practiceReportingRideIndex + offset));
            }
            renderPracticeReporting();
        }

        function togglePracticeReportingSort() {
            practiceReportingSortDirection = practiceReportingSortDirection === 'asc' ? 'desc' : 'asc';
            renderPracticeReporting();
        }

        function togglePracticeReportingStatus(rideId, riderId) {
            const ride = data.rides.find(r => r.id === rideId);
            if (!ride) return;
            if (!Array.isArray(ride.availableRiders)) {
                ride.availableRiders = [];
            }
            const normalizedId = typeof riderId === 'string' ? parseInt(riderId, 10) : riderId;
            const idToUse = Number.isFinite(normalizedId) ? normalizedId : riderId;
            const existingIndex = ride.availableRiders.findIndex(id => {
                const normalized = typeof id === 'string' ? parseInt(id, 10) : id;
                return (Number.isFinite(normalized) ? normalized : id) === idToUse;
            });
            if (existingIndex >= 0) {
                ride.availableRiders.splice(existingIndex, 1);
            } else {
                ride.availableRiders.push(idToUse);
            }
            ride.attendanceInitialized = true;
            saveRideToDB(ride);
            renderPracticeReporting();
        }

        function toggleUnassignedPaletteVisibility() {
            const palette = document.getElementById('new-attendees-sticky');
            const isVisible = !!palette;
            if (isVisible) {
                unassignedPaletteVisibility = 'hide';
            } else {
                unassignedPaletteVisibility = 'show';
            }
            renderAssignments(data.rides.find(r => r.id === data.currentRide));
        }

        function updateUnassignedPaletteToggleButton(isVisible) {
            const toggleBtn = document.getElementById('unassigned-palette-toggle-btn');
            if (!toggleBtn) return;
            toggleBtn.textContent = isVisible ? 'Hide Unassigned Palette' : 'Show Unassigned Palette';
        }

        function startUnassignedPaletteResize(event) {
            event.preventDefault();
            const startY = event.clientY;
            const startHeight = unassignedPaletteHeight;
            const onMove = (moveEvent) => {
                const delta = moveEvent.clientY - startY;
                const nextHeight = Math.max(140, Math.min(600, startHeight + delta));
                unassignedPaletteHeight = nextHeight;
                document.querySelectorAll('[data-unassigned-list="true"]').forEach(list => {
                    list.style.height = `${nextHeight}px`;
                    list.style.maxHeight = `${nextHeight}px`;
                });
            };
            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function changePracticeCoachesSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const validSorts = ['pace', 'level', 'firstName', 'lastName', 'assignedGroup', 'availability'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace';
            }
            
            ride.practiceCoachesSort = sortBy;
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }

        function togglePracticeCoachesSortDirection() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            const current = ride.practiceCoachesSortDirection || 'asc';
            ride.practiceCoachesSortDirection = current === 'asc' ? 'desc' : 'asc';
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }
        
        function setAllPracticeRiders(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                console.warn('setAllPracticeRiders: No current ride found');
                return;
            }
            
            console.log('🔵 setAllPracticeRiders called:', { selectAll, rideId: ride.id });
            console.log('🔵 setAllPracticeRiders: ride.availableRiders BEFORE:', {
                length: ride.availableRiders?.length,
                first10: ride.availableRiders?.slice(0, 10)
            });
            
            if (selectAll) {
                ride.availableRiders = data.riders ? data.riders.map(r => r.id) : [];
                console.log('🔵 setAllPracticeRiders: Selected all', ride.availableRiders.length, 'riders');
            } else {
                ride.availableRiders = [];
                console.log('🔵 setAllPracticeRiders: Cleared all riders');
                // Remove riders from all groups if clearing all
                ride.groups.forEach(group => {
                    group.riders = [];
                });
            }
            
            ride.attendanceInitialized = true;
            
            console.log('🔵 setAllPracticeRiders: ride.availableRiders AFTER:', {
                length: ride.availableRiders.length,
                first10: ride.availableRiders.slice(0, 10)
            });
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        function setAllPracticeCoaches(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (selectAll) {
                ride.availableCoaches = data.coaches.map(c => c.id);
            } else {
                ride.availableCoaches = [];
                // Remove coaches from all groups if clearing all
                ride.groups.forEach(group => {
                    if (group.coaches.leader) group.coaches.leader = null;
                    if (group.coaches.sweep) group.coaches.sweep = null;
                    if (group.coaches.roam) group.coaches.roam = null;
                    if (Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        // Attendance frame resizing
        let attendanceResizeActive = false;
        let attendanceResizeStartY = 0;
        let attendanceResizeStartHeight = 0;
        
        function startResizeAttendance(event) {
            event.preventDefault();
            attendanceResizeActive = true;
            attendanceResizeStartY = event.clientY;
            const container = document.getElementById('practice-attendance-lists-container');
            if (container) {
                attendanceResizeStartHeight = container.offsetHeight;
            }
            
            document.addEventListener('mousemove', handleAttendanceResize);
            document.addEventListener('mouseup', stopResizeAttendance);
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
        }
        
        function handleAttendanceResize(event) {
            if (!attendanceResizeActive) return;
            
            const deltaY = event.clientY - attendanceResizeStartY;
            const container = document.getElementById('practice-attendance-lists-container');
            if (container) {
                const newHeight = Math.max(200, Math.min(800, attendanceResizeStartHeight + deltaY));
                container.style.height = newHeight + 'px';
            }
        }
        
        function stopResizeAttendance() {
            attendanceResizeActive = false;
            document.removeEventListener('mousemove', handleAttendanceResize);
            document.removeEventListener('mouseup', stopResizeAttendance);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        function updateGroupRoute(groupId, routeId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const group = ride.groups.find(g => String(g.id) === String(groupId));
            if (!group) return;
            
            group.routeId = routeId || null;
            saveRideToDB(ride);
            
            // Re-render assignments to show/hide route preview
            renderAssignments(ride);
            // updateRoutePreviews is called inside renderAssignments
        }

        function renderRouteOptions(selectedRouteId, group, ride) {
            const routes = data.routes || [];
            if (routes.length === 0) {
                return '<option value="">No routes available</option>';
            }
            
            // If no group or ride provided, render all routes normally
            if (!group || !ride) {
                return routes.map(route => {
                    const selected = selectedRouteId && String(route.id) === String(selectedRouteId) ? 'selected' : '';
                    let routeText = escapeHtml(route.name || 'Unnamed Route');
                    
                    // Add distance, elevation, and time if available
                    const details = [];
                    if (route.distance) details.push(route.distance);
                    if (route.elevation) details.push(route.elevation);
                    if (route.estimatedTime) details.push(route.estimatedTime);
                    if (details.length > 0) {
                        routeText += ` (${details.join(' / ')})`;
                    }
                    
                    return `<option value="${route.id}" ${selected}>${routeText}</option>`;
                }).join('');
            }
            
            // Parse practice time
            const practiceStartTime = ride.startTime || ride.time || '';
            const practiceEndTime = ride.endTime || '';
            let practiceDurationMinutes = null;
            let practiceStartMinutes = null;
            
            if (practiceStartTime && practiceEndTime) {
                // Parse time strings (format: "HH:MM")
                const startParts = practiceStartTime.split(':');
                const endParts = practiceEndTime.split(':');
                if (startParts.length === 2 && endParts.length === 2) {
                    const startMins = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
                    const endMins = parseInt(endParts[0], 10) * 60 + parseInt(endParts[1], 10);
                    practiceDurationMinutes = endMins - startMins;
                    practiceStartMinutes = startMins;
                }
            }
            
            // Get group riders' fitness and skills ranges
            const groupRiders = (group.riders || [])
                .map(id => getRiderById(id))
                .filter(Boolean);
            
            let groupFitnessMin = null;
            let groupFitnessMax = null;
            let groupSkillsMin = null;
            let groupSkillsMax = null;
            
            if (groupRiders.length > 0) {
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                
                const fitnesses = groupRiders.map(r => Math.max(1, Math.min(fitnessScale, parseInt(r.fitness || Math.ceil(fitnessScale / 2), 10))));
                const skills = groupRiders.map(r => Math.max(1, Math.min(skillsScale, parseInt(r.skills || Math.ceil(skillsScale / 2), 10))));
                
                groupFitnessMin = Math.min(...fitnesses);
                groupFitnessMax = Math.max(...fitnesses);
                groupSkillsMin = Math.min(...skills);
                groupSkillsMax = Math.max(...skills);
            }
            
            // Categorize routes
            const matchingRoutes = [];
            const otherRoutes = [];
            
            routes.forEach(route => {
                let matchesTime = false;
                let matchesFitnessSkills = false;
                
                // Check time match
                if (practiceDurationMinutes !== null && practiceStartMinutes !== null && route.estimatedTime) {
                    // Parse route time range
                    const timeRangeMatch = route.estimatedTime.match(/(.+?)\s*-\s*(.+)/);
                    if (timeRangeMatch) {
                        const time1Str = timeRangeMatch[1].trim();
                        const time2Str = timeRangeMatch[2].trim();
                        const time1Seconds = parseTime(time1Str);
                        const time2Seconds = parseTime(time2Str);
                        const time1Minutes = time1Seconds / 60; // Convert seconds to minutes
                        const time2Minutes = time2Seconds / 60;
                        const routeMidpointMinutes = (time1Minutes + time2Minutes) / 2;
                        const routeMaxMinutes = Math.max(time1Minutes, time2Minutes);
                        
                        // Check: midpoint fits within practice time AND upper end is not more than 30 min longer
                        if (routeMidpointMinutes <= practiceDurationMinutes && 
                            routeMaxMinutes <= practiceDurationMinutes + 30) {
                            matchesTime = true;
                        }
                    }
                }
                
                // Check fitness/skills match
                if (groupFitnessMin !== null && groupFitnessMax !== null && 
                    groupSkillsMin !== null && groupSkillsMax !== null) {
                    const fitnessScale = getFitnessScale();
                    const skillsScale = getSkillsScale();
                    
                    const routeFitnessMin = route.fitnessMin !== undefined ? route.fitnessMin : 1;
                    const routeFitnessMax = route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
                    const routeSkillsMin = route.skillsMin !== undefined ? route.skillsMin : 1;
                    const routeSkillsMax = route.skillsMax !== undefined ? route.skillsMax : skillsScale;
                    
                    // Check if ranges overlap
                    const fitnessOverlaps = !(routeFitnessMax < groupFitnessMin || routeFitnessMin > groupFitnessMax);
                    const skillsOverlaps = !(routeSkillsMax < groupSkillsMin || routeSkillsMin > groupSkillsMax);
                    
                    if (fitnessOverlaps && skillsOverlaps) {
                        matchesFitnessSkills = true;
                    }
                }
                
                // Route matches if both time and fitness/skills match
                if (matchesTime && matchesFitnessSkills) {
                    matchingRoutes.push(route);
                } else {
                    otherRoutes.push(route);
                }
            });
            
            // Build HTML: matching routes first, then separator, then others
            let html = '';
            
            // Matching routes
            matchingRoutes.forEach(route => {
                const selected = selectedRouteId && String(route.id) === String(selectedRouteId) ? 'selected' : '';
                let routeText = escapeHtml(route.name || 'Unnamed Route');
                
                const details = [];
                if (route.distance) details.push(route.distance);
                if (route.elevation) details.push(route.elevation);
                if (route.estimatedTime) details.push(route.estimatedTime);
                if (details.length > 0) {
                    routeText += ` (${details.join(' / ')})`;
                }
                
                html += `<option value="${route.id}" ${selected}>${routeText}</option>`;
            });
            
            // Separator if there are both matching and other routes
            if (matchingRoutes.length > 0 && otherRoutes.length > 0) {
                html += `<option disabled>──────────</option>`;
            }
            
            // Other routes
            otherRoutes.forEach(route => {
                const selected = selectedRouteId && String(route.id) === String(selectedRouteId) ? 'selected' : '';
                let routeText = escapeHtml(route.name || 'Unnamed Route');
                
                const details = [];
                if (route.distance) details.push(route.distance);
                if (route.elevation) details.push(route.elevation);
                if (route.estimatedTime) details.push(route.estimatedTime);
                if (details.length > 0) {
                    routeText += ` (${details.join(' / ')})`;
                }
                
                html += `<option value="${route.id}" ${selected}>${routeText}</option>`;
            });
            
            return html;
        }

        function updateRoutePreviews() {
            // Find all route preview containers and populate them with Strava embed code
            const previewContainers = document.querySelectorAll('.route-preview-container');
            previewContainers.forEach(container => {
                const routeId = container.getAttribute('data-route-id');
                if (!routeId) return;
                
                const route = getRouteById(routeId);
                if (route && route.stravaEmbedCode) {
                    container.innerHTML = route.stravaEmbedCode;
                } else {
                    container.style.display = 'none';
                }
            });
        }

        function getCoachFirstNames(group) {
            const coachesList = [];
            
            if (group.coaches.leader) {
                const coach = getCoachById(group.coaches.leader);
                if (coach) coachesList.push(coach);
            }
            if (group.coaches.sweep) {
                const coach = getCoachById(group.coaches.sweep);
                if (coach) coachesList.push(coach);
            }
            if (group.coaches.roam) {
                const coach = getCoachById(group.coaches.roam);
                if (coach) coachesList.push(coach);
            }
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(coachId => {
                    if (coachId) {
                        const coach = getCoachById(coachId);
                        if (coach) coachesList.push(coach);
                    }
                });
            }
            
            if (coachesList.length === 0) return '';
            
            // Extract first names
            const firstNames = coachesList.map(coach => {
                const name = coach.name || '';
                const parts = name.trim().split(/\s+/);
                return parts[0] || name;
            });
            
            // Check for duplicates and add last initial if needed
            const nameCounts = {};
            firstNames.forEach(name => {
                nameCounts[name] = (nameCounts[name] || 0) + 1;
            });
            
            const result = coachesList.map(coach => {
                const name = coach.name || '';
                const parts = name.trim().split(/\s+/);
                const firstName = parts[0] || name;
                
                // If duplicate first name, add last initial
                if (nameCounts[firstName] > 1 && parts.length > 1) {
                    const lastInitial = parts[parts.length - 1].charAt(0).toUpperCase();
                    return `${firstName} ${lastInitial}`;
                }
                return firstName;
            });
            
            return result.join(', ');
        }

        function getRiderFitnessRange(group) {
            if (!group.riders || group.riders.length === 0) {
                return '0 riders';
            }
            
            const fitnesses = group.riders
                .map(id => getRiderById(id))
                .filter(Boolean)
                .map(r => parseInt(r.fitness || '5', 10))
                .filter(f => !isNaN(f));
            
            if (fitnesses.length === 0) {
                return `${group.riders.length} riders`;
            }
            
            const minFitness = Math.min(...fitnesses);
            const maxFitness = Math.max(...fitnesses);
            
            if (minFitness === maxFitness) {
                return `${group.riders.length} riders, Pace ${minFitness}`;
            } else {
                return `${group.riders.length} riders, Pace ${minFitness}-${maxFitness}`;
            }
        }

        function checkGroupCompliance(group) {
            // Check if group has a leader that meets the minimum level setting
            if (!group.coaches.leader) {
                return false;
            }
            const leader = getCoachById(group.coaches.leader);
            if (!leader) return false;
            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const leaderLevel = parseInt(leader.coachingLicenseLevel || leader.level || '1', 10);
            if (!Number.isFinite(leaderLevel) || leaderLevel < minLeaderLevel) {
                return false;
            }
            
            // Check if group has at least one coach
            const coachCount = countGroupCoaches(group);
            if (coachCount === 0) {
                return false;
            }
            
            // Check coach/rider ratio
            const capacity = groupCapacity(group);
            if (coachCount > 0 && group.riders.length > capacity) {
                return false;
            }
            
            return true;
        }

        function updateGroupPaceOrder(value) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            const normalized = normalizeGroupPaceOrder(value);
            ride.groupPaceOrder = normalized;
            if (!data.seasonSettings) {
                data.seasonSettings = buildDefaultSeasonSettings();
            }
            data.seasonSettings.groupPaceOrder = normalized;
            saveData();
            renderAssignments(ride);
        }

        function switchUnassignedView(view) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (view !== 'riders' && view !== 'coaches') {
                view = 'riders'; // Default to riders if invalid
            }
            
            ride.unassignedView = view;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function updateDebugOutput() {
            const debugEl = document.getElementById('auto-assign-debug');
            const copyBtn = document.getElementById('copy-debug-btn');
            if (!debugEl) return;
            if (autoAssignDebugLog) {
                debugEl.style.display = 'block';
                debugEl.textContent = autoAssignDebugLog;
                if (copyBtn) copyBtn.style.display = 'block';
            } else {
                debugEl.style.display = 'none';
                debugEl.textContent = '';
                if (copyBtn) copyBtn.style.display = 'none';
            }
        }
        
        function copyDebugToClipboard() {
            if (!autoAssignDebugLog) return;
            navigator.clipboard.writeText(autoAssignDebugLog).then(() => {
                const btn = document.getElementById('copy-debug-btn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        }

        function addGroup() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Save state before change
            saveAssignmentState(ride);
            
            // Find next available group number
            const existingLabels = ride.groups.map(g => g.label).filter(Boolean);
            let nextNumber = 1;
            while (existingLabels.includes(`Group ${nextNumber}`)) {
                nextNumber++;
            }
            const group = createGroup(`Group ${nextNumber}`);
            ride.groups.push(group);
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeGroupSort(groupId, sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            group.sortBy = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeUnassignedRidersSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            ride.unassignedRidersSort = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeUnassignedCoachesSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'level', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            ride.unassignedCoachesSort = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function deleteGroup(groupId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            const numericId = parseInt(groupId, 10);
            if (!Number.isFinite(numericId)) return;

            const group = findGroupById(ride, numericId);
            if (!group) return;

            if (!confirm('Delete this group? Riders will move back to the unassigned list.')) {
                return;
            }
            
            // Save state before change
            saveAssignmentState(ride);

            ride.groups = ride.groups.filter(g => g.id !== numericId);
            // Don't renumber - keep other group names persistent
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        // Drag and drop functions
        function allowDrop(ev) {
            let payload;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('application/json') || '{}');
            } catch (err) {
                payload = {};
            }
            const expectedType = ev.currentTarget.dataset.dropType;
            if (expectedType && payload.type && expectedType !== payload.type) {
                return;
            }
            ev.preventDefault();
            
            // Highlight drop target
            const target = ev.currentTarget;
            if (target.classList.contains('coach-inline-item')) {
                // Highlighting a coach name
                target.style.background = '#e3f2fd';
                target.style.border = '2px solid #1976d2';
            } else if (target.classList.contains('coach-drop-zone')) {
                // Highlighting dropzone
                target.style.background = '#e3f2fd';
                target.style.borderColor = '#1976d2';
                target.style.borderStyle = 'solid';
                // Hide the text when dragging over
                const textSpan = target.querySelector('span');
                if (textSpan) textSpan.style.opacity = '0.5';
            }
            target.classList.add('drag-over');
        }

        function dragLeave(ev) {
            const target = ev.currentTarget;
            target.classList.remove('drag-over');
            
            // Remove highlight
            if (target.classList.contains('coach-inline-item')) {
                const index = parseInt(target.dataset.insertPosition || '0', 10);
                target.style.background = index % 2 === 0 ? '#f9f9f9' : '#fff';
                target.style.border = 'none';
            } else if (target.classList.contains('coach-drop-zone')) {
                target.style.background = '#f9f9f9';
                target.style.borderColor = '#ccc';
                target.style.borderStyle = 'dashed';
                // Show the text again when leaving
                const textSpan = target.querySelector('span');
                if (textSpan) textSpan.style.opacity = '1';
            }
        }

        // Auto-scroll during drag
        let autoScrollInterval = null;
        let isAssignmentDragging = false;
        let currentMouseY = 0;

        function ensureScrollIndicators() {
            if (document.getElementById('drag-scroll-top') && document.getElementById('drag-scroll-bottom')) {
                return;
            }
            const topIndicator = document.createElement('div');
            topIndicator.id = 'drag-scroll-top';
            topIndicator.style.position = 'fixed';
            topIndicator.style.top = '0';
            topIndicator.style.left = '0';
            topIndicator.style.right = '0';
            topIndicator.style.height = '100px';
            topIndicator.style.pointerEvents = 'none';
            topIndicator.style.background = 'rgba(33, 150, 243, 0.15)';
            topIndicator.style.borderBottom = '1px dashed rgba(33, 150, 243, 0.5)';
            topIndicator.style.opacity = '0';
            topIndicator.style.transition = 'opacity 0.15s ease';
            topIndicator.style.zIndex = '9999';

            const bottomIndicator = document.createElement('div');
            bottomIndicator.id = 'drag-scroll-bottom';
            bottomIndicator.style.position = 'fixed';
            bottomIndicator.style.bottom = '0';
            bottomIndicator.style.left = '0';
            bottomIndicator.style.right = '0';
            bottomIndicator.style.height = '100px';
            bottomIndicator.style.pointerEvents = 'none';
            bottomIndicator.style.background = 'rgba(33, 150, 243, 0.15)';
            bottomIndicator.style.borderTop = '1px dashed rgba(33, 150, 243, 0.5)';
            bottomIndicator.style.opacity = '0';
            bottomIndicator.style.transition = 'opacity 0.15s ease';
            bottomIndicator.style.zIndex = '9999';

            document.body.appendChild(topIndicator);
            document.body.appendChild(bottomIndicator);
        }

        // Add global mousemove listener to track mouse position during drag
        if (!window.dragScrollListenerAdded) {
            document.addEventListener('mousemove', (e) => {
                if (isAssignmentDragging) {
                    currentMouseY = e.clientY;
                    checkAndScroll();
                }
            });
            document.addEventListener('dragover', (e) => {
                if (isAssignmentDragging) {
                    currentMouseY = e.clientY;
                    checkAndScroll();
                }
            });
            window.dragScrollListenerAdded = true;
        }

        // Auto-scroll functionality
        function startAutoScroll() {
            // Clear any existing interval
            stopAutoScroll();
            
            // Check mouse position periodically during drag
            autoScrollInterval = setInterval(() => {
                if (!isAssignmentDragging) {
                    stopAutoScroll();
                    return;
                }
                
                // Get mouse position (we'll track this via document mousemove)
                checkAndScroll();
            }, 50); // Check every 50ms
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
        }

        function checkAndScroll() {
            if (!isAssignmentDragging) return;
            
            const viewportHeight = window.innerHeight;
            const scrollTriggerZone = 100; // 100px from bottom
            const scrollSpeed = 15; // Pixels to scroll per check
            ensureScrollIndicators();
            const topIndicator = document.getElementById('drag-scroll-top');
            const bottomIndicator = document.getElementById('drag-scroll-bottom');
            if (topIndicator && bottomIndicator) {
                topIndicator.style.opacity = '0.25';
                bottomIndicator.style.opacity = '0.25';
            }
            
            // Check if mouse is in the bottom scroll trigger zone
            const distanceFromBottom = viewportHeight - currentMouseY;
            
            if (distanceFromBottom < scrollTriggerZone && distanceFromBottom > 0) {
                if (bottomIndicator) bottomIndicator.style.opacity = '0.7';
                // Calculate scroll amount based on how close to bottom
                // Closer to bottom = faster scroll
                const scrollAmount = Math.max(5, scrollSpeed * (1 - (distanceFromBottom / scrollTriggerZone)));
                
                // Scroll down
                window.scrollBy({
                    top: scrollAmount,
                    behavior: 'auto' // Instant scroll for smooth dragging
                });
            }
            
            // Also check top of viewport for scrolling up
            const scrollTriggerZoneTop = 100; // 100px from top
            if (currentMouseY < scrollTriggerZoneTop && currentMouseY > 0) {
                if (topIndicator) topIndicator.style.opacity = '0.7';
                const scrollAmount = Math.max(5, scrollSpeed * (1 - (currentMouseY / scrollTriggerZoneTop)));
                window.scrollBy({
                    top: -scrollAmount,
                    behavior: 'auto'
                });
            }
        }

        function drag(ev) {
            const type = ev.target.dataset.dragType;
            if (!type) return;

            const payload = { type };
            if (type === 'rider') {
                payload.riderId = parseInt(ev.target.dataset.riderId, 10);
            } else if (type === 'coach') {
                payload.coachId = parseInt(ev.target.dataset.coachId, 10);
                if (ev.target.dataset.sourceGroupId) {
                    payload.sourceGroupId = ev.target.dataset.sourceGroupId;
                }
                if (ev.target.dataset.sourceRole) {
                    payload.sourceRole = ev.target.dataset.sourceRole;
                }
            } else {
                return;
            }

            ev.dataTransfer.setData('application/json', JSON.stringify(payload));
            ev.target.classList.add('dragging');
            
            // Start auto-scroll monitoring
            isAssignmentDragging = true;
            ensureScrollIndicators();
            startAutoScroll();
        }

        function dragEnd(ev) {
            ev.target.classList.remove('dragging');
            
            // Stop auto-scroll monitoring
            isAssignmentDragging = false;
            stopAutoScroll();
            const topIndicator = document.getElementById('drag-scroll-top');
            const bottomIndicator = document.getElementById('drag-scroll-bottom');
            if (topIndicator) topIndicator.style.opacity = '0';
            if (bottomIndicator) bottomIndicator.style.opacity = '0';
        }

        function drop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.remove('drag-over');
            
            let payload = null;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('application/json'));
            } catch (err) {
                payload = null;
            }
            if (!payload || !payload.type) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (payload.type === 'rider') {
                handleRiderDrop(ride, payload, ev.currentTarget);
            } else if (payload.type === 'coach') {
                handleCoachDrop(ride, payload, ev.currentTarget, ev);
            }

            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        }

        function handleRiderDrop(ride, payload, dropTarget) {
            const riderId = parseInt(payload.riderId, 10);
            if (!Number.isFinite(riderId)) return;

            const dropType = dropTarget.dataset.dropType;
            if (dropType && dropType !== 'rider') return;

            const targetGroupId = dropTarget.dataset.groupId;
            let previousGroupId = null;

            ride.groups.forEach(group => {
                if (group.riders.includes(riderId)) {
                    previousGroupId = group.id;
                }
            });

            removeRiderFromGroups(ride, riderId);

            if (targetGroupId !== 'unassigned') {
                const numericGroupId = parseInt(targetGroupId, 10);
                const group = findGroupById(ride, numericGroupId);
                if (!group) {
                    if (previousGroupId !== null) {
                        const previousGroup = findGroupById(ride, previousGroupId);
                        if (previousGroup) {
                            previousGroup.riders.push(riderId);
                        }
                    }
                    renderAssignments(ride);
                    return;
                }

                const coachCount = countGroupCoaches(group);
                if (coachCount === 0) {
                    alert('Assign at least one coach before adding riders to this group.');
                    if (previousGroupId !== null) {
                        const previousGroup = findGroupById(ride, previousGroupId);
                        if (previousGroup) {
                            previousGroup.riders.push(riderId);
                        }
                    }
                    renderAssignments(ride);
                    return;
                }

                // Allow adding riders even if it exceeds capacity - group will be marked as non-compliant (red)
                // This allows flexibility when moving things around
                if (!group.riders.includes(riderId)) {
                    group.riders.push(riderId);
                    const rider = getRiderById(riderId);
                    if (!group.fitnessTag && rider) {
                        group.fitnessTag = rider.fitness || null;
                    }
                }
            }
            
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        let pendingCoachMove = null;
        
        // Undo/Redo history for group assignments
        let assignmentHistory = [];
        let assignmentHistoryIndex = -1;
        const MAX_HISTORY = 50; // Limit history to prevent memory issues
        let isUndoRedoInProgress = false; // Flag to prevent saving state during undo/redo
        
        // Save current state of group assignments for undo/redo
        function saveAssignmentState(ride) {
            if (!ride || isUndoRedoInProgress) return; // Don't save during undo/redo
            
            // Deep clone the groups and available riders/coaches
            const state = {
                rideId: ride.id,
                groups: JSON.parse(JSON.stringify(ride.groups || [])),
                availableRiders: [...(ride.availableRiders || [])],
                availableCoaches: [...(ride.availableCoaches || [])]
            };
            
            // Remove any history after current index (when doing a new action after undo)
            if (assignmentHistoryIndex < assignmentHistory.length - 1) {
                assignmentHistory = assignmentHistory.slice(0, assignmentHistoryIndex + 1);
            }
            
            // Add new state to history
            assignmentHistory.push(state);
            
            // Limit history size
            if (assignmentHistory.length > MAX_HISTORY) {
                assignmentHistory.shift();
            } else {
                assignmentHistoryIndex++;
            }
            
            // Update button states
            updateUndoRedoButtons();
        }
        
        // Undo last assignment change
        function undoAssignmentChange() {
            if (assignmentHistoryIndex < 0) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Set flag to prevent saving state during undo
            isUndoRedoInProgress = true;
            
            // Check if current state matches the last saved state (don't undo if already at this state)
            if (assignmentHistoryIndex === assignmentHistory.length - 1) {
                // Move back one step
                assignmentHistoryIndex--;
            }
            
            if (assignmentHistoryIndex < 0) {
                isUndoRedoInProgress = false;
                updateUndoRedoButtons();
                return;
            }
            
            // Restore previous state
            const previousState = assignmentHistory[assignmentHistoryIndex];
            if (!previousState || previousState.rideId !== ride.id) {
                isUndoRedoInProgress = false;
                updateUndoRedoButtons();
                return;
            }
            
            // Restore groups and available lists
            ride.groups = JSON.parse(JSON.stringify(previousState.groups));
            ride.availableRiders = [...previousState.availableRiders];
            ride.availableCoaches = [...previousState.availableCoaches];
            
            // Save and render
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
            
            // Clear flag and update button states
            isUndoRedoInProgress = false;
            updateUndoRedoButtons();
        }
        
        // Redo last undone change
        function redoAssignmentChange() {
            if (assignmentHistoryIndex >= assignmentHistory.length - 1) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Set flag to prevent saving state during redo
            isUndoRedoInProgress = true;
            
            // Move forward one step
            assignmentHistoryIndex++;
            
            const nextState = assignmentHistory[assignmentHistoryIndex];
            if (!nextState || nextState.rideId !== ride.id) {
                assignmentHistoryIndex--; // Revert if state doesn't match
                isUndoRedoInProgress = false;
                updateUndoRedoButtons();
                return;
            }
            
            // Restore next state
            ride.groups = JSON.parse(JSON.stringify(nextState.groups));
            ride.availableRiders = [...nextState.availableRiders];
            ride.availableCoaches = [...nextState.availableCoaches];
            
            // Save and render
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
            
            // Clear flag and update button states
            isUndoRedoInProgress = false;
            updateUndoRedoButtons();
        }
        
        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                const canUndo = assignmentHistoryIndex >= 0;
                undoBtn.disabled = !canUndo;
                undoBtn.style.opacity = canUndo ? '1' : '0.5';
                undoBtn.style.cursor = canUndo ? 'pointer' : 'not-allowed';
            }
            
            if (redoBtn) {
                const canRedo = assignmentHistoryIndex < assignmentHistory.length - 1;
                redoBtn.disabled = !canRedo;
                redoBtn.style.opacity = canRedo ? '1' : '0.5';
                redoBtn.style.cursor = canRedo ? 'pointer' : 'not-allowed';
            }
        }
        
        // Clear history when switching rides or clearing assignments
        function clearAssignmentHistory() {
            assignmentHistory = [];
            assignmentHistoryIndex = -1;
            updateUndoRedoButtons();
        }
        
        function showCoachMoveMenu(event, coachId, groupId, rideId) {
            const menu = document.getElementById('coach-move-context-menu');
            if (!menu) return;
            
            const ride = data.rides.find(r => r.id === rideId);
            if (!ride) return;
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            const currentRole = getCoachRoleInGroup(group, coachId);
            if (!currentRole) return;
            
            // Store move info
            pendingCoachMove = { ride, coachId, groupId, rideId };
            
            // Build role options (other roles in current group)
            const roleOptionsDiv = document.getElementById('coach-move-role-options');
            roleOptionsDiv.innerHTML = '';
            
            const roles = ['leader', 'sweep', 'roam'];
            roles.forEach(role => {
                if (role !== currentRole && role !== 'extraRoam') {
                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                    const hasCoach = role === 'leader' ? group.coaches.leader : role === 'sweep' ? group.coaches.sweep : group.coaches.roam;
                    
                    // Check if coach can be leader (must meet minimum level requirement)
                    const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (role === 'leader' && (!Number.isFinite(level) || level < minLeaderLevel)) {
                        return; // Skip leader option if not eligible
                    }
                    
                    const button = document.createElement('button');
                    button.className = 'context-menu-item';
                    button.style.cssText = 'width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;';
                    button.textContent = hasCoach ? `Swap with ${roleLabel}` : `Move to ${roleLabel}`;
                    button.onclick = () => {
                        moveCoachToRole(ride, coachId, groupId, role);
                        menu.style.display = 'none';
                        pendingCoachMove = null;
                    };
                    roleOptionsDiv.appendChild(button);
                }
            });
            
            // Build group options (other groups)
            const groupOptionsDiv = document.getElementById('coach-move-group-options');
            groupOptionsDiv.innerHTML = '';
            
            ride.groups.forEach(otherGroup => {
                if (otherGroup.id !== groupId) {
                    const button = document.createElement('button');
                    button.className = 'context-menu-item';
                    button.style.cssText = 'width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;';
                    const groupLabel = otherGroup.label || `Group ${otherGroup.id}`;
                    button.textContent = `Move to ${groupLabel}`;
                    button.onclick = () => {
                        moveCoachToGroup(ride, coachId, groupId, otherGroup.id);
                        menu.style.display = 'none';
                        pendingCoachMove = null;
                    };
                    groupOptionsDiv.appendChild(button);
                }
            });
            
            // Position menu at button location
            menu.style.display = 'block';
            const rect = event.target.getBoundingClientRect();
            menu.style.left = `${rect.right + 5}px`;
            menu.style.top = `${rect.top}px`;
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && e.target !== event.target) {
                    menu.style.display = 'none';
                    pendingCoachMove = null;
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }
        
        function moveCoachToRole(ride, coachId, groupId, targetRole) {
            // Save state before change
            saveAssignmentState(ride);
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            // Check minimum level requirement for leader
            if (targetRole === 'leader') {
                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                if (!Number.isFinite(level) || level < minLeaderLevel) {
                    alert(`Only Level ${minLeaderLevel} or higher coaches can serve as leader.`);
                    return;
                }
            }
            
            const currentRole = getCoachRoleInGroup(group, coachId);
            if (!currentRole) return;
            
            // Get the coach currently in the target role
            let targetCoachId = null;
            if (targetRole === 'leader') targetCoachId = group.coaches.leader;
            else if (targetRole === 'sweep') targetCoachId = group.coaches.sweep;
            else if (targetRole === 'roam') targetCoachId = group.coaches.roam;
            
            // Swap roles
            if (targetCoachId) {
                // Clear both roles
                if (currentRole === 'leader') group.coaches.leader = null;
                else if (currentRole === 'sweep') group.coaches.sweep = null;
                else if (currentRole === 'roam') group.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(group.coaches.extraRoam)) {
                    const index = group.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                }
                
                // Assign coaches to new roles
                if (targetRole === 'leader') group.coaches.leader = coachId;
                else if (targetRole === 'sweep') group.coaches.sweep = coachId;
                else if (targetRole === 'roam') group.coaches.roam = coachId;
                
                // Assign target coach to current role
                if (currentRole === 'leader') group.coaches.leader = targetCoachId;
                else if (currentRole === 'sweep') group.coaches.sweep = targetCoachId;
                else if (currentRole === 'roam') group.coaches.roam = targetCoachId;
                else if (currentRole === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) group.coaches.extraRoam = [];
                    group.coaches.extraRoam.push(targetCoachId);
                }
            } else {
                // Target role is empty, just move coach
                if (currentRole === 'leader') group.coaches.leader = null;
                else if (currentRole === 'sweep') group.coaches.sweep = null;
                else if (currentRole === 'roam') group.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(group.coaches.extraRoam)) {
                    const index = group.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                }
                
                if (targetRole === 'leader') group.coaches.leader = coachId;
                else if (targetRole === 'sweep') group.coaches.sweep = coachId;
                else if (targetRole === 'roam') group.coaches.roam = coachId;
            }
            
            // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead
            
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function moveCoachToGroup(ride, coachId, sourceGroupId, targetGroupId) {
            // Save state before change
            saveAssignmentState(ride);
            
            const sourceGroup = findGroupById(ride, sourceGroupId);
            const targetGroup = findGroupById(ride, targetGroupId);
            if (!sourceGroup || !targetGroup) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            // Remove coach from source group
            const currentRole = getCoachRoleInGroup(sourceGroup, coachId);
            if (currentRole) {
                if (currentRole === 'leader') sourceGroup.coaches.leader = null;
                else if (currentRole === 'sweep') sourceGroup.coaches.sweep = null;
                else if (currentRole === 'roam') sourceGroup.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(sourceGroup.coaches.extraRoam)) {
                    const index = sourceGroup.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) sourceGroup.coaches.extraRoam.splice(index, 1);
                }
            }
            
            // Ensure coach is available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            
            // Add to target group at next available position
            if (!targetGroup.coaches.leader) {
                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                if (Number.isFinite(level) && level >= minLeaderLevel) {
                    targetGroup.coaches.leader = coachId;
                } else {
                    targetGroup.coaches.sweep = coachId;
                }
            } else if (!targetGroup.coaches.sweep) {
                targetGroup.coaches.sweep = coachId;
            } else if (!targetGroup.coaches.roam) {
                targetGroup.coaches.roam = coachId;
            } else {
                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                    targetGroup.coaches.extraRoam = [];
                }
                targetGroup.coaches.extraRoam.push(coachId);
            }
            
            // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead
            
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function showCoachDropContextMenu(event, ride, coachId, groupId, targetCoachId = null) {
            const menu = document.getElementById('coach-drop-context-menu');
            if (!menu) return;
            
            // Store drop info for context menu actions
            pendingCoachDrop = { ride, coachId, groupId, targetCoachId };
            
            // Position menu at drop location
            menu.style.display = 'block';
            menu.style.left = `${event.clientX}px`;
            menu.style.top = `${event.clientY}px`;
            
            // Remove existing event listeners by cloning
            const addBtn = document.getElementById('coach-drop-add');
            const swapBtn = document.getElementById('coach-drop-swap');
            
            const newAddBtn = addBtn.cloneNode(true);
            const newSwapBtn = swapBtn.cloneNode(true);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);
            swapBtn.parentNode.replaceChild(newSwapBtn, swapBtn);
            
            // Update button text if dropping on specific coach
            if (targetCoachId) {
                const targetCoach = getCoachById(targetCoachId);
                newSwapBtn.textContent = targetCoach ? `Swap with ${targetCoach.name}` : 'Swap with Coach';
                newAddBtn.textContent = 'Add Coach to Group';
            } else {
                newSwapBtn.textContent = 'Swap with Coach';
                newAddBtn.textContent = 'Add Coach to Group';
            }
            
            // Add new event listeners
            newAddBtn.addEventListener('click', handleCoachDropAdd);
            newSwapBtn.addEventListener('click', handleCoachDropSwap);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.style.display = 'none';
                    pendingCoachDrop = null;
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }
        
        function handleCoachDropAdd() {
            if (!pendingCoachDrop) return;
            const { ride, coachId, groupId } = pendingCoachDrop;
            const menu = document.getElementById('coach-drop-context-menu');
            if (menu) menu.style.display = 'none';
            
            const group = findGroupById(ride, groupId);
            if (!group) {
                pendingCoachDrop = null;
                return;
            }
            
            // Save state before change
            saveAssignmentState(ride);
            
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            addCoachToGroup(ride, coachId, groupId);
            
            // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead
            
            saveRideToDB(ride);
            renderAssignments(ride);
            pendingCoachDrop = null;
        }
        
        function handleCoachDropSwap() {
            if (!pendingCoachDrop) return;
            const { ride, coachId, groupId, targetCoachId } = pendingCoachDrop;
            const menu = document.getElementById('coach-drop-context-menu');
            if (menu) menu.style.display = 'none';
            
            // Save state before change
            saveAssignmentState(ride);
            
            if (targetCoachId) {
                // Direct swap with specific coach
                swapCoachWithTarget(ride, coachId, groupId, targetCoachId);
                // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead
                saveRideToDB(ride);
                renderAssignments(ride);
            } else {
                // For swap when dropping on group container, show selection dialog
                swapCoachInGroup(ride, coachId, groupId);
            }
            pendingCoachDrop = null;
        }
        
        function insertCoachAtPosition(ride, coachId, groupId, position) {
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Remove coach from any other groups first
            removeCoachFromGroups(ride, coachId);
            
            // Get current coaches in order
            const coachesOrder = [];
            if (group.coaches.leader) coachesOrder.push({ id: group.coaches.leader, role: 'leader' });
            if (group.coaches.sweep) coachesOrder.push({ id: group.coaches.sweep, role: 'sweep' });
            if (group.coaches.roam) coachesOrder.push({ id: group.coaches.roam, role: 'roam' });
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) coachesOrder.push({ id, role: 'extraRoam' });
                });
            }
            
            // Insert at position
            coachesOrder.splice(position, 0, { id: coachId, role: null });
            
            // Clear all roles
            group.coaches.leader = null;
            group.coaches.sweep = null;
            group.coaches.roam = null;
            group.coaches.extraRoam = [];
            
            // Reassign roles based on new order: Leader, Sweep, Roam, then Roam for rest
            coachesOrder.forEach((coach, index) => {
                const coachObj = getCoachById(coach.id);
                if (!coachObj) return;
                
                if (index === 0) {
                    // First position = Leader (only if meets minimum level requirement)
                    const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (Number.isFinite(level) && level >= minLeaderLevel) {
                        group.coaches.leader = coach.id;
                    } else {
                        // Not eligible for leader, assign as sweep
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 1) {
                    // Second position = Sweep (or Leader if first wasn't eligible)
                    if (!group.coaches.leader) {
                        const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                        const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                        if (Number.isFinite(level) && level >= minLeaderLevel) {
                            group.coaches.leader = coach.id;
                        } else {
                            group.coaches.sweep = coach.id;
                        }
                    } else {
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 2) {
                    // Third position = Roam
                    group.coaches.roam = coach.id;
                } else {
                    // Additional coaches = Roam (in extraRoam array)
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam.push(coach.id);
                }
            });
        }
        
        function swapCoachWithTarget(ride, coachId, groupId, targetCoachId) {
            // Save state before change
            saveAssignmentState(ride);
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Get the role of the target coach (the one being dropped on)
            const targetRole = getCoachRoleInGroup(group, targetCoachId);
            if (!targetRole) {
                // Target coach not in this group, just add the dragged coach
                if (!ride.availableCoaches.includes(coachId)) {
                    ride.availableCoaches.push(coachId);
                }
                addCoachToGroup(ride, coachId, groupId);
                return;
            }
            
            // Find the dragged coach's current role and group
            let draggedCoachRole = null;
            let draggedCoachGroupId = null;
            ride.groups.forEach(g => {
                const role = getCoachRoleInGroup(g, coachId);
                if (role) {
                    draggedCoachRole = role;
                    draggedCoachGroupId = g.id;
                }
            });
            
            // Ensure both coaches are available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            if (!ride.availableCoaches.includes(targetCoachId)) {
                ride.availableCoaches.push(targetCoachId);
            }
            
            // First, assign dragged coach to target's role (before clearing target)
            if (targetRole === 'extraRoam') {
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                }
                // Remove target from extraRoam first
                const targetIndex = group.coaches.extraRoam.indexOf(targetCoachId);
                if (targetIndex >= 0) {
                    group.coaches.extraRoam.splice(targetIndex, 1);
                }
                // Add dragged coach
                group.coaches.extraRoam.push(coachId);
            } else {
                // Store target's role temporarily
                // Assign dragged coach to target's role
                group.coaches[targetRole] = coachId;
            }
            
            // Now handle the target coach - assign it to dragged coach's old role
            if (draggedCoachRole) {
                if (draggedCoachGroupId === groupId) {
                    // Both coaches in same group - assign target to dragged coach's old role
                    if (draggedCoachRole === 'extraRoam') {
                        if (!Array.isArray(group.coaches.extraRoam)) {
                            group.coaches.extraRoam = [];
                        }
                        // Remove dragged coach from extraRoam (it's already been moved to targetRole)
                        const draggedIndex = group.coaches.extraRoam.indexOf(coachId);
                        if (draggedIndex >= 0) {
                            group.coaches.extraRoam.splice(draggedIndex, 1);
                        }
                        // Add target to extraRoam
                        group.coaches.extraRoam.push(targetCoachId);
                    } else {
                        // Dragged coach was in a different role, assign target to that role
                        group.coaches[draggedCoachRole] = targetCoachId;
                    }
                } else {
                    // Dragged coach was in different group - assign target to that group/role
                    const sourceGroup = findGroupById(ride, draggedCoachGroupId);
                    if (sourceGroup) {
                        // Remove dragged coach from source group
                        if (draggedCoachRole === 'extraRoam') {
                            if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                                const index = sourceGroup.coaches.extraRoam.indexOf(coachId);
                                if (index >= 0) {
                                    sourceGroup.coaches.extraRoam.splice(index, 1);
                                }
                            }
                        } else {
                            sourceGroup.coaches[draggedCoachRole] = null;
                        }
                        // Assign target to source group
                        if (draggedCoachRole === 'extraRoam') {
                            if (!Array.isArray(sourceGroup.coaches.extraRoam)) {
                                sourceGroup.coaches.extraRoam = [];
                            }
                            sourceGroup.coaches.extraRoam.push(targetCoachId);
                        } else {
                            sourceGroup.coaches[draggedCoachRole] = targetCoachId;
                        }
                    }
                }
            } else {
                // Dragged coach had no role - target becomes unassigned (already cleared above when we assigned dragged coach)
            }
        }

        function handleCoachDrop(ride, payload, dropTarget, ev) {
            const coachId = parseInt(payload.coachId, 10);
            if (!Number.isFinite(coachId)) return;

            const dropType = dropTarget.dataset.dropType;
            if (dropType && dropType !== 'coach') return;

            // Save state before change
            saveAssignmentState(ride);

            const targetRole = dropTarget.dataset.role || null;
            const targetGroupIdAttr = dropTarget.dataset.groupId;
            const sourceGroupId = payload.sourceGroupId ? parseInt(payload.sourceGroupId, 10) : null;

            const coach = getCoachById(coachId);
            if (!coach) {
                alert('Selected coach no longer exists.');
                renderAssignments(ride);
                return;
            }

            // Handle drop to unassigned
            if (targetGroupIdAttr === 'unassigned' || !targetGroupIdAttr) {
                removeCoachFromGroups(ride, coachId);
                saveRideToDB(ride);
                renderAssignments(ride);
                return;
            }

            const numericGroupId = parseInt(targetGroupIdAttr, 10);
            if (!Number.isFinite(numericGroupId)) return;

            const group = findGroupById(ride, numericGroupId);
            if (!group) return;

            // Check if dropping on another coach in the same group (reordering)
            if (dropTarget.classList.contains('coach-inline-item')) {
                const targetCoachId = parseInt(dropTarget.dataset.coachId, 10);
                const targetRole = dropTarget.dataset.role;
                
                // If dropping on a coach in the same group, swap roles
                if (sourceGroupId === numericGroupId && Number.isFinite(targetCoachId) && targetCoachId !== coachId) {
                    const draggedRole = payload.sourceRole;
                    const targetCoach = getCoachById(targetCoachId);
                    
                    if (targetCoach && draggedRole) {
                        // Swap the coaches' roles
                        // First, clear both roles temporarily
                        if (draggedRole === 'extraRoam') {
                            if (Array.isArray(group.coaches.extraRoam)) {
                                const index = group.coaches.extraRoam.indexOf(coachId);
                                if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                            }
                        } else {
                            group.coaches[draggedRole] = null;
                        }
                        
                        if (targetRole === 'extraRoam') {
                            if (Array.isArray(group.coaches.extraRoam)) {
                                const index = group.coaches.extraRoam.indexOf(targetCoachId);
                                if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                            }
                        } else {
                            group.coaches[targetRole] = null;
                        }
                        
                        // Assign dragged coach to target's role
                        if (targetRole === 'extraRoam') {
                            if (!Array.isArray(group.coaches.extraRoam)) {
                                group.coaches.extraRoam = [];
                            }
                            if (!group.coaches.extraRoam.includes(coachId)) {
                                group.coaches.extraRoam.push(coachId);
                            }
                        } else {
                            // Check level requirement for leader
                            if (targetRole === 'leader') {
                                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                                if (!Number.isFinite(level) || level < minLeaderLevel) {
                                    // Can't be leader, restore original state
                                    if (draggedRole === 'extraRoam') {
                                        if (!Array.isArray(group.coaches.extraRoam)) {
                                            group.coaches.extraRoam = [];
                                        }
                                        if (!group.coaches.extraRoam.includes(coachId)) {
                                            group.coaches.extraRoam.push(coachId);
                                        }
                                    } else {
                                        group.coaches[draggedRole] = coachId;
                                    }
                                    if (targetRole === 'extraRoam') {
                                        if (!Array.isArray(group.coaches.extraRoam)) {
                                            group.coaches.extraRoam = [];
                                        }
                                        if (!group.coaches.extraRoam.includes(targetCoachId)) {
                                            group.coaches.extraRoam.push(targetCoachId);
                                        }
                                    } else {
                                        group.coaches[targetRole] = targetCoachId;
                                    }
                                    alert('Only Level 2 or Level 3 coaches can serve as leader.');
                                    saveRideToDB(ride);
                                    renderAssignments(ride);
                                    return;
                                }
                            }
                            group.coaches[targetRole] = coachId;
                        }
                        
                        // Assign target coach to dragged coach's role
                        if (draggedRole === 'extraRoam') {
                            if (!Array.isArray(group.coaches.extraRoam)) {
                                group.coaches.extraRoam = [];
                            }
                            if (!group.coaches.extraRoam.includes(targetCoachId)) {
                                group.coaches.extraRoam.push(targetCoachId);
                            }
                        } else {
                            // Check level requirement for leader
                            if (draggedRole === 'leader') {
                                const targetLevel = parseInt(targetCoach.coachingLicenseLevel || targetCoach.level || '1', 10);
                                if (!Number.isFinite(targetLevel) || targetLevel < 2) {
                                    // Target can't be leader, assign to sweep instead
                                    if (!group.coaches.sweep) {
                                        group.coaches.sweep = targetCoachId;
                                    } else if (!group.coaches.roam) {
                                        group.coaches.roam = targetCoachId;
                                    } else {
                                        if (!Array.isArray(group.coaches.extraRoam)) {
                                            group.coaches.extraRoam = [];
                                        }
                                        if (!group.coaches.extraRoam.includes(targetCoachId)) {
                                            group.coaches.extraRoam.push(targetCoachId);
                                        }
                                    }
                                } else {
                                    group.coaches[draggedRole] = targetCoachId;
                                }
                            } else {
                                group.coaches[draggedRole] = targetCoachId;
                            }
                        }
                        
                        saveRideToDB(ride);
                        renderAssignments(ride);
                        return;
                    }
                }
            }

            // If dropping to a dropzone with a specific role (like leader drop zone), assign to that role
            if (targetRole && targetRole !== 'unassigned') {
                // Dropping to a specific role slot (e.g., leader drop zone)
                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                if (targetRole === 'leader' && (!Number.isFinite(level) || level < minLeaderLevel)) {
                    alert(`Only Level ${minLeaderLevel} or higher coaches can serve as leader.`);
                    renderAssignments(ride);
                    return;
                }

                if (!ride.availableCoaches.includes(coachId)) {
                    ride.availableCoaches.push(coachId);
                }

                assignCoachToGroup(ride, coachId, numericGroupId, targetRole);
            } else {
                // If dropping to a dropzone (no specific role), add coach to group
                // Remove coach from source group if moving from another group
                if (sourceGroupId && sourceGroupId !== numericGroupId) {
                    removeCoachFromGroups(ride, coachId);
                }
                
                // Add coach to target group (will assign to first available role)
                addCoachToGroup(ride, coachId, numericGroupId);
            }

            // Note: Riders are NOT automatically unassigned - group will be marked non-compliant instead

            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function getCoachRoleInGroup(group, coachId) {
            if (group.coaches.leader === coachId) return 'leader';
            if (group.coaches.sweep === coachId) return 'sweep';
            if (group.coaches.roam === coachId) return 'roam';
            if (Array.isArray(group.coaches.extraRoam) && group.coaches.extraRoam.includes(coachId)) return 'extraRoam';
            return null;
        }
        
        function addCoachToGroup(ride, coachId, groupId) {
            const group = findGroupById(ride, groupId);
            if (!group) return false;
            
            // Remove coach from any other groups first
            removeCoachFromGroups(ride, coachId);
            
            // Ensure coach is marked as available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            
            // Add to first available role: leader, sweep, roam, then extraRoam
            if (!group.coaches.leader) {
                const coach = getCoachById(coachId);
                if (coach) {
                    const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (Number.isFinite(level) && level >= minLeaderLevel) {
                        group.coaches.leader = coachId;
                        return true;
                    }
                }
            }
            if (!group.coaches.sweep) {
                group.coaches.sweep = coachId;
                return true;
            }
            if (!group.coaches.roam) {
                group.coaches.roam = coachId;
                return true;
            }
            // Add to extraRoam
            if (!Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam = [];
            }
            if (!group.coaches.extraRoam.includes(coachId)) {
                group.coaches.extraRoam.push(coachId);
                return true;
            }
            return false;
        }
        
        function swapCoachInGroup(ride, coachId, groupId) {
            // Save state before change
            saveAssignmentState(ride);
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Get list of coaches in group
            const coachesInGroup = [];
            if (group.coaches.leader) {
                const coach = getCoachById(group.coaches.leader);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'leader' });
            }
            if (group.coaches.sweep) {
                const coach = getCoachById(group.coaches.sweep);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'sweep' });
            }
            if (group.coaches.roam) {
                const coach = getCoachById(group.coaches.roam);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'roam' });
            }
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) {
                        const coach = getCoachById(id);
                        if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'extraRoam' });
                    }
                });
            }
            
            if (coachesInGroup.length === 0) {
                addCoachToGroup(ride, coachId, groupId);
                return;
            }
            
            // Show selection dialog
            const coachList = coachesInGroup.map((c, i) => `${i + 1}. ${c.name}`).join('\n');
            const selection = prompt(`Select coach to swap with (1-${coachesInGroup.length}):\n\n${coachList}`);
            const selectedIndex = parseInt(selection, 10) - 1;
            
            if (selectedIndex >= 0 && selectedIndex < coachesInGroup.length) {
                const targetCoach = coachesInGroup[selectedIndex];
                const targetRole = targetCoach.role;
                
                // Swap the coaches
                assignCoachToGroup(ride, coachId, groupId, targetRole);
            }
        }
        
        function reorderCoachesInGroup(ride, group, draggedCoachId, targetCoachId) {
            // Get current order of coaches
            const coachesOrder = [];
            if (group.coaches.leader) coachesOrder.push({ id: group.coaches.leader, role: 'leader' });
            if (group.coaches.sweep) coachesOrder.push({ id: group.coaches.sweep, role: 'sweep' });
            if (group.coaches.roam) coachesOrder.push({ id: group.coaches.roam, role: 'roam' });
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) coachesOrder.push({ id, role: 'extraRoam' });
                });
            }
            
            // Find indices
            const draggedIndex = coachesOrder.findIndex(c => c.id === draggedCoachId);
            const targetIndex = coachesOrder.findIndex(c => c.id === targetCoachId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove dragged coach from its position
            const draggedCoach = coachesOrder.splice(draggedIndex, 1)[0];
            
            // Insert at target position
            const newIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
            coachesOrder.splice(newIndex, 0, draggedCoach);
            
            // Clear all roles
            group.coaches.leader = null;
            group.coaches.sweep = null;
            group.coaches.roam = null;
            group.coaches.extraRoam = [];
            
            // Reassign roles based on new order: Leader, Sweep, Roam, then Roam for rest
            coachesOrder.forEach((coach, index) => {
                const coachObj = getCoachById(coach.id);
                if (!coachObj) return;
                
                if (index === 0) {
                    // First position = Leader (only if meets minimum level requirement)
                    const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (Number.isFinite(level) && level >= minLeaderLevel) {
                        group.coaches.leader = coach.id;
                    } else {
                        // Not eligible for leader, assign as sweep
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 1) {
                    // Second position = Sweep (or Leader if first wasn't eligible)
                    if (!group.coaches.leader) {
                        const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                        const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                        if (Number.isFinite(level) && level >= minLeaderLevel) {
                            group.coaches.leader = coach.id;
                        } else {
                            group.coaches.sweep = coach.id;
                        }
                    } else {
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 2) {
                    // Third position = Roam
                    group.coaches.roam = coach.id;
                } else {
                    // Additional coaches = Roam (in extraRoam array)
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam.push(coach.id);
                }
            });
        }

        function moveRiderBetweenGroups(currentGroupId, riderId, direction) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            const currentGroup = findGroupById(ride, currentGroupId);
            if (!currentGroup) return;

            // Verify rider is in current group
            if (!currentGroup.riders.includes(riderId)) return;

            // Groups are sorted by fitness score (descending) in renderAssignments
            // So Group 1 is fastest, Group 2 is next fastest, etc.
            // direction -1 = move to previous group (faster/higher fitness) - UP arrow
            // direction 1 = move to next group (slower/lower fitness) - DOWN arrow
            
            // Get groups sorted by fitness (same order as displayed)
            const sortedGroups = ride.groups.slice().sort(getGroupPaceComparator(ride));

            // Find current group's index in sorted array
            const currentGroupIndex = sortedGroups.findIndex(g => g.id === currentGroupId);
            if (currentGroupIndex === -1) return;

            // Calculate target group index
            const targetGroupIndex = currentGroupIndex + direction;
            if (targetGroupIndex < 0 || targetGroupIndex >= sortedGroups.length) {
                // Cannot move - already at first or last group
                return;
            }

            const targetGroup = sortedGroups[targetGroupIndex];
            if (!targetGroup) return;

            // Check target group has at least one coach
            const coachCount = countGroupCoaches(targetGroup);
            if (coachCount === 0) {
                alert('Target group must have at least one coach assigned before moving riders to it.');
                renderAssignments(ride);
                return;
            }

            // Allow moving riders even if it exceeds capacity - group will be marked as non-compliant (red)
            // This allows flexibility when moving things around

            // Remove rider from current group
            currentGroup.riders = currentGroup.riders.filter(id => id !== riderId);

            // Add rider to target group
            if (!targetGroup.riders.includes(riderId)) {
                targetGroup.riders.push(riderId);
            }

            // Validate requirements for both groups after move
            const currentWarnings = validateGroupRequirements(currentGroup, ride);
            const targetWarnings = validateGroupRequirements(targetGroup, ride);
            const allWarnings = [...currentWarnings, ...targetWarnings];

            if (allWarnings.length > 0) {
                const warningMsg = allWarnings.join('\n');
                alert(`Warning: Moving this rider may violate requirements:\n\n${warningMsg}\n\nThe move has been made, but please review the groups.`);
            }

            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function validateGroupRequirements(group, ride) {
            const warnings = [];
            const coachCount = countGroupCoaches(group);
            const capacity = groupCapacity(group);
            const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);

            // Check minimum leader level requirement
            if (group.coaches.leader) {
                const leader = getCoachById(group.coaches.leader);
                if (leader) {
                    const leaderLevel = parseInt(leader.coachingLicenseLevel || leader.level || '1', 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (!Number.isFinite(leaderLevel) || leaderLevel < minLeaderLevel) {
                        warnings.push(`Leader must be Level ${minLeaderLevel} or higher (current: Level ${leaderLevel || 1})`);
                    }
                }
            } else {
                warnings.push('Group must have a leader assigned');
            }

            // Check leader:rider ratio based on total coaches (not just leader)
            if (coachCount > 0) {
                const ridersPerCoachActual = group.riders.length / coachCount;
                if (ridersPerCoachActual > ridersPerCoach) {
                    warnings.push(`Leader:rider ratio exceeds 1:${ridersPerCoach} (current: 1:${Math.ceil(ridersPerCoachActual)})`);
                }
            }

            // Check riders per coach requirement (for all coaches)
            if (coachCount > 0 && group.riders.length > capacity) {
                warnings.push(`Group exceeds capacity: ${group.riders.length} riders with ${coachCount} coach(es) (capacity: ${capacity} = ${coachCount} × ${ridersPerCoach})`);
            }

            return warnings;
        }

        // ============ RIDE ASSIGNMENTS (MOBILE-FRIENDLY) ============

        function getNextUpcomingRide() {
            const now = new Date();
            now.setHours(0, 0, 0, 0);
            
            // Get all non-cancelled, non-deleted rides with dates
            const upcomingRides = (data.rides || [])
                .filter(ride => {
                    if (ride.deleted) return false; // Exclude deleted practices
                    if (ride.cancelled) return false;
                    if (!ride.date) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    return rideDate >= now;
                })
                .map(ride => ({
                    ride,
                    date: parseISODate(ride.date)
                }))
                .filter(item => item.date !== null)
                .sort((a, b) => a.date - b.date);
            
            return upcomingRides.length > 0 ? upcomingRides[0].ride : null;
        }

        function getRouteById(routeId) {
            if (!routeId) return null;
            return (data.routes || []).find(route => String(route.id) === String(routeId)) || null;
        }

        async function renderRideAssignments() {
            const container = document.getElementById('ride-assignments-container');
            if (!container) return;

            const ride = getNextUpcomingRide();
            
            // Check and auto-unpublish if 12 hours have passed
            if (ride) {
                await checkAndAutoUnpublish(ride);
            }
            
            if (!ride) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 18px; margin-bottom: 8px;">No upcoming ride scheduled</p>
                        <p style="font-size: 14px;">Check the Practice Planner to add practices.</p>
                    </div>
                `;
                return;
            }

            const rideDate = parseISODate(ride.date);
            const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            const goals = (ride.goals || '').trim();
            
            // Get practice time and location
            const practice = getPracticeSettingsForRide(ride);
            const practiceTime = ride.startTime || ride.time || (practice ? practice.time : '');
            const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
            const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
            const locationLat = ride.locationLat || (practice ? practice.locationLat : null);
            const locationLng = ride.locationLng || (practice ? practice.locationLng : null);
            
            // Format time display
            let timeDisplay = '';
            if (practiceTime) {
                const formattedStart = formatTimeForDisplay(practiceTime);
                if (practiceEndTime) {
                    const formattedEnd = formatTimeForDisplay(practiceEndTime);
                    timeDisplay = `${formattedStart} - ${formattedEnd}`;
                } else {
                    timeDisplay = formattedStart;
                }
            }
            
            // Always show goals at the top (visible regardless of which groups are opened)
            let html = `
                <div style="margin-bottom: 24px;">
                    <h2 style="margin: 0 0 12px 0; font-size: 20px; color: #333;">${escapeHtml(dateDisplay)}</h2>
                    <div style="margin-bottom: 12px; padding: 12px; background: #f9f9f9; border-radius: 4px; font-size: 14px; color: #555;">
                        ${timeDisplay ? `<div style="margin-bottom: 6px;"><strong>Time:</strong> ${escapeHtml(timeDisplay)}</div>` : ''}
                        ${practiceLocation ? `<div style="margin-bottom: 6px;"><strong>Location:</strong> ${escapeHtml(practiceLocation)}</div>` : ''}
                        <div id="practice-weather" style="margin-top: ${timeDisplay || practiceLocation ? '6px' : '0'};">
                            <div><strong>Weather:</strong> <span id="weather-loading">Loading...</span></div>
                            <div><strong>Precip:</strong> <span id="weather-precip">--</span></div>
                            <div id="weather-alerts" style="margin-top: 4px; color: #b00020;"></div>
                        </div>
                    </div>
                    ${goals ? `<div style="padding: 12px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 4px; margin-bottom: 16px;">
                        <strong style="display: block; margin-bottom: 4px; color: #1976D2;">Practice Goals:</strong>
                        <span style="color: #555;">${escapeHtml(goals)}</span>
                    </div>` : ''}
                </div>
            `;

            // Check if groups are published
            if (!ride.publishedGroups) {
                html += `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 18px; margin-bottom: 8px;">Group Assignments Pending</p>
                        <p style="font-size: 14px; color: #999;">Group assignments will be posted here once they are published.</p>
                    </div>
                `;
            } else if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                html += `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 16px;">No groups assigned yet</p>
                        <p style="font-size: 14px; margin-top: 8px;">Go to Practice Planner to assign riders and coaches.</p>
                    </div>
                `;
            } else {
                html += '<div class="mobile-assignment-groups">';
                
                // Sort groups sequentially by label (Group 1, Group 2, etc.)
                const sortedGroups = [...ride.groups].sort((a, b) => {
                    const labelA = a.label || '';
                    const labelB = b.label || '';
                    // Extract numbers from labels for comparison
                    const numA = parseInt(labelA.replace(/\D/g, '')) || 0;
                    const numB = parseInt(labelB.replace(/\D/g, '')) || 0;
                    return numA - numB;
                });
                
                sortedGroups.forEach((group, index) => {
                    const groupId = `group-${group.id || index}`;
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    const allCoaches = [leader, sweep, roam, ...extraRoam].filter(Boolean);
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;
                    
                    // Build coaches with their roles
                    const coachesWithRoles = [];
                    if (leader) coachesWithRoles.push({ coach: leader, role: 'Leader' });
                    if (sweep) coachesWithRoles.push({ coach: sweep, role: 'Sweep' });
                    if (roam) coachesWithRoles.push({ coach: roam, role: 'Roam' });
                    extraRoam.forEach(coach => {
                        coachesWithRoles.push({ coach, role: 'Roam+' });
                    });
                    
                    html += `
                        <div class="mobile-group-card" style="margin-bottom: 0; border: 1px solid #ddd; border-radius: 0; overflow: hidden; background: white; border-top: ${index === 0 ? '1px solid #ddd' : 'none'};">
                            <button class="mobile-group-header" onclick="toggleMobileGroup('${groupId}')" style="width: 100%; padding: 8px 16px; background: #f5f5f5; border: none; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 600; color: #333;">
                                <span>${escapeHtml(group.label || `Group ${index + 1}`)}</span>
                                <span class="mobile-group-toggle" id="toggle-${groupId}" style="font-size: 20px; transition: transform 0.2s;">▼</span>
                            </button>
                            <div class="mobile-group-content" id="${groupId}" style="display: none; padding: 16px;">
                                ${riders.length > 0 ? `
                                    <div style="margin-bottom: ${coachesWithRoles.length > 0 ? '20px' : '0'};">
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${riders.map(rider => {
                                                // Render rider card without any badges
                                                return renderRiderCardHtml(rider, { compact: true, draggable: false, showMoveControls: false, sortBy: 'name', hideBadges: true });
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${coachesWithRoles.length > 0 ? `
                                    <div style="margin-top: ${riders.length > 0 ? '20px' : '0'}; margin-bottom: 16px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Ride Leaders</h3>
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${coachesWithRoles.map(({ coach, role }) => {
                                                // Build coach card matching rider card structure exactly
                                                // Remove background colors for coaches in rider assignments tab
                                                const name = coach.name || 'Coach';
                                                const safeName = escapeHtml(name);
                                                const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                                                const photo = coach.photo ? escapeHtml(coach.photo) : '';
                                                const roleBadge = `<span class="badge badge-level" style="background: #e3f2fd; color: #1976D2;">${escapeHtml(role)}</span>`;
                                                return `
                                                    <div class="coach-card compact" style="background: transparent !important;">
                                                        <div class="avatar-circle coach">
                                                            ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                                                        </div>
                                                        <div class="card-body">
                                                            <strong>${safeName}</strong>
                                                            <span class="badge-single">${roleBadge}</span>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${route ? (() => {
                                    // Try to get Strava URL from stored field or extract from embed code
                                    let stravaUrl = route.stravaUrl;
                                    if (!stravaUrl && route.stravaEmbedCode) {
                                        // Try to extract URL from embed code
                                        const urlMatch = route.stravaEmbedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
                                        if (urlMatch) {
                                            stravaUrl = urlMatch[0];
                                        }
                                    }
                                    return `
                                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                                            <strong style="display: block; margin-bottom: 8px; font-size: 14px; color: #666;">Route:</strong>
                                            <div style="font-size: 14px; color: #333;">
                                                <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                                                ${route.distance || route.elevation || route.estimatedTime ? `
                                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                        ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                                                        ${route.distance && (route.elevation || route.estimatedTime) ? ' · ' : ''}
                                                        ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                                                        ${route.elevation && route.estimatedTime ? ' · ' : ''}
                                                        ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                                                    </div>
                                                ` : ''}
                                                ${stravaUrl ? `
                                                    <a href="${escapeHtml(stravaUrl)}" target="_blank" rel="noopener noreferrer" style="display: inline-block; margin-top: 6px; font-size: 12px; color: #FC4C02; text-decoration: none; font-weight: 500;">
                                                        View Full Map on Strava →
                                                    </a>
                                                ` : route.stravaEmbedCode ? `
                                                    <div style="font-size: 11px; color: #999; margin-top: 4px; font-style: italic;">
                                                        (Strava link not available - route may need to be re-saved)
                                                    </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                    `;
                                })() : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }

            container.innerHTML = html;
            
            // Load weather data if location is available
            if (locationLat && locationLng && rideDate && practiceTime) {
                loadWeatherForPractice(locationLat, locationLng, rideDate, practiceTime, 'weather');
            } else {
                const weatherEl = document.getElementById('weather-loading');
                if (weatherEl) {
                    weatherEl.textContent = 'Weather unavailable (location or time not set)';
                }
                const precipEl = document.getElementById('weather-precip');
                if (precipEl) {
                    precipEl.textContent = '--';
                }
                const alertsEl = document.getElementById('weather-alerts');
                if (alertsEl) {
                    alertsEl.textContent = '';
                }
            }
        }
        
        async function loadWeatherForPractice(lat, lng, date, time, targetPrefix = 'weather') {
            const weatherEl = document.getElementById(`${targetPrefix}-loading`);
            const precipEl = document.getElementById(`${targetPrefix}-precip`);
            const alertsEl = document.getElementById(`${targetPrefix}-alerts`);
            if (!weatherEl) return;
            
            try {
                // Calculate the practice date/time
                const practiceDateTime = new Date(date);
                const [hours, minutes] = time.split(':').map(Number);
                practiceDateTime.setHours(hours || 15, minutes || 30, 0, 0);
                
                // Use a free weather API - OpenWeatherMap requires API key
                // For now, we'll use a simple approach with Open-Meteo (free, no API key needed)
                // This provides basic weather forecasts
                const now = new Date();
                const daysUntilPractice = Math.ceil((practiceDateTime - now) / (1000 * 60 * 60 * 24));
                
                if (daysUntilPractice < 0) {
                    weatherEl.textContent = 'Practice date has passed';
                    if (precipEl) precipEl.textContent = '--';
                    if (alertsEl) alertsEl.textContent = '';
                    return;
                }
                
                if (daysUntilPractice > 7) {
                    weatherEl.textContent = 'Weather forecast available up to 7 days ahead';
                    if (precipEl) precipEl.textContent = '--';
                    if (alertsEl) alertsEl.textContent = '';
                    return;
                }
                
                // Use Open-Meteo API (free, no API key required)
                // Request temperature in Fahrenheit and use practice location coordinates
                const forecastUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,weathercode,precipitation_probability&forecast_days=7&timezone=auto&temperature_unit=fahrenheit&alerts=all`;
                
                // Debug: Log the location being used for weather lookup
                const ride = getNextUpcomingRide();
                if (ride) {
                    const practice = getPracticeSettingsForRide(ride);
                    const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
                    console.log('🌤️ Weather lookup:', { lat, lng, date, time, practiceLocation, rideLocation: ride.locationLat || ride.locationLng ? 'from ride' : 'from practice settings' });
                }
                
                const response = await fetch(forecastUrl);
                const data = await response.json();
                
                if (data.hourly && data.hourly.time && data.hourly.temperature_2m) {
                    // Find the closest hour to practice time
                    const practiceHour = practiceDateTime.getHours();
                    const practiceDateStr = practiceDateTime.toISOString().split('T')[0];
                    
                    // Find matching time slot
                    let closestIndex = -1;
                    let minDiff = Infinity;
                    
                    data.hourly.time.forEach((timeStr, index) => {
                        if (timeStr.startsWith(practiceDateStr)) {
                            const hour = new Date(timeStr).getHours();
                            const diff = Math.abs(hour - practiceHour);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIndex = index;
                            }
                        }
                    });
                    
                    if (closestIndex >= 0) {
                        const temp = Math.round(data.hourly.temperature_2m[closestIndex]);
                        const weatherCode = data.hourly.weathercode[closestIndex];
                        const precipChance = data.hourly.precipitation_probability
                            ? Math.round(data.hourly.precipitation_probability[closestIndex])
                            : null;
                        
                        // Convert weather code to description
                        const weatherDescriptions = {
                            0: 'Clear', 1: 'Mostly clear', 2: 'Partly cloudy', 3: 'Overcast',
                            45: 'Foggy', 48: 'Depositing rime fog',
                            51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',
                            56: 'Light freezing drizzle', 57: 'Dense freezing drizzle',
                            61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',
                            66: 'Light freezing rain', 67: 'Heavy freezing rain',
                            71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',
                            77: 'Snow grains', 80: 'Slight rain showers', 81: 'Moderate rain showers',
                            82: 'Violent rain showers', 85: 'Slight snow showers', 86: 'Heavy snow showers',
                            95: 'Thunderstorm', 96: 'Thunderstorm with slight hail', 99: 'Thunderstorm with heavy hail'
                        };
                        
                        const description = weatherDescriptions[weatherCode] || 'Unknown';
                        weatherEl.textContent = `${temp}°F, ${description}`;
                        if (precipEl) {
                            precipEl.textContent = Number.isFinite(precipChance) ? `${precipChance}% chance` : 'N/A';
                        }
                        if (alertsEl) {
                            const alerts = Array.isArray(data.alerts) ? data.alerts : [];
                            if (alerts.length > 0) {
                                const alertTitles = alerts
                                    .map(alert => alert.event || alert.title || alert.description)
                                    .filter(Boolean);
                                alertsEl.textContent = alertTitles.length > 0
                                    ? `Alerts: ${alertTitles.join(' • ')}`
                                    : 'Weather alerts issued for this area';
                            } else {
                                alertsEl.textContent = '';
                            }
                        }
                    } else {
                        weatherEl.textContent = 'Weather forecast not available for this time';
                        if (precipEl) precipEl.textContent = '--';
                        if (alertsEl) alertsEl.textContent = '';
                    }
                } else {
                    weatherEl.textContent = 'Weather data unavailable';
                    if (precipEl) precipEl.textContent = '--';
                    if (alertsEl) alertsEl.textContent = '';
                }
            } catch (error) {
                console.error('Error loading weather:', error);
                if (weatherEl) weatherEl.textContent = 'Weather unavailable';
                if (precipEl) precipEl.textContent = '--';
                if (alertsEl) alertsEl.textContent = '';
            }
        }

        function toggleMobileGroup(groupId) {
            const content = document.getElementById(groupId);
            const toggle = document.getElementById(`toggle-${groupId}`);
            
            if (!content || !toggle) return;
            
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            toggle.textContent = isHidden ? '▲' : '▼';
            toggle.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(180deg)';
        }

        // ============ COACH ASSIGNMENTS (MOBILE-FRIENDLY) ============

        async function renderCoachAssignments() {
            const container = document.getElementById('coach-assignments-container');
            if (!container) return;

            const ride = getNextUpcomingRide();
            
            // Check and auto-unpublish if 12 hours have passed
            if (ride) {
                await checkAndAutoUnpublish(ride);
            }
            
            if (!ride) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 18px; margin-bottom: 8px;">No upcoming ride scheduled</p>
                        <p style="font-size: 14px;">Check the Practice Planner to add practices.</p>
                    </div>
                `;
                return;
            }

            const rideDate = parseISODate(ride.date);
            const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            const goals = (ride.goals || '').trim();
            
            // Get practice time and location
            const practice = getPracticeSettingsForRide(ride);
            const practiceTime = ride.startTime || ride.time || (practice ? practice.time : '');
            const practiceEndTime = ride.endTime || (practice ? practice.endTime : '');
            const practiceLocation = ride.meetLocation || (practice ? practice.meetLocation : '');
            const locationLat = ride.locationLat || (practice ? practice.locationLat : null);
            const locationLng = ride.locationLng || (practice ? practice.locationLng : null);
            
            // Format time display
            let timeDisplay = '';
            if (practiceTime) {
                const formattedStart = formatTimeForDisplay(practiceTime);
                if (practiceEndTime) {
                    const formattedEnd = formatTimeForDisplay(practiceEndTime);
                    timeDisplay = `${formattedStart} - ${formattedEnd}`;
                } else {
                    timeDisplay = formattedStart;
                }
            }
            
            // Always show goals at the top (visible regardless of which groups are opened)
            let html = `
                <div style="margin-bottom: 24px;">
                    <h2 style="margin: 0 0 12px 0; font-size: 20px; color: #333;">${escapeHtml(dateDisplay)}</h2>
                    <div style="margin-bottom: 12px; padding: 12px; background: #f9f9f9; border-radius: 4px; font-size: 14px; color: #555;">
                        ${timeDisplay ? `<div style="margin-bottom: 6px;"><strong>Time:</strong> ${escapeHtml(timeDisplay)}</div>` : ''}
                        ${practiceLocation ? `<div style="margin-bottom: 6px;"><strong>Location:</strong> ${escapeHtml(practiceLocation)}</div>` : ''}
                        <div id="coach-practice-weather" style="margin-top: ${timeDisplay || practiceLocation ? '6px' : '0'};">
                            <div><strong>Weather:</strong> <span id="coach-weather-loading">Loading...</span></div>
                            <div><strong>Precip:</strong> <span id="coach-weather-precip">--</span></div>
                            <div id="coach-weather-alerts" style="margin-top: 4px; color: #b00020;"></div>
                        </div>
                    </div>
                    ${goals ? `<div style="padding: 12px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 4px; margin-bottom: 16px;">
                        <strong style="display: block; margin-bottom: 4px; color: #1976D2;">Practice Goals:</strong>
                        <span style="color: #555;">${escapeHtml(goals)}</span>
                    </div>` : ''}
                </div>
            `;

            // Check if groups are published
            if (!ride.publishedGroups) {
                html += `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 18px; margin-bottom: 8px;">Group Assignments Pending</p>
                        <p style="font-size: 14px; color: #999;">Group assignments will be posted here once they are published.</p>
                    </div>
                `;
            } else if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                html += `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 16px;">No groups assigned yet</p>
                        <p style="font-size: 14px; margin-top: 8px;">Go to Practice Planner to assign riders and coaches.</p>
                    </div>
                `;
            } else {
                html += '<div class="mobile-assignment-groups">';
                
                // Sort groups sequentially by label (Group 1, Group 2, etc.)
                const sortedGroups = [...ride.groups].sort((a, b) => {
                    const labelA = a.label || '';
                    const labelB = b.label || '';
                    // Extract numbers from labels for comparison
                    const numA = parseInt(labelA.replace(/\D/g, '')) || 0;
                    const numB = parseInt(labelB.replace(/\D/g, '')) || 0;
                    return numA - numB;
                });
                
                sortedGroups.forEach((group, index) => {
                    const groupId = `coach-group-${group.id || index}`;
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    const allCoaches = [leader, sweep, roam, ...extraRoam].filter(Boolean);
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;
                    
                    // Build coaches with their roles
                    const coachesWithRoles = [];
                    if (leader) coachesWithRoles.push({ coach: leader, role: 'Leader' });
                    if (sweep) coachesWithRoles.push({ coach: sweep, role: 'Sweep' });
                    if (roam) coachesWithRoles.push({ coach: roam, role: 'Roam' });
                    extraRoam.forEach(coach => {
                        coachesWithRoles.push({ coach, role: 'Roam+' });
                    });
                    
                    // Check group compliance for header color
                    const isCompliant = checkGroupCompliance(group);
                    const headerColor = isCompliant ? '#2196F3' : '#d32f2f'; // Blue if compliant, red if not
                    
                    html += `
                        <div class="mobile-group-card" style="margin-bottom: 0; border: 1px solid #ddd; border-radius: 0; overflow: hidden; background: white; border-top: ${index === 0 ? '1px solid #ddd' : 'none'};">
                            <button class="mobile-group-header" onclick="toggleMobileGroup('${groupId}')" style="width: 100%; padding: 8px 16px; background: ${headerColor}; color: white; border: none; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 600;">
                                <span>${escapeHtml(group.label || `Group ${index + 1}`)}</span>
                                <span class="mobile-group-toggle" id="toggle-${groupId}" style="font-size: 20px; transition: transform 0.2s; color: white;">▼</span>
                            </button>
                            <div class="mobile-group-content" id="${groupId}" style="display: none; padding: 16px;">
                                ${coachesWithRoles.length > 0 ? `
                                    <div style="margin-bottom: ${riders.length > 0 ? '20px' : '0'};">
                                        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Ride Leaders</h3>
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${coachesWithRoles.map(({ coach, role }) => {
                                                // Build coach card matching rider card structure exactly
                                                const name = coach.name || 'Coach';
                                                const safeName = escapeHtml(name);
                                                const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                                                const photo = coach.photo ? escapeHtml(coach.photo) : '';
                                                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                                                const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
                                                const classes = ['coach-card', 'compact'];
                                                if (levelNum === 1) classes.push('coach-level-1');
                                                else if (levelNum === 2) classes.push('coach-level-2');
                                                else if (levelNum === 3) classes.push('coach-level-3');
                                                const roleBadge = `<span class="badge badge-level" style="background: #e3f2fd; color: #1976D2;">${escapeHtml(role)}</span>`;
                                                // Get coach phone number
                                                const coachPhone = coach.phone || coach.mobile || '';
                                                const coachPhoneLink = coachPhone ? `tel:${coachPhone.replace(/[^\d+]/g, '')}` : '';
                                                
                                                return `
                                                    <div class="${classes.join(' ')}" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px; position: relative;">
                                                        <div class="avatar-circle coach">
                                                            ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                                                        </div>
                                                        <strong style="flex: 1; min-width: 0;">${safeName}</strong>
                                                        <div style="flex-shrink: 0; margin-left: auto; margin-right: 4px;">
                                                            <span class="badge-single">${roleBadge}</span>
                                                        </div>
                                                        <div style="display: flex; align-items: center; gap: 4px; flex-shrink: 0;">
                                                            ${coachPhoneLink ? `
                                                                <a href="${escapeHtml(coachPhoneLink)}" style="display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #4CAF50; color: white; text-decoration: none; flex-shrink: 0;" title="Call ${safeName}">
                                                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                                                                    </svg>
                                                                </a>
                                                            ` : ''}
                                                            <button onclick="showCoachAssignmentMenu(event, 'coach', ${coach.id}, ${group.id}, '${escapeHtml(role)}')" style="display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: transparent; border: none; cursor: pointer; flex-shrink: 0; padding: 0; color: #666;" title="Menu">
                                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                                    <circle cx="12" cy="12" r="1"></circle>
                                                                    <circle cx="12" cy="5" r="1"></circle>
                                                                    <circle cx="12" cy="19" r="1"></circle>
                                                                </svg>
                                                            </button>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${riders.length > 0 ? `
                                    <div style="margin-top: ${coachesWithRoles.length > 0 ? '20px' : '0'};">
                                        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Riders (${riders.length})</h3>
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${riders.map(rider => {
                                                // Custom rendering for coach assignments tab with phone, fitness, and skills
                                                const name = rider.name || 'Rider';
                                                const safeName = escapeHtml(name);
                                                const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                                                const photoSrc = rider.photo;
                                                let photo = '';
                                                if (photoSrc && (photoSrc.startsWith('data:') || photoSrc.startsWith('http') || photoSrc.startsWith('assets/'))) {
                                                    photo = escapeHtml(photoSrc);
                                                } else {
                                                    const gender = (rider.gender || '').toUpperCase();
                                                    if (gender === 'M') photo = 'assets/male_default.png';
                                                    else if (gender === 'F') photo = 'assets/female_default.png';
                                                    else photo = 'assets/nonbinary_default.png';
                                                }
                                                
                                                const fitnessScale = getFitnessScale();
                                                const fitness = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
                                                const skillsScale = getSkillsScale();
                                                const skills = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
                                                const skillsTooltip = getBikeSkillsTooltip(skills, skillsScale);
                                                
                                                // Get phone number
                                                const phone = rider.phone || rider.mobile || '';
                                                const phoneLink = phone ? `tel:${phone.replace(/[^\d+]/g, '')}` : '';
                                                
                                                const medicalIcon = getMedicalIconHtml(rider.allergiesOrMedicalNeeds || rider.medicalNotes || '');
                                                return `
                                                    <div class="rider-card compact" style="border: none !important; border-style: none !important; display: flex; align-items: center; gap: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px; position: relative;">
                                                        <div class="avatar-circle">
                                                            ${photo ? `<img class="avatar-image" src="${escapeHtml(photo)}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                                                        </div>
                                                        <strong style="flex: 1; min-width: 0;">${safeName}${medicalIcon}</strong>
                                                        <div style="display: flex; flex-direction: column; gap: 2px; flex-shrink: 0; margin-left: auto; margin-right: 4px;">
                                                            <span class="badge badge-pace-${fitness}">Pace ${fitness}</span>
                                                            <span class="badge badge-skills-${skills}" title="${getBikeSkillsTooltip(skills, getSkillsScale()).replace(/\n/g, '&#10;')}" style="cursor: help;">Skills ${skills}</span>
                                                        </div>
                                                        <div style="display: flex; align-items: center; gap: 4px; flex-shrink: 0;">
                                                            ${phoneLink ? `
                                                                <a href="${escapeHtml(phoneLink)}" style="display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; background: #4CAF50; color: white; text-decoration: none; flex-shrink: 0;" title="Call ${safeName}">
                                                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                                                                    </svg>
                                                                </a>
                                                            ` : ''}
                                                            <button onclick="showCoachAssignmentMenu(event, 'rider', ${rider.id}, ${group.id})" style="display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: transparent; border: none; cursor: pointer; flex-shrink: 0; padding: 0; color: #666;" title="Menu">
                                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                                    <circle cx="12" cy="12" r="1"></circle>
                                                                    <circle cx="12" cy="5" r="1"></circle>
                                                                    <circle cx="12" cy="19" r="1"></circle>
                                                                </svg>
                                                            </button>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${route ? (() => {
                                    // Try to get Strava URL from stored field or extract from embed code
                                    let stravaUrl = route.stravaUrl;
                                    if (!stravaUrl && route.stravaEmbedCode) {
                                        // Try to extract URL from embed code
                                        const urlMatch = route.stravaEmbedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
                                        if (urlMatch) {
                                            stravaUrl = urlMatch[0];
                                        }
                                    }
                                    return `
                                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                                            <strong style="display: block; margin-bottom: 8px; font-size: 14px; color: #666;">Route:</strong>
                                            <div style="font-size: 14px; color: #333;">
                                                <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                                                ${route.distance || route.elevation || route.estimatedTime ? `
                                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                        ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                                                        ${route.distance && (route.elevation || route.estimatedTime) ? ' · ' : ''}
                                                        ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                                                        ${route.elevation && route.estimatedTime ? ' · ' : ''}
                                                        ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                                                    </div>
                                                ` : ''}
                                                ${stravaUrl ? `
                                                    <a href="${escapeHtml(stravaUrl)}" target="_blank" rel="noopener noreferrer" style="display: inline-block; margin-top: 6px; font-size: 12px; color: #FC4C02; text-decoration: none; font-weight: 500;">
                                                        View Full Map on Strava →
                                                    </a>
                                                ` : route.stravaEmbedCode ? `
                                                    <div style="font-size: 11px; color: #999; margin-top: 4px; font-style: italic;">
                                                        (Strava link not available - route may need to be re-saved)
                                                    </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                    `;
                                })() : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }

            container.innerHTML = html;
            
            // Load weather data if location is available
            if (locationLat && locationLng && rideDate && practiceTime) {
                loadWeatherForPractice(locationLat, locationLng, rideDate, practiceTime, 'coach-weather');
            } else {
                const weatherEl = document.getElementById('coach-weather-loading');
                if (weatherEl) {
                    weatherEl.textContent = 'Weather unavailable (location or time not set)';
                }
                const precipEl = document.getElementById('coach-weather-precip');
                if (precipEl) {
                    precipEl.textContent = '--';
                }
                const alertsEl = document.getElementById('coach-weather-alerts');
                if (alertsEl) {
                    alertsEl.textContent = '';
                }
            }
        }

        // ============ COACH ASSIGNMENTS CONTEXT MENU ============

        function showCoachAssignmentMenu(event, type, id, groupId, role = null) {
            event.stopPropagation();
            event.preventDefault();
            
            // Remove any existing context menu
            const existingMenu = document.getElementById('coach-assignment-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'coach-assignment-context-menu';
            menu.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                min-width: 150px;
                padding: 4px 0;
            `;
            
            // Position menu to the left of the button (so it doesn't go off screen)
            const rect = event.target.closest('button').getBoundingClientRect();
            menu.style.right = `${window.innerWidth - rect.right}px`;
            menu.style.top = `${rect.top}px`;
            
            // Add menu items
            const items = [
                { label: 'Absent', action: () => handleAbsent(type, id, groupId, role) },
                { label: 'Moved', action: () => handleMoved(type, id, groupId, role) }
            ];
            
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.cssText = `
                    padding: 8px 16px;
                    cursor: pointer;
                    font-size: 14px;
                    color: #333;
                `;
                menuItem.onmouseenter = () => menuItem.style.background = '#f5f5f5';
                menuItem.onmouseleave = () => menuItem.style.background = 'transparent';
                menuItem.onclick = (e) => {
                    e.stopPropagation();
                    item.action();
                    menu.remove();
                };
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && e.target !== event.target) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }
        
        function handleAbsent(type, id, groupId, role) {
            const ride = getNextUpcomingRide();
            if (!ride || !ride.groups) return;
            
            const group = ride.groups.find(g => g.id === groupId);
            if (!group) return;
            
            // Get name for confirmation
            const name = type === 'rider' 
                ? (getRiderById(id)?.name || 'Rider')
                : (getCoachById(id)?.name || 'Coach');
            
            // Confirm before marking as absent
            if (!confirm(`Are you sure ${escapeHtml(name)} is absent?`)) {
                return;
            }
            
            if (type === 'rider') {
                // Remove rider from group
                group.riders = group.riders.filter(riderId => riderId !== id);
                // Remove from available riders
                if (ride.availableRiders) {
                    ride.availableRiders = ride.availableRiders.filter(riderId => riderId !== id);
                }
            } else if (type === 'coach') {
                // Remove coach from group based on role
                if (role === 'Leader') {
                    group.coaches.leader = null;
                } else if (role === 'Sweep') {
                    group.coaches.sweep = null;
                } else if (role === 'Roam') {
                    group.coaches.roam = null;
                } else if (role === 'Roam+') {
                    if (Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = group.coaches.extraRoam.filter(coachId => coachId !== id);
                    }
                }
                // Remove from available coaches
                if (ride.availableCoaches) {
                    ride.availableCoaches = ride.availableCoaches.filter(coachId => coachId !== id);
                }
            }
            
            // Save and re-render
            saveRideToDB(ride);
            renderCoachAssignments();
        }
        
        function handleMoved(type, id, groupId, role) {
            const ride = getNextUpcomingRide();
            if (!ride || !ride.groups) return;
            
            const sourceGroup = ride.groups.find(g => g.id === groupId);
            if (!sourceGroup) return;
            
            // Get other groups (excluding current group)
            const otherGroups = ride.groups.filter(g => g.id !== groupId);
            
            if (otherGroups.length === 0) {
                alert('No other groups available to move to.');
                return;
            }
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.id = 'move-assignment-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2196F3;
                border: 1px solid #1976D2;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10001;
                padding: 20px;
                min-width: 300px;
                max-width: 90%;
            `;
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 10000;
            `;
            
            const name = type === 'rider' 
                ? (getRiderById(id)?.name || 'Rider')
                : (getCoachById(id)?.name || 'Coach');
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; font-size: 18px; color: white;">Move ${escapeHtml(name)}</h3>
                <p style="margin: 0 0 16px 0; color: rgba(255,255,255,0.9); font-size: 14px;">Select destination group:</p>
                <div style="margin-bottom: 16px;">
                    ${otherGroups.map(g => `
                        <button onclick="completeMove('${type}', ${id}, ${groupId}, ${g.id}, '${role || ''}')" 
                                style="display: block; width: 100%; padding: 12px; margin-bottom: 8px; text-align: left; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; font-size: 14px; color: white;">
                            ${escapeHtml(g.label || `Group ${ride.groups.indexOf(g) + 1}`)}
                        </button>
                    `).join('')}
                </div>
                <div style="display: flex; justify-content: flex-end; gap: 8px;">
                    <button onclick="closeMoveDialog()" class="btn-small secondary" style="background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); color: white;">Cancel</button>
                </div>
            `;
            
            overlay.onclick = closeMoveDialog;
            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
            
            // Store dialog references globally for cleanup
            window.currentMoveDialog = dialog;
            window.currentMoveOverlay = overlay;
        }
        
        function completeMove(type, id, sourceGroupId, targetGroupId, role) {
            const ride = getNextUpcomingRide();
            if (!ride || !ride.groups) return;
            
            const sourceGroup = ride.groups.find(g => g.id === sourceGroupId);
            const targetGroup = ride.groups.find(g => g.id === targetGroupId);
            
            if (!sourceGroup || !targetGroup) return;
            
            if (type === 'rider') {
                // Remove from source group
                sourceGroup.riders = sourceGroup.riders.filter(riderId => riderId !== id);
                // Add to target group
                if (!targetGroup.riders.includes(id)) {
                    targetGroup.riders.push(id);
                }
            } else if (type === 'coach') {
                // Remove from source group based on role
                if (role === 'Leader') {
                    sourceGroup.coaches.leader = null;
                } else if (role === 'Sweep') {
                    sourceGroup.coaches.sweep = null;
                } else if (role === 'Roam') {
                    sourceGroup.coaches.roam = null;
                } else if (role === 'Roam+') {
                    if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                        sourceGroup.coaches.extraRoam = sourceGroup.coaches.extraRoam.filter(coachId => coachId !== id);
                    }
                }
                
                // Add to target group (assign to first available role)
                if (!targetGroup.coaches.leader) {
                    targetGroup.coaches.leader = id;
                } else if (!targetGroup.coaches.sweep) {
                    targetGroup.coaches.sweep = id;
                } else if (!targetGroup.coaches.roam) {
                    targetGroup.coaches.roam = id;
                } else {
                    if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                        targetGroup.coaches.extraRoam = [];
                    }
                    if (!targetGroup.coaches.extraRoam.includes(id)) {
                        targetGroup.coaches.extraRoam.push(id);
                    }
                }
            }
            
            // Save and re-render
            saveRideToDB(ride);
            renderCoachAssignments();
            closeMoveDialog();
        }
        
        function closeMoveDialog() {
            if (window.currentMoveDialog) {
                window.currentMoveDialog.remove();
                window.currentMoveDialog = null;
            }
            if (window.currentMoveOverlay) {
                window.currentMoveOverlay.remove();
                window.currentMoveOverlay = null;
            }
        }

        // ============ ROUTES MANAGEMENT ============

        // Helper functions for parsing route values for sorting
        function parseDistance(distStr) {
            if (!distStr) return 0;
            const match = distStr.match(/([\d.]+)/);
            return match ? parseFloat(match[1]) : 0;
        }

        function parseElevation(elevStr) {
            if (!elevStr) return 0;
            const match = elevStr.replace(/,/g, '').match(/([\d.]+)/);
            return match ? parseFloat(match[1]) : 0;
        }

        function parseTime(timeStr) {
            if (!timeStr) return 0;
            // Handle formats like "1:30:00", "1h 30m", "90:00", etc.
            const parts = timeStr.match(/(\d+)/g);
            if (!parts) return 0;
            
            if (parts.length === 3) {
                // HH:MM:SS format
                return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
            } else if (parts.length === 2) {
                // MM:SS or HH:MM format
                return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else if (parts.length === 1) {
                // Single number (minutes)
                return parseInt(parts[0]) * 60;
            }
            return 0;
        }

        function parseTimeMidpoint(timeStr) {
            if (!timeStr || timeStr === 'N/A') return 0;
            
            // Handle time ranges like "1:30:00 - 2:00:00" or "1:30-2:00"
            const rangeMatch = timeStr.match(/(.+?)\s*-\s*(.+)/);
            if (rangeMatch) {
                const time1 = parseTime(rangeMatch[1].trim());
                const time2 = parseTime(rangeMatch[2].trim());
                // Return midpoint
                return (time1 + time2) / 2;
            }
            
            // Single time value
            return parseTime(timeStr);
        }

        function getRoutesViewMode() {
            return localStorage.getItem('routesViewMode') || 'thumbnails';
        }

        function setRoutesViewMode(mode) {
            if (mode !== 'thumbnails' && mode !== 'list') return;
            localStorage.setItem('routesViewMode', mode);
            updateRoutesViewToggle();
            renderRoutes();
        }

        function updateRoutesViewToggle() {
            const mode = getRoutesViewMode();
            const thumbBtn = document.getElementById('routes-view-thumbnails');
            const listBtn = document.getElementById('routes-view-list');
            if (thumbBtn) thumbBtn.classList.toggle('active', mode === 'thumbnails');
            if (listBtn) listBtn.classList.toggle('active', mode === 'list');
        }

        function renderRoutes() {
            const container = document.getElementById('routes-grid');
            if (!container) return;

            if (!Array.isArray(data.routes) || data.routes.length === 0) {
                container.innerHTML = '<div class="empty-state">No routes added yet. Click "Add/Edit Routes..." to get started.</div>';
                return;
            }

            // Clear container
            container.innerHTML = '';

            // Get sort option
            const sortBySelect = document.getElementById('routes-sort-by');
            const sortBy = sortBySelect ? sortBySelect.value : 'distance-desc';
            const viewMode = getRoutesViewMode();
            updateRoutesViewToggle();

            container.classList.toggle('routes-list', viewMode === 'list');
            container.classList.toggle('routes-grid', viewMode !== 'list');

            // Separate Strava routes (with embed code) and manual routes (without embed code)
            let stravaRoutes = data.routes.filter(route => route.stravaEmbedCode);
            let manualRoutes = data.routes.filter(route => !route.stravaEmbedCode);

            // Sort routes
            const sortRoutes = (routes) => {
                if (!Array.isArray(routes) || routes.length === 0) return routes;
                
                return [...routes].sort((a, b) => {
                    let compareA, compareB;
                    
                    try {
                    if (sortBy.startsWith('distance-')) {
                        compareA = parseDistance(a.distance || '0');
                        compareB = parseDistance(b.distance || '0');
                    } else if (sortBy.startsWith('elevation-')) {
                        compareA = parseElevation(a.elevation || '0');
                        compareB = parseElevation(b.elevation || '0');
                    } else if (sortBy.startsWith('time-')) {
                        compareA = parseTimeMidpoint(a.estimatedTime || '0:00');
                        compareB = parseTimeMidpoint(b.estimatedTime || '0:00');
                    } else {
                        return 0;
                    }
                    
                    // Determine sort direction
                    const isAscending = sortBy.endsWith('-asc');
                        const result = isAscending ? compareA - compareB : compareB - compareA;
                        return result;
                    } catch (error) {
                        console.error('Error sorting routes:', error);
                        return 0;
                    }
                });
            };

            stravaRoutes = sortRoutes(stravaRoutes);
            manualRoutes = sortRoutes(manualRoutes);

            if (viewMode === 'list') {
                const allRoutes = sortRoutes(data.routes);
                const rows = allRoutes.map(route => {
                    const name = escapeHtml(route.name || 'Untitled Route');
                    const isStrava = route.stravaEmbedCode ? true : false;
                    const stravaIcon = isStrava ? '<img src="assets/strava_logo.png" alt="Strava" style="height: 16px; width: auto; vertical-align: middle; margin-right: 8px;">' : '';
                    const distance = escapeHtml(route.distance || 'N/A');
                    const elevation = escapeHtml(route.elevation || 'N/A');
                    const duration = escapeHtml(route.estimatedTime || 'N/A');
                    return `<tr>
                        <td>${stravaIcon}${name}</td>
                        <td>${distance}</td>
                        <td>${elevation}</td>
                        <td>${duration}</td>
                    </tr>`;
                }).join('');

                container.innerHTML = `
                    <div class="routes-list-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Route Name</th>
                                    <th>Distance</th>
                                    <th>Elevation Gain</th>
                                    <th>Duration</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${rows}
                            </tbody>
                        </table>
                    </div>
                `;
                return;
            }

            // Render Strava routes first
            stravaRoutes.forEach(route => {
                renderRouteCard(route, container);
            });

            // Add separator if both types exist
            if (stravaRoutes.length > 0 && manualRoutes.length > 0) {
                const separator = document.createElement('div');
                separator.style.cssText = 'grid-column: 1 / -1; height: 1px; background: #e0e0e0; margin: 20px 0;';
                container.appendChild(separator);
            }

            // Render manual routes below Strava routes
            manualRoutes.forEach(route => {
                renderRouteCard(route, container, true);
            });
        }

        function renderRouteCard(route, container, isManual = false) {
            const routeCard = document.createElement('div');
            // Force manual routes to span full width to appear below Strava routes
            if (isManual) {
                routeCard.style.cssText = 'width: 100%; margin-bottom: 0; grid-column: 1 / -1;';
            } else {
                routeCard.style.cssText = 'width: 420px; margin-bottom: 0;';
            }

            if (route.stravaEmbedCode && !isManual) {
                // Embed container - no card, no header, no description, just the map
                // Scale to 70% of standard size (405px * 0.7 = 283.5px, rounded to 284px)
                const embedContainer = document.createElement('div');
                embedContainer.style.cssText = 'width: 420px; height: 284px; border: none; border-radius: 0; overflow: hidden; position: relative;';
                
                // Wrapper to scale the embed content to 70%
                const embedWrapper = document.createElement('div');
                embedWrapper.style.cssText = 'transform: scale(0.7); transform-origin: top left; width: 142.86%; height: 142.86%; position: absolute; top: 0; left: 0;';
                
                // Create inner container for the embed (standard size)
                const innerContainer = document.createElement('div');
                innerContainer.style.cssText = 'width: 100%; height: 405px; position: relative;';
                
                // Insert embed code as raw HTML
                innerContainer.innerHTML = route.stravaEmbedCode;
                
                // If there are script tags, we need to execute them
                const scripts = innerContainer.querySelectorAll('script');
                scripts.forEach(oldScript => {
                    const newScript = document.createElement('script');
                    // Copy all attributes
                    Array.from(oldScript.attributes).forEach(attr => {
                        newScript.setAttribute(attr.name, attr.value);
                    });
                    // Copy script content
                    newScript.textContent = oldScript.textContent;
                    // Replace old script with new one (which will execute)
                    oldScript.parentNode.replaceChild(newScript, oldScript);
                });

                // Check if we need to load Strava embed.js
                if (innerContainer.querySelector('[data-embed-type="route"]') && 
                    !document.querySelector('script[src="https://strava-embeds.com/embed.js"]')) {
                    const stravaScript = document.createElement('script');
                    stravaScript.src = 'https://strava-embeds.com/embed.js';
                    // Suppress Mapbox errors from Strava embeds
                    stravaScript.onerror = () => {
                        console.warn('Strava embed script failed to load');
                    };
                    document.head.appendChild(stravaScript);
                }
                
                embedWrapper.appendChild(innerContainer);
                embedContainer.appendChild(embedWrapper);
                routeCard.appendChild(embedContainer);
                
                // Add route info line below the map
                const routeInfoLine = document.createElement('div');
                routeInfoLine.style.cssText = 'margin-top: 8px; margin-bottom: 20px; font-size: 11px; color: #666; line-height: 1.4;';
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                const fitnessMin = route.fitnessMin !== undefined ? route.fitnessMin : 1;
                const fitnessMax = route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
                const skillsMin = route.skillsMin !== undefined ? route.skillsMin : 1;
                const skillsMax = route.skillsMax !== undefined ? route.skillsMax : skillsScale;
                
                const fitnessRange = (fitnessMin === 1 && fitnessMax === fitnessScale) ? 'ALL' : `${fitnessMin}-${fitnessMax}`;
                const skillsRange = (skillsMin === 1 && skillsMax === skillsScale) ? 'ALL' : `${skillsMin}-${skillsMax}`;
                
                const durationText = route.estimatedTime || 'N/A';
                
                routeInfoLine.textContent = `Relative Pace Range: ${fitnessRange} | Bike Skills Range: ${skillsRange} | Duration: ${durationText}`;
                routeCard.appendChild(routeInfoLine);
            } else {
                // For manual routes, show route info card instead of embed
                const routeInfoCard = document.createElement('div');
                routeInfoCard.style.cssText = 'padding: 20px; background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 4px;';
                routeInfoCard.innerHTML = `
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                    ${route.distance || route.elevation || route.estimatedTime ? `
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">
                            ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                            ${route.distance && (route.elevation || route.estimatedTime) ? ' · ' : ''}
                            ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                            ${route.elevation && route.estimatedTime ? ' · ' : ''}
                            ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                        </div>
                    ` : ''}
                    ${route.description ? `
                        <div style="font-size: 13px; color: #666; margin-top: 8px; line-height: 1.4;">${escapeHtml(route.description)}</div>
                    ` : ''}
                `;
                routeCard.appendChild(routeInfoCard);
                
                // Add route info line below the card
                const routeInfoLine = document.createElement('div');
                routeInfoLine.style.cssText = 'margin-top: 8px; margin-bottom: 20px; font-size: 11px; color: #666; line-height: 1.4;';
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                const fitnessMin = route.fitnessMin !== undefined ? route.fitnessMin : 1;
                const fitnessMax = route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
                const skillsMin = route.skillsMin !== undefined ? route.skillsMin : 1;
                const skillsMax = route.skillsMax !== undefined ? route.skillsMax : skillsScale;
                
                const fitnessRange = (fitnessMin === 1 && fitnessMax === fitnessScale) ? 'ALL' : `${fitnessMin}-${fitnessMax}`;
                const skillsRange = (skillsMin === 1 && skillsMax === skillsScale) ? 'ALL' : `${skillsMin}-${skillsMax}`;
                
                const durationText = route.estimatedTime || 'N/A';
                
                routeInfoLine.textContent = `Relative Pace Range: ${fitnessRange} | Bike Skills Range: ${skillsRange} | Duration: ${durationText}`;
                routeCard.appendChild(routeInfoLine);
            }
            
            container.appendChild(routeCard);
        }

        function openRoutesManagerModal() {
            const modal = document.getElementById('routes-manager-modal');
            const listContainer = document.getElementById('routes-manager-list');
            if (!modal || !listContainer) return;

            // Render routes list
            const routes = data.routes || [];
            if (routes.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No routes added yet.</div>';
            } else {
                listContainer.innerHTML = routes.map(route => {
                    const isStrava = !!route.stravaEmbedCode;
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #e0e0e0;">
                            <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; flex-wrap: nowrap;">
                                        ${isStrava ? '<img src="assets/strava_logo.png" alt="Strava" style="height: 16px; width: auto; flex-shrink: 0;">' : ''}
                                        <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">${escapeHtml(route.name || 'Unnamed Route')}</span>
                                    </div>
                                    ${route.distance || route.elevation || route.estimatedTime ? `
                                        <div style="font-size: 12px; color: #666;">
                                            ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                                            ${route.distance && (route.elevation || route.estimatedTime) ? ' · ' : ''}
                                            ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                                            ${route.elevation && route.estimatedTime ? ' · ' : ''}
                                            ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-small secondary" onclick="openAddRouteModal(${route.id}, ${!route.stravaEmbedCode})">Edit</button>
                                <button class="btn-small danger" onclick="deleteRouteHandler(${route.id}); openRoutesManagerModal();">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeRoutesManagerModal() {
            const modal = document.getElementById('routes-manager-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        function openAddRouteModal(routeId, isManualRoute = false) {
            const modal = document.getElementById('add-route-modal');
            const titleEl = document.getElementById('add-route-modal-title');
            const headerEl = document.getElementById('add-route-modal-header');
            const embedCodeSection = document.querySelector('#add-route-modal [for="route-embed-code"]')?.closest('div[style*="position: relative"]');
            const fetchContainer = document.getElementById('fetch-route-data-container');
            
            if (!modal) return;

            // Close routes manager modal if open
            closeRoutesManagerModal();

            const isEdit = routeId !== null;
            const route = isEdit ? (data.routes || []).find(r => r.id === routeId) : null;
            
            // Determine if this is a manual route (non-Strava)
            const isManual = isManualRoute || (route && !route.stravaEmbedCode);
            
            // Show/hide embed code section based on route type
            if (embedCodeSection) {
                embedCodeSection.style.display = isManual ? 'none' : 'block';
            }
            if (fetchContainer) {
                fetchContainer.style.display = isManual ? 'none' : 'block';
            }
            
            // Update header styling
            if (headerEl) {
                if (isManual) {
                    headerEl.style.backgroundColor = '';
                    headerEl.style.color = '';
                } else {
                    headerEl.style.backgroundColor = '#fc5200';
                    headerEl.style.color = 'white';
                }
            }
            
            // Update title
            if (titleEl) {
                if (isEdit) {
                    titleEl.textContent = isManual ? 'Edit Route' : 'Edit Strava Route';
                } else {
                    titleEl.textContent = isManual ? 'Add Route' : 'Add Strava Route';
                }
            }

            // Populate or clear form
            document.getElementById('route-name').value = route ? (route.name || '') : '';
            document.getElementById('route-description').value = route ? (route.description || '') : '';
            document.getElementById('route-distance').value = route ? (route.distance || '') : '';
            document.getElementById('route-elevation').value = route ? (route.elevation || '') : '';
            document.getElementById('route-time').value = route ? (route.estimatedTime || '') : '';
            document.getElementById('route-embed-code').value = route ? (route.stravaEmbedCode || '') : '';
            
            // Update placeholder text based on route type
            const nameInput = document.getElementById('route-name');
            const distanceInput = document.getElementById('route-distance');
            const elevationInput = document.getElementById('route-elevation');
            const timeInput = document.getElementById('route-time');
            
            if (isManual) {
                if (nameInput) nameInput.placeholder = 'Enter route name';
                if (distanceInput) distanceInput.placeholder = 'Enter distance (e.g., 15.5 mi)';
                if (elevationInput) elevationInput.placeholder = 'Enter elevation gain (e.g., 1,200 ft)';
                if (timeInput) timeInput.placeholder = 'Enter estimated time (e.g., 2:04:20 or 2h 4m)';
            } else {
                if (nameInput) nameInput.placeholder = 'Will be auto-filled from Strava, or enter manually';
                if (distanceInput) distanceInput.placeholder = 'Will be auto-filled from Strava';
                if (elevationInput) elevationInput.placeholder = 'Will be auto-filled from Strava';
                if (timeInput) timeInput.placeholder = 'Will be calculated from distance and elevation';
            }
            
            // Initialize fitness range slider (default to full range: 1 to current fitness scale)
            const fitnessScale = getFitnessScale();
            // For new routes, default to full range (1 to fitnessScale)
            const fitnessMin = route && route.fitnessMin !== undefined ? route.fitnessMin : 1;
            const fitnessMax = route && route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
            // Ensure at least 1-value difference, but preserve full range for new routes
            const validFitnessMin = route ? Math.min(fitnessMin, Math.max(1, fitnessMax - 1)) : 1;
            const validFitnessMax = route ? Math.max(fitnessMax, Math.min(fitnessScale, fitnessMin + 1)) : fitnessScale;
            const fitnessMinInput = document.getElementById('route-fitness-min');
            const fitnessMaxInput = document.getElementById('route-fitness-max');
            if (fitnessMinInput && fitnessMaxInput) {
                fitnessMinInput.value = validFitnessMin;
                fitnessMaxInput.value = validFitnessMax;
                fitnessMinInput.max = validFitnessMax - 1;
                fitnessMaxInput.min = validFitnessMin + 1;
                fitnessMaxInput.max = fitnessScale;
            }
            setTimeout(() => {
                updateFitnessRange();
                setupSliderDrag('fitness', 1, fitnessScale, fitnessScale - 1);
            }, 50);
            
            // Initialize bike skills range slider (default to full range: 1 to current skills scale)
            const skillsScale = getSkillsScale();
            // For new routes, default to full range (1 to skillsScale)
            const skillsMin = route && route.skillsMin !== undefined ? route.skillsMin : 1;
            const skillsMax = route && route.skillsMax !== undefined ? route.skillsMax : skillsScale;
            // Ensure at least 1-value difference, but preserve full range for new routes
            const validSkillsMin = route ? Math.min(skillsMin, Math.max(1, skillsMax - 1)) : 1;
            const validSkillsMax = route ? Math.max(skillsMax, Math.min(skillsScale, skillsMin + 1)) : skillsScale;
            const skillsMinInput = document.getElementById('route-skills-min');
            const skillsMaxInput = document.getElementById('route-skills-max');
            if (skillsMinInput && skillsMaxInput) {
                skillsMinInput.value = validSkillsMin;
                skillsMaxInput.value = validSkillsMax;
                skillsMinInput.max = validSkillsMax - 1;
                skillsMaxInput.min = validSkillsMin + 1;
                skillsMaxInput.max = skillsScale;
            }
            setTimeout(() => {
                updateSkillsRange();
                setupSliderDrag('skills', 1, skillsScale, skillsScale - 1);
            }, 50);
            
            // Update max attributes and regenerate scale labels
            updateInputMaxAttributes();
            updateRouteSliderLabels();
            
            // Add event listeners for auto-calculating time when distance/elevation change
            const distanceInputEl = document.getElementById('route-distance');
            const elevationInputEl = document.getElementById('route-elevation');
            const timeInputEl = document.getElementById('route-time');
            
            // Remove existing listeners by cloning and replacing
            if (distanceInputEl) {
                const newDistanceInput = distanceInputEl.cloneNode(true);
                distanceInputEl.parentNode.replaceChild(newDistanceInput, distanceInputEl);
            }
            if (elevationInputEl) {
                const newElevationInput = elevationInputEl.cloneNode(true);
                elevationInputEl.parentNode.replaceChild(newElevationInput, elevationInputEl);
            }
            
            // Add new listeners
            const updatedDistanceInput = document.getElementById('route-distance');
            const updatedElevationInput = document.getElementById('route-elevation');
            const updatedTimeInput = document.getElementById('route-time');
            
            function updateTimeFromDistanceElevation() {
                const distance = updatedDistanceInput ? updatedDistanceInput.value.trim() : '';
                const elevation = updatedElevationInput ? updatedElevationInput.value.trim() : '';
                if (distance && updatedTimeInput) {
                    const calculatedTime = calculateEstimatedTime(distance, elevation);
                    if (calculatedTime) {
                        // Always update since field is readonly and calculated
                        updatedTimeInput.value = calculatedTime;
                    }
                }
            }
            
            if (updatedDistanceInput) {
                updatedDistanceInput.addEventListener('input', updateTimeFromDistanceElevation);
                updatedDistanceInput.addEventListener('blur', updateTimeFromDistanceElevation);
            }
            if (updatedElevationInput) {
                updatedElevationInput.addEventListener('input', updateTimeFromDistanceElevation);
                updatedElevationInput.addEventListener('blur', updateTimeFromDistanceElevation);
            }
            
            // Store route ID for editing and route type
            if (isEdit) {
                modal.setAttribute('data-editing-route-id', routeId);
            } else {
                modal.removeAttribute('data-editing-route-id');
            }
            modal.setAttribute('data-is-manual-route', isManual ? 'true' : 'false');

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');

            // Setup embed code listener for auto-fetch (only for Strava routes)
            if (!isManual) {
                setupRouteDataExtraction();
            }

            // Focus on route name input for manual routes, embed code for Strava routes
            setTimeout(() => {
                if (isManual) {
                    document.getElementById('route-name').focus();
                } else {
                    document.getElementById('route-embed-code').focus();
                }
            }, 100);
        }

        // Configuration for proxy server
        const PROXY_SERVER_URL = 'http://localhost:3001'; // Change this if your server runs on a different port/URL

        function setupRouteDataExtraction() {
            const embedCodeInput = document.getElementById('route-embed-code');
            const fetchBtn = document.getElementById('fetch-route-data-btn');
            if (!embedCodeInput || !fetchBtn) return;
            
            // Enable/disable fetch button based on embed code content
            function updateButtonState() {
                const embedCode = embedCodeInput.value.trim();
                const extractedUrl = embedCode ? extractRouteUrlFromEmbed(embedCode) : null;
                const hasValidUrl = !!extractedUrl;
                
                fetchBtn.disabled = !hasValidUrl;
                
                const statusEl = document.getElementById('fetch-route-status');
                if (!hasValidUrl && embedCode) {
                    // Show helpful message if code is pasted but URL can't be extracted
                    if (statusEl) {
                        statusEl.textContent = 'Make sure the embed code contains a Strava URL';
                        statusEl.style.color = '#ff9800';
                    }
                } else if (hasValidUrl) {
                    // Show that URL was found
                    if (statusEl && !statusEl.textContent.includes('✓') && !statusEl.textContent.includes('Error') && !statusEl.textContent.includes('Fetching')) {
                        statusEl.textContent = 'Ready to fetch';
                        statusEl.style.color = '#4caf50';
                    }
                } else {
                    // Clear status when no embed code
                    if (statusEl && !statusEl.textContent.includes('✓') && !statusEl.textContent.includes('Error')) {
                        statusEl.textContent = '';
                    }
                }
            }
            
            // Check on input
            embedCodeInput.addEventListener('input', updateButtonState);
            
            // Check on paste (with slight delay to let paste complete)
            embedCodeInput.addEventListener('paste', function() {
                setTimeout(updateButtonState, 100);
            });
            
            // Initial state check
            updateButtonState();
        }

        function extractRouteUrlFromEmbed(embedCode) {
            // Method 1: Try to find URL in src attribute of iframe (old format)
            const iframeSrcMatch = embedCode.match(/src=["']([^"']*strava\.com[^"']*)["']/i);
            if (iframeSrcMatch) {
                return iframeSrcMatch[1];
            }
            
            // Method 2: Try to find any Strava URL in the code
            const urlMatch = embedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
            if (urlMatch) {
                return urlMatch[0];
            }
            
            // Method 3: Extract route ID from new Strava embed format (data-embed-id)
            // Handle both quoted and unquoted values, with optional whitespace
            const routeIdMatch = embedCode.match(/data-embed-id\s*=\s*["']?(\d+)["']?/i);
            if (routeIdMatch) {
                const routeId = routeIdMatch[1];
                // Construct Strava route URL from the route ID
                return `https://www.strava.com/routes/${routeId}`;
            }
            
            // Method 4: Try to find route ID in various patterns
            const routeIdPatterns = [
                /routes\/(\d+)/i,
                /route\/(\d+)/i,
                /\/r\/(\d+)/i
            ];
            
            for (const pattern of routeIdPatterns) {
                const match = embedCode.match(pattern);
                if (match) {
                    return `https://www.strava.com/routes/${match[1]}`;
                }
            }
            
            return null;
        }

        // Calculate estimated time based on distance and elevation
        // Uses configurable mountain biking speeds, adjusted for elevation and route length
        function calculateEstimatedTime(distanceStr, elevationStr) {
            if (!distanceStr) return null;
            
            // Get settings (with defaults)
            const settings = data.timeEstimationSettings || {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            // Parse distance (handle formats like "22.6 mi", "15.5 km", etc.)
            const distanceMatch = distanceStr.match(/(\d+\.?\d*)\s*(mi|km|miles|kilometers?)/i);
            if (!distanceMatch) return null;
            
            let distanceMiles = parseFloat(distanceMatch[1]);
            const unit = distanceMatch[2].toLowerCase();
            if (unit === 'km' || unit === 'kilometers' || unit === 'kilometer') {
                distanceMiles = distanceMiles * 0.621371; // Convert km to miles
            }
            
            // Parse elevation (handle formats like "3,079 ft", "1000 m", etc.)
            let elevationFeet = 0;
            if (elevationStr) {
                const elevMatch = elevationStr.match(/([\d,]+\.?\d*)\s*(ft|feet|m|meters?)/i);
                if (elevMatch) {
                    elevationFeet = parseFloat(elevMatch[1].replace(/,/g, ''));
                    const elevUnit = elevMatch[2].toLowerCase();
                    if (elevUnit === 'm' || elevUnit === 'meters' || elevUnit === 'meter') {
                        elevationFeet = elevationFeet * 3.28084; // Convert meters to feet
                    }
                }
            }
            
            // Calculate adjustments
            const elevationAdjustment = (elevationFeet / 1000) * settings.elevationAdjustment;
            const lengthAdjustment = Math.max(0, (distanceMiles - 10) * settings.lengthAdjustmentFactor);
            
            // Calculate speeds with adjustments
            const fastSpeed = Math.max(settings.fastSpeedMin, settings.fastSpeedBase - elevationAdjustment - lengthAdjustment);
            const slowSpeed = Math.max(settings.slowSpeedMin, settings.slowSpeedBase - elevationAdjustment - lengthAdjustment);
            
            // Calculate time in hours
            const fastTimeHours = distanceMiles / fastSpeed;
            const slowTimeHours = distanceMiles / slowSpeed;
            
            // Convert to HH:MM format, rounded to nearest 5 minutes
            function formatTime(hours) {
                const totalMinutes = Math.round(hours * 60);
                // Round to nearest 5 minutes
                const roundedMinutes = Math.round(totalMinutes / 5) * 5;
                const h = Math.floor(roundedMinutes / 60);
                const m = roundedMinutes % 60;
                
                if (h > 0) {
                    return `${h}:${String(m).padStart(2, '0')}`;
                } else {
                    return `0:${String(m).padStart(2, '0')}`;
                }
            }
            
            const fastTime = formatTime(fastTimeHours);
            const slowTime = formatTime(slowTimeHours);
            
            // Return range format: "fastTime - slowTime" or just one time if they're close
            if (fastTime === slowTime) {
                return fastTime;
            } else {
                return `${fastTime} - ${slowTime}`;
            }
        }

        async function fetchRouteDataFromEmbed() {
            const embedCodeInput = document.getElementById('route-embed-code');
            const statusEl = document.getElementById('fetch-route-status');
            const fetchBtn = document.getElementById('fetch-route-data-btn');
            
            if (!embedCodeInput) return;
            
            const embedCode = embedCodeInput.value.trim();
            if (!embedCode) {
                if (statusEl) statusEl.textContent = 'Please paste embed code first';
                return;
            }
            
            const routeUrl = extractRouteUrlFromEmbed(embedCode);
            if (!routeUrl) {
                if (statusEl) statusEl.textContent = 'Could not extract route URL from embed code';
                return;
            }
            
            // Update UI
            if (fetchBtn) {
                fetchBtn.disabled = true;
                fetchBtn.textContent = 'Fetching...';
            }
            if (statusEl) statusEl.textContent = 'Fetching route data...';
            
            try {
                const response = await fetch(`${PROXY_SERVER_URL}/api/fetch-strava-route?url=${encodeURIComponent(routeUrl)}`);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Populate form fields (always populate when auto-fill is clicked)
                if (data.name) {
                    const nameInput = document.getElementById('route-name');
                    if (nameInput) {
                        nameInput.value = data.name;
                    }
                }
                
                if (data.distance) {
                    const distanceInput = document.getElementById('route-distance');
                    if (distanceInput) {
                        distanceInput.value = data.distance;
                    }
                }
                
                if (data.elevation) {
                    const elevationInput = document.getElementById('route-elevation');
                    if (elevationInput) {
                        elevationInput.value = data.elevation;
                    }
                }
                
                // Calculate estimated time based on distance and elevation (instead of using Strava's time)
                const calculatedTime = calculateEstimatedTime(data.distance || '', data.elevation || '');
                if (calculatedTime) {
                    const timeInput = document.getElementById('route-time');
                    if (timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
                
                if (statusEl) {
                    statusEl.textContent = '✓ Route data fetched successfully!';
                    statusEl.style.color = '#4caf50';
                }
                
            } catch (error) {
                console.error('Error fetching route data:', error);
                
                // Check for connection errors
                const isConnectionError = error.message.includes('Failed to fetch') || 
                                         error.message.includes('network') || 
                                         error.message.toLowerCase().includes('connection') ||
                                         error.message.includes('ERR_CONNECTION_REFUSED') ||
                                         error.name === 'TypeError';
                
                if (statusEl) {
                    if (isConnectionError) {
                        statusEl.innerHTML = '⚠️ Strava API server not available. The auto-fill feature requires a backend server to be running. You can still enter route information manually.';
                        statusEl.style.color = '#ff9800';
                    } else {
                        statusEl.textContent = `Error: ${error.message}`;
                        statusEl.style.color = '#f44336';
                    }
                }
                
                // Only show alert for non-connection errors (connection errors already have status message)
                if (!isConnectionError) {
                    let errorMessage = `Unable to fetch route data automatically.\n\nError: ${error.message}\n\n`;
                    errorMessage += `Make sure the proxy server is running on ${PROXY_SERVER_URL}\n\n`;
                    errorMessage += `You can still enter the route information manually.`;
                    alert(errorMessage);
                }
            } finally {
                if (fetchBtn) {
                    fetchBtn.disabled = false;
                    fetchBtn.textContent = '🔍 Auto-fill Route Info from Strava';
                }
            }
        }

        // Slider drag functionality
        let isDragging = false;
        let dragHandle = null;
        let dragSlider = null;
        let dragType = null;
        let dragStartX = 0;
        let dragStartPercent = 0;

        // Global drag handlers (only add once)
        if (!window.sliderDragHandlersAdded) {
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                handleDrag(e);
            });
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                handleDrag(e);
            });
            document.addEventListener('mouseup', function() {
                stopDrag();
            });
            document.addEventListener('touchend', function() {
                stopDrag();
            });
            window.sliderDragHandlersAdded = true;
        }

        function handleDrag(e) {
            if (!isDragging || !dragSlider) return;
            
            const track = document.getElementById(`route-${dragSlider}-slider-track`);
            if (!track) return;
            
            const rect = track.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            // Use actual scale values instead of hardcoded values
            const sliderMax = dragSlider === 'fitness' ? getFitnessScale() : getSkillsScale();
            // Round to ensure whole number values
            const value = Math.round(1 + (percent / 100) * (sliderMax - 1));
            updateSliderValue(dragSlider, dragType, value);
        }

        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                if (dragHandle) dragHandle.style.cursor = 'grab';
                dragHandle = null;
                dragSlider = null;
                dragType = null;
                dragStartX = 0;
                dragStartPercent = 0;
            }
        }

        function setupSliderDrag(sliderName, minValue, maxValue, totalRange) {
            const minHandle = document.getElementById(`route-${sliderName}-min-handle`);
            const maxHandle = document.getElementById(`route-${sliderName}-max-handle`);
            const track = document.getElementById(`route-${sliderName}-slider-track`);
            
            if (!minHandle || !maxHandle || !track) return;

            // Remove existing listeners by cloning and replacing
            const newMinHandle = minHandle.cloneNode(true);
            const newMaxHandle = maxHandle.cloneNode(true);
            minHandle.parentNode.replaceChild(newMinHandle, minHandle);
            maxHandle.parentNode.replaceChild(newMaxHandle, maxHandle);

            function startDrag(e, type) {
                isDragging = true;
                dragHandle = type === 'min' ? newMinHandle : newMaxHandle;
                dragSlider = sliderName;
                dragType = type;
                dragHandle.style.cursor = 'grabbing';
                e.preventDefault();
                e.stopPropagation();
            }

            newMinHandle.addEventListener('mousedown', (e) => startDrag(e, 'min'));
            newMaxHandle.addEventListener('mousedown', (e) => startDrag(e, 'max'));
            newMinHandle.addEventListener('touchstart', (e) => startDrag(e, 'min'));
            newMaxHandle.addEventListener('touchstart', (e) => startDrag(e, 'max'));
        }

        function updateSliderValue(sliderName, type, newValue) {
            // Get elements fresh each time (handles may have been cloned)
            const minHandle = document.getElementById(`route-${sliderName}-min-handle`);
            const maxHandle = document.getElementById(`route-${sliderName}-max-handle`);
            const range = document.getElementById(`route-${sliderName}-slider-range`);
            const minValueDisplay = document.getElementById(`route-${sliderName}-min-value`);
            const maxValueDisplay = document.getElementById(`route-${sliderName}-max-value`);
            const minInput = document.getElementById(`route-${sliderName}-min`);
            const maxInput = document.getElementById(`route-${sliderName}-max`);
            
            if (!minInput || !maxInput) return;
            
            const sliderMax = sliderName === 'fitness' ? getFitnessScale() : getSkillsScale();
            // Round to whole numbers to ensure sliders snap to integer values
            let minValue = Math.round(parseFloat(minInput.value) || 1);
            let maxValue = Math.round(parseFloat(maxInput.value) || sliderMax);
            
            // Round the new value to nearest whole number
            newValue = Math.round(newValue);
            
            if (type === 'min') {
                // Min cannot exceed (max - 1) to maintain at least 1-value range
                newValue = Math.max(1, Math.min(newValue, maxValue - 1));
                minInput.value = newValue;
                minValue = newValue;
                // Update max input's min constraint
                maxInput.min = minValue + 1;
            } else if (type === 'max') {
                // Max cannot go below (min + 1) to maintain at least 1-value range
                newValue = Math.max(minValue + 1, Math.min(newValue, sliderMax));
                maxInput.value = newValue;
                maxValue = newValue;
                // Update min input's max constraint
                minInput.max = maxValue - 1;
            }
            
            // Calculate percentages based on current scale
            const scaleRange = sliderMax - 1;
            const minPercent = scaleRange > 0 ? ((minValue - 1) / scaleRange) * 100 : 0;
            const maxPercent = scaleRange > 0 ? ((maxValue - 1) / scaleRange) * 100 : 100;
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }

        function updateFitnessRange() {
            const minInput = document.getElementById('route-fitness-min');
            const maxInput = document.getElementById('route-fitness-max');
            if (!minInput || !maxInput) return;
            
            const fitnessScale = getFitnessScale();
            // Round to whole numbers to ensure sliders snap to integer values
            let minValue = Math.round(parseFloat(minInput.value) || 1);
            let maxValue = Math.round(parseFloat(maxInput.value) || fitnessScale);
            
            // Clamp values to valid range
            minValue = Math.max(1, Math.min(minValue, fitnessScale));
            maxValue = Math.max(1, Math.min(maxValue, fitnessScale));
            
            // Enforce constraints: min < max and at least 1-value difference
            if (minValue >= maxValue) {
                if (minInput === document.activeElement || dragType === 'min') {
                    maxValue = Math.min(fitnessScale, minValue + 1);
                    maxInput.value = maxValue;
                } else {
                    minValue = Math.max(1, maxValue - 1);
                    minInput.value = minValue;
                }
            }
            
            // Update input values to ensure they're whole numbers
            minInput.value = minValue;
            maxInput.value = maxValue;
            
            // Calculate percentages based on current scale
            const scaleRange = fitnessScale - 1;
            const minPercent = scaleRange > 0 ? ((minValue - 1) / scaleRange) * 100 : 0;
            const maxPercent = scaleRange > 0 ? ((maxValue - 1) / scaleRange) * 100 : 100;
            
            const range = document.getElementById('route-fitness-slider-range');
            const minHandle = document.getElementById('route-fitness-min-handle');
            const maxHandle = document.getElementById('route-fitness-max-handle');
            const minValueDisplay = document.getElementById('route-fitness-min-value');
            const maxValueDisplay = document.getElementById('route-fitness-max-value');
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }
        
        function updateSkillsRange() {
            const minInput = document.getElementById('route-skills-min');
            const maxInput = document.getElementById('route-skills-max');
            if (!minInput || !maxInput) return;
            
            const skillsScale = getSkillsScale();
            // Round to whole numbers to ensure sliders snap to integer values
            let minValue = Math.round(parseFloat(minInput.value) || 1);
            let maxValue = Math.round(parseFloat(maxInput.value) || skillsScale);
            
            // Clamp values to valid range
            minValue = Math.max(1, Math.min(minValue, skillsScale));
            maxValue = Math.max(1, Math.min(maxValue, skillsScale));
            
            // Enforce constraints: min < max and at least 1-value difference
            if (minValue >= maxValue) {
                if (minInput === document.activeElement || dragType === 'min') {
                    maxValue = Math.min(skillsScale, minValue + 1);
                    maxInput.value = maxValue;
                } else {
                    minValue = Math.max(1, maxValue - 1);
                    minInput.value = minValue;
                }
            }
            
            // Update input values to ensure they're whole numbers
            minInput.value = minValue;
            maxInput.value = maxValue;
            
            // Calculate percentages based on current scale
            const scaleRange = skillsScale - 1;
            const minPercent = scaleRange > 0 ? ((minValue - 1) / scaleRange) * 100 : 0;
            const maxPercent = scaleRange > 0 ? ((maxValue - 1) / scaleRange) * 100 : 100;
            
            const range = document.getElementById('route-skills-slider-range');
            const minHandle = document.getElementById('route-skills-min-handle');
            const maxHandle = document.getElementById('route-skills-max-handle');
            const minValueDisplay = document.getElementById('route-skills-min-value');
            const maxValueDisplay = document.getElementById('route-skills-max-value');
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }
        
        function showEmbedCodeTooltip(event) {
            const tooltip = document.getElementById('embed-code-tooltip');
            if (!tooltip) return;
            
            tooltip.style.display = 'block';
            
            // Position tooltip relative to the icon
            const icon = event.target;
            const iconRect = icon.getBoundingClientRect();
            const container = tooltip.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            // Calculate position relative to container
            const relativeLeft = iconRect.left - containerRect.left;
            const relativeTop = iconRect.top - containerRect.top;
            
            // Position to the right of the icon
            tooltip.style.left = (relativeLeft + iconRect.width + 8) + 'px';
            tooltip.style.top = (relativeTop - 4) + 'px';
            
            // Adjust if tooltip would go off screen
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                if (tooltipRect.right > containerRect.right) {
                    // Position to the left of icon instead
                    tooltip.style.left = (relativeLeft - tooltipRect.width - 8) + 'px';
                }
                
                if (tooltipRect.bottom > containerRect.bottom) {
                    // Position above icon
                    tooltip.style.top = (relativeTop - tooltipRect.height - 8) + 'px';
                }
            }, 0);
        }
        
        function hideEmbedCodeTooltip() {
            const tooltip = document.getElementById('embed-code-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function closeAddRouteModal() {
            const modal = document.getElementById('add-route-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            hideEmbedCodeTooltip();
        }

        // Store original settings when modal opens for discard functionality
        let timeEstimationSettingsOriginal = null;

        function openTimeEstimationSettings() {
            const modal = document.getElementById('time-estimation-settings-modal');
            if (!modal) {
                console.error('Time estimation settings modal not found');
                return;
            }
            
            // Load current settings
            const settings = data.timeEstimationSettings || {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            // Store original settings for discard functionality
            timeEstimationSettingsOriginal = JSON.parse(JSON.stringify(settings));
            
            const fastSpeedInput = document.getElementById('time-settings-fast-speed');
            const slowSpeedInput = document.getElementById('time-settings-slow-speed');
            const fastMinInput = document.getElementById('time-settings-fast-min');
            const slowMinInput = document.getElementById('time-settings-slow-min');
            const elevationInput = document.getElementById('time-settings-elevation');
            const lengthInput = document.getElementById('time-settings-length');
            
            if (fastSpeedInput) fastSpeedInput.value = settings.fastSpeedBase;
            if (slowSpeedInput) slowSpeedInput.value = settings.slowSpeedBase;
            if (fastMinInput) fastMinInput.value = settings.fastSpeedMin;
            if (slowMinInput) slowMinInput.value = settings.slowSpeedMin;
            if (elevationInput) elevationInput.value = settings.elevationAdjustment;
            if (lengthInput) lengthInput.value = settings.lengthAdjustmentFactor;
            
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeTimeEstimationSettings() {
            const modal = document.getElementById('time-estimation-settings-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            timeEstimationSettingsOriginal = null;
        }

        function saveTimeEstimationSettings() {
            // Save current values (updateTimeEstimationSettings already saves to data and localStorage)
            updateTimeEstimationSettings();
            closeTimeEstimationSettings();
        }

        function discardTimeEstimationSettings() {
            if (!timeEstimationSettingsOriginal) {
                closeTimeEstimationSettings();
                return;
            }
            
            // Restore original values
            const fastSpeedInput = document.getElementById('time-settings-fast-speed');
            const slowSpeedInput = document.getElementById('time-settings-slow-speed');
            const fastMinInput = document.getElementById('time-settings-fast-min');
            const slowMinInput = document.getElementById('time-settings-slow-min');
            const elevationInput = document.getElementById('time-settings-elevation');
            const lengthInput = document.getElementById('time-settings-length');
            
            if (fastSpeedInput) fastSpeedInput.value = timeEstimationSettingsOriginal.fastSpeedBase;
            if (slowSpeedInput) slowSpeedInput.value = timeEstimationSettingsOriginal.slowSpeedBase;
            if (fastMinInput) fastMinInput.value = timeEstimationSettingsOriginal.fastSpeedMin;
            if (slowMinInput) slowMinInput.value = timeEstimationSettingsOriginal.slowSpeedMin;
            if (elevationInput) elevationInput.value = timeEstimationSettingsOriginal.elevationAdjustment;
            if (lengthInput) lengthInput.value = timeEstimationSettingsOriginal.lengthAdjustmentFactor;
            
            // Restore data object
            data.timeEstimationSettings = JSON.parse(JSON.stringify(timeEstimationSettingsOriginal));
            saveData();
            
            // Recalculate time for current route if modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
            
            closeTimeEstimationSettings();
        }

        function previewTimeEstimationSettings() {
            // Preview changes without saving - just update the time estimate if route modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    // Temporarily update settings for preview
                    const tempSettings = {
                        fastSpeedBase: parseFloat(document.getElementById('time-settings-fast-speed').value) || 12.5,
                        slowSpeedBase: parseFloat(document.getElementById('time-settings-slow-speed').value) || 10,
                        fastSpeedMin: parseFloat(document.getElementById('time-settings-fast-min').value) || 5.5,
                        slowSpeedMin: parseFloat(document.getElementById('time-settings-slow-min').value) || 4,
                        elevationAdjustment: parseFloat(document.getElementById('time-settings-elevation').value) || 0.5,
                        lengthAdjustmentFactor: parseFloat(document.getElementById('time-settings-length').value) || 0.1
                    };
                    
                    // Temporarily set settings for calculation
                    const originalSettings = data.timeEstimationSettings;
                    data.timeEstimationSettings = tempSettings;
                    
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    
                    // Restore original settings
                    data.timeEstimationSettings = originalSettings;
                    
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
        }

        function updateTimeEstimationSettings() {
            const settings = {
                fastSpeedBase: parseFloat(document.getElementById('time-settings-fast-speed').value) || 12.5,
                slowSpeedBase: parseFloat(document.getElementById('time-settings-slow-speed').value) || 10,
                fastSpeedMin: parseFloat(document.getElementById('time-settings-fast-min').value) || 5.5,
                slowSpeedMin: parseFloat(document.getElementById('time-settings-slow-min').value) || 4,
                elevationAdjustment: parseFloat(document.getElementById('time-settings-elevation').value) || 0.5,
                lengthAdjustmentFactor: parseFloat(document.getElementById('time-settings-length').value) || 0.1
            };
            
            data.timeEstimationSettings = settings;
            saveData();
            
            // Recalculate time for current route if modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
        }

        function resetTimeEstimationSettings() {
            const defaults = {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            document.getElementById('time-settings-fast-speed').value = defaults.fastSpeedBase;
            document.getElementById('time-settings-slow-speed').value = defaults.slowSpeedBase;
            document.getElementById('time-settings-fast-min').value = defaults.fastSpeedMin;
            document.getElementById('time-settings-slow-min').value = defaults.slowSpeedMin;
            document.getElementById('time-settings-elevation').value = defaults.elevationAdjustment;
            document.getElementById('time-settings-length').value = defaults.lengthAdjustmentFactor;
            
            previewTimeEstimationSettings();
        }

        async function saveRoute() {
            const modal = document.getElementById('add-route-modal');
            const isEdit = modal && modal.hasAttribute('data-editing-route-id');
            const routeId = isEdit ? parseInt(modal.getAttribute('data-editing-route-id'), 10) : null;
            const isManual = modal && modal.getAttribute('data-is-manual-route') === 'true';

            const nameInput = document.getElementById('route-name');
            const descriptionInput = document.getElementById('route-description');
            const distanceInput = document.getElementById('route-distance');
            const elevationInput = document.getElementById('route-elevation');
            const timeInput = document.getElementById('route-time');
            const embedCodeInput = document.getElementById('route-embed-code');
            const fitnessMinInput = document.getElementById('route-fitness-min');
            const fitnessMaxInput = document.getElementById('route-fitness-max');
            const skillsMinInput = document.getElementById('route-skills-min');
            const skillsMaxInput = document.getElementById('route-skills-max');

            const name = nameInput.value.trim();
            const embedCode = embedCodeInput ? embedCodeInput.value.trim() : '';
            const fitnessMin = parseInt(fitnessMinInput.value);
            const fitnessMax = parseInt(fitnessMaxInput.value);
            const skillsMin = parseInt(skillsMinInput.value);
            const skillsMax = parseInt(skillsMaxInput.value);

            if (!name) {
                alert('Please enter a route name');
                return;
            }

            // Only require embed code for Strava routes
            if (!isManual && !embedCode) {
                alert('Please paste the Strava embed code');
                return;
            }

            // Extract Strava URL from embed code if it exists
            let stravaUrl = null;
            if (embedCode && !isManual) {
                stravaUrl = extractRouteUrlFromEmbed(embedCode);
                // Clean up URL - remove query parameters that might break the link
                if (stravaUrl) {
                    stravaUrl = stravaUrl.split('?')[0];
                }
            }

            // Initialize routes array if needed
            if (!Array.isArray(data.routes)) {
                data.routes = [];
            }

            // Prepare route data
            const routeData = {
                        name: name,
                        description: descriptionInput.value.trim() || null,
                        stravaEmbedCode: isManual ? null : embedCode,
                        stravaUrl: isManual ? null : stravaUrl,
                        distance: distanceInput.value.trim() || null,
                        elevation: elevationInput.value.trim() || null,
                        estimatedTime: timeInput ? timeInput.value.trim() || null : null,
                        fitnessMin: fitnessMin,
                        fitnessMax: fitnessMax,
                        skillsMin: skillsMin,
                        skillsMax: skillsMax
                    };

            // Check if database functions are available and user is authenticated
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof updateRoute !== 'undefined' && typeof createRoute !== 'undefined') {
                // Authenticated user - save to Supabase
                try {
                    if (isEdit && routeId) {
                        // Update existing route in Supabase
                        const updated = await updateRoute(routeId, routeData);
                        // Update local data (merge with existing fields, prioritize Supabase response)
                        const routeIndex = data.routes.findIndex(r => r.id === routeId);
                        if (routeIndex >= 0) {
                            data.routes[routeIndex] = { ...data.routes[routeIndex], ...routeData, ...updated };
                }
            } else {
                        // Create new route in Supabase
                        const created = await createRoute(routeData);
                        // Add to local data (use full data from Supabase response)
                        routeData.id = created.id;
                        data.routes.push({ ...routeData, ...created });
                    }
                    // Save to localStorage as backup (after successful Supabase save)
            saveData();
                } catch (error) {
                    console.error('Error saving route to Supabase:', error);
                    // Fall back to localStorage-only save
                    if (isEdit && routeId) {
                        const routeIndex = data.routes.findIndex(r => r.id === routeId);
                        if (routeIndex >= 0) {
                            data.routes[routeIndex] = { ...data.routes[routeIndex], ...routeData };
                        }
                    } else {
                        routeData.id = Date.now() + Math.floor(Math.random() * 1000);
                        data.routes.push(routeData);
                    }
                    saveData();
                }
            } else {
                // Not authenticated - save to localStorage only
                if (isEdit && routeId) {
                    const routeIndex = data.routes.findIndex(r => r.id === routeId);
                    if (routeIndex >= 0) {
                        data.routes[routeIndex] = { ...data.routes[routeIndex], ...routeData };
                    }
                } else {
                    routeData.id = Date.now() + Math.floor(Math.random() * 1000);
                    data.routes.push(routeData);
                }
                saveData();
            }
            
            // Render routes
            renderRoutes();
            
            // Close modal and reopen routes manager
            closeAddRouteModal();
            openRoutesManagerModal();
        }

        async function deleteRouteHandler(routeId) {
            if (!confirm('Are you sure you want to delete this route?')) {
                return;
            }

            // Check if database functions are available and user is authenticated
            const client = getSupabaseClient();
            const currentUser = typeof getCurrentUser === 'function' ? getCurrentUser() : null;
            
            if (client && currentUser && typeof deleteRoute !== 'undefined') {
                // Authenticated user - delete from Supabase
                try {
                    await deleteRoute(routeId);
            // Remove from local data
            data.routes = data.routes.filter(r => r.id !== routeId);
                } catch (error) {
                    console.error('Error deleting route from Supabase:', error);
                    // Still remove from local data on error
                    data.routes = data.routes.filter(r => r.id !== routeId);
            saveData();
                }
            } else {
                // Not authenticated - delete from localStorage only
                data.routes = data.routes.filter(r => r.id !== routeId);
                saveData();
            }
            
            // Re-render routes
            renderRoutes();
        }

        // ============ RACES MANAGEMENT ============
        
        function openAddRacesModal() {
            const modal = document.getElementById('add-races-modal');
            if (!modal) return;
            
            // Initialize races array if needed
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            renderRacesList();
            
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }
        
        function closeAddRacesModal() {
            const modal = document.getElementById('add-races-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }
        
        function renderRacesList() {
            const container = document.getElementById('races-list-container');
            if (!container) return;
            
            if (!Array.isArray(data.races) || data.races.length === 0) {
                container.innerHTML = '<p style="color: #666; font-size: 14px; margin-bottom: 12px;">No races added yet. Click "Add Another Race" to get started.</p>';
                addRaceEntry();
                return;
            }
            
            container.innerHTML = data.races.map((race, index) => {
                const raceDate = race.raceDate || '';
                const preRideDate = race.preRideDate || '';
                const name = escapeHtml(race.name || '');
                const location = escapeHtml(race.location || '');
                
                return `
                    <div class="form-row" style="border: 1px solid #ddd; border-radius: 4px; padding: 12px; margin-bottom: 12px; background: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 8px;">
                            <strong style="color: #333;">Race ${index + 1}</strong>
                            <button class="btn-small danger" onclick="removeRaceEntry(${index})" style="padding: 4px 8px; font-size: 11px;">Remove</button>
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Race Name</label>
                            <input type="text" id="race-name-${index}" value="${name}" placeholder="e.g., NorCal League Race 1" style="width: 100%;">
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Race Date</label>
                            <input type="date" id="race-date-${index}" value="${raceDate}" style="width: 100%;" onchange="handleRaceDateChange(${index})">
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Pre-Ride Date</label>
                            <input type="date" id="preride-date-${index}" value="${preRideDate}" style="width: 100%;">
                        </div>
                        <div style="flex: 1;">
                            <label class="field-label">Location</label>
                            <input type="text" id="race-location-${index}" value="${location}" placeholder="e.g., Granite Bay" style="width: 100%;">
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function addRaceEntry() {
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            // First, save any current form values to data.races before adding a new entry
            const racesContainer = document.getElementById('races-list-container');
            if (racesContainer) {
                const raceInputs = racesContainer.querySelectorAll('[id^="race-name-"]');
                raceInputs.forEach((nameInput, index) => {
                    const raceId = nameInput.id.replace('race-name-', '');
                    const name = nameInput.value.trim();
                    const raceDateInput = document.getElementById(`race-date-${raceId}`);
                    const preRideDateInput = document.getElementById(`preride-date-${raceId}`);
                    const locationInput = document.getElementById(`race-location-${raceId}`);
                    
                    const raceDate = raceDateInput ? raceDateInput.value.trim() : '';
                    const preRideDate = preRideDateInput ? preRideDateInput.value.trim() : '';
                    const location = locationInput ? locationInput.value.trim() : '';
                    
                    // Update or create race entry
                    if (index < data.races.length) {
                        // Update existing race
                        data.races[index].name = name;
                        data.races[index].raceDate = raceDate;
                        data.races[index].preRideDate = preRideDate;
                        data.races[index].location = location;
                    } else {
                        // Create new race entry
                        data.races.push({
                            id: Date.now() + Math.floor(Math.random() * 1000) + index,
                            name: name,
                            raceDate: raceDate,
                            preRideDate: preRideDate,
                            location: location
                        });
                    }
                });
            }
            
            // Now add a new empty race entry
            data.races.push({
                id: Date.now() + Math.floor(Math.random() * 1000),
                name: '',
                raceDate: '',
                preRideDate: '',
                location: ''
            });
            
            renderRacesList();
        }
        
        function handleRaceDateChange(index) {
            const raceDateInput = document.getElementById(`race-date-${index}`);
            const preRideDateInput = document.getElementById(`preride-date-${index}`);
            
            if (!raceDateInput || !preRideDateInput) return;
            
            const raceDate = raceDateInput.value;
            if (!raceDate) return;
            
            // Only auto-fill if preride date is empty
            if (!preRideDateInput.value) {
                const raceDateObj = parseISODate(raceDate);
                if (raceDateObj) {
                    // Set preride date to day before race date
                    const preRideDateObj = new Date(raceDateObj);
                    preRideDateObj.setDate(preRideDateObj.getDate() - 1);
                    preRideDateInput.value = formatDateToISO(preRideDateObj);
                }
            }
        }

        function removeRaceEntry(index) {
            if (!confirm('Are you sure you want to remove this race?')) {
                return;
            }
            
            // First, save all current form values to data.races before removing
            const racesContainer = document.getElementById('races-list-container');
            if (racesContainer) {
                const raceInputs = racesContainer.querySelectorAll('[id^="race-name-"]');
                raceInputs.forEach((nameInput, idx) => {
                    const raceId = nameInput.id.replace('race-name-', '');
                    const name = nameInput.value.trim();
                    const raceDateInput = document.getElementById(`race-date-${raceId}`);
                    const preRideDateInput = document.getElementById(`preride-date-${raceId}`);
                    const locationInput = document.getElementById(`race-location-${raceId}`);
                    
                    const raceDate = raceDateInput ? raceDateInput.value.trim() : '';
                    const preRideDate = preRideDateInput ? preRideDateInput.value.trim() : '';
                    const location = locationInput ? locationInput.value.trim() : '';
                    
                    // Update existing race entry
                    if (idx < data.races.length) {
                        data.races[idx].name = name;
                        data.races[idx].raceDate = raceDate;
                        data.races[idx].preRideDate = preRideDate;
                        data.races[idx].location = location;
                    }
                });
            }
            
            if (Array.isArray(data.races) && index >= 0 && index < data.races.length) {
                data.races.splice(index, 1);
                renderRacesList();
            }
        }
        
        function saveRaces() {
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            // Collect all race data from inputs
            const racesContainer = document.getElementById('races-list-container');
            if (!racesContainer) return;
            
            const raceInputs = racesContainer.querySelectorAll('[id^="race-name-"]');
            const updatedRaces = [];
            
            raceInputs.forEach((nameInput, index) => {
                const raceId = nameInput.id.replace('race-name-', '');
                const name = nameInput.value.trim();
                const raceDateInput = document.getElementById(`race-date-${raceId}`);
                const preRideDateInput = document.getElementById(`preride-date-${raceId}`);
                const locationInput = document.getElementById(`race-location-${raceId}`);
                
                const raceDate = raceDateInput ? raceDateInput.value.trim() : '';
                const preRideDate = preRideDateInput ? preRideDateInput.value.trim() : '';
                const location = locationInput ? locationInput.value.trim() : '';
                
                // Only save if at least name or date is provided
                if (name || raceDate) {
                    // Find existing race by index or create new
                    const existingRace = data.races[index];
                    updatedRaces.push({
                        id: existingRace ? existingRace.id : (Date.now() + Math.floor(Math.random() * 1000) + index),
                        name: name,
                        raceDate: raceDate,
                        preRideDate: preRideDate,
                        location: location
                    });
                }
            });
            
            data.races = updatedRaces;
            saveData();
            
            // Re-render calendar to show races
            renderSeasonCalendar();
            renderSeasonCalendarForSettings();
            
            closeAddRacesModal();
        }

        // Auto-Assign Settings Modal Functions
        function openAutoAssignSettingsModal() {
            const modal = document.getElementById('auto-assign-settings-modal');
            if (!modal) return;

            // Initialize settings if needed
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                if (!data.autoAssignSettings) {
                    data.autoAssignSettings = {
                        parameters: [
                            { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 1, enabled: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' },
                            { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 2, enabled: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                            { id: 'preferredCoachesPerGroup', name: 'Preferred Coaches per Group', value: 3, priority: 3, enabled: true, type: 'number', min: 1, max: 10, description: 'Target number of coaches per group' },
                            { id: 'preferredGroupSize', name: 'Preferred Group Size Range', valueMin: 4, valueMax: 8, priority: 4, enabled: true, type: 'range', min: 1, max: 30, description: 'Preferred number of riders per group (min-max range)' }
                        ]
                    };
                }
            }

            // Create draft copy
            autoAssignSettingsDraft = {
                parameters: data.autoAssignSettings.parameters.map(p => ({ ...p }))
            };

            renderAutoAssignSettings();
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeAutoAssignSettingsModal() {
            const modal = document.getElementById('auto-assign-settings-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            autoAssignSettingsDraft = null;
        }

        function renderAutoAssignSettings() {
            const container = document.getElementById('auto-assign-settings-list');
            if (!container || !autoAssignSettingsDraft) return;

            // Sort by priority
            const sortedParams = [...autoAssignSettingsDraft.parameters].sort((a, b) => a.priority - b.priority);

            container.innerHTML = sortedParams.map((param, index) => {
                const isRange = param.type === 'range' || (param.valueMin !== undefined && param.valueMax !== undefined);
                
                let inputHtml = '';
                if (isRange) {
                    // Range input (for preferredGroupSize)
                    inputHtml = `
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <label style="font-size: 12px; color: #666;">Min:</label>
                                <input 
                                    type="number" 
                                    id="auto-assign-param-${param.id}-min" 
                                    value="${param.valueMin || param.min || 1}" 
                                    min="${param.min || 1}" 
                                    max="${param.max || 100}"
                                    style="width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                                    onchange="updateAutoAssignParamRange('${param.id}', 'min', this.value)"
                                >
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <label style="font-size: 12px; color: #666;">Max:</label>
                                <input 
                                    type="number" 
                                    id="auto-assign-param-${param.id}-max" 
                                    value="${param.valueMax || param.max || 100}" 
                                    min="${param.min || 1}" 
                                    max="${param.max || 100}"
                                    style="width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                                    onchange="updateAutoAssignParamRange('${param.id}', 'max', this.value)"
                                >
                            </div>
                            <div style="flex: 1; font-size: 12px; color: #999;">
                                Range: ${param.min || 1} - ${param.max || 100}
                            </div>
                        </div>
                    `;
                } else {
                    // Single value input
                    inputHtml = `
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <input 
                                type="number" 
                                id="auto-assign-param-${param.id}" 
                                value="${param.value || 1}" 
                                min="${param.min || 1}" 
                                max="${param.max || 100}"
                                style="width: 100px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                                onchange="updateAutoAssignParamValue('${param.id}', this.value)"
                            >
                            <div style="flex: 1; font-size: 12px; color: #999;">
                                Range: ${param.min || 1} - ${param.max || 100}
                            </div>
                        </div>
                    `;
                }
                
                return `
                    <div style="border: 1px solid #ddd; border-radius: 4px; padding: 16px; margin-bottom: 12px; background: white;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <label style="font-weight: 600; color: #333; font-size: 14px; display: block; margin-bottom: 4px;">
                                    ${escapeHtml(param.name)}
                                </label>
                                <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                                    ${escapeHtml(param.description || '')}
                                </div>
                            </div>
                        </div>
                        ${inputHtml}
                    </div>
                `;
            }).join('');
        }

        function updateAutoAssignParamValue(id, value) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            const numValue = parseInt(value, 10);
            if (Number.isFinite(numValue)) {
                param.value = Math.max(param.min || 1, Math.min(param.max || 100, numValue));
            }
        }

        function updateAutoAssignParamRange(id, minOrMax, value) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            const numValue = parseInt(value, 10);
            if (Number.isFinite(numValue)) {
                if (minOrMax === 'min') {
                    param.valueMin = Math.max(param.min || 1, Math.min(param.max || 100, numValue));
                    // Ensure min doesn't exceed max
                    if (param.valueMax !== undefined && param.valueMin > param.valueMax) {
                        param.valueMin = param.valueMax;
                    }
                } else {
                    param.valueMax = Math.max(param.min || 1, Math.min(param.max || 100, numValue));
                    // Ensure max isn't less than min
                    if (param.valueMin !== undefined && param.valueMax < param.valueMin) {
                        param.valueMax = param.valueMin;
                    }
                }
            }
        }

        function saveAutoAssignSettings() {
            if (!autoAssignSettingsDraft) return;
            
            // Save to data
            data.autoAssignSettings = {
                parameters: autoAssignSettingsDraft.parameters.map(p => ({ ...p }))
            };
            
            // Save to localStorage
            saveData();
            
            closeAutoAssignSettingsModal();
            alert('Auto-assign settings saved successfully!');
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
