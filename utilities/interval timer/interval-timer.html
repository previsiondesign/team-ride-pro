<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Interval Timer">
    <meta name="apple-mobile-web-app-status-bar-style" content="#2196F3">
    <title>Interval Timer</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' fill='%232196F3' rx='40'/%3E%3Ctext x='90' y='130' font-size='100' font-family='Arial' fill='white' text-anchor='middle'%3E⏱%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Allerta+Stencil&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #333;
        }
        
        body.fullscreen {
            padding: 0;
            overflow: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        body.fullscreen .container {
            max-width: 100%;
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Use dynamic viewport height for mobile */
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            background: transparent;
            display: block;
            position: relative;
            overflow: hidden;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
            color: #333;
            font-weight: 600;
        }
        
        .setup-screen, .timer-screen, .countdown-screen {
            display: none;
        }
        
        .setup-screen.active, .timer-screen.active, .countdown-screen.active {
            display: block;
        }
        
        body.fullscreen .setup-screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        
        body.fullscreen .countdown-screen.active {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }
        
        body.fullscreen .countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        body.fullscreen .timer-screen.active {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }
        
        body.fullscreen h1 {
            display: block;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            font-size: 18px;
            z-index: 10;
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen h1 {
                font-size: 20px;
                top: 15px;
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen h1 {
                font-size: 14px;
                top: 12px;
            }
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 11px;
            text-transform: uppercase;
            color: #777;
            font-weight: 500;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            color: #333;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #2196F3;
        }
        
        .button {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }
        
        .button:hover {
            background: #1976D2;
        }
        
        .button-primary {
            background: #2196F3;
            color: white;
        }
        
        .button-secondary {
            background: #757575;
            color: white;
        }
        
        .button-secondary:hover {
            background: #616161;
        }
        
        .timer-display {
            text-align: center;
            margin: 40px 0;
        }
        
        body.fullscreen .timer-display {
            position: absolute;
            top: 38%;
            left: 50%;
            transform: translate(-50%, -50%) scaleY(1.5);
            width: 100%;
            margin: 0;
            padding: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .time {
            font-size: 72px;
            font-weight: 600;
            line-height: 1;
            color: #333;
            margin-bottom: 15px;
            font-family: 'Allerta Stencil', sans-serif;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0;
            display: inline-block;
            text-align: center;
        }
        
        body.fullscreen .time {
            font-size: 42vw;
            margin: 0;
            line-height: 1;
            letter-spacing: 0;
            color: #333;
            text-align: center;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Allerta Stencil', sans-serif;
            font-variant-numeric: tabular-nums;
            display: block;
            width: 4ch;
        }
        
        /* Completion state - smaller text to prevent overlap */
        body.fullscreen .time.complete,
        body.fullscreen #timeDisplay.complete {
            font-size: 28vw;
            margin-bottom: 20px;
            width: auto;
        }
        
        body.fullscreen .phase.complete,
        body.fullscreen #phaseDisplay.complete {
            margin-bottom: 15px;
        }
        
        body.fullscreen .interval-count.complete,
        body.fullscreen #intervalDisplay.complete {
            margin-top: 15px;
        }
        
        @media (orientation: portrait) {
            body.fullscreen .time {
                font-size: 38vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .time {
                font-size: 36vw;
            }
            
            body.fullscreen .time.complete,
            body.fullscreen #timeDisplay.complete {
                font-size: 24vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .time {
                font-size: 33vw;
            }
            
            body.fullscreen .time.complete,
            body.fullscreen #timeDisplay.complete {
                font-size: 22vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 360px) {
            body.fullscreen .time {
                font-size: 30vw;
            }
            
            body.fullscreen .time.complete,
            body.fullscreen #timeDisplay.complete {
                font-size: 20vw;
            }
        }
        
        .phase {
            font-size: 18px;
            margin-top: 15px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        body.fullscreen .phase {
            font-size: 5vw;
            margin: 0;
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, calc(-50% - 25vw));
            z-index: 10;
            font-weight: 700;
            margin-bottom: 10px;
            white-space: nowrap;
            max-width: 90vw;
            overflow: hidden;
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .phase {
                font-size: 10vw;
                transform: translate(-50%, calc(-50% - 22vw));
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .phase {
                font-size: 7vw;
                transform: translate(-50%, calc(-50% - 20vw));
            }
        }
        
        @media (orientation: portrait) and (max-width: 360px) {
            body.fullscreen .phase {
                font-size: 8vw;
                transform: translate(-50%, calc(-50% - 18vw));
            }
        }
        
        .phase.work {
            color: #4CAF50;
        }
        
        .phase.rest {
            color: #FF9800;
        }
        
        .interval-count {
            font-size: 14px;
            margin-top: 10px;
            color: #666;
        }
        
        body.fullscreen .interval-count {
            font-size: 5vw;
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, calc(-50% + 25vw));
            color: #333;
            z-index: 10;
            font-weight: 500;
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .interval-count {
                font-size: 7.5vw;
                transform: translate(-50%, calc(-50% + 22vw));
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .interval-count {
                font-size: 6vw;
                transform: translate(-50%, calc(-50% + 20vw));
            }
        }
        
        @media (orientation: portrait) and (max-width: 360px) {
            body.fullscreen .interval-count {
                font-size: 6.5vw;
                transform: translate(-50%, calc(-50% + 18vw));
            }
        }
        
        .countdown-display {
            text-align: center;
        }
        
        .countdown-number {
            font-size: 200px;
            font-weight: 400;
            line-height: 1;
            color: #2196F3;
            font-family: 'Allerta Stencil', sans-serif;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0;
            display: inline-block;
            width: 1em;
            text-align: center;
        }
        
        body.fullscreen .countdown-number {
            font-size: 42vw;
            line-height: 1;
            letter-spacing: 0;
            color: #2196F3;
            font-weight: 400;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Allerta Stencil', sans-serif;
            font-variant-numeric: tabular-nums;
            display: block;
            width: 1ch;
            margin: 0;
            text-align: center;
        }
        
        @media (orientation: portrait) {
            body.fullscreen .countdown-number {
                font-size: 38vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .countdown-number {
                font-size: 36vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .countdown-number {
                font-size: 33vw;
            }
        }
        
        @media (orientation: portrait) and (max-width: 360px) {
            body.fullscreen .countdown-number {
                font-size: 30vw;
            }
        }
        
        .countdown-label {
            font-size: 32px;
            margin-top: 20px;
            color: #666;
        }
        
        body.fullscreen .countdown-label {
            font-size: 5vw;
            margin-top: 30px;
            color: #666;
            font-weight: 500;
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .countdown-label {
                font-size: 6vw;
                margin-top: 25px;
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .countdown-label {
                font-size: 7vw;
                margin-top: 20px;
            }
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }
        
        body.fullscreen .controls {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            gap: 10px;
            margin: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }
        
        body.fullscreen .controls .button {
            padding: 16px 24px;
            font-size: 18px;
            width: 100%;
            font-weight: 600;
        }
        
        body.fullscreen .controls .button.stop-button {
            background: #f44336;
            color: white;
        }
        
        body.fullscreen .controls .button.stop-button:hover {
            background: #d32f2f;
        }
        
        @media (orientation: portrait) and (max-width: 500px) {
            body.fullscreen .controls {
                bottom: 20px;
                width: calc(100% - 30px);
                gap: 8px;
            }
            
            body.fullscreen .controls .button {
                padding: 20px 20px;
                font-size: 50px;
            }
        }
        
        @media (orientation: portrait) and (max-width: 400px) {
            body.fullscreen .controls {
                bottom: 20px;
                width: calc(100% - 30px);
                gap: 8px;
            }
            
            body.fullscreen .controls .button {
                padding: 18px 18px;
                font-size: 45px;
            }
        }
        
        @media (orientation: portrait) and (max-width: 360px) {
            body.fullscreen .controls {
                bottom: 20px;
                width: calc(100% - 30px);
                gap: 8px;
            }
            
            body.fullscreen .controls .button {
                padding: 16px 16px;
                font-size: 40px;
            }
        }
        
        .controls .button {
            margin-top: 0;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .timer-screen.work .container {
            border-left: 4px solid #4CAF50;
        }
        
        .timer-screen.rest .container {
            border-left: 4px solid #FF9800;
        }
        
        body.fullscreen .timer-screen.work .container,
        body.fullscreen .timer-screen.rest .container {
            border-left: none;
        }
        
        body.work {
            background: #f1f8e9;
        }
        
        body.rest {
            background: #fff3e0;
        }
        
        body.fullscreen.work {
            background: #f1f8e9;
        }
        
        body.fullscreen.rest {
            background: #fff3e0;
        }
        
        body.fullscreen .timer-screen.work {
            background: #f1f8e9;
        }
        
        body.fullscreen .timer-screen.rest {
            background: #fff3e0;
        }
        
        body.fullscreen .countdown-screen {
            background: #f5f5f5;
        }
        
        .pulsing {
            animation: pulse 1s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interval Timer</h1>
        
        <!-- Setup Screen -->
        <div class="setup-screen active">
            <div class="input-group">
                <label>Work Time</label>
                <div style="display: flex; gap: 10px;">
                    <div style="flex: 1;">
                        <label for="workMinutes" style="font-size: 10px; margin-bottom: 4px; display: block;">Minutes</label>
                        <input type="number" id="workMinutes" value="1" min="0" max="60">
                    </div>
                    <div style="flex: 1;">
                        <label for="workSeconds" style="font-size: 10px; margin-bottom: 4px; display: block;">Seconds</label>
                        <input type="number" id="workSeconds" value="0" min="0" max="59">
                    </div>
                </div>
            </div>
            
            <div class="input-group">
                <label>Rest Time</label>
                <div style="display: flex; gap: 10px;">
                    <div style="flex: 1;">
                        <label for="restMinutes" style="font-size: 10px; margin-bottom: 4px; display: block;">Minutes</label>
                        <input type="number" id="restMinutes" value="1" min="0" max="60">
                    </div>
                    <div style="flex: 1;">
                        <label for="restSeconds" style="font-size: 10px; margin-bottom: 4px; display: block;">Seconds</label>
                        <input type="number" id="restSeconds" value="0" min="0" max="59">
                    </div>
                </div>
            </div>
            
            <div class="input-group">
                <label for="intervals">Number of Intervals</label>
                <input type="number" id="intervals" value="4" min="1" max="100">
            </div>
            
            <div class="input-group">
                <label for="workPhrase">Work Phrase</label>
                <input type="text" id="workPhrase" value="Effort" placeholder="Effort">
            </div>
            
            <div class="input-group">
                <label for="restPhrase">Rest Phrase</label>
                <input type="text" id="restPhrase" value="Easy" placeholder="Easy">
            </div>
            
            <button class="button button-primary" onclick="startTimer()">Start Timer</button>
        </div>
        
        <!-- Countdown Screen -->
        <div class="countdown-screen">
            <div class="countdown-display">
                <div class="countdown-number" id="countdownNumber">5</div>
                <div class="countdown-label">Starting in...</div>
            </div>
        </div>
        
        <!-- Timer Screen -->
        <div class="timer-screen">
            <div class="phase" id="phaseDisplay">WORK</div>
            <div class="timer-display">
                <div class="time" id="timeDisplay">00:00</div>
            </div>
            <div class="interval-count" id="intervalDisplay">Interval 1 of 8</div>
            <div class="controls">
                <button class="button button-secondary" onclick="pauseResume()" id="pauseButton">Pause</button>
                <button class="button button-secondary stop-button" onclick="stopTimer()">Stop</button>
            </div>
        </div>
    </div>
    
    <script>
        let workTime, restTime, totalIntervals;
        let workPhrase, restPhrase;
        let currentInterval = 1;
        let isWorkPhase = true;
        let timeRemaining = 0;
        let timerInterval = null;
        let countdownInterval = null;
        let isPaused = false;
        let countdownRemaining = 5;
        let intervalAnnouncementStarted = false;
        let workCountdownStarted = false;
        
        // Timestamp-based timing for background execution
        let phaseStartTime = null;
        let phaseDuration = 0;
        let pausedTime = 0;
        let pauseStartTime = null;
        
        // Audio context for bell chime (iOS Safari requires persistent context)
        let audioContext = null;
        
        // Initialize audio context (must be called from user interaction on iOS)
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // iOS Safari starts in suspended state - resume it
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch (error) {
                    console.log('Audio context not supported:', error);
                }
            } else if (audioContext.state === 'suspended') {
                // Resume if suspended
                audioContext.resume();
            }
        }
        
        // Speech synthesis functions
        let voicesLoaded = false;
        let voicesCache = [];
        
        // Load voices when available (critical for mobile)
        function loadVoices() {
            if ('speechSynthesis' in window) {
                voicesCache = window.speechSynthesis.getVoices();
                if (voicesCache.length > 0) {
                    voicesLoaded = true;
                }
            }
        }
        
        if ('speechSynthesis' in window) {
            // Load voices immediately
            loadVoices();
            
            // Also listen for when voices are loaded (important for mobile)
            window.speechSynthesis.onvoiceschanged = loadVoices;
            
            // Force voice loading on mobile by calling getVoices() multiple times
            // This is a known workaround for iOS Safari
            let loadAttempts = 0;
            const forceLoadVoices = setInterval(() => {
                loadVoices();
                loadAttempts++;
                if (voicesLoaded || loadAttempts > 10) {
                    clearInterval(forceLoadVoices);
                }
            }, 100);
        }
        
        function speak(text) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                // Small delay to ensure API is ready (especially on mobile)
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    
                    // Reload voices if not cached (mobile browsers sometimes need this)
                    if (!voicesLoaded || voicesCache.length === 0) {
                        loadVoices();
                    }
                    
                    // Try to use a more natural voice if available
                    if (voicesCache.length > 0) {
                        const preferredVoice = voicesCache.find(voice => 
                            voice.lang.includes('en') && 
                            (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.name.includes('Samantha') || voice.name.includes('Enhanced'))
                        );
                        if (preferredVoice) {
                            utterance.voice = preferredVoice;
                        } else if (voicesCache.length > 0) {
                            // Fallback to first English voice
                            const englishVoice = voicesCache.find(voice => voice.lang.startsWith('en'));
                            if (englishVoice) {
                                utterance.voice = englishVoice;
                            }
                        }
                    }
                    
                    // Error handling for mobile
                    utterance.onerror = (event) => {
                        console.log('Speech error:', event.error);
                    };
                    
                    utterance.onend = () => {
                        // Speech completed
                    };
                    
                    window.speechSynthesis.speak(utterance);
                }, 50); // Small delay helps on mobile browsers
            }
        }
        
        function formatTimeForSpeech(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            
            if (minutes > 0 && secs > 0) {
                return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} and ${secs} ${secs === 1 ? 'second' : 'seconds'}`;
            } else if (minutes > 0) {
                return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;
            } else {
                return `${secs} ${secs === 1 ? 'second' : 'seconds'}`;
            }
        }
        
        // Play a loud bell chime using Web Audio API
        function playDing() {
            // Ensure audio context is initialized and resumed (critical for iOS)
            initAudioContext();
            
            if (!audioContext || audioContext.state === 'closed') {
                return;
            }
            
            try {
                // Resume if suspended (iOS Safari requirement)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playDingSound();
                    }).catch(() => {});
                } else {
                    playDingSound();
                }
            } catch (error) {
                console.log('Audio error:', error);
            }
        }
        
        function playDingSound() {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            
            // Create multiple oscillators for a rich bell-like sound
            // Bell tones typically have multiple harmonics
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 - pleasant bell chord
            const oscillators = [];
            const gainNodes = [];
            
            frequencies.forEach((freq, index) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, now);
                
                // Each harmonic decays at slightly different rates for bell-like effect
                const delay = index * 0.02; // Slight stagger
                const attackTime = 0.01;
                const decayTime = 0.3 + (index * 0.1);
                const sustainLevel = 0.1;
                const releaseTime = 0.5;
                
                gain.gain.setValueAtTime(0, now + delay);
                gain.gain.linearRampToValueAtTime(1.0, now + delay + attackTime); // Maximum volume
                gain.gain.exponentialRampToValueAtTime(sustainLevel, now + delay + attackTime + decayTime);
                gain.gain.exponentialRampToValueAtTime(0.001, now + delay + attackTime + decayTime + releaseTime);
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(now + delay);
                osc.stop(now + delay + attackTime + decayTime + releaseTime);
                
                oscillators.push(osc);
                gainNodes.push(gain);
            });
        }
        
        function autoResizePhaseText(element) {
            if (!document.body.classList.contains('fullscreen')) {
                return; // Only resize in fullscreen mode
            }
            
            // Reset to CSS default (remove inline style) to start fresh
            element.style.fontSize = '';
            
            // Force a reflow to get accurate measurements
            void element.offsetHeight;
            
            // Get the max width (90vw as set in CSS)
            const maxWidth = window.innerWidth * 0.9;
            const minFontSize = 12; // Minimum readable size in pixels
            
            // Get current computed font size
            let fontSize = parseFloat(window.getComputedStyle(element).fontSize);
            const originalFontSize = fontSize;
            
            // Reduce font size until text fits
            while (element.scrollWidth > maxWidth && fontSize > minFontSize) {
                fontSize -= 0.5;
                element.style.fontSize = fontSize + 'px';
            }
            
            // If we had to reduce significantly, convert to vw for better scaling
            if (fontSize < originalFontSize * 0.7) {
                const vwSize = (fontSize / window.innerWidth) * 100;
                element.style.fontSize = vwSize + 'vw';
            }
        }
        
        // Auto-resize on window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                const phaseEl = document.getElementById('phaseDisplay');
                if (phaseEl && document.body.classList.contains('fullscreen')) {
                    autoResizePhaseText(phaseEl);
                }
            }, 100);
        });
        
        function startTimer() {
            const workMinutes = parseInt(document.getElementById('workMinutes').value) || 0;
            const workSeconds = parseInt(document.getElementById('workSeconds').value) || 0;
            const restMinutes = parseInt(document.getElementById('restMinutes').value) || 0;
            const restSeconds = parseInt(document.getElementById('restSeconds').value) || 0;
            
            workTime = (workMinutes * 60) + workSeconds;
            restTime = (restMinutes * 60) + restSeconds;
            totalIntervals = parseInt(document.getElementById('intervals').value);
            workPhrase = document.getElementById('workPhrase').value.trim() || 'Work';
            restPhrase = document.getElementById('restPhrase').value.trim() || 'Rest';
            
            currentInterval = 1;
            isWorkPhase = true;
            timeRemaining = workTime;
            isPaused = false;
            countdownRemaining = 5;
            intervalAnnouncementStarted = false;
            workCountdownStarted = false;
            phaseStartTime = null;
            pausedTime = 0;
            pauseStartTime = null;
            
            // Remove completion classes if present
            document.getElementById('timeDisplay').classList.remove('complete');
            document.getElementById('phaseDisplay').classList.remove('complete');
            document.getElementById('intervalDisplay').classList.remove('complete');
            
            // Initialize audio context (must be from user interaction on iOS)
            initAudioContext();
            
            // Activate speech API on mobile (iOS Safari requires immediate activation after user interaction)
            if ('speechSynthesis' in window) {
                // Trigger a silent/quick test to unlock the API
                const testUtterance = new SpeechSynthesisUtterance('');
                testUtterance.volume = 0;
                window.speechSynthesis.speak(testUtterance);
                window.speechSynthesis.cancel(); // Cancel immediately
            }
            
            // Go to fullscreen
            document.body.classList.add('fullscreen');
            
            // Show countdown screen
            document.querySelector('.setup-screen').classList.remove('active');
            document.querySelector('.timer-screen').classList.remove('active');
            document.querySelector('.countdown-screen').classList.add('active');
            
            // Update countdown display
            document.getElementById('countdownNumber').textContent = countdownRemaining;
            
            // Start countdown with timestamp-based timing
            const countdownStartTime = Date.now();
            const countdownDuration = 5; // 5 seconds
            let lastSpokenCountdown = 6; // Track what we've spoken to avoid repeats
            
            countdownInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - countdownStartTime) / 1000);
                const previousCountdown = countdownRemaining;
                countdownRemaining = Math.max(0, countdownDuration - elapsed);
                
                document.getElementById('countdownNumber').textContent = countdownRemaining;
                
                // Speak countdown numbers 3, 2, 1 (only when crossing threshold)
                if (countdownRemaining <= 3 && countdownRemaining > 0 && countdownRemaining !== lastSpokenCountdown) {
                    speak(countdownRemaining.toString());
                    lastSpokenCountdown = countdownRemaining;
                }
                
                if (countdownRemaining <= 0) {
                    clearInterval(countdownInterval);
                    startActualTimer();
                }
            }, 100); // Check more frequently for accuracy
        }
        
        function startActualTimer() {
            // Hide countdown, show timer
            document.querySelector('.countdown-screen').classList.remove('active');
            document.querySelector('.timer-screen').classList.add('active');
            
            // Initialize timestamp-based timing
            phaseStartTime = Date.now();
            phaseDuration = workTime;
            timeRemaining = workTime;
            pausedTime = 0;
            
            // Play ding and announce start (with slight pause after chime)
            playDing();
            const timeText = formatTimeForSpeech(workTime);
            setTimeout(() => {
                speak(`${workPhrase} for ${timeText}`);
            }, 600); // 600ms pause after chime
            
            updateDisplay();
            timerInterval = setInterval(tick, 100); // Check more frequently for accuracy
        }
        
        function tick() {
            if (isPaused) {
                if (pauseStartTime === null) {
                    pauseStartTime = Date.now();
                }
                return;
            }
            
            // Resume from pause - adjust timing
            if (pauseStartTime !== null) {
                const pauseDuration = Math.floor((Date.now() - pauseStartTime) / 1000);
                pausedTime += pauseDuration;
                pauseStartTime = null;
            }
            
            // Calculate elapsed time using timestamps (works even when page is in background)
            const now = Date.now();
            const elapsed = Math.floor((now - phaseStartTime - pausedTime * 1000) / 1000);
            const previousTimeRemaining = timeRemaining;
            timeRemaining = Math.max(0, phaseDuration - elapsed);
            
            // Only trigger announcements when crossing thresholds (avoid repeats)
            const crossedThreshold = (prev, curr, threshold) => {
                return prev > threshold && curr <= threshold;
            };
            
            // Handle countdown at end of work period (last 3 seconds)
            if (isWorkPhase && timeRemaining <= 3 && timeRemaining > 0) {
                if (!workCountdownStarted && crossedThreshold(previousTimeRemaining, timeRemaining, 3)) {
                    workCountdownStarted = true;
                }
                // Count down audibly for the last 3 seconds (only on whole seconds)
                if (timeRemaining !== previousTimeRemaining && timeRemaining > 0 && timeRemaining <= 3) {
                    speak(timeRemaining.toString());
                }
            }
            
            // Handle interval announcement during rest period
            if (!isWorkPhase && timeRemaining <= 5 && timeRemaining > 0) {
                // Only announce if there's another interval coming
                if (currentInterval < totalIntervals) {
                    if (!intervalAnnouncementStarted && crossedThreshold(previousTimeRemaining, timeRemaining, 5)) {
                        // Start the announcement at 5 seconds so it completes around 3 seconds
                        intervalAnnouncementStarted = true;
                        speak(`Starting Interval ${currentInterval + 1} of ${totalIntervals} in`);
                    }
                }
                // Count down audibly for the last 3 seconds (always, even on last interval)
                if (timeRemaining <= 3 && timeRemaining > 0 && timeRemaining !== previousTimeRemaining) {
                    speak(timeRemaining.toString());
                }
            }
            
            if (timeRemaining <= 0) {
                if (isWorkPhase) {
                    // Switch to rest - play ding at transition
                    playDing();
                    isWorkPhase = false;
                    phaseStartTime = Date.now();
                    phaseDuration = restTime;
                    timeRemaining = restTime;
                    pausedTime = 0;
                    intervalAnnouncementStarted = false;
                    workCountdownStarted = false;
                    const timeText = formatTimeForSpeech(restTime);
                    setTimeout(() => {
                        speak(`${restPhrase} for ${timeText}`);
                    }, 600); // 600ms pause after chime
                } else {
                    // Switch to next work interval
                    currentInterval++;
                    intervalAnnouncementStarted = false;
                    workCountdownStarted = false;
                    
                    if (currentInterval > totalIntervals) {
                        // Timer complete
                        completeTimer();
                        return;
                    }
                    
                    // Start the work interval - play ding at transition
                    playDing();
                    isWorkPhase = true;
                    phaseStartTime = Date.now();
                    phaseDuration = workTime;
                    timeRemaining = workTime;
                    pausedTime = 0;
                    const timeText = formatTimeForSpeech(workTime);
                    setTimeout(() => {
                        speak(`${workPhrase} for ${timeText}`);
                    }, 300); // 300ms pause after chime
                }
            }
            
            updateDisplay();
        }
        
        function updateDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            document.getElementById('timeDisplay').textContent = 
                `${minutes}:${String(seconds).padStart(2, '0')}`;
            
            const phaseEl = document.getElementById('phaseDisplay');
            phaseEl.textContent = isWorkPhase ? (workPhrase || 'WORK').toUpperCase() : (restPhrase || 'REST').toUpperCase();
            phaseEl.className = isWorkPhase ? 'phase work' : 'phase rest';
            
            // Auto-resize phase text to fit on one line
            setTimeout(() => autoResizePhaseText(phaseEl), 0);
            
            document.getElementById('intervalDisplay').textContent = 
                `Interval ${currentInterval} of ${totalIntervals}`;
            
            const timerScreen = document.querySelector('.timer-screen');
            timerScreen.className = isWorkPhase ? 'timer-screen active work' : 'timer-screen active rest';
            
            // Update body class for subtle background change
            document.body.className = isWorkPhase ? 'fullscreen work' : 'fullscreen rest';
            
            // Pulse effect in last 3 seconds
            if (timeRemaining <= 3) {
                timerScreen.classList.add('pulsing');
            } else {
                timerScreen.classList.remove('pulsing');
            }
        }
        
        function pauseResume() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseStartTime = Date.now();
            } else {
                // When resuming, adjust pausedTime
                if (pauseStartTime !== null) {
                    const pauseDuration = Math.floor((Date.now() - pauseStartTime) / 1000);
                    pausedTime += pauseDuration;
                    pauseStartTime = null;
                }
            }
            document.getElementById('pauseButton').textContent = isPaused ? 'Resume' : 'Pause';
        }
        
        function stopTimer() {
            clearInterval(timerInterval);
            clearInterval(countdownInterval);
            window.speechSynthesis.cancel();
            
            // Release wake lock
            if (wakeLock !== null) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                }).catch(() => {});
            }
            
            // Reset timing variables
            phaseStartTime = null;
            pausedTime = 0;
            pauseStartTime = null;
            
            document.body.className = '';
            document.querySelector('.timer-screen').classList.remove('active', 'work', 'rest');
            document.querySelector('.countdown-screen').classList.remove('active');
            document.querySelector('.setup-screen').classList.add('active');
            document.getElementById('pauseButton').textContent = 'Pause';
        }
        
        function completeTimer() {
            clearInterval(timerInterval);
            clearInterval(countdownInterval);
            window.speechSynthesis.cancel();
            
            // Release wake lock
            if (wakeLock !== null) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                }).catch(() => {});
            }
            
            speak('Workout complete! Great job!');
            
            const timeDisplay = document.getElementById('timeDisplay');
            const phaseDisplay = document.getElementById('phaseDisplay');
            const intervalDisplay = document.getElementById('intervalDisplay');
            
            timeDisplay.textContent = '✓ DONE';
            timeDisplay.classList.add('complete');
            phaseDisplay.textContent = 'COMPLETE';
            phaseDisplay.classList.add('complete');
            intervalDisplay.textContent = 'Great work!';
            intervalDisplay.classList.add('complete');
        }
        
        // Prevent screen sleep on mobile
        let wakeLock = null;
        let wakeLockSupported = 'wakeLock' in navigator;
        
        async function requestWakeLock() {
            try {
                if (wakeLockSupported) {
                    // Release existing lock if any
                    if (wakeLock !== null) {
                        await wakeLock.release().catch(() => {});
                    }
                    wakeLock = await navigator.wakeLock.request('screen');
                    
                    // Handle wake lock release (e.g., when screen is manually locked)
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock released');
                        // Try to re-acquire if timer is still running
                        if (timerInterval !== null || countdownInterval !== null) {
                            requestWakeLock();
                        }
                    });
                }
            } catch (err) {
                console.log('Wake Lock error:', err);
            }
        }
        
        // Re-acquire wake lock when page becomes visible
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden && wakeLockSupported) {
                // Page became visible - re-acquire wake lock if timer is running
                if (timerInterval !== null || countdownInterval !== null) {
                    await requestWakeLock();
                }
            }
        });
        
        // Request wake lock when timer starts
        const originalStartTimer = startTimer;
        startTimer = function() {
            requestWakeLock();
            originalStartTimer();
        };
        
        // Handle fullscreen on mobile
        if (document.documentElement.requestFullscreen) {
            document.addEventListener('click', function() {
                if (document.body.classList.contains('fullscreen') && !document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen not supported or denied');
                    });
                }
            }, { once: false });
        }
        
        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available
                                    console.log('New service worker available');
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
            
            // Listen for service worker messages (e.g., offline status)
            navigator.serviceWorker.addEventListener('message', (event) => {
                console.log('Service Worker message:', event.data);
            });
        }
    </script>


</body></html>