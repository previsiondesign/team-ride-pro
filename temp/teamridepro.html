<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tam High MTB Team Roster and Practice Manager</title>
    <!-- Auth scripts removed - using localStorage only -->
    <link rel="stylesheet" href="styles.css?v=20241220b">
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <div class="header-title-container">
                <img src="assets/tam-high-logo.png" alt="Tam High Logo" class="header-logo" id="header-logo">
                <h1>Tam High Mountain Bike Racing Team</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
                <div class="user-menu" id="user-menu">
                    <div class="user-info">
                        <span class="user-name" id="user-name">Adam Phillips</span>
                        <span class="user-role" id="user-role">Coach</span>
                    </div>
                    <div class="user-menu-buttons">
                        <button class="btn-small secondary" onclick="handleDummyLogout()">Sign Out</button>
                    </div>
                </div>
                <div class="mobile-menu-container">
                    <button class="mobile-menu-button" id="mobile-menu-button" onclick="toggleMobileMenu()" aria-label="Menu">
                    </button>
                    <div class="mobile-menu-dropdown" id="mobile-menu-dropdown">
                        <button class="mobile-menu-item active" onclick="selectMobileTab('settings')">Team Dashboard</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('roster')">Roster</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('routes')">Routes</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('rides')">Practice Planner</button>
                        <button class="mobile-menu-item" onclick="selectMobileTab('assignments')">Practice Assignments</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tabs" id="desktop-tabs">
            <button class="tab active" onclick="switchTab('settings', this)">Team Dashboard</button>
            <button class="tab" onclick="switchTab('roster', this)">Roster</button>
            <button class="tab" onclick="switchTab('routes', this)">Routes</button>
            <button class="tab" onclick="switchTab('rides', this)">Practice Planner</button>
            <button class="tab" onclick="switchTab('assignments', this)">Practice Assignments</button>
        </div>assets/tam-high-logo.png

        <!-- SEASON CALENDAR TAB -->
        <div id="settings-tab" class="tab-content active">
            <div class="section">
                <div class="form-row" style="margin-bottom: 16px;">
                    <div style="flex:1;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <label class="field-label" style="margin:0;">Season Date Range</label>
                            <button class="btn-small secondary" onclick="applySeasonUpdates('dates')" title="Update calendar after changing dates">Update Dates</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="date" id="season-start-date" style="flex: 1;" onchange="updateSeasonDateRange()">
                            <span style="color: #666; font-weight: 500;">‚Äì</span>
                            <input type="date" id="season-end-date" style="flex: 1;" onchange="updateSeasonDateRange()">
                        </div>
                    </div>
                </div>
                <div class="season-calendar-wrapper" id="season-calendar-wrapper-settings">
                    <div class="season-calendar-header" style="display: none;">
                        <h3 style="margin:0;">Season Calendar</h3>
                    </div>
                    <div id="season-calendar-settings" class="season-calendar-empty">
                        Set your season dates and practices to see the calendar here.
                    </div>
                </div>
                <div style="margin-top: 12px; display: flex; gap: 8px;">
                    <button class="btn-small" onclick="addPracticeRow()">Add Recurring Practice</button>
                    <button class="btn-small secondary" onclick="openAddSinglePracticeModal()">Add Single Practice</button>
                    <button class="btn-small secondary" onclick="openAddRacesModal()">Add Races</button>
                </div>
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; margin-top: 16px;">
                        <label class="field-label" style="margin:0;">Regular Practices</label>
                        <button class="btn-small secondary" onclick="applySeasonUpdates('practices')" title="Update calendar after changing regular practices">Update Practices</button>
                    </div>
                    <div id="practice-rows" class="practice-rows"></div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Coach Roles</h3>
                    <div id="coach-roles-container" style="margin-bottom: 20px;">
                        <!-- Coach roles will be dynamically added here -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="new-coach-role-name" placeholder="Role name (e.g., Head Coach)" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <select id="new-coach-role-coach" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">Select Coach</option>
                        </select>
                        <button class="btn-small" onclick="addCoachRole()">Add Role</button>
                    </div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Rider Roles</h3>
                    <div id="rider-roles-container" style="margin-bottom: 20px;">
                        <!-- Rider roles will be dynamically added here -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="new-rider-role-name" placeholder="Role name (e.g., Captain)" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <select id="new-rider-role-rider" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">Select Rider</option>
                        </select>
                        <button class="btn-small" onclick="addRiderRole()">Add Role</button>
                    </div>
                </div>
                <div class="section" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                    <h3 style="margin-bottom: 12px; color: #555;">Rating Scales</h3>
                    <div class="form-row" style="margin-bottom: 12px;">
                        <label class="field-label" style="min-width: 200px;">Fitness Scale (1 to X):</label>
                        <input type="number" id="fitness-scale" min="3" max="20" value="5" style="width: 100px;" onchange="updateScaleSettings()">
                        <span style="color: #666; margin-left: 8px;">Current: 1-<span id="fitness-scale-display">5</span></span>
                    </div>
                    <div class="form-row" style="margin-bottom: 12px;">
                        <label class="field-label" style="min-width: 200px;">Bike Skills Scale (1 to X):</label>
                        <input type="number" id="skills-scale" min="2" max="10" value="3" style="width: 100px;" onchange="updateScaleSettings()">
                        <span style="color: #666; margin-left: 8px;">Current: 1-<span id="skills-scale-display">3</span></span>
                    </div>
                    <div style="margin-top: 12px; padding: 12px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 13px; color: #856404;">
                        <strong>Note:</strong> Changing scales will automatically convert all existing fitness and skills ratings to the new scale.
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="exportSeasonSettings()">Export Settings</button>
                    <button class="btn-small secondary" onclick="importSeasonSettings()">Import Settings</button>
                    <button class="btn-small" onclick="saveSeasonSettings()" style="margin-left: auto;">Save Settings</button>
                </div>
            </div>
        </div>

        <!-- ROSTER TAB -->
        <div id="roster-tab" class="tab-content">
            <div class="section" style="padding-top: 8px;">
                <div class="roster-controls" style="margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                        <button id="roster-toggle-riders" class="btn-small active" onclick="toggleRosterView('riders')" style="padding: 10px 20px; font-size: 15px; font-weight: 600;">Riders</button>
                        <button id="roster-toggle-coaches" class="btn-small secondary" onclick="toggleRosterView('coaches')" style="padding: 10px 20px; font-size: 15px; font-weight: 600;">Coaches</button>
                    </div>
                    <div class="group-by-control" id="roster-group-by-container">
                        <label id="roster-group-by-label" for="rider-group-by">Group by:</label>
                        <select id="rider-group-by" onchange="groupRiders(this.value)" style="display: block;">
                            <option value="">None</option>
                            <option value="name">Name</option>
                            <option value="gender">Gender</option>
                            <option value="grade">Grade</option>
                            <option value="racingGroup">Racing Group</option>
                            <option value="pace">Fitness</option>
                            <option value="skills">Bike Skills</option>
                        </select>
                        <select id="coach-group-by" onchange="groupCoaches(this.value)" style="display: none;">
                            <option value="">None</option>
                            <option value="name">Name</option>
                            <option value="level">Coach Level</option>
                            <option value="pace">Pace</option>
                        </select>
                    </div>
                </div>
                
                <!-- RIDERS VIEW -->
                <div id="roster-riders-view">
                    <div id="riders-list" class="roster-grid"></div>
                    <div style="margin-top: 16px; text-align: center; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn-small" onclick="openAddRiderModal()">Add Team Rider</button>
                        <button class="btn-small secondary" onclick="importRidersFromCSV()">Import Riders from CSV</button>
                        <button class="btn-small secondary" onclick="updateRidersFromCSVFile()">Update Roster Changes from CSV</button>
                        <button class="btn-small danger" onclick="purgeRiders()">Purge Riders</button>
                    </div>
                    <div id="rider-update-debug" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; display: none; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;"></div>
                </div>

                <!-- COACHES VIEW -->
                <div id="roster-coaches-view" style="display: none;">
                    <div id="coaches-list" class="roster-grid"></div>
                    <div style="margin-top: 16px; text-align: center; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn-small" onclick="openAddCoachModal()">Add Coach</button>
                        <button class="btn-small secondary" onclick="importCoachesFromCSV()">Import Coaches from CSV</button>
                        <button class="btn-small secondary" onclick="updateCoachesFromCSVFile()">Update Roster Changes from CSV</button>
                        <button class="btn-small danger" onclick="purgeCoaches()">Purge Coaches</button>
                    </div>
                    <div id="coach-update-debug" style="margin-top: 20px; padding: 15px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; display: none; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>

        <!-- RIDES TAB -->
        <div id="rides-tab" class="tab-content">
            <div class="section">
                <div id="practice-navigation" style="display: none; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
                    <button class="btn-small secondary" onclick="navigateToPriorPractice()" id="prior-practice-btn">‚Üê Show Prior Practice</button>
                    <span id="current-practice-date" style="font-weight: 600; color: #333;"></span>
                    <button class="btn-small secondary" onclick="navigateToNextPractice()" id="next-practice-btn">Show Next Practice ‚Üí</button>
                </div>
            </div>

            <div id="current-ride" style="display: none;">
                <div class="section">
                    <h2 id="ride-title"></h2>
                    <div style="margin-top: 10px; margin-bottom: 15px;">
                        <label for="practice-goals" style="display: block; margin-bottom: 6px; font-weight: 500; color: #555;">Practice Goals</label>
                        <input type="text" id="practice-goals" placeholder="Enter practice goals (e.g., Endurance training, Hill climbs, Technical skills)" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" onchange="updatePracticeGoals()">
                    </div>
                    
                    <!-- Practice Attendance Section -->
                    <div style="margin-top: 20px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;" onclick="togglePracticeAttendance()">
                            <strong style="font-size: 16px;">Practice Attendance</strong>
                            <span id="practice-attendance-arrow" style="font-size: 18px;">‚ñº</span>
                        </div>
                        <div id="practice-attendance-content" style="display: none; margin-top: 12px; padding: 12px; border: 1px solid #ddd; border-radius: 4px; background: #fff; position: relative;">
                            <div id="practice-attendance-resize-handle" style="position: absolute; bottom: 0; left: 0; right: 0; height: 8px; cursor: ns-resize; background: transparent; z-index: 10;" onmousedown="startResizeAttendance(event)"></div>
                            <div id="practice-attendance-lists-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 400px; overflow: hidden;">
                                <div id="practice-riders-list" class="assignment-column" style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
                                    <!-- Riders will be populated here -->
                                </div>
                                <div id="practice-coaches-list" class="assignment-column" style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
                                    <!-- Coaches will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="action-bar">
                        <button class="btn-small" onclick="autoAssign()">ü§ñ Autofill Assignments</button>
                        <button class="btn-small secondary" onclick="openAutoAssignSettingsModal()">‚öôÔ∏è Auto-Assign Settings</button>
                        <button class="btn-small secondary" onclick="clearAssignments()">Clear Assignments</button>
                        <button id="cancel-practice-btn" class="btn-small danger" onclick="deleteCurrentRide()">Cancel Practice</button>
                        <button id="delete-practice-btn" class="btn-small danger" onclick="permanentlyDeleteCurrentRide()">Delete Practice</button>
                    </div>

                    <div id="assignments" class="assignments"></div>
                    <div style="margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <strong>Auto-Assignment Debug Output</strong>
                            <button class="btn-small" onclick="copyDebugToClipboard()" id="copy-debug-btn" style="display: none;">Copy to Clipboard</button>
                        </div>
                        <pre id="auto-assign-debug" class="debug-output" style="display: none;"></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIDE ASSIGNMENTS TAB -->
        <div id="assignments-tab" class="tab-content">
            <div class="section">
                <div id="ride-assignments-container">
                    <!-- Ride assignments will be loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- ROUTES TAB -->
        <div id="routes-tab" class="tab-content">
            <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button class="btn-small" onclick="openRoutesManagerModal()">Add/Edit Routes...</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label for="routes-sort-by" style="font-size: 14px; color: #666;">Sort By:</label>
                        <select id="routes-sort-by" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; cursor: pointer;" onchange="renderRoutes()">
                            <option value="distance-asc">Distance (shortest to longest)</option>
                            <option value="distance-desc">Distance (longest to shortest)</option>
                            <option value="elevation-asc">Elev Gain (least to most)</option>
                            <option value="elevation-desc">Elev Gain (most to least)</option>
                            <option value="time-asc">Duration (shortest to longest)</option>
                            <option value="time-desc">Duration (longest to shortest)</option>
                        </select>
                    </div>
                </div>
                <div id="routes-grid" class="routes-grid">
                    <!-- Routes will be loaded dynamically -->
                </div>
            </div>
        </div>
    </div>

    <div id="season-setup-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 900px; width: min(900px, 95%);">
            <div class="modal-header">
                <span>Season Setup</span>
                <button class="btn-small secondary" onclick="closeSeasonSetupModal()">Close</button>
                </div>
            <div class="modal-body">
                <div class="form-row">
                    <div style="flex:1;">
                        <label for="season-start-date" class="field-label">Season Start</label>
                        <input type="date" id="season-start-date">
                    </div>
                    <div style="flex:1;">
                        <label for="season-end-date" class="field-label">Season End</label>
                        <input type="date" id="season-end-date">
                    </div>
                </div>
                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <label class="field-label" style="margin:0;">Regular Practices</label>
                        <div style="display:flex; gap:8px;">
                            <button class="btn-small secondary" onclick="addPracticeRow()">Add Recurring Practice</button>
                            <button class="btn-small secondary" onclick="openAddSinglePracticeModal()">Add single practice</button>
                            <button class="btn-small secondary" onclick="openAddRacesModal()">Add Races</button>
                        </div>
                    </div>
                    <div id="practice-rows" class="practice-rows"></div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="exportSeasonSettings()">Export Settings</button>
                    <button class="btn-small secondary" onclick="importSeasonSettings()">Import Settings</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn-small secondary" onclick="closeSeasonSetupModal()">Cancel</button>
                    <button class="btn-small" onclick="saveSeasonSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <div id="location-map-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 800px; width: min(800px, 95%);">
            <div class="modal-header">
                <span>Select Meet Location</span>
                <button class="btn-small secondary" onclick="closeLocationMapModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 12px;">
                    <label for="location-search" class="field-label">Search Location</label>
                    <input type="text" id="location-search" placeholder="Search for a location..." style="width: 100%; padding: 8px; margin-bottom: 8px;" onkeypress="if(event.key === 'Enter') searchLocation();">
                    <button class="btn-small" onclick="searchLocation()">Search</button>
                </div>
                <div id="map-container" style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 12px; background: #f0f0f0; position: relative; z-index: 1;">
                    <div id="map-placeholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666; z-index: 0;">
                        <p>Map will load here</p>
                        <p style="font-size: 12px; margin-top: 8px;">Click on the map to set location</p>
                    </div>
                </div>
                <div class="form-row">
                    <div style="flex: 1;">
                        <label for="location-latitude" class="field-label">Latitude</label>
                        <input type="number" id="location-latitude" step="0.000001" placeholder="0.000000" style="width: 100%;">
                    </div>
                    <div style="flex: 1;">
                        <label for="location-longitude" class="field-label">Longitude</label>
                        <input type="number" id="location-longitude" step="0.000001" placeholder="0.000000" style="width: 100%;">
                    </div>
                </div>
                <div style="margin-top: 12px;">
                    <label for="location-address" class="field-label">Address</label>
                    <input type="text" id="location-address" placeholder="Address will appear here" style="width: 100%;">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeLocationMapModal()">Cancel</button>
                <button class="btn-small" onclick="saveLocation()">Save Location</button>
            </div>
        </div>
    </div>

    <div id="add-races-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px; width: min(700px, 95%);">
            <div class="modal-header">
                <span>Add Races</span>
                <button class="btn-small secondary" onclick="closeAddRacesModal()">Close</button>
            </div>
            <div class="modal-body">
                <div id="races-list-container" style="margin-bottom: 16px;">
                    <!-- Race entries will be added here -->
                </div>
                <button class="btn-small secondary" onclick="addRaceEntry()" style="margin-bottom: 12px;">+ Add Another Race</button>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddRacesModal()">Cancel</button>
                <button class="btn-small" onclick="saveRaces()">Save Races</button>
            </div>
        </div>
    </div>

    <div id="add-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span>Add Additional Practice</span>
                <button class="btn-small secondary" onclick="closeAddPracticeModal()">Close</button>
                </div>
            <div class="modal-body">
                <div class="form-row">
                    <div style="flex:1;">
                        <label for="practice-date" class="field-label">Date</label>
                        <input type="date" id="practice-date">
                    </div>
                    <div style="flex:1;">
                        <label for="practice-time" class="field-label">Time</label>
                        <input type="time" id="practice-time">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddPracticeModal()">Cancel</button>
                <button class="btn-small" onclick="saveAddPractice()">Add Practice</button>
            </div>
        </div>
    </div>

    <div id="edit-coach-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span id="edit-coach-modal-title">Edit Coach</span>
                <button class="btn-small secondary" onclick="closeEditCoachModal()">Close</button>
            </div>
            <div class="modal-body">
                <div class="modal-photo-section">
                    <div class="modal-photo-container">
                        <div class="modal-photo" id="edit-coach-photo-container" style="position: relative;">
                            <img id="edit-coach-photo-preview" src="" alt="Coach photo" style="display: none; width: 100%; height: 100%; object-fit: cover;">
                            <span id="edit-coach-photo-placeholder" class="photo-placeholder" style="display: flex;">üö¥</span>
                            <div class="photo-edit-overlay">
                                <span class="photo-edit-icon">‚úèÔ∏è</span>
                            </div>
                            <input type="file" id="edit-coach-photo-input" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleCoachPhotoUploadInModal(this)">
                        </div>
                    </div>
                    <div class="modal-name-field">
                        <div class="modal-name-row">
                            <div class="modal-name-col">
                                <label for="edit-coach-first-name" class="field-label">First Name</label>
                                <input type="text" id="edit-coach-first-name">
                            </div>
                            <div class="modal-name-col">
                                <label for="edit-coach-last-name" class="field-label">Last Name</label>
                                <input type="text" id="edit-coach-last-name">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-form-container" style="max-height: 70vh; overflow-y: auto;">
                    <div class="modal-labels-column">
                        <div class="modal-field-label">Email</div>
                        <div class="modal-field-label">Cell Phone</div>
                        <div class="modal-field-label">Work Phone</div>
                        <div class="modal-field-label">Home Phone</div>
                        <div class="modal-field-label">Gender</div>
                        <div class="modal-field-label">Coaching License Level</div>
                        <div class="modal-field-label">Registered</div>
                        <div class="modal-field-label">Paid</div>
                        <div class="modal-field-label">Background Check</div>
                        <div class="modal-field-label">Level 3 Exam Completed</div>
                        <div class="modal-field-label">PDU/CEU Units</div>
                        <div class="modal-field-label">Field Work Hours</div>
                        <div class="modal-field-label">First Aid Type, Expires</div>
                        <div class="modal-field-label">CPR Expires</div>
                        <div class="modal-field-label">Concussion Training Completed</div>
                        <div class="modal-field-label">NICA Philosophy Completed</div>
                        <div class="modal-field-label">Athlete Abuse Awareness Completed</div>
                        <div class="modal-field-label">License Level 1 Completed</div>
                        <div class="modal-field-label">License Level 2 Completed</div>
                        <div class="modal-field-label">License Level 3 Completed</div>
                        <div class="modal-field-label">OTB Skills 101 Classroom Completed</div>
                        <div class="modal-field-label">OTB Skills 101 Outdoor Completed</div>
                        <div class="modal-field-label">NICA Leader Summit Completed</div>
                        <div class="modal-field-label">Fitness (1-10)</div>
                        <div class="modal-field-label">Notes</div>
                    </div>
                    <div class="modal-inputs-column">
                        <div class="modal-form-row">
                            <input type="email" id="edit-coach-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-work-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-coach-home-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-coach-gender" class="modal-field-input">
                                <option value="">Select Gender</option>
                                <option value="M">M</option>
                                <option value="F">F</option>
                                <option value="NB">Nonbinary</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-coach-level" class="modal-field-input">
                                <option value="N/A">N/A</option>
                                <option value="1">Level 1</option>
                                <option value="2">Level 2</option>
                                <option value="3">Level 3</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-registered" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-paid" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-background-check" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-level3-exam" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-pdu-ceu" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-field-work-hours" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-first-aid" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-cpr-expires" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-concussion-training" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-nica-philosophy" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-abuse-awareness" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level2" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-license-level3" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-otb-classroom" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-otb-outdoor" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-coach-nica-summit" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-coach-fitness" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <label for="edit-coach-skills" class="field-label">Bike Skills</label>
                            <input type="number" id="edit-coach-skills" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-coach-notes" rows="3" class="modal-field-input"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between;">
                <button id="delete-coach-btn" class="btn-small danger" onclick="deleteCoachFromModal()" style="display: none;">Delete Record</button>
                <div style="display: flex; gap: 8px; margin-left: auto;">
                    <button class="btn-small secondary" onclick="closeEditCoachModal()">Cancel</button>
                    <button class="btn-small" onclick="saveCoachFromModal()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="edit-rider-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <span id="edit-rider-modal-title">Edit Team Rider</span>
                <button class="btn-small secondary" onclick="closeEditRiderModal()">Close</button>
            </div>
            <div class="modal-body">
                <div class="modal-photo-section">
                    <div class="modal-photo-container">
                        <div class="modal-photo" id="edit-rider-photo-container" style="position: relative;">
                            <img id="edit-rider-photo-preview" src="" alt="Rider photo" style="display: none; width: 100%; height: 100%; object-fit: cover;">
                            <span id="edit-rider-photo-placeholder" class="photo-placeholder" style="display: flex;">üë§</span>
                            <div class="photo-edit-overlay">
                                <span class="photo-edit-icon">‚úèÔ∏è</span>
                            </div>
                            <input type="file" id="edit-rider-photo-input" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleRiderPhotoUploadInModal(this)">
                        </div>
                    </div>
                    <div class="modal-name-field">
                        <div class="modal-name-row">
                            <div class="modal-name-col">
                                <label for="edit-rider-first-name" class="field-label">First Name</label>
                                <input type="text" id="edit-rider-first-name">
                            </div>
                            <div class="modal-name-col">
                                <label for="edit-rider-last-name" class="field-label">Last Name</label>
                                <input type="text" id="edit-rider-last-name">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-form-container" style="max-height: 70vh; overflow-y: auto;">
                    <div class="modal-labels-column">
                        <div class="modal-field-label">Email</div>
                        <div class="modal-field-label">Cell Phone</div>
                        <div class="modal-field-label">Address</div>
                        <div class="modal-field-label">Gender</div>
                        <div class="modal-field-label">Grade</div>
                        <div class="modal-field-label">Racing Group</div>
                        <div class="modal-field-label">Birthday</div>
                        <div class="modal-field-label">Primary Parent/Guardian</div>
                        <div class="modal-field-label">Primary Parent Cell</div>
                        <div class="modal-field-label">Primary Parent Email</div>
                        <div class="modal-field-label">Primary Parent Address</div>
                        <div class="modal-field-label">Second Parent/Guardian</div>
                        <div class="modal-field-label">Second Parent Cell</div>
                        <div class="modal-field-label">Second Parent Email</div>
                        <div class="modal-field-label">Alternate Contact Name</div>
                        <div class="modal-field-label">Alternate Contact Relationship</div>
                        <div class="modal-field-label">Alternate Contact Cell</div>
                        <div class="modal-field-label">Primary Physician</div>
                        <div class="modal-field-label">Primary Physician Phone</div>
                        <div class="modal-field-label">Medical Insurance Company</div>
                        <div class="modal-field-label">Medical Insurance Account #</div>
                        <div class="modal-field-label">Allergies/Medical Needs</div>
                        <div class="modal-field-label">Fitness (1-10)</div>
                        <div class="modal-field-label">Bike Skills (1-4)</div>
                        <div class="modal-field-label">Notes</div>
                    </div>
                    <div class="modal-inputs-column">
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-email" placeholder="Email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-phone" placeholder="(XXX) XXX-XXXX" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-address" placeholder="Address" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-gender" class="modal-field-input" onchange="updateRacingGroupOptions(); updateDefaultPhoto()">
                                <option value="">Select Gender</option>
                                <option value="M">M</option>
                                <option value="F">F</option>
                                <option value="NB">Nonbinary</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-grade" class="modal-field-input">
                                <option value="9th">9th</option>
                                <option value="10th">10th</option>
                                <option value="11th">11th</option>
                                <option value="12th">12th</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <select id="edit-rider-racing-group" class="modal-field-input" disabled>
                                <option value="">Select Gender First</option>
                            </select>
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-birthday" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-parent-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-primary-parent-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-primary-parent-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-parent-address" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-second-parent-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-second-parent-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="email" id="edit-rider-second-parent-email" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-alternate-contact-name" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-alternate-contact-relationship" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-alternate-contact-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-primary-physician" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="tel" id="edit-rider-primary-physician-phone" class="modal-field-input" maxlength="14" oninput="formatPhoneNumber(this)">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-medical-insurance-company" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="text" id="edit-rider-medical-insurance-account" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-rider-allergies" rows="2" class="modal-field-input"></textarea>
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-rider-fitness" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <input type="number" id="edit-rider-skills" min="1" class="modal-field-input">
                        </div>
                        <div class="modal-form-row">
                            <textarea id="edit-rider-notes" rows="3" class="modal-field-input"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between;">
                <button id="delete-rider-btn" class="btn-small danger" onclick="deleteRiderFromModal()" style="display: none;">Delete Record</button>
                <div style="display: flex; gap: 8px; margin-left: auto;">
                    <button class="btn-small secondary" onclick="closeEditRiderModal()">Cancel</button>
                    <button class="btn-small" onclick="saveRiderFromModal()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="notes-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span id="notes-modal-title">Notes</span>
                <button class="btn-small secondary" onclick="closeNotesModal()">Close</button>
            </div>
            <div class="modal-body">
                <p id="notes-modal-content" style="white-space: pre-wrap; margin: 0;"></p>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeNotesModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Login/Auth Modal - DISABLED (using localStorage) -->
    <div id="auth-overlay" class="auth-overlay hidden" style="display: none;">
        <div class="login-container">
            <h2 class="login-title">Tam High MTB Team</h2>
            <p class="login-subtitle">Sign in to access the practice manager</p>
            
            <div id="auth-error" class="error-message" style="display: none;"></div>
            
            <div id="login-form">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label class="field-label" for="login-email">Email</label>
                        <input type="email" id="login-email" class="modal-field-input" placeholder="your@email.com" autocomplete="email">
                    </div>
                    <div>
                        <label class="field-label" for="login-password">Password</label>
                        <input type="password" id="login-password" class="modal-field-input" placeholder="Password" autocomplete="current-password">
                    </div>
                    <button class="btn-small" onclick="handleLogin()" style="width: 100%; margin-top: 8px;">Sign In</button>
                    <div style="text-align: center; margin-top: 8px;">
                        <a href="#" class="auth-link" onclick="event.preventDefault(); showPasswordReset();">Forgot password?</a>
                    </div>
                    <div id="resend-verification" style="text-align: center; margin-top: 8px; display: none;">
                        <a href="#" class="auth-link" onclick="event.preventDefault(); handleResendVerification();">Resend verification email</a>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                    <span style="font-size: 14px; color: #64748b;">Don't have an account? </span>
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showSignup();">Sign up</a>
                </div>
            </div>
            
            <div id="signup-form" style="display: none;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <label class="field-label" for="signup-name">Name</label>
                        <input type="text" id="signup-name" class="modal-field-input" placeholder="Your Name" autocomplete="name">
                    </div>
                    <div>
                        <label class="field-label" for="signup-email">Email</label>
                        <input type="email" id="signup-email" class="modal-field-input" placeholder="your@email.com" autocomplete="email">
                    </div>
                    <div>
                        <label class="field-label" for="signup-password">Password</label>
                        <input type="password" id="signup-password" class="modal-field-input" placeholder="Create a password" autocomplete="new-password">
                    </div>
                    <button class="btn-small" onclick="handleSignup()" style="width: 100%; margin-top: 8px;">Create Account</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showLogin();">Back to sign in</a>
                </div>
            </div>
            
            <div id="password-reset-form" style="display: none;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <p style="font-size: 14px; color: #64748b; margin-bottom: 8px;">Enter your email to receive a password reset link.</p>
                    <div>
                        <label class="field-label" for="reset-email">Email</label>
                        <input type="email" id="reset-email" class="modal-field-input" placeholder="your@email.com" autocomplete="email">
                    </div>
                    <button class="btn-small" onclick="handlePasswordReset()" style="width: 100%; margin-top: 8px;">Send Reset Link</button>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <a href="#" class="auth-link" onclick="event.preventDefault(); showLogin();">Back to sign in</a>
                </div>
            </div>
            
            <div id="public-access-link" style="text-align: center; margin-top: 24px; padding-top: 24px; border-top: 1px solid #e2e8f0;">
                <a href="rider-view.html" class="auth-link" style="font-size: 14px; text-decoration: none;">Continue as rider (public access)</a>
            </div>
        </div>
    </div>

    <div id="auto-assign-settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 800px;">
            <div class="modal-header">
                <span>Auto-Assignment Settings</span>
                <button class="btn-small secondary" onclick="closeAutoAssignSettingsModal()">Close</button>
            </div>
            <div class="modal-body">
                <p style="margin: 0 0 16px 0; color: #666; font-size: 13px;">
                    Adjust parameters and their priority to control how riders and coaches are automatically assigned to groups. 
                    Drag rows to reorder priority (lower numbers = higher priority).
                </p>
                <div id="auto-assign-params-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="resetAutoAssignSettings()">Reset to Defaults</button>
                <button class="btn-small secondary" onclick="closeAutoAssignSettingsModal()">Cancel</button>
                <button class="btn-small" onclick="saveAutoAssignSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- ADD ROUTE MODAL -->
    <div id="routes-manager-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 1000px; width: min(1000px, 95%);">
            <div class="modal-header">
                <span>Manage Routes</span>
                <button class="btn-small secondary" onclick="closeRoutesManagerModal()">Close</button>
            </div>
            <div class="modal-body">
                <div id="routes-manager-list" style="max-height: 500px; overflow-y: auto;">
                    <!-- Routes list will be loaded dynamically -->
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 12px;">
                    <button class="btn-small" onclick="openAddRouteModal(null)" style="background-color: #fc5200; color: white; border-color: #fc5200;">Add Strava Route</button>
                    <button class="btn-small" onclick="openAddRouteModal(null, true)">Add Route</button>
                </div>
            </div>
        </div>
    </div>

    <div id="add-route-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header" id="add-route-modal-header" style="background-color: #fc5200; color: white;">
                <span id="add-route-modal-title">Add Strava Route</span>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="position: relative;">
                        <label for="route-embed-code" class="field-label" style="display: flex; align-items: center; gap: 6px;">
                            Strava Embed Code
                            <span class="info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background-color: #666; color: white; font-size: 11px; font-weight: bold; cursor: help; user-select: none;" onmouseenter="showEmbedCodeTooltip(event)" onmouseleave="hideEmbedCodeTooltip()">i</span>
                        </label>
                        <div id="embed-code-tooltip" style="position: absolute; background-color: #333; color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 10000; pointer-events: none; display: none; max-width: 300px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); white-space: normal; line-height: 1.4;">To get the embed code: Go to your Strava route page ‚Üí Click the "Share" button ‚Üí Copy the embed code</div>
                        <textarea id="route-embed-code" class="modal-field-input" rows="6" placeholder="Paste the Strava embed iframe code here..."></textarea>
                        <div id="fetch-route-data-container" style="margin-top: 12px;">
                            <button type="button" id="fetch-route-data-btn" class="btn-small" onclick="fetchRouteDataFromEmbed()" disabled>
                                üîç Auto-fill Route Info from Strava
                            </button>
                            <span id="fetch-route-status" style="margin-left: 8px; font-size: 12px; color: #666;"></span>
                        </div>
                    </div>
                    <div>
                        <label for="route-name" class="field-label">Route Name</label>
                        <input type="text" id="route-name" class="modal-field-input" placeholder="Will be auto-filled from Strava, or enter manually">
                    </div>
                    <div class="form-row">
                        <div style="flex:1;">
                            <label for="route-distance" class="field-label">Distance (Optional)</label>
                            <input type="text" id="route-distance" class="modal-field-input" placeholder="Will be auto-filled from Strava">
                        </div>
                        <div style="flex:1;">
                            <label for="route-elevation" class="field-label">Elevation Gain (Optional)</label>
                            <input type="text" id="route-elevation" class="modal-field-input" placeholder="Will be auto-filled from Strava">
                        </div>
                    </div>
                    <div>
                        <label for="route-time" class="field-label" style="display: flex; align-items: center; gap: 8px;">
                            <span>Approximate time range to complete route</span>
                            <button type="button" onclick="openTimeEstimationSettings()" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center; color: #666;" title="Time estimation settings">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"></path>
                                </svg>
                            </button>
                        </label>
                        <input type="text" id="route-time" class="modal-field-input" placeholder="Will be calculated from distance and elevation" readonly style="background-color: #f5f5f5; cursor: not-allowed;">
                    </div>
                    <div>
                        <label class="field-label">Most appropriate Fitness Range</label>
                        <div id="route-fitness-slider-container" style="position: relative; padding: 5px 0;">
                            <div id="route-fitness-slider-track" style="position: relative; height: 6px; background: #e0e0e0; border-radius: 3px; margin: 8px 0;">
                                <div id="route-fitness-slider-range" style="position: absolute; height: 100%; background: #2196F3; border-radius: 3px; left: 0%; width: 100%; top: 0;"></div>
                                <div id="route-fitness-min-handle" class="slider-handle" data-slider="fitness" data-type="min" style="position: absolute; left: 0%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <div id="route-fitness-max-handle" class="slider-handle" data-slider="fitness" data-type="max" style="position: absolute; left: 100%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <input type="range" id="route-fitness-min" min="1" max="5" value="1" step="1" style="display: none;" oninput="updateFitnessRange()">
                                <input type="range" id="route-fitness-max" min="2" max="5" value="5" step="1" style="display: none;" oninput="updateFitnessRange()">
                            </div>
                            <div id="route-fitness-labels" style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: #666;">
                                <!-- Labels will be generated dynamically -->
                            </div>
                            <div style="text-align: center; margin-top: 4px; font-size: 12px; font-weight: 600; color: #2196F3;">
                                <span id="route-fitness-min-value">1</span> - <span id="route-fitness-max-value">5</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label class="field-label">Most appropriate Bike Skills Range</label>
                        <div id="route-skills-slider-container" style="position: relative; padding: 5px 0;">
                            <div id="route-skills-slider-track" style="position: relative; height: 6px; background: #e0e0e0; border-radius: 3px; margin: 8px 0;">
                                <div id="route-skills-slider-range" style="position: absolute; height: 100%; background: #2196F3; border-radius: 3px; left: 0%; width: 100%; top: 0;"></div>
                                <div id="route-skills-min-handle" class="slider-handle" data-slider="skills" data-type="min" style="position: absolute; left: 0%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <div id="route-skills-max-handle" class="slider-handle" data-slider="skills" data-type="max" style="position: absolute; left: 100%; transform: translate(-50%, -50%); width: 20px; height: 20px; background: #2196F3; border-radius: 50%; cursor: grab; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: auto; top: 50%;"></div>
                                <input type="range" id="route-skills-min" min="1" max="3" value="1" step="1" style="display: none;" oninput="updateSkillsRange()">
                                <input type="range" id="route-skills-max" min="2" max="3" value="3" step="1" style="display: none;" oninput="updateSkillsRange()">
                            </div>
                            <div id="route-skills-labels" style="display: flex; justify-content: space-between; margin-top: 6px; font-size: 11px; color: #666;">
                                <!-- Labels will be generated dynamically -->
                            </div>
                            <div style="text-align: center; margin-top: 4px; font-size: 12px; font-weight: 600; color: #2196F3;">
                                <span id="route-skills-min-value">1</span> - <span id="route-skills-max-value">3</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label for="route-description" class="field-label">Notes (Optional)</label>
                        <textarea id="route-description" class="modal-field-input" rows="3" placeholder="Brief description of the route..."></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-small secondary" onclick="closeAddRouteModal()">Cancel</button>
                <button class="btn-small" onclick="saveRoute()">Save Route</button>
            </div>
        </div>
    </div>

    <!-- Time Estimation Settings Modal -->
    <div id="time-estimation-settings-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <span>Time Estimation Settings</span>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <p style="font-size: 14px; color: #666; margin: 0;">Adjust the speed parameters used to calculate route completion time estimates. Changes apply to all routes.</p>
                    
                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0;">Base Speeds (mph)</h3>
                        <div class="form-row">
                            <div style="flex: 1;">
                                <label for="time-settings-fast-speed" class="field-label">Faster Rider Base Speed</label>
                                <input type="number" id="time-settings-fast-speed" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Base speed for faster riders (mph)</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-slow-speed" class="field-label">Slower Rider Base Speed</label>
                                <input type="number" id="time-settings-slow-speed" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Base speed for slower riders (mph)</small>
                            </div>
                        </div>
                        <div class="form-row" style="margin-top: 12px;">
                            <div style="flex: 1;">
                                <label for="time-settings-fast-min" class="field-label">Faster Rider Minimum Speed</label>
                                <input type="number" id="time-settings-fast-min" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Minimum speed regardless of conditions (mph)</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-slow-min" class="field-label">Slower Rider Minimum Speed</label>
                                <input type="number" id="time-settings-slow-min" class="modal-field-input" step="0.1" min="1" max="20" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Minimum speed regardless of conditions (mph)</small>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0;">Adjustments</h3>
                        <div class="form-row">
                            <div style="flex: 1;">
                                <label for="time-settings-elevation" class="field-label">Elevation Adjustment</label>
                                <input type="number" id="time-settings-elevation" class="modal-field-input" step="0.1" min="0" max="5" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Speed reduction (mph) per 1000 ft of elevation gain</small>
                            </div>
                            <div style="flex: 1;">
                                <label for="time-settings-length" class="field-label">Length Adjustment Factor</label>
                                <input type="number" id="time-settings-length" class="modal-field-input" step="0.01" min="0" max="1" onchange="previewTimeEstimationSettings()">
                                <small style="color: #666; font-size: 12px;">Speed reduction (mph) per mile over 10 miles</small>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e0e0e0; padding-top: 16px;">
                        <button class="btn-small secondary" onclick="resetTimeEstimationSettings()">Reset to Defaults</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="discardTimeEstimationSettings()">Discard Changes</button>
                <button class="btn-small" onclick="saveTimeEstimationSettings()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Practice Context Menu -->
    <div id="practice-context-menu" class="context-menu" style="display: none; position: absolute; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 10000; min-width: 180px;">
        <button class="context-menu-item" onclick="deletePracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Delete Practice</button>
        <button class="context-menu-item" onclick="cancelPracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Cancel Practice</button>
        <button id="restore-practice-btn" class="context-menu-item" onclick="restoreCancelledPractice()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333; display: none;">Restore Practice</button>
        <button class="context-menu-item" onclick="reschedulePracticeFromContext()" style="width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;">Reschedule Practice</button>
    </div>
    
    <div id="coach-move-context-menu" class="context-menu" style="display: none; position: absolute; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 10000; min-width: 180px;">
        <div id="coach-move-role-options"></div>
        <hr style="margin: 4px 0; border: none; border-top: 1px solid #ddd;">
        <div id="coach-move-group-options"></div>
    </div>

    <!-- Cancel Practice Modal -->
    <div id="cancel-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span>Cancel Practice</span>
                <button class="btn-small secondary" onclick="closeCancelPracticeModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <p style="font-size: 14px; color: #666; margin: 0;">Please select a reason for cancelling this practice:</p>
                    <div>
                        <label for="cancel-reason" class="field-label">Cancellation Reason</label>
                        <select id="cancel-reason" class="modal-field-input">
                            <option value="Weather">Weather</option>
                            <option value="Staffing">Staffing</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeCancelPracticeModal()">Cancel</button>
                <button class="btn-small" onclick="confirmCancelPractice()" style="background-color: #f44336; color: white; border-color: #f44336;">Cancel Practice</button>
            </div>
        </div>
    </div>

    <!-- Reschedule Practice Modal -->
    <div id="reschedule-practice-modal" class="modal-overlay" aria-hidden="true">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span>Reschedule Practice</span>
                <button class="btn-small secondary" onclick="closeReschedulePracticeModal()">Close</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label for="reschedule-date" class="field-label">New Date</label>
                        <input type="date" id="reschedule-date" class="modal-field-input">
                    </div>
                    <div class="form-row">
                        <div style="flex: 1;">
                            <label for="reschedule-time" class="field-label">Time</label>
                            <input type="time" id="reschedule-time" class="modal-field-input">
                        </div>
                        <div style="flex: 1;">
                            <label for="reschedule-end-time" class="field-label">End Time</label>
                            <input type="time" id="reschedule-end-time" class="modal-field-input">
                        </div>
                    </div>
                    <div>
                        <label for="reschedule-location" class="field-label">Location</label>
                        <input type="text" id="reschedule-location" class="modal-field-input" placeholder="Enter location">
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid #e0e0e0;">
                <button class="btn-small secondary" onclick="closeReschedulePracticeModal()">Cancel</button>
                <button class="btn-small" onclick="confirmReschedulePractice()" style="background-color: #2196F3; color: white; border-color: #2196F3;">Reschedule</button>
            </div>
        </div>
    </div>

    <script>
        // Data storage
        let data = {
            riders: [],
            coaches: [],
            rides: [],
            routes: [],
            races: [],
            currentRide: null,
            seasonSettings: {
                startDate: '',
                endDate: '',
                practices: [],
                fitnessScale: 5,  // Default: 5 increments (1-5)
                skillsScale: 3    // Default: 3 increments (1-3)
            },
            coachRoles: [],  // Array of { roleName: string, coachId: number }
            riderRoles: [],  // Array of { roleName: string, riderId: number }
            timeEstimationSettings: {
                fastSpeedBase: 12.5,      // mph - faster rider base speed
                slowSpeedBase: 10,        // mph - slower rider base speed
                fastSpeedMin: 5.5,        // mph - minimum speed for faster rider
                slowSpeedMin: 4,          // mph - minimum speed for slower rider
                elevationAdjustment: 0.5, // mph reduction per 1000 ft elevation
                lengthAdjustmentFactor: 0.1 // mph reduction per mile over 10 miles
            },
            autoAssignSettings: {
                parameters: [
                    { id: 'minGroupSize', name: 'Minimum Group Size', value: 4, priority: 1, enabled: true, type: 'number', min: 1, max: 20, description: 'Minimum number of riders per group' },
                    { id: 'maxGroupSize', name: 'Maximum Group Size', value: 10, priority: 2, enabled: true, type: 'number', min: 1, max: 30, description: 'Maximum number of riders per group' },
                    { id: 'preferredGroupSize', name: 'Preferred Group Size', value: 7, priority: 3, enabled: true, type: 'number', min: 1, max: 20, description: 'Target number of riders per group' },
                    { id: 'maxFitnessSpread', name: 'Maximum Fitness Spread', value: 2, priority: 4, enabled: true, type: 'number', min: 0, max: 10, description: 'Maximum fitness difference within a group' },
                    { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 5, enabled: true, type: 'number', min: 1, max: 20, description: 'Capacity multiplier: coaches √ó this value' },
                    { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 6, enabled: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                    { id: 'groupsPerRiderMin', name: 'Groups Calculation (Min)', value: 7, priority: 7, enabled: true, type: 'number', min: 1, max: 20, description: 'Divide riders by this to get minimum groups' },
                    { id: 'groupsPerRiderMax', name: 'Groups Calculation (Max)', value: 10, priority: 8, enabled: true, type: 'number', min: 1, max: 20, description: 'Divide riders by this to get maximum groups' }
                ]
            },
            sampleVersion: null
        };

        let autoAssignDebugLog = '';
        let seasonSettingsDraft = null;

        const SAMPLE_DATA_VERSION = 6;
        
        // Helper functions to get rating scales
        function getFitnessScale() {
            return (data.seasonSettings && data.seasonSettings.fitnessScale) ? data.seasonSettings.fitnessScale : 5;
        }
        
        function getSkillsScale() {
            return (data.seasonSettings && data.seasonSettings.skillsScale) ? data.seasonSettings.skillsScale : 3;
        }
        
        // Convert a value from one scale to another (proportional conversion)
        function convertScale(value, oldMax, newMax) {
            if (oldMax === newMax) return value;
            if (value < 1) return 1;
            if (value > oldMax) value = oldMax;
            // Convert proportionally: (value - 1) / (oldMax - 1) * (newMax - 1) + 1
            const proportion = (value - 1) / (oldMax - 1);
            const newValue = Math.round(proportion * (newMax - 1) + 1);
            return Math.max(1, Math.min(newMax, newValue));
        }
        
        // Helper functions to get auto-assignment settings
        function getAutoAssignSetting(id, defaultValue) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return defaultValue;
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return defaultValue;
            return param.value;
        }
        
        // Get priority of a parameter (lower number = higher priority)
        function getParamPriority(id) {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return 999; // Low priority if not found
            }
            const param = data.autoAssignSettings.parameters.find(p => p.id === id);
            if (!param || !param.enabled) return 999;
            return param.priority;
        }
        
        // Get all enabled parameters sorted by priority (requirements first)
        function getEnabledParamsByPriority() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled)
                .sort((a, b) => {
                    // Requirements always come first
                    if (a.requirement && !b.requirement) return -1;
                    if (!a.requirement && b.requirement) return 1;
                    // Then sort by priority
                    return a.priority - b.priority;
                });
        }
        
        // Get all requirements sorted by priority
        function getRequirements() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled && p.requirement)
                .sort((a, b) => a.priority - b.priority);
        }
        
        // Get all preferences sorted by priority
        function getPreferences() {
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                return [];
            }
            return data.autoAssignSettings.parameters
                .filter(p => p.enabled && !p.requirement)
                .sort((a, b) => a.priority - b.priority);
        }
        
        // Check if constraint A can be relaxed in favor of constraint B
        function canRelaxConstraint(constraintAId, constraintBId) {
            return getParamPriority(constraintAId) > getParamPriority(constraintBId);
        }
        
        // Legacy constants for backward compatibility (now use getAutoAssignSetting)
        function getMIN_GROUP_SIZE() { 
            const param = data.autoAssignSettings?.parameters?.find(p => p.id === 'preferredGroupSize');
            return param?.valueMin || 4; 
        }
        function getMAX_FITNESS_SPREAD() { return getAutoAssignSetting('organizeByPace', 2); }
        const DAYS_OF_WEEK = [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ];

        const COACH_NAMES_MALE = [
            'Alex Johnson', 'David Patel', 'Owen McCarthy', 'Cole Ramirez', 'Marcus Lee',
            'Noah Foster', 'Declan Scott', 'Gavin Brooks', 'Ryan Mitchell', 'James Wilson',
            'Michael Thompson', 'Christopher Davis', 'Daniel Martinez', 'Matthew Anderson'
        ];
        
        const COACH_NAMES_FEMALE = [
            'Maria Chen', 'Lisa Hernandez', 'Priya Singh', 'Jenna King', 'Emily Baker',
            'Harper Wright', 'Sofia Navarro', 'Sarah Johnson', 'Jessica Taylor', 'Amanda White',
            'Jennifer Brown', 'Nicole Garcia', 'Rachel Martinez', 'Lauren Rodriguez'
        ];
        
        const COACH_NAMES = [...COACH_NAMES_MALE, ...COACH_NAMES_FEMALE];

        const COACH_NOTES = [
            'Focuses on fundamentals and beginner confidence.',
            'Great with route planning and pacing.',
            'Specializes in technical climbing drills.',
            'Leads safety briefings and mechanical checks.',
            'Encourages endurance development on long rides.'
        ];

        const COACH_FITNESS_SAMPLES = [1, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9, 10];

        const RIDER_NAMES_MALE = [
            'Ethan Cole', 'Logan Price', 'Wyatt Brooks', 'Benjamin Ortiz', 'Caleb Jordan',
            'Landon Hayes', 'Julian Foster', 'Isaiah Blake', 'Xavier Dunn', 'Grayson Tate',
            'Leo Ramirez', 'Connor Walsh', 'Miles Curtis', 'Sebastian Ford', 'Jordan Knox',
            'Noah Parker', 'Lucas Bennett', 'Owen Carter', 'Mason Reed', 'Ethan Mitchell',
            'Aiden Cooper', 'Jackson Hill', 'Liam Walker', 'Hunter Scott', 'Carter Johnson',
            'Tyler Davis', 'Ryan Martinez', 'Nathan Brown', 'Dylan Wilson', 'Cole Anderson',
            'Blake Taylor', 'Jake Thompson', 'Luke Garcia'
        ];
        
        const RIDER_NAMES_FEMALE = [
            'Mia Torres', 'Ava Reed', 'Chloe Sanders', 'Layla Kim', 'Nora Fields',
            'Scarlett Evans', 'Zoe McCoy', 'Riley Porter', 'Paisley Grant', 'Brooklyn Shaw',
            'Piper Klein', 'Sage Elliott', 'Ellie Benson', 'Adeline Harper', 'Mila Lawson',
            'Sophia Martinez', 'Emma Davis', 'Olivia Wilson', 'Isabella Garcia', 'Amelia Rodriguez',
            'Charlotte Brown', 'Harper Lee', 'Evelyn Taylor', 'Abigail Moore'
        ];
        
        const RIDER_NAMES = [...RIDER_NAMES_MALE, ...RIDER_NAMES_FEMALE];

        const RIDER_NOTES = [
            'Consistent climber with strong endurance.',
            'Working on cornering technique.',
            'Prefers technical terrain and rock gardens.',
            'Great with group communication and morale.',
            'Developing sprint speed for race finishes.'
        ];

        const RIDER_FITNESS_SAMPLES = [
            1, 2,
            3, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5,
            6, 6, 6, 6, 6,
            7, 7, 7,
            8, 8,
            9,
            10
        ];
        const RIDER_GENDER_SAMPLES = ['M', 'F'];

        function buildDefaultCoaches() {
            const base = Date.now();
            const coaches = [];
            
            // Generate 20 coaches with gender-appropriate photos
            for (let i = 0; i < 20; i++) {
                const isMale = i < 14; // 14 male, 6 female (70% male, 30% female for coaches)
                const nameList = isMale ? COACH_NAMES_MALE : COACH_NAMES_FEMALE;
                const nameIndex = i % nameList.length;
                const name = nameList[nameIndex];
                // Generate valid 10-digit phone number: 415-555-0100 to 415-555-0119
                // Using 415 area code (Marin County) and 555 exchange (fictional but valid)
                const phoneNumber = `415555${(100 + i).toString().padStart(4, '0')}`;
                const fitnessValue = COACH_FITNESS_SAMPLES[i % COACH_FITNESS_SAMPLES.length];
                
                // Use randomuser.me for adult photos - men/women directories
                const photoIndex = (i % 50) + 1;
                const photo = isMale 
                    ? `https://randomuser.me/api/portraits/men/${photoIndex}.jpg`
                    : `https://randomuser.me/api/portraits/women/${photoIndex}.jpg`;
                
                coaches.push({
                    id: base + i + 1,
                    name,
                    phone: phoneNumber,
                    level: String((i % 3) + 1),
                    fitness: String(fitnessValue),
                    photo: photo,
                    notes: COACH_NOTES[i % COACH_NOTES.length]
                });
            }
            
            return coaches;
        }

        function buildDefaultRiders() {
            const base = Date.now() + 1000;
            const grades = ['9th', '10th', '11th', '12th'];
            const boysGroups = ['Freshman Boys', 'JV2 Boys', 'JV1 Boys', 'Varsity Boys'];
            const girlsGroups = ['Freshman Girls', 'JV2 Girls', 'JV1 Girls', 'Varsity Girls'];
            const riders = [];
            
            // Generate 50 riders: 65% male (32-33), 35% female (17-18)
            const totalRiders = 50;
            const maleCount = Math.round(totalRiders * 0.65); // 32-33 males
            const femaleCount = totalRiders - maleCount; // 17-18 females
            
            for (let i = 0; i < totalRiders; i++) {
                const isMale = i < maleCount;
                const nameList = isMale ? RIDER_NAMES_MALE : RIDER_NAMES_FEMALE;
                const nameIndex = i % nameList.length;
                const name = nameList[nameIndex];
                // Generate valid 10-digit phone number: 415-556-0200 to 415-556-0249
                // Using 415 area code (Marin County) and 556 exchange to differentiate from coaches
                const phoneNumber = `415556${(200 + i).toString().padStart(4, '0')}`;
                const fitnessValue = RIDER_FITNESS_SAMPLES[i % RIDER_FITNESS_SAMPLES.length];
                const genderValue = isMale ? 'M' : 'F';
                const groups = isMale ? boysGroups : girlsGroups;
                const gradeIndex = i % grades.length;
                // Distribute racing groups more evenly
                const groupIndex = Math.floor((i % (groups.length * 4)) / 4);
                
                // Use realistic photos that match gender
                // Using randomuser.me with different index ranges for variety
                // Note: These are adult photos, but they're the most realistic free option
                // For a production app, you'd use a service with actual teen photos
                const photoIndex = (i % 70) + 1;
                const photo = isMale 
                    ? `https://randomuser.me/api/portraits/men/${photoIndex}.jpg`
                    : `https://randomuser.me/api/portraits/women/${photoIndex}.jpg`;
                
                riders.push({
                    id: base + i + 1,
                    name,
                    phone: phoneNumber,
                    grade: grades[gradeIndex],
                    racingGroup: groups[groupIndex],
                    fitness: String(fitnessValue),
                    gender: genderValue,
                    photo: photo,
                    notes: RIDER_NOTES[i % RIDER_NOTES.length]
                });
            }
            
            return riders;
        }

        function buildDefaultSeasonSettings() {
            return {
                startDate: '',
                endDate: '',
                practices: [],
                fitnessScale: 5,
                skillsScale: 3
            };
        }
        
        // Convert all fitness and skills ratings when scales change
        function convertAllRatingsToNewScales(oldFitnessScale, newFitnessScale, oldSkillsScale, newSkillsScale) {
            let convertedCount = 0;
            
            // Convert rider fitness and skills
            if (data.riders) {
                data.riders.forEach(rider => {
                    if (rider.fitness && oldFitnessScale !== newFitnessScale) {
                        const oldValue = parseInt(rider.fitness, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldFitnessScale) {
                            rider.fitness = String(convertScale(oldValue, oldFitnessScale, newFitnessScale));
                            convertedCount++;
                        }
                    }
                    if (rider.skills && oldSkillsScale !== newSkillsScale) {
                        const oldValue = parseInt(rider.skills, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldSkillsScale) {
                            rider.skills = String(convertScale(oldValue, oldSkillsScale, newSkillsScale));
                            convertedCount++;
                        }
                    }
                });
            }
            
            // Convert coach fitness
            if (data.coaches) {
                data.coaches.forEach(coach => {
                    if (coach.fitness && oldFitnessScale !== newFitnessScale) {
                        const oldValue = parseInt(coach.fitness, 10);
                        if (!isNaN(oldValue) && oldValue >= 1 && oldValue <= oldFitnessScale) {
                            coach.fitness = String(convertScale(oldValue, oldFitnessScale, newFitnessScale));
                            convertedCount++;
                        }
                    }
                });
            }
            
            if (convertedCount > 0) {
                alert(`Converted ${convertedCount} rating(s) to the new scale(s).`);
            }
        }
        
        // Update scale settings UI when changed
        function updateScaleSettings() {
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            
            if (fitnessScaleInput && fitnessScaleDisplay) {
                fitnessScaleDisplay.textContent = fitnessScaleInput.value;
            }
            if (skillsScaleInput && skillsScaleDisplay) {
                skillsScaleDisplay.textContent = skillsScaleInput.value;
            }
            
            // Update input max attributes
            updateInputMaxAttributes();
        }
        
        // Update max attributes of fitness/skills inputs based on current scales
        function updateInputMaxAttributes() {
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            
            const coachFitnessInput = document.getElementById('edit-coach-fitness');
            const coachSkillsInput = document.getElementById('edit-coach-skills');
            const riderFitnessInput = document.getElementById('edit-rider-fitness');
            const riderSkillsInput = document.getElementById('edit-rider-skills');
            
            // Route fitness/skills range inputs
            const routeFitnessMin = document.getElementById('route-fitness-min');
            const routeFitnessMax = document.getElementById('route-fitness-max');
            const routeSkillsMin = document.getElementById('route-skills-min');
            const routeSkillsMax = document.getElementById('route-skills-max');
            
            if (coachFitnessInput) coachFitnessInput.max = fitnessScale;
            if (coachSkillsInput) coachSkillsInput.max = skillsScale;
            if (riderFitnessInput) riderFitnessInput.max = fitnessScale;
            if (riderSkillsInput) riderSkillsInput.max = skillsScale;
            
            // Update route range inputs
            if (routeFitnessMin) {
                routeFitnessMin.max = fitnessScale;
                // Ensure current value doesn't exceed new max
                if (parseInt(routeFitnessMin.value) > fitnessScale) {
                    routeFitnessMin.value = fitnessScale;
                }
            }
            if (routeFitnessMax) {
                routeFitnessMax.max = fitnessScale;
                routeFitnessMax.min = 2; // Ensure min is at least 2
                // Ensure current value doesn't exceed new max
                if (parseInt(routeFitnessMax.value) > fitnessScale) {
                    routeFitnessMax.value = fitnessScale;
                }
            }
            if (routeSkillsMin) {
                routeSkillsMin.max = skillsScale;
                // Ensure current value doesn't exceed new max
                if (parseInt(routeSkillsMin.value) > skillsScale) {
                    routeSkillsMin.value = skillsScale;
                }
            }
            if (routeSkillsMax) {
                routeSkillsMax.max = skillsScale;
                routeSkillsMax.min = 2; // Ensure min is at least 2
                // Ensure current value doesn't exceed new max
                if (parseInt(routeSkillsMax.value) > skillsScale) {
                    routeSkillsMax.value = skillsScale;
                }
            }
        }
        
        // Update route slider scale labels dynamically
        function updateRouteSliderLabels() {
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            
            // Update fitness slider labels
            const fitnessLabelsContainer = document.getElementById('route-fitness-labels');
            if (fitnessLabelsContainer) {
                fitnessLabelsContainer.innerHTML = '';
                for (let i = 1; i <= fitnessScale; i++) {
                    const span = document.createElement('span');
                    span.textContent = i;
                    fitnessLabelsContainer.appendChild(span);
                }
            }
            
            // Update skills slider labels
            const skillsLabelsContainer = document.getElementById('route-skills-labels');
            if (skillsLabelsContainer) {
                skillsLabelsContainer.innerHTML = '';
                for (let i = 1; i <= skillsScale; i++) {
                    const span = document.createElement('span');
                    span.textContent = i;
                    skillsLabelsContainer.appendChild(span);
                }
            }
        }

        function generateId() {
            return Date.now() + Math.floor(Math.random() * 100000);
        }

        function normalizeCoachId(value) {
            const id = parseInt(value, 10);
            return Number.isFinite(id) ? id : null;
        }

        function normalizeTimeValue(value) {
            if (!value && value !== 0) return '';
            const stringValue = String(value).trim();
            const match = stringValue.match(/^(\d{1,2})(?::?(\d{2}))?$/);
            if (!match) {
                const parts = stringValue.split(':');
                if (parts.length >= 2) {
                    const hour = Math.max(0, Math.min(23, parseInt(parts[0], 10) || 0));
                    const minute = Math.max(0, Math.min(59, parseInt(parts[1], 10) || 0));
                    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                }
                return '';
            }

            const hour = Math.max(0, Math.min(23, parseInt(match[1], 10) || 0));
            const minute = Math.max(0, Math.min(59, parseInt(match[2] !== undefined ? match[2] : '0', 10) || 0));
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        function normalizePracticeEntry(entry) {
            if (!entry || typeof entry !== 'object') {
                return null;
            }

            const normalizedDay = Number.isFinite(entry.dayOfWeek)
                ? entry.dayOfWeek
                : Number.isFinite(entry.day)
                    ? entry.day
                    : Number.isFinite(entry.weekday)
                        ? entry.weekday
                        : parseInt(entry.dayOfWeek ?? entry.day ?? entry.weekday, 10);

            const dayOfWeek = Number.isFinite(normalizedDay) ? normalizedDay : NaN;
            if (!Number.isFinite(dayOfWeek) || dayOfWeek < 0 || dayOfWeek > 6) {
                return null;
            }

            const time = normalizeTimeValue(entry.time || entry.startTime || '');
            if (!time) {
                return null;
            }

            const endTime = normalizeTimeValue(entry.endTime || '');

            return {
                id: entry.id || generateId(),
                dayOfWeek,
                time,
                endTime,
                description: entry.description || '',
                meetLocation: entry.meetLocation || '',
                locationLat: entry.locationLat != null && Number.isFinite(parseFloat(entry.locationLat)) ? parseFloat(entry.locationLat) : null,
                locationLng: entry.locationLng != null && Number.isFinite(parseFloat(entry.locationLng)) ? parseFloat(entry.locationLng) : null
            };
        }

        function createGroup(label) {
            return {
                id: generateId(),
                label,
                coaches: {
                    leader: null,
                    sweep: null,
                    roam: null,
                    extraRoam: []
                },
                riders: [],
                fitnessTag: null,
                sortBy: 'pace', // Default sort by pace
                routeId: null // Route assigned to this group
            };
        }

        function computeGroupsInfo(ride) {
            return ride.groups.map(group => {
                const capacity = groupCapacity(group);
                const maxGroupSize = getAutoAssignSetting('maxGroupSize', 10);
                const preferredGroupSize = getAutoAssignSetting('preferredGroupSize', 7);
                const minGroupSize = getMIN_GROUP_SIZE();
                
                // Determine target sizes based on priority order
                // Capacity (ridersPerCoach) is the absolute limit
                // maxGroupSize, preferredGroupSize, and minGroupSize are constraints that can be relaxed
                const baseMax = Math.min(maxGroupSize, capacity);
                const targetMax = Math.max(1, baseMax);
                const targetPreferred = Math.min(preferredGroupSize, targetMax);
                const targetMin = Math.min(minGroupSize, targetPreferred);
                
                return {
                    group,
                    capacity,
                    targetMin,
                    targetPreferred,
                    targetMax,
                    fitness: group.fitnessTag != null ? parseInt(group.fitnessTag, 10) : null,
                    // Store priorities for decision making
                    maxGroupSizePriority: getParamPriority('maxGroupSize'),
                    preferredGroupSizePriority: getParamPriority('preferredGroupSize'),
                    minGroupSizePriority: getParamPriority('minGroupSize')
                };
            }).filter(info => info.capacity > 0);
        }

        function addExtraCoach(group, coachId) {
            if (!coachId) return;
            if (group.coaches.leader === coachId || group.coaches.sweep === coachId || group.coaches.roam === coachId) {
                return;
            }
            if (!Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam = [];
            }
            if (!group.coaches.extraRoam.includes(coachId)) {
                group.coaches.extraRoam.push(coachId);
            }
        }

        function mergeSmallGroups(ride, debugLines) {
            let mergedSomething = true;
            while (mergedSomething) {
                mergedSomething = false;
                const infos = computeGroupsInfo(ride);
                const minGroupSize = getMIN_GROUP_SIZE();
                for (const info of infos) {
                    const group = info.group;
                    if (group.riders.length >= minGroupSize) {
                        continue;
                    }
                    const sourceFitness = info.fitness;
                    let bestCandidate = null;
                    for (const candidate of infos) {
                        if (candidate.group === group) continue;
                        // Check if we can exceed targetMax based on priority
                        const maxGroupSizePriority = getParamPriority('maxGroupSize');
                        const minGroupSizePriority = getParamPriority('minGroupSize');
                        
                        // If minGroupSize has higher priority than maxGroupSize, allow exceeding maxGroupSize to satisfy minGroupSize
                        const capacityLimit = (minGroupSizePriority < maxGroupSizePriority) 
                            ? candidate.capacity 
                            : Math.min(candidate.targetMax, candidate.capacity);
                        if (candidate.group.riders.length + group.riders.length > capacityLimit) continue;
                        const targetFitness = candidate.fitness;
                        const maxFitnessSpread = getMAX_FITNESS_SPREAD();
                        const diff = (sourceFitness != null && targetFitness != null)
                            ? Math.abs(targetFitness - sourceFitness)
                            : maxFitnessSpread;
                        if (diff > maxFitnessSpread) continue;
                        if (
                            !bestCandidate ||
                            diff < bestCandidate.diff ||
                            (diff === bestCandidate.diff && candidate.group.riders.length < bestCandidate.info.group.riders.length)
                        ) {
                            bestCandidate = { info: candidate, diff };
                        }
                    }

                    if (bestCandidate) {
                        const target = bestCandidate.info.group;
                        const groupLabel = `${group.label}`;
                        const targetLabel = `${target.label}`;

                        if (group.coaches.sweep && !target.coaches.sweep) {
                            target.coaches.sweep = group.coaches.sweep;
                        } else {
                            addExtraCoach(target, group.coaches.sweep);
                        }

                        if (group.coaches.roam && !target.coaches.roam) {
                            target.coaches.roam = group.coaches.roam;
                        } else {
                            addExtraCoach(target, group.coaches.roam);
                        }

                        addExtraCoach(target, group.coaches.leader);

                        if (Array.isArray(group.coaches.extraRoam)) {
                            group.coaches.extraRoam.forEach(id => addExtraCoach(target, id));
                        }

                        target.riders = target.riders.concat(group.riders);
                        debugLines.push(`Merged ${groupLabel} (${group.riders.length} riders) into ${targetLabel} (fitness diff ${bestCandidate.diff}).`);

                        ride.groups = ride.groups.filter(g => g !== group);
                        mergedSomething = true;
                        break;
                    }
                }
            }

            const postMergeInfos = computeGroupsInfo(ride);
            const minGroupSize = getMIN_GROUP_SIZE();
            postMergeInfos.forEach(info => {
                if (info.group.riders.length < minGroupSize) {
                    debugLines.push(`‚ö†Ô∏è ${info.group.label} remains below minimum size with ${info.group.riders.length} riders.`);
                }
            });
        }

        function dissolveSmallGroups(ride, debugLines) {
            let dissolved = false;
            let groupsInfo = computeGroupsInfo(ride);
            const minGroupSize = getMIN_GROUP_SIZE();
            const maxFitnessSpread = getMAX_FITNESS_SPREAD();
            groupsInfo
                .filter(info => info.group.riders.length > 0 && info.group.riders.length < minGroupSize)
                .forEach(info => {
                    const sourceGroup = info.group;
                    const sourceFitness = info.fitness;
                    const riderCount = sourceGroup.riders.length;

                    let targetInfo = null;
                    let usedDiff = null;
                    const allowedDiffs = [maxFitnessSpread, maxFitnessSpread + 1, maxFitnessSpread + 2];

                    for (const allowedDiff of allowedDiffs) {
                        const candidates = computeGroupsInfo(ride)
                            .filter(candidate => candidate.group !== sourceGroup)
                            .map(candidate => {
                                const projectedSize = candidate.group.riders.length + riderCount;
                                const diff = (sourceFitness != null && candidate.fitness != null)
                                    ? Math.abs(candidate.fitness - sourceFitness)
                                    : 0;
                                return { candidate, projectedSize, diff };
                            })
                            .filter(entry => {
                                const maxGroupSize = getAutoAssignSetting('maxGroupSize', 10);
                                const maxGroupSizePriority = getParamPriority('maxGroupSize');
                                const minGroupSizePriority = getParamPriority('minGroupSize');
                                
                                // Allow exceeding maxGroupSize if minGroupSize has higher priority
                                const sizeLimit = (minGroupSizePriority < maxGroupSizePriority)
                                    ? entry.candidate.capacity
                                    : Math.min(maxGroupSize, entry.candidate.capacity);
                                
                                return entry.projectedSize <= sizeLimit && entry.diff <= allowedDiff;
                            })
                            .sort((a, b) => {
                                if (a.diff !== b.diff) return a.diff - b.diff;
                                return a.candidate.group.riders.length - b.candidate.group.riders.length;
                            });

                        if (candidates.length > 0) {
                            targetInfo = candidates[0].candidate;
                            usedDiff = candidates[0].diff;
                            break;
                        }
                    }

                    if (!targetInfo) {
                        debugLines.push(`‚ö†Ô∏è Unable to dissolve ${sourceGroup.label}; no groups can accept ${riderCount} riders without exceeding size limits.`);
                        return;
                    }

                    const targetGroup = targetInfo.group;

                    sourceGroup.riders.forEach(riderId => {
                        if (!targetGroup.riders.includes(riderId)) {
                            targetGroup.riders.push(riderId);
                        }
                    });

                    if (targetGroup.fitnessTag == null && sourceGroup.fitnessTag != null) {
                        targetGroup.fitnessTag = sourceGroup.fitnessTag;
                    }

                    addExtraCoach(targetGroup, sourceGroup.coaches.leader);
                    if (sourceGroup.coaches.sweep && !targetGroup.coaches.sweep) {
                        targetGroup.coaches.sweep = sourceGroup.coaches.sweep;
                    } else {
                        addExtraCoach(targetGroup, sourceGroup.coaches.sweep);
                    }
                    if (sourceGroup.coaches.roam && !targetGroup.coaches.roam) {
                        targetGroup.coaches.roam = sourceGroup.coaches.roam;
                    } else {
                        addExtraCoach(targetGroup, sourceGroup.coaches.roam);
                    }
                    if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                        sourceGroup.coaches.extraRoam.forEach(id => addExtraCoach(targetGroup, id));
                    }

                    const diffNote = usedDiff != null ? ` (fitness diff ${usedDiff})` : '';
                    debugLines.push(`Dissolved ${sourceGroup.label} (${riderCount} riders) into ${targetGroup.label}${diffNote}.`);
                    ride.groups = ride.groups.filter(group => group !== sourceGroup);
                    dissolved = true;
                });

            // Don't renumber - keep group names persistent
        }

        function renderRiderCardHtml(rider, options = {}) {
            const {
                draggable = true,
                showAttendance = false,
                isAvailable = true,
                assignmentLabel = '',
                checkboxHandler = null,
                compact = false,
                showMoveControls = false,
                groupId = null,
                canMoveUp = false,
                canMoveDown = false,
                sortBy = 'pace'
            } = options;

            const name = rider.name || 'Rider';
            const safeName = escapeHtml(name);
            const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
            
            // Determine photo - use uploaded photo or default based on gender
            let photoSrc = rider.photo;
            if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                const gender = (rider.gender || '').toUpperCase();
                if (gender === 'M') photoSrc = 'assets/male_default.png';
                else if (gender === 'F') photoSrc = 'assets/female_default.png';
                else photoSrc = 'assets/nonbinary_default.png';
            }
            const photo = photoSrc ? escapeHtml(photoSrc) : '';
            const fitnessScale = getFitnessScale();
            const fitness = String(Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10))));
            const genderValue = (rider.gender || '').toUpperCase();
            const gradeLabel = escapeHtml(formatGradeLabel(rider.grade));
            const classes = ['rider-card'];
            if (showAttendance) classes.push('attendance-card');
            if (!isAvailable) classes.push('attendance-off');
            if (compact) classes.push('compact');
            const dragAttributes = (draggable && isAvailable)
                ? `draggable="true"
                     data-drag-type="rider"
                     data-rider-id="${rider.id}"
                     ondragstart="drag(event)"
                     ondragend="dragEnd(event)"`
                : '';
            const checkboxHtml = showAttendance && checkboxHandler
                ? `<label class="attendance-checkbox">
                        <input type="checkbox" ${isAvailable ? 'checked' : ''} onchange="${checkboxHandler}">
                   </label>`
                : '';
            const assignmentNote = showAttendance && assignmentLabel
                ? `<span class="attendance-note">${assignmentLabel}</span>`
                : '';
            const moveControlsHtml = showMoveControls && groupId !== null
                ? `<div class="rider-move-controls">
                    <button class="rider-move-btn" onclick="moveRiderBetweenGroups(${groupId}, ${rider.id}, -1)" ${!canMoveUp ? 'disabled' : ''} title="Move to previous group (higher fitness)">‚ñ≤</button>
                    <button class="rider-move-btn" onclick="moveRiderBetweenGroups(${groupId}, ${rider.id}, 1)" ${!canMoveDown ? 'disabled' : ''} title="Move to next group (lower fitness)">‚ñº</button>
                   </div>`
                : '';
            
            // Show only the badge for the current sort option
            let badgeHtml = '';
            if (sortBy === 'pace') {
                badgeHtml = `<span class="badge badge-pace-${fitness}">Fitness ${fitness}</span>`;
            } else if (sortBy === 'skills') {
                const skills = Math.max(1, Math.min(4, parseInt(rider.skills || '2', 10)));
                badgeHtml = `<span class="badge badge-skills-${skills}">Bike Skills ${skills}</span>`;
            } else if (sortBy === 'grade') {
                badgeHtml = gradeLabel ? `<span class="badge badge-grade">${gradeLabel}</span>` : '';
            } else if (sortBy === 'gender') {
                badgeHtml = genderValue ? `<span class="badge badge-gender">${escapeHtml(genderValue)}</span>` : '';
            } else {
                // For name sort, show pace badge as default
                badgeHtml = `<span class="badge badge-pace-${fitness}">Fitness ${fitness}</span>`;
            }
            
            return `
                <div class="${classes.join(' ')}" ${dragAttributes}>
                    <div class="avatar-circle">
                        ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                    </div>
                    ${checkboxHtml}
                    <div class="card-body">
                        <strong>${safeName}</strong>
                        ${badgeHtml ? `<span class="badge-single">${badgeHtml}</span>` : ''}
                        ${assignmentNote}
                    </div>
                    ${moveControlsHtml}
                </div>
            `;
        }

        function renderCoachCardHtml(coach, sourceGroupId, sourceRole, options = {}) {
            const {
                draggable = true,
                showAttendance = false,
                isAvailable = true,
                assignmentLabel = '',
                compact = false,
                checkboxHandler = null,
                sortBy = 'pace'
            } = options;

            // Support both old 'level' and new 'coachingLicenseLevel' fields
            const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
            const level = escapeHtml(levelRaw);
            const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
            const fitness = escapeHtml(coach.fitness || '5');
            const name = coach.name || 'Coach';
            const safeName = escapeHtml(name);
            const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
            const photo = coach.photo ? escapeHtml(coach.photo) : '';
            const groupAttr = sourceGroupId != null ? `data-source-group-id="${sourceGroupId}"` : '';
            const roleAttr = sourceRole ? `data-source-role="${sourceRole}"` : '';
            const classes = ['coach-card'];
            if (showAttendance) classes.push('attendance-card');
            if (!isAvailable) classes.push('attendance-off');
            if (compact) classes.push('compact');
            // Add level-based class for styling
            if (levelRaw === 'N/A' || levelNum === 0) {
                classes.push('coach-level-na');
            } else if (levelNum === 1) classes.push('coach-level-1');
            else if (levelNum === 2) classes.push('coach-level-2');
            else if (levelNum === 3) classes.push('coach-level-3');
            const dragAttributes = (draggable && isAvailable)
                ? `draggable="true"
                     data-drag-type="coach"
                     data-coach-id="${coach.id}"
                     ${groupAttr}
                     ${roleAttr}
                     ondragstart="drag(event)"
                     ondragend="dragEnd(event)"`
                : `${groupAttr} ${roleAttr}`;
            const checkboxHtml = showAttendance
                ? `<label class="attendance-checkbox">
                        <input type="checkbox" ${isAvailable ? 'checked' : ''} onchange="${checkboxHandler || `toggleCoachAvailability(${coach.id})`}">
                   </label>`
                : '';
            const assignmentNote = showAttendance && assignmentLabel
                ? `<span class="attendance-note">${assignmentLabel}</span>`
                : '';

            // Show only the badge for the current sort option (or default to pace for non-compact, show both for compact non-sorted)
            let badgeHtml = '';
            if (compact) {
                if (sortBy === 'pace') {
                    badgeHtml = `<span class="badge badge-pace-${fitness}">Fitness ${fitness}</span>`;
                } else if (sortBy === 'level') {
                    const levelDisplay = levelRaw === 'N/A' ? 'N/A' : `Level ${level}`;
                    badgeHtml = `<span class="badge badge-level">${levelDisplay}</span>`;
                } else {
                    // For name sort, show pace badge as default
                    badgeHtml = `<span class="badge badge-pace-${fitness}">Fitness ${fitness}</span>`;
                }
            } else {
                // Non-compact mode: show both level and pace
                badgeHtml = `<div class="coach-meta">Level ${level} ¬∑ Fitness ${fitness}</div>`;
            }

            return `
                <div class="${classes.join(' ')}" ${dragAttributes}>
                    <div class="avatar-circle coach">
                        ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                    </div>
                    ${checkboxHtml}
                    <div class="card-body">
                        <strong>${safeName}</strong>
                        ${badgeHtml ? (compact ? `<span class="badge-single">${badgeHtml}</span>` : badgeHtml) : ''}
                        ${assignmentNote}
                    </div>
                </div>
            `;
        }

        function renderGroupCoachesInline(group, ride) {
            // Build list of coaches in order: Leader, Sweep, Roam, then additional Roam
            const coachesList = [];
            
            // Get all coaches with their roles
            if (group.coaches.leader) {
                const coach = getCoachById(group.coaches.leader);
                if (coach) coachesList.push({ coach, role: 'leader', roleLabel: 'Leader' });
            }
            if (group.coaches.sweep) {
                const coach = getCoachById(group.coaches.sweep);
                if (coach) coachesList.push({ coach, role: 'sweep', roleLabel: 'Sweep' });
            }
            if (group.coaches.roam) {
                const coach = getCoachById(group.coaches.roam);
                if (coach) coachesList.push({ coach, role: 'roam', roleLabel: 'Roam' });
            }
            // Add all extraRoam coaches as "Roam"
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(coachId => {
                    if (coachId) {
                        const coach = getCoachById(coachId);
                        if (coach) coachesList.push({ coach, role: 'extraRoam', roleLabel: 'Roam' });
                    }
                });
            }
            
            // Render coaches with Move buttons
            let html = '';
            coachesList.forEach(({ coach, role, roleLabel }, index) => {
                const isAvailable = ride.availableCoaches.includes(coach.id);
                const assignmentLabel = isAvailable ? '' : 'Unavailable';
                const coachCard = renderCoachCardHtml(coach, group.id, role, {
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel,
                    draggable: false,
                    compact: true,
                    sortBy: 'pace',
                    inlineRole: roleLabel
                });
                
                // Add the coach item with Move button
                html += `
                    <div class="coach-inline-item" 
                         data-coach-id="${coach.id}"
                         data-role="${role}"
                         data-group-id="${group.id}"
                         style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px; padding: 4px; border-radius: 4px; background: ${index % 2 === 0 ? '#f9f9f9' : '#fff'};">
                        <div style="flex: 1; min-width: 0; display: flex; align-items: center;">
                            ${coachCard}
                            <span class="coach-role-badge" style="margin-left: 8px; padding: 2px 8px; background: #e3f2fd; color: #1976d2; border-radius: 12px; font-size: 11px; font-weight: 500; white-space: nowrap;">${roleLabel}</span>
                        </div>
                        <button class="btn-small" onclick="showCoachMoveMenu(event, ${coach.id}, ${group.id}, ${ride.id})" style="margin-left: 8px; padding: 4px 8px; font-size: 12px;">Move</button>
                    </div>
                `;
            });
            
            return html;
        }
        
        function renderCoachSlotHtml(group, roleKey, label, ride) {
            let coachId = null;
            if (roleKey === 'extraRoam') {
                coachId = Array.isArray(group.coaches.extraRoam) ? group.coaches.extraRoam[0] : null;
            } else {
                coachId = group.coaches[roleKey];
            }

            const coach = coachId ? getCoachById(coachId) : null;
            const isAvailable = coach ? ride.availableCoaches.includes(coach.id) : false;
            const assignmentLabel = coach
                ? (isAvailable ? '' : 'Unavailable')
                : '';
            const content = coach
                ? renderCoachCardHtml(coach, group.id, roleKey, {
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel,
                    draggable: true,
                    compact: true,
                    sortBy: 'pace' // Coaches in groups always show pace (no sorting for coach slots)
                })
                : '<div class="coach-slot-empty">Drop coach here</div>';

            return `
                <div class="coach-role-slot ${coach ? '' : 'empty'}"
                     data-drop-type="coach"
                     data-group-id="${group.id}"
                     data-role="${roleKey}"
                     ondrop="drop(event)"
                     ondragover="allowDrop(event)"
                     ondragleave="dragLeave(event)"
                     style="border: none; border-style: none;">
                    <div class="coach-role-label">${label}</div>
                    ${content}
                </div>
            `;
        }

        function rebalanceGroupCoaches(ride, availableCoaches, debugLines) {
            let sortedCoaches = availableCoaches
                .slice()
                .sort((a, b) => {
                    const fitnessDiff = getCoachFitnessValue(b) - getCoachFitnessValue(a);
                    if (fitnessDiff !== 0) return fitnessDiff;
                    const levelDiff = (parseInt(b.level, 10) || 0) - (parseInt(a.level, 10) || 0);
                    if (levelDiff !== 0) return levelDiff;
                    return (b.name || '').localeCompare(a.name || '');
                });

            const groupsOrdered = ride.groups
                .map(group => ({
                    group,
                    fitness: getGroupFitnessScore(group),
                    size: group.riders.length
                }))
                .sort((a, b) => {
                    if (b.fitness !== a.fitness) return b.fitness - a.fitness;
                    return b.size - a.size;
                });

            // Preserve leaders that meet the requirement - don't clear them
            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const minLeaderLevelPriority = getParamPriority('minLeaderLevel');
            const useLeaderLevelConstraint = minLeaderLevelPriority < 999;
            const preservedLeaders = new Map(); // group -> leaderId
            
            ride.groups.forEach(group => {
                const currentLeader = getCoachById(group.coaches.leader);
                if (currentLeader) {
                    const leaderLevel = parseInt(currentLeader.level, 10) || 0;
                    if (leaderLevel >= minLeaderLevel) {
                        // Preserve this leader - it meets the requirement
                        preservedLeaders.set(group, currentLeader.id);
                    }
                }
                // Clear sweep, roam, and extraRoam (but preserve leader if it meets requirement)
                group.coaches.sweep = null;
                group.coaches.roam = null;
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                } else {
                    group.coaches.extraRoam = [];
                }
            });
            
            // Restore preserved leaders
            preservedLeaders.forEach((leaderId, group) => {
                group.coaches.leader = leaderId;
            });
            
            // Remove preserved leaders from available coaches list (they're already assigned)
            const preservedLeaderIds = new Set(Array.from(preservedLeaders.values()));
            sortedCoaches = sortedCoaches.filter(coach => !preservedLeaderIds.has(coach.id));

            const extraAssignments = [];

            const getCoachLevel = coach => {
                const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                if (levelRaw === 'N/A') return 0;
                return parseInt(levelRaw, 10) || 0;
            };
            const popCoach = () => sortedCoaches.length ? sortedCoaches.shift() : null;

            groupsOrdered.forEach(entry => {
                if (sortedCoaches.length === 0) return;

                const picks = [];
                while (picks.length < 3 && sortedCoaches.length > 0) {
                    picks.push(popCoach());
                }

                if (picks.length === 0) return;

                // Only enforce leader level constraint if it's enabled and has priority
                if (useLeaderLevelConstraint && !picks.some(coach => getCoachLevel(coach) >= minLeaderLevel)) {
                    const eligibleIdx = sortedCoaches.findIndex(coach => getCoachLevel(coach) >= minLeaderLevel);
                    if (eligibleIdx >= 0) {
                        picks.push(sortedCoaches.splice(eligibleIdx, 1)[0]);
                    } else {
                        debugLines.push(`‚ö†Ô∏è ${entry.group.label} does not have a Level ${minLeaderLevel}+ coach available; using best available coach as leader.`);
                    }
                }

                if (!entry.group.coaches.leader) {
                    picks.sort((a, b) => getCoachFitnessValue(b) - getCoachFitnessValue(a));

                    let leaderIndex = -1;
                    if (useLeaderLevelConstraint) {
                        leaderIndex = picks.findIndex(coach => getCoachLevel(coach) >= minLeaderLevel);
                    } else {
                        // If constraint not enabled, just use the best coach
                        leaderIndex = 0;
                    }
                    let leaderCoach;
                    if (leaderIndex === -1) {
                        leaderCoach = picks.shift();
                    } else {
                        leaderCoach = picks.splice(leaderIndex, 1)[0];
                    }
                    if (leaderCoach) {
                        entry.group.coaches.leader = leaderCoach.id;
                    }
                }

                if (!entry.group.coaches.sweep) {
                    const sweepCoach = picks.shift();
                    if (sweepCoach) {
                        entry.group.coaches.sweep = sweepCoach.id;
                    }
                }

                if (!entry.group.coaches.roam) {
                    const roamCoach = picks.shift();
                    if (roamCoach) {
                        entry.group.coaches.roam = roamCoach.id;
                    }
                }

                picks.forEach(coach => {
                    if (coach) {
                        sortedCoaches.unshift(coach);
                    }
                });
            });

            // Helper function to count coaches in a group
            const countCoachesInGroup = (group) => {
                let count = 0;
                if (group.coaches.leader) count++;
                if (group.coaches.sweep) count++;
                if (group.coaches.roam) count++;
                if (Array.isArray(group.coaches.extraRoam)) {
                    count += group.coaches.extraRoam.filter(Boolean).length;
                }
                return count;
            };

            // Fair distribution: Only assign 4th coaches after all groups have 3 coaches
            // Only assign 3rd coaches after all groups have at least 2 coaches
            while (sortedCoaches.length > 0) {
                // Check if any group has fewer than 2 coaches
                const groupsWithOneCoach = ride.groups.filter(g => countCoachesInGroup(g) === 1);
                if (groupsWithOneCoach.length > 0) {
                    // Assign to groups with only 1 coach first
                    const targetGroup = groupsWithOneCoach[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!targetGroup.coaches.sweep) {
                            targetGroup.coaches.sweep = coach.id;
                        } else if (!targetGroup.coaches.roam) {
                            targetGroup.coaches.roam = coach.id;
                        }
                    }
                    continue;
                }
                
                // Check if any group has fewer than 3 coaches
                const groupsWithTwoCoaches = ride.groups.filter(g => countCoachesInGroup(g) === 2);
                if (groupsWithTwoCoaches.length > 0) {
                    // Assign to groups with only 2 coaches
                    const targetGroup = groupsWithTwoCoaches[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!targetGroup.coaches.roam) {
                            targetGroup.coaches.roam = coach.id;
                        } else {
                            if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                targetGroup.coaches.extraRoam = [];
                            }
                            targetGroup.coaches.extraRoam.push(coach.id);
                            extraAssignments.push({ coachId: coach.id, groupId: targetGroup.id });
                        }
                    }
                    continue;
                }
                
                // All groups have at least 3 coaches, now assign 4th coaches
                const groupsWithThreeCoaches = ride.groups.filter(g => countCoachesInGroup(g) === 3);
                if (groupsWithThreeCoaches.length > 0) {
                    const targetGroup = groupsWithThreeCoaches[0];
                    const coach = popCoach();
                    if (coach) {
                        if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                            targetGroup.coaches.extraRoam = [];
                        }
                        targetGroup.coaches.extraRoam.push(coach.id);
                        extraAssignments.push({ coachId: coach.id, groupId: targetGroup.id });
                    }
                    continue;
                }
                
                // All groups have 4+ coaches, break
                break;
            }
            
            const allRolesFilled = ride.groups.every(group =>
                group.coaches.leader && group.coaches.sweep && group.coaches.roam
            );

            return {
                extrasAssigned: extraAssignments.length,
                extraAssignments,
                allGroupsStaffed: allRolesFilled
            };
        }

        function renderEmptyGroupCard() {
            return `
                <div class="coach-group empty-group">
                    <div class="empty-message">
                        No groups yet. Use Autofill Assignments or Add Group to begin assigning riders and coaches.
                    </div>
                </div>
            `;
        }

        // Permission check functions (always return true in localStorage mode)
        function canAdjustAssignments() {
            return true; // No authentication in localStorage mode
        }

        function assignCoachToGroup(ride, coachId, groupId, role) {
            if (!canAdjustAssignments()) {
                alert('You do not have permission to adjust assignments');
                return false;
            }

            const group = findGroupById(ride, groupId);
            if (!group) return false;

            // Find what role the dragged coach currently has (if any)
            let draggedCoachCurrentRole = null;
            let draggedCoachCurrentGroupId = null;
            
            ride.groups.forEach(g => {
                if (g.id === groupId) {
                    // Check if coach is already in this group
                    if (g.coaches.leader === coachId) {
                        draggedCoachCurrentRole = 'leader';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.sweep === coachId) {
                        draggedCoachCurrentRole = 'sweep';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.roam === coachId) {
                        draggedCoachCurrentRole = 'roam';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (Array.isArray(g.coaches.extraRoam) && g.coaches.extraRoam.includes(coachId)) {
                        draggedCoachCurrentRole = 'extraRoam';
                        draggedCoachCurrentGroupId = g.id;
                    }
                } else {
                    // Check other groups
                    if (g.coaches.leader === coachId) {
                        draggedCoachCurrentRole = 'leader';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.sweep === coachId) {
                        draggedCoachCurrentRole = 'sweep';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (g.coaches.roam === coachId) {
                        draggedCoachCurrentRole = 'roam';
                        draggedCoachCurrentGroupId = g.id;
                    } else if (Array.isArray(g.coaches.extraRoam) && g.coaches.extraRoam.includes(coachId)) {
                        draggedCoachCurrentRole = 'extraRoam';
                        draggedCoachCurrentGroupId = g.id;
                    }
                }
            });

            // Check if target role is already occupied
            let existingCoachId = null;
            if (role === 'extraRoam') {
                if (Array.isArray(group.coaches.extraRoam) && group.coaches.extraRoam.length > 0) {
                    existingCoachId = group.coaches.extraRoam[0];
                }
            } else {
                existingCoachId = group.coaches[role] || null;
            }

            // If target role is occupied, swap the coaches (works within same group and between groups)
            if (existingCoachId && existingCoachId !== coachId) {
                // Find the source group (where the dragged coach currently is)
                const sourceGroup = draggedCoachCurrentGroupId 
                    ? findGroupById(ride, draggedCoachCurrentGroupId) 
                    : null;
                
                // First, remove both coaches from their current assignments
                removeCoachFromGroups(ride, coachId);
                removeCoachFromGroups(ride, existingCoachId);
                
                // Assign dragged coach to target role in target group
                if (role === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam[0] = coachId;
                    group.coaches.extraRoam = group.coaches.extraRoam.slice(0, 1);
                } else {
                    group.coaches[role] = coachId;
                }
                
                // If dragged coach had a previous role, assign existing coach to that role
                if (draggedCoachCurrentRole && sourceGroup) {
                    if (draggedCoachCurrentRole === 'extraRoam') {
                        if (!Array.isArray(sourceGroup.coaches.extraRoam)) {
                            sourceGroup.coaches.extraRoam = [];
                        }
                        sourceGroup.coaches.extraRoam[0] = existingCoachId;
                        sourceGroup.coaches.extraRoam = sourceGroup.coaches.extraRoam.slice(0, 1);
                    } else {
                        sourceGroup.coaches[draggedCoachCurrentRole] = existingCoachId;
                    }
                }
                // If dragged coach had no previous role, existing coach just becomes unassigned
                // (already handled by removeCoachFromGroups above)
            } else {
                // Target role is empty, just assign normally
                removeCoachFromGroups(ride, coachId);
                
                if (role === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam[0] = coachId;
                    group.coaches.extraRoam = group.coaches.extraRoam.slice(0, 1);
                } else {
                    group.coaches[role] = coachId;
                }
            }
            
            // Save ride immediately after assignment change
            saveRideToDB(ride);
            return true;
        }

        function getCoachById(id) {
            return data.coaches.find(coach => coach.id === id) || null;
        }

        function getRiderById(id) {
            return data.riders.find(rider => rider.id === id) || null;
        }

        function getCoachFitnessValue(coach) {
            return parseInt(coach?.fitness ?? coach?.level ?? '5', 10) || 5;
        }

        function getGroupFitnessScore(group) {
            if (group.fitnessTag != null) {
                const value = parseInt(group.fitnessTag, 10);
                if (Number.isFinite(value)) return value;
            }

            const riderFitnessValues = group.riders
                .map(id => getRiderById(id))
                .filter(Boolean)
                .map(rider => parseInt(rider.fitness || '5', 10))
                .filter(Number.isFinite);

            if (riderFitnessValues.length === 0) {
                return 5;
            }

            const sum = riderFitnessValues.reduce((acc, value) => acc + value, 0);
            return Math.round(sum / riderFitnessValues.length);
        }

        function countGroupCoaches(group) {
            const baseCount = ['leader', 'sweep', 'roam'].reduce((count, role) => {
                return count + (group.coaches[role] ? 1 : 0);
            }, 0);
            const extra = Array.isArray(group.coaches.extraRoam) ? group.coaches.extraRoam.filter(Boolean).length : 0;
            return baseCount + extra;
        }

        function groupCapacity(group) {
            const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
            return countGroupCoaches(group) * ridersPerCoach;
        }

        function findGroupById(ride, groupId) {
            return ride.groups.find(group => group.id === groupId) || null;
        }

        function removeRiderFromGroups(ride, riderId) {
            ride.groups.forEach(group => {
                group.riders = group.riders.filter(id => id !== riderId);
                if (group.riders.length === 0) {
                    group.fitnessTag = null;
                }
            });
        }

        function removeCoachFromGroups(ride, coachId) {
            ride.groups.forEach(group => {
                ['leader', 'sweep', 'roam'].forEach(role => {
                    if (group.coaches[role] === coachId) {
                        group.coaches[role] = null;
                    }
                });
                if (Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = group.coaches.extraRoam.filter(id => id !== coachId);
                }

                const capacity = groupCapacity(group);
                if (group.riders.length > capacity) {
                    group.riders = group.riders.slice(0, capacity);
                }
            });
        }

        function getCoachAssignmentMap(ride) {
            const map = {};
            ride.groups.forEach(group => {
                ['leader', 'sweep', 'roam'].forEach(role => {
                    const coachId = group.coaches[role];
                    if (coachId) {
                        map[coachId] = {
                            groupId: group.id,
                            role
                        };
                    }
                });
                if (Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam.forEach((coachId, index) => {
                        if (coachId) {
                            map[coachId] = {
                                groupId: group.id,
                                role: index === 0 ? 'extraRoam' : `extraRoam${index + 1}`
                            };
                        }
                    });
                }
            });
            return map;
        }

        function renumberGroups(ride, sequential = false) {
            if (sequential) {
                // Renumber all groups sequentially (1, 2, 3, 4...) without gaps
                ride.groups.forEach((group, index) => {
                    group.label = `Group ${index + 1}`;
                });
            } else {
                // Only assign labels to groups that don't have them
                // Preserve existing labels to maintain persistence
                const existingLabels = new Set(ride.groups.map(g => g.label).filter(Boolean));
                let nextNumber = 1;
                
                ride.groups.forEach((group) => {
                    if (!group.label || group.label.trim() === '') {
                        // Find next available group number
                        while (existingLabels.has(`Group ${nextNumber}`)) {
                            nextNumber++;
                        }
                        group.label = `Group ${nextNumber}`;
                        existingLabels.add(group.label);
                        nextNumber++;
                    }
                });
            }
        }

        function normalizeRideStructure(ride) {
            const updated = Object.assign({}, ride);
            let changed = false;

            if (!Array.isArray(updated.availableCoaches)) {
                updated.availableCoaches = [];
                changed = true;
            }

            if (!Array.isArray(updated.availableRiders)) {
                updated.availableRiders = [];
                changed = true;
            }

            // Only validate IDs if rosters are loaded - preserve assignments even if rosters aren't loaded yet
            const coachesLoaded = Array.isArray(data.coaches) && data.coaches.length > 0;
            const ridersLoaded = Array.isArray(data.riders) && data.riders.length > 0;
            
            const validCoachIds = coachesLoaded ? new Set(data.coaches.map(coach => coach.id)) : new Set();
            const validRiderIds = ridersLoaded ? new Set(data.riders.map(rider => rider.id)) : new Set();

            // If rosters aren't loaded yet, preserve all IDs (they might be valid, just not loaded)
            // Only filter if rosters are loaded
            const uniqueCoaches = new Set();
            if (coachesLoaded) {
                updated.availableCoaches = updated.availableCoaches
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && validCoachIds.has(id) && !uniqueCoaches.has(id) && uniqueCoaches.add(id));
            } else {
                // Preserve IDs even if rosters aren't loaded - just deduplicate
                updated.availableCoaches = updated.availableCoaches
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && !uniqueCoaches.has(id) && uniqueCoaches.add(id));
            }

            const uniqueRiders = new Set();
            if (ridersLoaded) {
                updated.availableRiders = updated.availableRiders
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && validRiderIds.has(id) && !uniqueRiders.has(id) && uniqueRiders.add(id));
            } else {
                // Preserve IDs even if rosters aren't loaded - just deduplicate
                updated.availableRiders = updated.availableRiders
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id) && !uniqueRiders.has(id) && uniqueRiders.add(id));
            }

            if (!Array.isArray(updated.groups)) {
                updated.groups = [];
                changed = true;
            }

            if (updated.assignments && typeof updated.assignments === 'object') {
                let index = updated.groups.length + 1;
                Object.entries(updated.assignments).forEach(([coachIdStr, riderIds]) => {
                    const coachId = parseInt(coachIdStr, 10);
                    if (!Number.isFinite(coachId)) {
                        return;
                    }

                    const group = createGroup(`Group ${index++}`);
                    const coach = getCoachById(coachId);

                    if (coach) {
                        const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                        const level = levelRaw === 'N/A' ? 0 : parseInt(levelRaw, 10);
                        if (Number.isFinite(level) && level >= 2) {
                            group.coaches.leader = coachId;
                        } else {
                            group.coaches.sweep = coachId;
                        }

                        if (!updated.availableCoaches.includes(coachId)) {
                            updated.availableCoaches.push(coachId);
                        }
                    }

                    if (Array.isArray(riderIds)) {
                        // Preserve rider IDs even if rosters aren't loaded yet
                        if (ridersLoaded) {
                            group.riders = riderIds
                                .map(id => parseInt(id, 10))
                                .filter(id => Number.isFinite(id) && validRiderIds.has(id));
                        } else {
                            // Preserve all valid numeric IDs - rosters might not be loaded yet
                            group.riders = riderIds
                                .map(id => parseInt(id, 10))
                                .filter(id => Number.isFinite(id));
                        }

                        group.riders.forEach(riderId => {
                            if (!updated.availableRiders.includes(riderId)) {
                                updated.availableRiders.push(riderId);
                            }
                        });
                    }

                    updated.groups.push(group);
                });

                delete updated.assignments;
                changed = true;
            }

            updated.groups = updated.groups.map((group, idx) => {
                // Preserve coach IDs even if rosters aren't loaded yet
                const extraRoam = group.coaches && Array.isArray(group.coaches.extraRoam)
                    ? (coachesLoaded
                        ? group.coaches.extraRoam
                            .map(id => parseInt(id, 10))
                            .filter(id => Number.isFinite(id) && validCoachIds.has(id))
                        : group.coaches.extraRoam
                            .map(id => parseInt(id, 10))
                            .filter(id => Number.isFinite(id)))
                    : [];

                const legacyFitnessTag = group.fitnessTag || group.abilityTag || null;
                const normalized = {
                    id: typeof group.id === 'number' ? group.id : generateId(),
                    label: group.label || `Group ${idx + 1}`,
                    coaches: {
                        leader: group.coaches ? normalizeCoachId(group.coaches.leader) : null,
                        sweep: group.coaches ? normalizeCoachId(group.coaches.sweep) : null,
                        roam: group.coaches ? normalizeCoachId(group.coaches.roam) : null,
                        extraRoam: extraRoam
                    },
                    riders: Array.isArray(group.riders)
                        ? (ridersLoaded
                            ? Array.from(new Set(group.riders.map(id => parseInt(id, 10)).filter(id => Number.isFinite(id) && validRiderIds.has(id))))
                            : Array.from(new Set(group.riders.map(id => parseInt(id, 10)).filter(id => Number.isFinite(id)))))
                        : [],
                    fitnessTag: legacyFitnessTag,
                    routeId: group.routeId !== undefined ? group.routeId : null
                };

                if (!normalized.coaches.leader && normalized.coaches.sweep) {
                    const sweepCoach = getCoachById(normalized.coaches.sweep);
                    const level = sweepCoach ? parseInt(sweepCoach.level, 10) : 0;
                    if (Number.isFinite(level) && level >= 2) {
                        normalized.coaches.leader = normalized.coaches.sweep;
                        normalized.coaches.sweep = null;
                    }
                }

                if (normalized.coaches.leader && !updated.availableCoaches.includes(normalized.coaches.leader)) {
                    updated.availableCoaches.push(normalized.coaches.leader);
                }
                ['sweep', 'roam'].forEach(role => {
                    const coachId = normalized.coaches[role];
                    if (coachId && !updated.availableCoaches.includes(coachId)) {
                        updated.availableCoaches.push(coachId);
                    }
                });
                normalized.coaches.extraRoam.forEach(coachId => {
                    if (coachId && !updated.availableCoaches.includes(coachId)) {
                        updated.availableCoaches.push(coachId);
                    }
                });

                normalized.riders.forEach(riderId => {
                    if (!updated.availableRiders.includes(riderId)) {
                        updated.availableRiders.push(riderId);
                    }
                });

                return normalized;
            });

            updated.groups.forEach((group, index) => {
                group.label = group.label || `Group ${index + 1}`;
                // Ensure routeId exists
                if (group.routeId === undefined) {
                    group.routeId = null;
                    changed = true;
                }
            });

            updated.availableCoaches = Array.from(new Set(updated.availableCoaches));
            updated.availableRiders = Array.from(new Set(updated.availableRiders));

            return { ride: updated, changed };
        }

        // Authentication handlers
        function showAuthError(message) {
            const errorDiv = document.getElementById('auth-error');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        function hideAuthError() {
            const errorDiv = document.getElementById('auth-error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        function showLogin() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('signup-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'none';
            hideAuthError();
        }

        function showSignup() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('signup-form').style.display = 'block';
            document.getElementById('password-reset-form').style.display = 'none';
            hideAuthError();
        }

        function showPasswordReset() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('signup-form').style.display = 'none';
            document.getElementById('password-reset-form').style.display = 'block';
            hideAuthError();
        }

        async function handleLogin() {
            hideAuthError();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            if (!email || !password) {
                showAuthError('Please enter both email and password');
                return;
            }

            try {
                await signInWithEmail(email, password);
                // Auth state change will handle UI update
            } catch (error) {
                // Check if error is about email not verified
                if (error.message && error.message.includes('Email not confirmed')) {
                    showAuthError('Please verify your email first. Check your inbox for the verification link.');
                    document.getElementById('resend-verification').style.display = 'block';
                } else {
                    showAuthError(error.message || 'Login failed. Please check your credentials.');
                }
            }
        }

        async function handleSignup() {
            hideAuthError();
            const name = document.getElementById('signup-name').value;
            const email = document.getElementById('signup-email').value;
            const password = document.getElementById('signup-password').value;

            if (!name || !email || !password) {
                showAuthError('Please fill in all fields');
                return;
            }

            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }

            try {
                await signUpWithEmail(email, password, name);
                showAuthError('Account created! Please check your email to verify your account before signing in.');
            } catch (error) {
                showAuthError(error.message || 'Sign up failed. Please try again.');
            }
        }

        async function handleGoogleLogin() {
            hideAuthError();
            try {
                await signInWithGoogle();
                // OAuth will redirect, so no need to handle success here
            } catch (error) {
                showAuthError(error.message || 'Google login failed. Please try again.');
            }
        }

        async function handleAppleLogin() {
            hideAuthError();
            try {
                await signInWithApple();
                // OAuth will redirect, so no need to handle success here
            } catch (error) {
                showAuthError(error.message || 'Apple login failed. Please try again.');
            }
        }

        async function handlePasswordReset() {
            hideAuthError();
            const email = document.getElementById('reset-email').value;

            if (!email) {
                showAuthError('Please enter your email address');
                return;
            }

            try {
                await resetPassword(email);
                showAuthError('Password reset email sent! Check your inbox.');
            } catch (error) {
                showAuthError(error.message || 'Failed to send reset email. Please try again.');
            }
        }

        // Dummy logout function (for UI purposes only - no actual logout needed)
        function handleDummyLogout() {
            // Just show a message that logout isn't needed in localStorage mode
            if (confirm('You are using localStorage mode - no login required. This button is for UI layout only. Continue?')) {
                // Could optionally refresh the page or do nothing
                console.log('Dummy logout clicked - no action needed');
            }
        }

        // Dummy logout function (for UI purposes only - no actual logout needed)
        function handleDummyLogout() {
            // Just show a message that logout isn't needed in localStorage mode
            if (confirm('You are using localStorage mode - no login required. This button is for UI layout only. Continue?')) {
                // Could optionally refresh the page or do nothing
                console.log('Dummy logout clicked - no action needed');
            }
        }

        // Override auth state change handler
        async function handleAuthStateChange(isAuthenticated) {
            const authOverlay = document.getElementById('auth-overlay');
            const userMenu = document.getElementById('user-menu');
            const mainContainer = document.querySelector('.container');

            if (isAuthenticated) {
                // Hide auth overlay, show main app
                if (authOverlay) authOverlay.classList.add('hidden');
                if (mainContainer) mainContainer.style.display = 'block';
                
                // Show user menu
                if (userMenu) {
                    const currentUser = getCurrentUser();
                    const currentRole = getCurrentUserRole();
                    
                    const userNameEl = document.getElementById('user-name');
                    const userRoleEl = document.getElementById('user-role');
                    
                    if (userNameEl && currentUser) {
                        userNameEl.textContent = currentUser.user_metadata?.name || currentUser.email || 'User';
                    }
                    if (userRoleEl && currentRole) {
                        userRoleEl.textContent = currentRole.replace('_', ' ');
                    }
                    
                    userMenu.style.display = 'flex';
                }
                
                // Apply role-based UI restrictions
                applyRoleBasedAccess();
                
                // Wait for role to be fully loaded, then load data
                // Retry a few times if role isn't loaded yet
                let retries = 0;
                const maxRetries = 10; // Increased retries for role loading
                const checkRoleAndLoad = async () => {
                    const role = getCurrentUserRole();
                    // If role is loaded (even if null), or we've exhausted retries, load data
                    // For coaches, we want to make sure role is definitely loaded
                    if (role !== null || retries >= maxRetries) {
                        // Role is loaded (or null is expected), now load data
                        // Add a small delay to ensure RLS policies have the role
                        await new Promise(resolve => setTimeout(resolve, 300));
                        await loadApplicationData();
                    } else {
                        // Wait a bit and retry
                        retries++;
                        setTimeout(checkRoleAndLoad, 300); // Increased delay between retries
                    }
                };
                
                // Start checking after a short delay to let role load
                setTimeout(checkRoleAndLoad, 200);
            } else {
                // Show auth overlay, hide main app
                if (authOverlay) authOverlay.classList.remove('hidden');
                if (mainContainer) mainContainer.style.display = 'none';
                if (userMenu) userMenu.style.display = 'none';
            }
        }

        // Apply role-based access control to UI
        function applyRoleBasedAccess() {
            // Hide/show tabs based on role
            const tabs = {
                'settings': document.querySelector('.tab[onclick*="settings"]'),
                'roster': document.querySelector('.tab[onclick*="roster"]'),
                'rides': document.querySelector('.tab[onclick*="rides"]'),
                'routes': document.querySelector('.tab[onclick*="routes"]')
            };

            const tabContents = {
                'settings': document.getElementById('settings-tab'),
                'roster': document.getElementById('roster-tab'),
                'rides': document.getElementById('rides-tab'),
                'routes': document.getElementById('routes-tab')
            };

            // Season Setup button is now in user menu - no need to show/hide header-actions

            if (tabs.routes) {
                tabs.routes.style.display = canViewRoutes() ? 'block' : 'none';
            }

            // Update mobile menu
            const mobileMenuItems = document.querySelectorAll('.mobile-menu-item');
            mobileMenuItems.forEach(item => {
                const text = item.textContent.trim();
                if (text.includes('Routes') && !canViewRoutes()) {
                    item.style.display = 'none';
                } else if (text.includes('Season') && !canViewSeasonSetup()) {
                    item.style.display = 'none';
                } else {
                    item.style.display = 'block';
                }
            });
        }

        // Load application data from localStorage
        function loadApplicationData() {
            // Load from localStorage
            loadData();
            
            // Upgrade/normalize data
            upgradeData();
            
            // Re-normalize rides after rosters are loaded to validate assignments
            if (Array.isArray(data.rides)) {
                data.rides = data.rides.map(ride => {
                    const { ride: normalizedRide, changed: rideChanged } = normalizeRideStructure(ride);
                    if (rideChanged) {
                        saveData(); // Save normalized ride
                    }
                    return normalizedRide;
                });
            }
            
            // Render everything
            renderRiders();
            renderCoaches();
            renderRides();
            renderRoutes();
        }

        // Restore sample data to database
        function restoreSampleData() {
            if (!confirm('This will add sample riders and coaches to your data. Continue?')) {
                return;
            }

            // Check if data already exists
            const existingRiders = Array.isArray(data.riders) ? data.riders : [];
            const existingCoaches = Array.isArray(data.coaches) ? data.coaches : [];

            if (existingRiders.length > 0 || existingCoaches.length > 0) {
                if (!confirm('You already have ' + existingRiders.length + ' riders and ' + existingCoaches.length + ' coaches. This will ADD sample data (not replace). Continue?')) {
                    return;
                }
            }

            // Generate sample data
            const sampleCoaches = buildDefaultCoaches();
            const sampleRiders = buildDefaultRiders();

            // Add coaches to localStorage
            let coachesAdded = 0;
            for (const coach of sampleCoaches) {
                // Normalize phone number to 10 digits
                let phone = (coach.phone || '').replace(/\D/g, '');
                if (phone.length !== 10) {
                    phone = `415555${(100 + coachesAdded).toString().padStart(4, '0')}`;
                }
                
                const coachData = {
                    id: Date.now() + Math.floor(Math.random() * 1000) + coachesAdded,
                    name: coach.name,
                    phone: phone,
                    level: coach.level || '1',
                    fitness: coach.fitness || '5',
                    photo: coach.photo || null,
                    notes: coach.notes || ''
                };
                
                if (!Array.isArray(data.coaches)) data.coaches = [];
                data.coaches.push(coachData);
                coachesAdded++;
            }

            // Add riders to localStorage
            let ridersAdded = 0;
            for (const rider of sampleRiders) {
                // Normalize phone number to 10 digits
                let phone = (rider.phone || '').replace(/\D/g, '');
                if (phone.length !== 10) {
                    phone = `415556${(200 + ridersAdded).toString().padStart(4, '0')}`;
                }
                
                const riderData = {
                    id: Date.now() + Math.floor(Math.random() * 1000) + 10000 + ridersAdded,
                    name: rider.name,
                    phone: phone,
                    grade: rider.grade || '9th',
                    gender: rider.gender || null,
                    racingGroup: rider.racingGroup || 'Freshman',
                    fitness: rider.fitness || '5',
                    photo: rider.photo || null,
                    notes: rider.notes || ''
                };
                
                if (!Array.isArray(data.riders)) data.riders = [];
                data.riders.push(riderData);
                ridersAdded++;
            }

            // Save to localStorage
            saveData();

            alert(`Sample data restored!\n\nAdded ${coachesAdded} coaches and ${ridersAdded} riders.`);

            // Reload and render
            loadApplicationData();
        }

        // Check if database is empty and offer to restore sample data
        async function checkAndOfferSampleData() {
            if (!isCoach()) return; // Only show to coaches

            try {
                const riders = await getAllRiders();
                const coaches = await getAllCoaches();

                if (riders.length === 0 && coaches.length === 0) {
                    // Database is empty - offer to restore
                    const shouldRestore = confirm(
                        'Your database is empty. Would you like to load sample riders and coaches?\n\n' +
                        'This will add 20 sample coaches and 50 sample riders to help you get started.'
                    );

                    if (shouldRestore) {
                        await restoreSampleData();
                    }
                }
            } catch (error) {
                console.error('Error checking for sample data:', error);
                // Don't show alert - just log it
            }
        }

        // Initialize
        async function init() {
            // Load data from localStorage
            loadData();
            
            // Upgrade/normalize data structure
            upgradeData();
            
            // Load season settings (needed for settings tab to display correctly on refresh)
            loadSeasonSettings();
            
            // Render everything
            renderRiders();
            renderCoaches();
            renderRides();
            renderRoutes();
            
            // Show main app (no auth required)
            const authOverlay = document.getElementById('auth-overlay');
            const mainContainer = document.querySelector('.container');
            if (authOverlay) authOverlay.classList.add('hidden');
            if (mainContainer) mainContainer.style.display = 'block';
            
            // Show user menu with dummy info (for layout purposes)
            const userMenu = document.getElementById('user-menu');
            if (userMenu) userMenu.style.display = 'flex';
            
            // Set dummy user info
            const userNameEl = document.getElementById('user-name');
            const userRoleEl = document.getElementById('user-role');
            if (userNameEl) userNameEl.textContent = 'Adam Phillips';
            if (userRoleEl) userRoleEl.textContent = 'Coach';
            
            // Initialize mobile menu with current active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                const tabId = activeTab.id;
                if (tabId) {
                    const tabName = tabId.replace('-tab', '');
                    updateMobileMenu(tabName);
                }
            }
        }
        
        let lastVisibilityCheck = Date.now();
        let isReloading = false;
        
        // Flush any pending ride saves before reloading
        async function flushPendingSaves() {
            // Clear any pending debounced save
            if (window.rideSaveTimeout) {
                clearTimeout(window.rideSaveTimeout);
                window.rideSaveTimeout = null;
            }
            
            // Save current ride if it exists and has changes
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    try {
                        await saveRideToDB(ride);
                    } catch (error) {
                        console.error('Error flushing ride save:', error);
                    }
                }
            }
        }
        
        function handleVisibilityChange() {
            // Only reload if page becomes visible and it's been at least 5 seconds since last check
            if (!document.hidden && !isReloading) {
                const now = Date.now();
                // Only reload if it's been at least 5 seconds since last check (avoid rapid reloads)
                if (now - lastVisibilityCheck > 5000) {
                    lastVisibilityCheck = now;
                    loadApplicationData();
                }
            }
        }
        
        function handleWindowFocus() {
            // Reload data when window regains focus (but not if we just did a visibility check)
            if (!isReloading) {
                const now = Date.now();
                // Only reload if it's been at least 2 seconds since last check
                if (now - lastVisibilityCheck > 2000) {
                    lastVisibilityCheck = now;
                    loadApplicationData();
                }
            }
        }

        function escapeHtml(value) {
            if (value === undefined || value === null) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function mapAbilityToFitness(ability) {
            const numeric = parseInt(ability, 10);
            if (Number.isFinite(numeric)) {
                return Math.min(10, Math.max(1, numeric * 2));
            }
            return 5;
        }

        function convertRideLevelToFitness(level) {
            if (!level) return 5;
            const normalized = String(level).toLowerCase();
            const mapping = {
                'barely hanging on': 2,
                'ok for roam or sweep': 4,
                'ok to lead lower/middle groups': 7,
                'these kids are slow': 9
            };
            return mapping[normalized] || 5;
        }

        const GRADE_MAP = {
            freshman: '9th',
            sophomore: '10th',
            junior: '11th',
            senior: '12th',
            ninth: '9th',
            tenth: '10th',
            eleventh: '11th',
            twelfth: '12th',
            '9': '9th',
            '9th': '9th',
            '10': '10th',
            '10th': '10th',
            '11': '11th',
            '11th': '11th',
            '12': '12th',
            '12th': '12th'
        };

        function normalizeGradeValue(value) {
            if (!value) return '9th';
            const key = value.toString().trim().toLowerCase();
            return GRADE_MAP[key] || value.toString();
        }

        function formatGradeLabel(grade) {
            return normalizeGradeValue(grade);
        }

        function upgradeData() {
            let changed = false;

            // Ensure arrays exist - preserve existing data from Supabase
            if (!Array.isArray(data.coaches)) {
                data.coaches = [];
            }
            if (!Array.isArray(data.riders)) {
                data.riders = [];
            }
            
            // Initialize auto-assignment settings if missing
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                data.autoAssignSettings = {
                    parameters: [
                        { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 1, enabled: true, requirement: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' },
                        { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 2, enabled: true, requirement: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                        { id: 'preferredGroupSize', name: 'Preferred Min/Max Total Group Size', valueMin: 4, valueMax: 10, priority: 3, enabled: true, requirement: false, type: 'range', min: 1, max: 30, description: 'Preferred group size range (may be exceeded to meet requirements)' },
                        { id: 'organizeByPace', name: 'Organize Groups by Pace', value: 2, priority: 4, enabled: true, requirement: false, type: 'number', min: 0, max: 10, description: 'Preferred maximum pace range within groups' }
                    ]
                };
                changed = true;
            } else {
                // Migrate old parameters to new structure
                const oldParams = data.autoAssignSettings.parameters;
                const newParams = [];
                
                // Check if migration needed (old structure doesn't have requirement field)
                const needsMigration = !oldParams.some(p => p.hasOwnProperty('requirement'));
                
                if (needsMigration) {
                    // Find ridersPerCoach
                    const ridersPerCoach = oldParams.find(p => p.id === 'ridersPerCoach') || { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, enabled: true };
                    newParams.push({ ...ridersPerCoach, priority: 1, requirement: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' });
                    
                    // Find minLeaderLevel
                    const minLeaderLevel = oldParams.find(p => p.id === 'minLeaderLevel') || { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, enabled: true };
                    newParams.push({ ...minLeaderLevel, priority: 2, requirement: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' });
                    
                    // Combine min/max/preferred into single range parameter
                    const minGroupSize = oldParams.find(p => p.id === 'minGroupSize')?.value || 4;
                    const maxGroupSize = oldParams.find(p => p.id === 'maxGroupSize')?.value || 10;
                    newParams.push({ 
                        id: 'preferredGroupSize', 
                        name: 'Preferred Min/Max Total Group Size', 
                        valueMin: minGroupSize, 
                        valueMax: maxGroupSize, 
                        priority: 3, 
                        enabled: true, 
                        requirement: false, 
                        type: 'range', 
                        min: 1, 
                        max: 30, 
                        description: 'Preferred group size range (may be exceeded to meet requirements)' 
                    });
                    
                    // Convert maxFitnessSpread to organizeByPace
                    const maxFitnessSpread = oldParams.find(p => p.id === 'maxFitnessSpread') || { id: 'maxFitnessSpread', value: 2, enabled: true };
                    newParams.push({ 
                        id: 'organizeByPace', 
                        name: 'Organize Groups by Pace', 
                        value: maxFitnessSpread.value || 2, 
                        priority: 4, 
                        enabled: maxFitnessSpread.enabled !== false, 
                        requirement: false, 
                        type: 'number', 
                        min: 0, 
                        max: 10, 
                        description: 'Preferred maximum pace range within groups' 
                    });
                    
                    data.autoAssignSettings.parameters = newParams;
                    changed = true;
                }
            }

            data.coaches = data.coaches.map((coach, index) => {
                // Normalize phone number to 10 digits only
                let normalizedPhone = (coach.phone || '').replace(/\D/g, ''); // Remove all non-digits
                if (normalizedPhone.length !== 10) {
                    // If not 10 digits, generate a valid one based on index
                    normalizedPhone = `415555${(100 + index).toString().padStart(4, '0')}`;
                    changed = true;
                }
                
                // Support both old 'level' and new 'coachingLicenseLevel' fields
                const coachingLicenseLevel = coach.coachingLicenseLevel || coach.level || '1';
                
                // Preserve ALL existing fields, then override only the ones that need normalization
                const upgraded = {
                    ...coach, // Preserve all existing fields first
                    id: coach.id || Date.now(),
                    name: coach.name || '',
                    phone: normalizedPhone,
                    coachingLicenseLevel: coachingLicenseLevel,
                    level: coachingLicenseLevel, // Keep for backward compatibility
                    fitness: coach.fitness ? String(coach.fitness) : (coach.rideLevel ? String(convertRideLevelToFitness(coach.rideLevel)) : '5'),
                    photo: coach.photo || '',
                    notes: coach.notes || '',
                    // Ensure these fields exist (but don't overwrite if already present)
                    email: coach.email || '',
                    gender: coach.gender || '',
                    registered: coach.registered || '',
                    paid: coach.paid || '',
                    backgroundCheck: coach.backgroundCheck || '',
                    workPhone: coach.workPhone || '',
                    homePhone: coach.homePhone || ''
                };
                // Check if normalization actually changed anything
                // Since we use spread operator, all fields are preserved, so we only check normalized fields
                const originalPhone = (coach.phone || '').replace(/\D/g, '');
                const originalLevel = coach.coachingLicenseLevel || coach.level || '1';
                const originalFitness = coach.fitness ? String(coach.fitness) : (coach.rideLevel ? String(convertRideLevelToFitness(coach.rideLevel)) : '5');
                
                if (upgraded.phone !== originalPhone || 
                    upgraded.coachingLicenseLevel !== originalLevel ||
                    upgraded.fitness !== originalFitness) {
                    changed = true;
                }
                return upgraded;
            });

            const skillToFitness = {
                beginner: '2',
                intermediate: '4',
                advanced: '7',
                expert: '9'
            };

            data.riders = data.riders.map((rider, index) => {
                const normalizedGenderInput = (rider.gender || rider.sex || '').toString().trim().toUpperCase();
                const normalizedGender = ['M', 'F', 'NB'].includes(normalizedGenderInput) ? normalizedGenderInput : '';
                
                // Normalize phone number to 10 digits only
                let normalizedPhone = (rider.phone || '').replace(/\D/g, ''); // Remove all non-digits
                if (normalizedPhone.length !== 10) {
                    // If not 10 digits, generate a valid one based on index
                    normalizedPhone = `415556${(200 + index).toString().padStart(4, '0')}`;
                    changed = true;
                }
                
                // Preserve ALL existing fields, then override only the ones that need normalization
                const upgraded = {
                    ...rider, // Preserve all existing fields first
                    id: rider.id || Date.now(),
                    name: rider.name || '',
                    phone: normalizedPhone,
                    grade: normalizeGradeValue(rider.grade || '9th'),
                    racingGroup: rider.racingGroup || 'Freshman',
                    fitness: rider.fitness
                        ? String(rider.fitness)
                        : rider.abilityRanking
                            ? String(mapAbilityToFitness(rider.abilityRanking))
                            : (skillToFitness[rider.skillLevel] || '5'),
                    photo: rider.photo || '',
                    notes: rider.notes || '',
                    gender: normalizedGender,
                    // keep legacy skillLevel if present for compatibility
                    skillLevel: rider.skillLevel || undefined
                };
                if (!rider.fitness && (rider.abilityRanking || rider.skillLevel)) {
                    changed = true;
                }
                // Check if normalization actually changed anything
                // Since we use spread operator, all fields are preserved, so we only check normalized fields
                const originalPhone = (rider.phone || '').replace(/\D/g, '');
                const originalGrade = normalizeGradeValue(rider.grade || '9th');
                const originalRacingGroup = rider.racingGroup || 'Freshman';
                const originalFitness = rider.fitness ? String(rider.fitness) : (rider.abilityRanking ? String(mapAbilityToFitness(rider.abilityRanking)) : (skillToFitness[rider.skillLevel] || '5'));
                const originalGender = normalizedGender;
                
                if (upgraded.phone !== originalPhone ||
                    upgraded.grade !== originalGrade ||
                    upgraded.racingGroup !== originalRacingGroup ||
                    upgraded.fitness !== originalFitness ||
                    upgraded.gender !== originalGender) {
                    changed = true;
                }
                return upgraded;
            });

            // Only reset sample data if there's NO existing data (empty database)
            // Don't overwrite user's actual data!
            // IMPORTANT: We no longer generate dummy data - user should import from CSV instead
            if (data.sampleVersion !== SAMPLE_DATA_VERSION) {
                // Always update version to prevent future resets
                data.sampleVersion = SAMPLE_DATA_VERSION;
                
                // Initialize empty arrays if they don't exist (don't create dummy data)
                if (!Array.isArray(data.riders)) {
                    data.riders = [];
                    changed = true;
                }
                if (!Array.isArray(data.coaches)) {
                    data.coaches = [];
                    changed = true;
                }
            }

            if (!Array.isArray(data.rides)) {
                data.rides = [];
                changed = true;
            } else {
                data.rides = data.rides.map(ride => {
                    const { ride: normalizedRide, changed: rideChanged } = normalizeRideStructure(ride);
                    if (rideChanged) {
                        changed = true;
                    }
                    return normalizedRide;
                });
            }

            const previousSeasonState = JSON.stringify(data.seasonSettings || {});
            if (!data.seasonSettings || typeof data.seasonSettings !== 'object') {
                data.seasonSettings = buildDefaultSeasonSettings();
            }

            const normalizedPractices = Array.isArray(data.seasonSettings.practices)
                ? data.seasonSettings.practices
                    .map(practice => {
                        if (!practice || typeof practice !== 'object') {
                            return null;
                        }
                        
                        // Handle single practices (with specificDate) differently from recurring practices
                        const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined;
                        
                        if (isSinglePractice) {
                            // Single practice: require specificDate and time
                            const time = normalizeTimeValue(practice.time || practice.startTime || '');
                            if (!time || !practice.specificDate) {
                                return null;
                            }
                            
                            return {
                                id: practice.id || generateId(),
                                dayOfWeek: null,
                                specificDate: practice.specificDate,
                                time: time,
                                endTime: normalizeTimeValue(practice.endTime || '') || '',
                                description: practice.description || '',
                                meetLocation: practice.meetLocation || '',
                                locationLat: practice.locationLat || null,
                                locationLng: practice.locationLng || null
                            };
                        } else {
                            // Recurring practice: require dayOfWeek and time
                            const normalized = normalizePracticeEntry(practice);
                            if (!normalized) return null;
                            
                            // Preserve ALL fields from the original practice
                            return {
                                id: practice.id || normalized.id || generateId(),
                                dayOfWeek: normalized.dayOfWeek,
                                specificDate: null,
                                time: normalized.time,
                                endTime: practice.endTime || normalized.endTime || '',
                                description: practice.description || '',
                                meetLocation: practice.meetLocation || '',
                                locationLat: practice.locationLat || null,
                                locationLng: practice.locationLng || null
                            };
                        }
                    })
                    .filter(Boolean)
                : [];

            // Keep practices in the order they were created (no sorting)

            const normalizedSeason = {
                startDate: data.seasonSettings.startDate || '',
                endDate: data.seasonSettings.endDate || '',
                practices: normalizedPractices
            };

            // Only update if the normalized version is actually different
            // This prevents unnecessary overwrites when data is already correct
            const normalizedSeasonStr = JSON.stringify(normalizedSeason);
            if (normalizedSeasonStr !== previousSeasonState) {
                changed = true;
                data.seasonSettings = normalizedSeason;
            }
            // If unchanged, keep the original data.seasonSettings (preserves any extra fields)

            if (changed) {
                saveData();
            }
        }

        function handleFileChange(inputId, labelId) {
            const input = document.getElementById(inputId);
            const label = document.getElementById(labelId);
            if (!label) return;
            const defaultText = label.dataset.default || 'No file selected';

            if (input && input.files && input.files.length > 0) {
                label.textContent = input.files[0].name;
            } else {
                label.textContent = defaultText;
            }
        }

        function readPhotoFile(inputId) {
            return new Promise(resolve => {
                const input = document.getElementById(inputId);
                if (!input || !input.files || input.files.length === 0) {
                    resolve('');
                    return;
                }

                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('');
                reader.readAsDataURL(file);
            });
        }

        // Data persistence functions (using localStorage)
        const STORAGE_KEY = 'teamRideProData';
        const OLD_STORAGE_KEY = 'mtbRosterData'; // For migration from old filename

        function saveData() {
            try {
                const dataToSave = {
                    riders: data.riders,
                    coaches: data.coaches,
                    rides: data.rides,
                    routes: data.routes,
                    currentRide: data.currentRide,
                    seasonSettings: data.seasonSettings,
                    autoAssignSettings: data.autoAssignSettings,
                    sampleVersion: data.sampleVersion,
                    coachRoles: data.coachRoles || [],
                    riderRoles: data.riderRoles || []
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                console.log('Data saved to localStorage:', {
                    riders: data.riders.length,
                    coaches: data.coaches.length,
                    rides: data.rides.length,
                    routes: data.routes.length,
                    seasonSettings: data.seasonSettings ? {
                        startDate: data.seasonSettings.startDate,
                        endDate: data.seasonSettings.endDate,
                        practicesCount: data.seasonSettings.practices?.length || 0
                    } : null
                });
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                // If localStorage is full, try to clear old data
                try {
                    localStorage.clear();
                    const dataToSave = {
                        riders: data.riders,
                        coaches: data.coaches,
                        rides: data.rides,
                        routes: data.routes,
                        currentRide: data.currentRide,
                        seasonSettings: data.seasonSettings,
                        autoAssignSettings: data.autoAssignSettings,
                        sampleVersion: data.sampleVersion,
                        coachRoles: data.coachRoles || [],
                        riderRoles: data.riderRoles || []
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                } catch (clearError) {
                    console.error('Error clearing localStorage:', clearError);
                    alert('Unable to save data. Local storage may be full.');
                }
            }
        }

        function loadData() {
            try {
                // First, try to load from new key
                let stored = localStorage.getItem(STORAGE_KEY);
                
                // If not found, check for old key and migrate
                if (!stored) {
                    const oldStored = localStorage.getItem(OLD_STORAGE_KEY);
                    if (oldStored) {
                        console.log('Migrating data from old localStorage key...');
                        // Copy old data to new key
                        localStorage.setItem(STORAGE_KEY, oldStored);
                        stored = oldStored;
                        // Optionally remove old key (commented out to be safe)
                        // localStorage.removeItem(OLD_STORAGE_KEY);
                    }
                }
                
                if (stored) {
                    const parsed = JSON.parse(stored);
                    // Merge with existing data structure - preserve ALL fields
                    if (parsed.riders) data.riders = parsed.riders;
                    if (parsed.coaches) data.coaches = parsed.coaches;
                    if (parsed.rides) data.rides = parsed.rides;
                    if (parsed.routes) data.routes = parsed.routes;
                    if (parsed.currentRide !== undefined) data.currentRide = parsed.currentRide;
                    if (parsed.seasonSettings) {
                        // Preserve the entire seasonSettings object
                        data.seasonSettings = parsed.seasonSettings;
                    }
                    if (parsed.autoAssignSettings) data.autoAssignSettings = parsed.autoAssignSettings;
                    if (parsed.timeEstimationSettings) data.timeEstimationSettings = parsed.timeEstimationSettings;
                    if (parsed.sampleVersion !== undefined) data.sampleVersion = parsed.sampleVersion;
                    if (Array.isArray(parsed.coachRoles)) data.coachRoles = parsed.coachRoles;
                    else if (!data.coachRoles) data.coachRoles = [];
                    if (Array.isArray(parsed.riderRoles)) data.riderRoles = parsed.riderRoles;
                    else if (!data.riderRoles) data.riderRoles = [];
                    
                    // Ensure scale settings exist
                    if (!data.seasonSettings) {
                        data.seasonSettings = buildDefaultSeasonSettings();
                    }
                    if (!data.seasonSettings.fitnessScale) data.seasonSettings.fitnessScale = 5;
                    if (!data.seasonSettings.skillsScale) data.seasonSettings.skillsScale = 3;
                    
                    // Update input max attributes after data is loaded
                    setTimeout(updateInputMaxAttributes, 100);
                    
                    console.log('Data loaded from localStorage:', {
                        riders: data.riders.length,
                        coaches: data.coaches.length,
                        rides: data.rides.length,
                        routes: data.routes.length,
                        seasonSettings: data.seasonSettings ? {
                            startDate: data.seasonSettings.startDate,
                            endDate: data.seasonSettings.endDate,
                            practicesCount: data.seasonSettings.practices?.length || 0
                        } : null
                    });
                } else {
                    console.log('No data found in localStorage');
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // Save rider to localStorage
        function saveRiderToDB(riderData) {
            if (riderData.id && data.riders.find(r => r.id === riderData.id)) {
                // Update existing
                const index = data.riders.findIndex(r => r.id === riderData.id);
                if (index !== -1) {
                    data.riders[index] = { ...data.riders[index], ...riderData };
                }
            } else {
                // Create new
                const newRider = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    ...riderData
                };
                data.riders.push(newRider);
                return newRider;
            }
            saveData();
        }

        // Save coach to localStorage
        function saveCoachToDB(coachData) {
            if (coachData.id && data.coaches.find(c => c.id === coachData.id)) {
                // Update existing
                const index = data.coaches.findIndex(c => c.id === coachData.id);
                if (index !== -1) {
                    data.coaches[index] = { ...data.coaches[index], ...coachData };
                }
            } else {
                // Create new
                const newCoach = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    ...coachData
                };
                data.coaches.push(newCoach);
                return newCoach;
            }
            saveData();
        }

        // Debounced ride save function (using localStorage)
        window.rideSaveTimeout = null;
        function debouncedSaveRide(ride) {
            if (!ride || !ride.id) return;
            
            clearTimeout(window.rideSaveTimeout);
            window.rideSaveTimeout = setTimeout(() => {
                saveRideToDB(ride);
            }, 500); // Save 0.5 seconds after last change
        }

        // Save ride to localStorage
        function saveRideToDB(rideData) {
            if (rideData.id && data.rides.find(r => r.id === rideData.id)) {
                // Update existing - preserve all fields
                const index = data.rides.findIndex(r => r.id === rideData.id);
                if (index !== -1) {
                    // Merge to preserve all existing fields
                    data.rides[index] = { ...data.rides[index], ...rideData };
                }
            } else {
                // Create new
                const newRide = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    date: rideData.date,
                    availableCoaches: rideData.availableCoaches || [],
                    availableRiders: rideData.availableRiders || [],
                    assignments: rideData.assignments || {},
                    groups: rideData.groups || [],
                    cancelled: rideData.cancelled || false,
                    goals: rideData.goals || null
                };
                data.rides.push(newRide);
                return newRide;
            }
            saveData();
        }

        // Tab switching
        function switchTab(tabName, element) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.mobile-menu-item').forEach(t => t.classList.remove('active'));
            
            if (element) {
                element.classList.add('active');
            }
            const tab = document.getElementById(tabName + '-tab');
            if (tab) {
                tab.classList.add('active');
            }
            
            // Update mobile menu
            updateMobileMenu(tabName);
            
            if (tabName === 'rides') {
                renderRides();
            } else if (tabName === 'settings') {
                loadSeasonSettings();
                renderSeasonCalendarForSettings();
                updateRoleDropdowns();
            } else if (tabName === 'roster') {
                // Default to showing riders view
                toggleRosterView('riders');
            } else if (tabName === 'assignments') {
                renderRideAssignments();
            } else if (tabName === 'routes') {
                // Routes tab doesn't need any special rendering
            }
            
            // Update header button visibility when switching tabs
            updateHeaderEditSeasonButton();
        }

        function toggleMobileMenu() {
            const dropdown = document.getElementById('mobile-menu-dropdown');
            const button = document.getElementById('mobile-menu-button');
            if (dropdown && button) {
                const isOpen = dropdown.classList.contains('show');
                if (isOpen) {
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                } else {
                    dropdown.classList.add('show');
                    button.classList.add('open');
                }
            }
        }

        function selectMobileTab(tabName) {
            // Find the corresponding desktop tab button
            const tabs = document.querySelectorAll('#desktop-tabs .tab');
            let targetElement = null;
            tabs.forEach(tab => {
                if (tab.textContent.trim() === getTabLabel(tabName)) {
                    targetElement = tab;
                }
            });
            
            switchTab(tabName, targetElement);
            toggleMobileMenu(); // Close the dropdown
        }

        function getTabLabel(tabName) {
            const labels = {
                'settings': 'Team Dashboard',
                'roster': 'Roster',
                'coaches': 'Coach Roster',
                'team': 'Team Roster',
                'rides': 'Practice Planner',
                'assignments': 'Practice Assignments',
                'routes': 'Routes'
            };
            return labels[tabName] || tabName;
        }

        function updateMobileMenu(activeTabName) {
            const menuItems = document.querySelectorAll('.mobile-menu-item');
            
            menuItems.forEach(item => {
                item.classList.remove('active');
                const onclickAttr = item.getAttribute('onclick');
                if (onclickAttr) {
                    const match = onclickAttr.match(/'([^']+)'/);
                    if (match && match[1] === activeTabName) {
                        item.classList.add('active');
                    }
                }
            });
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
            const menuContainer = document.querySelector('.mobile-menu-container');
            const dropdown = document.getElementById('mobile-menu-dropdown');
            const button = document.getElementById('mobile-menu-button');
            
            if (menuContainer && dropdown && button) {
                if (!menuContainer.contains(event.target) && dropdown.classList.contains('show')) {
                    dropdown.classList.remove('show');
                    button.classList.remove('open');
                }
            }
        });

        // Initialize mobile menu on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial active tab for mobile menu
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                const tabId = activeTab.id;
                if (tabId) {
                    const tabName = tabId.replace('-tab', '');
                    updateMobileMenu(tabName);
                }
            }
        });

        // Rider management
        async function addRider() {
            if (!canEditRiders()) {
                alert('You do not have permission to add riders');
                return;
            }

            const name = document.getElementById('rider-name').value.trim();
            const phone = document.getElementById('rider-phone').value.trim();
            const grade = document.getElementById('rider-grade').value;
            const racingGroup = document.getElementById('rider-racing-group').value;
            const gender = document.getElementById('rider-gender').value || '';
            const fitnessInput = document.getElementById('rider-fitness').value;
            const notes = document.getElementById('rider-notes').value.trim();
            
            if (!name) {
                alert('Please enter a team rider name');
                return;
            }

            const fitnessValue = Math.max(1, Math.min(10, parseInt(fitnessInput || '5', 10)));

            const photo = await readPhotoFile('rider-photo');
            
            const riderData = {
                name,
                photo,
                phone,
                grade: normalizeGradeValue(grade),
                racing_group: racingGroup,
                gender: gender.toUpperCase(),
                fitness: String(fitnessValue),
                notes
            };

            saveRiderToDB(riderData);
            resetRiderForm();
            renderRiders();
        }

        function resetRiderForm() {
            document.getElementById('rider-photo').value = '';
            document.getElementById('rider-name').value = '';
            document.getElementById('rider-phone').value = '';
            document.getElementById('rider-grade').value = '9th';
            document.getElementById('rider-racing-group').value = 'Freshman';
            document.getElementById('rider-gender').value = '';
            document.getElementById('rider-fitness').value = '5';
            document.getElementById('rider-notes').value = '';
            handleFileChange('rider-photo', 'rider-photo-name');
        }

        async function deleteRider(id) {
            if (!canEditRiders()) {
                alert('You do not have permission to delete riders');
                return;
            }

            if (confirm('Delete this rider?')) {
                // Remove from riders array
                data.riders = data.riders.filter(r => r.id !== id);
                
                // Also update any rides that reference this rider
                for (const ride of data.rides) {
                    if (ride.availableRiders && ride.availableRiders.includes(id)) {
                        ride.availableRiders = ride.availableRiders.filter(riderId => riderId !== id);
                        // Update groups if needed
                        if (ride.groups) {
                            ride.groups.forEach(group => {
                                if (group.riders) {
                                    group.riders = group.riders.filter(riderId => riderId !== id);
                                }
                            });
                        }
                        saveRideToDB(ride);
                    }
                }
                
                saveData();
                renderRiders();
                if (data.currentRide) {
                    renderRides();
                }
            }
        }

        let currentEditingRiderId = null;

        function openEditRiderModal(id) {
            const rider = data.riders.find(r => r.id === id);
            if (!rider) return;

            currentEditingRiderId = id;
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-rider-modal-title');
            if (titleEl) titleEl.textContent = 'Edit Team Rider';
            
            const deleteBtn = document.getElementById('delete-rider-btn');
            if (deleteBtn) deleteBtn.style.display = 'block';

            // Populate name fields (prefer explicit first/last if present, otherwise split full name)
            const riderFirstNameInput = document.getElementById('edit-rider-first-name');
            const riderLastNameInput = document.getElementById('edit-rider-last-name');
            const fullName = rider.name || '';
            let firstName = rider.firstName || '';
            let lastName = rider.lastName || '';
            if (!firstName && !lastName && fullName) {
                const parts = fullName.trim().split(' ');
                if (parts.length > 1) {
                    lastName = parts.pop();
                    firstName = parts.join(' ');
                } else {
                    firstName = fullName;
                }
            }
            if (riderFirstNameInput) riderFirstNameInput.value = firstName || '';
            if (riderLastNameInput) riderLastNameInput.value = lastName || '';
            
            // Populate all CSV fields
            document.getElementById('edit-rider-email').value = rider.email || '';
            
            // Format phone number
            const phone = (rider.phone || '').replace(/\D/g, '');
            if (phone.length === 10) {
                const formattedPhone = `(${phone.substring(0, 3)}) ${phone.substring(3, 6)}-${phone.substring(6, 10)}`;
                document.getElementById('edit-rider-phone').value = formattedPhone;
            } else {
                document.getElementById('edit-rider-phone').value = rider.phone || '';
            }
            
            document.getElementById('edit-rider-address').value = rider.address || '';
            
            const genderValue = (rider.gender || '').toUpperCase();
            document.getElementById('edit-rider-gender').value = (genderValue === 'M' || genderValue === 'F' || genderValue === 'NB') ? genderValue : '';
            document.getElementById('edit-rider-grade').value = rider.grade || '9th';
            document.getElementById('edit-rider-birthday').value = rider.birthday || '';
            
            document.getElementById('edit-rider-primary-parent-name').value = rider.primaryParentName || '';
            const primaryParentPhone = (rider.primaryParentPhone || '').replace(/\D/g, '');
            if (primaryParentPhone.length === 10) {
                document.getElementById('edit-rider-primary-parent-phone').value = `(${primaryParentPhone.substring(0, 3)}) ${primaryParentPhone.substring(3, 6)}-${primaryParentPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-primary-parent-phone').value = rider.primaryParentPhone || '';
            }
            document.getElementById('edit-rider-primary-parent-email').value = rider.primaryParentEmail || '';
            document.getElementById('edit-rider-primary-parent-address').value = rider.primaryParentAddress || '';
            
            document.getElementById('edit-rider-second-parent-name').value = rider.secondParentName || '';
            const secondParentPhone = (rider.secondParentPhone || '').replace(/\D/g, '');
            if (secondParentPhone.length === 10) {
                document.getElementById('edit-rider-second-parent-phone').value = `(${secondParentPhone.substring(0, 3)}) ${secondParentPhone.substring(3, 6)}-${secondParentPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-second-parent-phone').value = rider.secondParentPhone || '';
            }
            document.getElementById('edit-rider-second-parent-email').value = rider.secondParentEmail || '';
            
            document.getElementById('edit-rider-alternate-contact-name').value = rider.alternateContactName || '';
            document.getElementById('edit-rider-alternate-contact-relationship').value = rider.alternateContactRelationship || '';
            const alternateContactPhone = (rider.alternateContactPhone || '').replace(/\D/g, '');
            if (alternateContactPhone.length === 10) {
                document.getElementById('edit-rider-alternate-contact-phone').value = `(${alternateContactPhone.substring(0, 3)}) ${alternateContactPhone.substring(3, 6)}-${alternateContactPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-alternate-contact-phone').value = rider.alternateContactPhone || '';
            }
            
            document.getElementById('edit-rider-primary-physician').value = rider.primaryPhysician || '';
            const primaryPhysicianPhone = (rider.primaryPhysicianPhone || '').replace(/\D/g, '');
            if (primaryPhysicianPhone.length === 10) {
                document.getElementById('edit-rider-primary-physician-phone').value = `(${primaryPhysicianPhone.substring(0, 3)}) ${primaryPhysicianPhone.substring(3, 6)}-${primaryPhysicianPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-rider-primary-physician-phone').value = rider.primaryPhysicianPhone || '';
            }
            document.getElementById('edit-rider-medical-insurance-company').value = rider.medicalInsuranceCompany || '';
            document.getElementById('edit-rider-medical-insurance-account').value = rider.medicalInsuranceAccountNumber || '';
            document.getElementById('edit-rider-allergies').value = rider.allergiesOrMedicalNeeds || '';
            
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-rider-fitness').value = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
            document.getElementById('edit-rider-skills').value = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
            document.getElementById('edit-rider-notes').value = rider.notes || '';

            // Update racing group options based on gender, then set value
            updateRacingGroupOptions();
            if (rider.racingGroup) {
                document.getElementById('edit-rider-racing-group').value = rider.racingGroup;
            }

            // Update photo preview - use default if no photo uploaded
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            if (rider.photo && !rider.photo.includes('_default.png')) {
                // Use uploaded photo (not a default)
                photoPreview.src = rider.photo;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                // Use default based on gender
                const gender = (rider.gender || '').toUpperCase();
                let defaultPhoto = '';
                if (gender === 'M') {
                    defaultPhoto = 'assets/male_default.png';
                } else if (gender === 'F') {
                    defaultPhoto = 'assets/female_default.png';
                } else if (gender === 'NB') {
                    defaultPhoto = 'assets/nonbinary_default.png';
                } else {
                    defaultPhoto = 'assets/nonbinary_default.png';
                }
                photoPreview.src = defaultPhoto;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function openAddRiderModal() {
            currentEditingRiderId = null;
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-rider-modal-title');
            if (titleEl) titleEl.textContent = 'Add Team Rider';
            
            const deleteBtn = document.getElementById('delete-rider-btn');
            if (deleteBtn) deleteBtn.style.display = 'none';

            const riderFirstNameInput = document.getElementById('edit-rider-first-name');
            const riderLastNameInput = document.getElementById('edit-rider-last-name');
            if (riderFirstNameInput) riderFirstNameInput.value = '';
            if (riderLastNameInput) riderLastNameInput.value = '';
            document.getElementById('edit-rider-phone').value = '';
            document.getElementById('edit-rider-gender').value = '';
            document.getElementById('edit-rider-grade').value = '9th';
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-rider-fitness').value = Math.ceil(fitnessScale / 2);
            document.getElementById('edit-rider-skills').value = Math.ceil(skillsScale / 2);
            document.getElementById('edit-rider-notes').value = '';

            // Reset racing group options
            updateRacingGroupOptions();

            // Reset photo preview
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            photoPreview.style.display = 'none';
            photoPlaceholder.style.display = 'flex';
            document.getElementById('edit-rider-photo-input').value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeEditRiderModal() {
            const modal = document.getElementById('edit-rider-modal');
            if (!modal) return;
            // Blur any focused elements before hiding modal to avoid aria-hidden warning
            const focusedElement = document.activeElement;
            if (focusedElement && modal.contains(focusedElement)) {
                focusedElement.blur();
            }
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentEditingRiderId = null;
        }

        async function saveRiderFromModal() {
            if (!canEditRiders()) {
                alert('You do not have permission to edit riders');
                return;
            }

            const firstNameInput = document.getElementById('edit-rider-first-name');
            const lastNameInput = document.getElementById('edit-rider-last-name');
            const firstName = firstNameInput ? firstNameInput.value.trim() : '';
            const lastName = lastNameInput ? lastNameInput.value.trim() : '';
            const name = `${firstName} ${lastName}`.trim();
            if (!firstName && !lastName) {
                alert('Please enter a rider first or last name');
                return;
            }

            const phoneInput = document.getElementById('edit-rider-phone').value.trim();
            const phoneDigits = phoneInput.replace(/\D/g, '');
            
            if (phoneDigits.length !== 10) {
                alert('Please enter a valid 10-digit phone number');
                return;
            }
            
            const phone = phoneDigits; // Store as digits only
            const grade = document.getElementById('edit-rider-grade').value.trim();
            const racingGroup = document.getElementById('edit-rider-racing-group').value.trim();
            const fitnessInput = document.getElementById('edit-rider-fitness').value;
            const skillsInput = document.getElementById('edit-rider-skills').value;
            const notes = document.getElementById('edit-rider-notes').value.trim();
            const genderValue = document.getElementById('edit-rider-gender')?.value?.toUpperCase();
            
            if (!genderValue || (genderValue !== 'M' && genderValue !== 'F' && genderValue !== 'NB')) {
                alert('Please select a gender');
                return;
            }
            
            if (!racingGroup) {
                alert('Please select a racing group');
                return;
            }

            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(fitnessInput || Math.ceil(fitnessScale / 2), 10)));
            const skillsValue = Math.max(1, Math.min(skillsScale, parseInt(skillsInput || Math.ceil(skillsScale / 2), 10)));

            // Get photo from preview or use default based on gender
            let photo = '';
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoInput = document.getElementById('edit-rider-photo-input');
            
            // Check if a new photo was uploaded
            if (photoInput && photoInput.files && photoInput.files.length > 0) {
                // Read the uploaded file
                const file = photoInput.files[0];
                const reader = new FileReader();
                photo = await new Promise((resolve) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => resolve('');
                    reader.readAsDataURL(file);
                });
            } else if (photoPreview.style.display !== 'none' && photoPreview.src) {
                // Use existing photo from preview
                photo = photoPreview.src;
            } else {
                // Use default based on gender
                if (genderValue === 'M') {
                    photo = 'assets/male_default.png';
                } else if (genderValue === 'F') {
                    photo = 'assets/female_default.png';
                } else if (genderValue === 'NB') {
                    photo = 'assets/nonbinary_default.png';
                } else {
                    photo = 'assets/nonbinary_default.png';
                }
            }

            // Get all CSV fields
            const email = document.getElementById('edit-rider-email').value.trim();
            const address = document.getElementById('edit-rider-address').value.trim();
            const birthday = document.getElementById('edit-rider-birthday').value.trim();
            
            const primaryParentName = document.getElementById('edit-rider-primary-parent-name').value.trim();
            const primaryParentPhoneInput = document.getElementById('edit-rider-primary-parent-phone').value.trim();
            const primaryParentPhoneDigits = primaryParentPhoneInput.replace(/\D/g, '');
            const primaryParentPhone = primaryParentPhoneDigits.length === 10 ? primaryParentPhoneDigits : '';
            const primaryParentEmail = document.getElementById('edit-rider-primary-parent-email').value.trim();
            const primaryParentAddress = document.getElementById('edit-rider-primary-parent-address').value.trim();
            
            const secondParentName = document.getElementById('edit-rider-second-parent-name').value.trim();
            const secondParentPhoneInput = document.getElementById('edit-rider-second-parent-phone').value.trim();
            const secondParentPhoneDigits = secondParentPhoneInput.replace(/\D/g, '');
            const secondParentPhone = secondParentPhoneDigits.length === 10 ? secondParentPhoneDigits : '';
            const secondParentEmail = document.getElementById('edit-rider-second-parent-email').value.trim();
            
            const alternateContactName = document.getElementById('edit-rider-alternate-contact-name').value.trim();
            const alternateContactRelationship = document.getElementById('edit-rider-alternate-contact-relationship').value.trim();
            const alternateContactPhoneInput = document.getElementById('edit-rider-alternate-contact-phone').value.trim();
            const alternateContactPhoneDigits = alternateContactPhoneInput.replace(/\D/g, '');
            const alternateContactPhone = alternateContactPhoneDigits.length === 10 ? alternateContactPhoneDigits : '';
            
            const primaryPhysician = document.getElementById('edit-rider-primary-physician').value.trim();
            const primaryPhysicianPhoneInput = document.getElementById('edit-rider-primary-physician-phone').value.trim();
            const primaryPhysicianPhoneDigits = primaryPhysicianPhoneInput.replace(/\D/g, '');
            const primaryPhysicianPhone = primaryPhysicianPhoneDigits.length === 10 ? primaryPhysicianPhoneDigits : '';
            const medicalInsuranceCompany = document.getElementById('edit-rider-medical-insurance-company').value.trim();
            const medicalInsuranceAccountNumber = document.getElementById('edit-rider-medical-insurance-account').value.trim();
            const allergiesOrMedicalNeeds = document.getElementById('edit-rider-allergies').value.trim();
            
            const riderData = {
                name,
                firstName,
                lastName,
                phone,
                photo,
                email,
                address,
                gender: genderValue,
                grade: normalizeGradeValue(grade || (currentEditingRiderId ? data.riders.find(r => r.id === currentEditingRiderId)?.grade : '9th')),
                birthday,
                primaryParentName,
                primaryParentPhone,
                primaryParentEmail,
                primaryParentAddress,
                secondParentName,
                secondParentPhone,
                secondParentEmail,
                alternateContactName,
                alternateContactRelationship,
                alternateContactPhone,
                primaryPhysician,
                primaryPhysicianPhone,
                medicalInsuranceCompany,
                medicalInsuranceAccountNumber,
                allergiesOrMedicalNeeds,
                racingGroup: racingGroup,
                fitness: String(fitnessValue),
                skills: String(skillsValue),
                notes
            };

            if (currentEditingRiderId) {
                riderData.id = currentEditingRiderId;
            }

            try {
                saveRiderToDB(riderData);
                renderRiders();
                closeEditRiderModal();
                if (data.currentRide) {
                    const ride = data.rides.find(r => r.id === data.currentRide);
                    if (ride) {
                        renderAssignments(ride);
                    }
                }
            } catch (error) {
                console.error('Error saving rider:', error);
                alert('Error saving rider: ' + (error.message || 'Unknown error'));
            }
        }

        function deleteRiderFromModal() {
            if (!currentEditingRiderId) return;
            if (!confirm('Delete this rider?')) return;
            
            deleteRider(currentEditingRiderId);
            closeEditRiderModal();
        }

        function showNotesModal(id, type) {
            const modal = document.getElementById('notes-modal');
            if (!modal) return;

            let record = null;
            let name = '';
            let notes = '';

            if (type === 'coach') {
                record = data.coaches.find(c => c.id === id);
                name = record ? record.name || 'Coach' : 'Coach';
                notes = record ? record.notes || '' : '';
            } else if (type === 'rider') {
                record = data.riders.find(r => r.id === id);
                name = record ? record.name || 'Rider' : 'Rider';
                notes = record ? record.notes || '' : '';
            }

            document.getElementById('notes-modal-title').textContent = `Notes: ${name}`;
            document.getElementById('notes-modal-content').textContent = notes || '(No notes)';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeNotesModal() {
            const modal = document.getElementById('notes-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        // Auto-assignment settings modal functions
        let autoAssignSettingsDraft = null;
        let draggedParamIndex = null;

        function openAutoAssignSettingsModal() {
            const modal = document.getElementById('auto-assign-settings-modal');
            if (!modal) return;

            // Initialize settings if needed
            if (!data.autoAssignSettings || !Array.isArray(data.autoAssignSettings.parameters)) {
                upgradeData();
            }

            // Create draft copy
            autoAssignSettingsDraft = {
                parameters: data.autoAssignSettings.parameters.map(p => ({ ...p }))
            };

            renderAutoAssignParams();
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeAutoAssignSettingsModal() {
            const modal = document.getElementById('auto-assign-settings-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            autoAssignSettingsDraft = null;
        }

        function renderAutoAssignParams() {
            const container = document.getElementById('auto-assign-params-list');
            if (!container || !autoAssignSettingsDraft) return;

            // Sort: requirements first, then by priority
            const sortedParams = [...autoAssignSettingsDraft.parameters].sort((a, b) => {
                if (a.requirement && !b.requirement) return -1;
                if (!a.requirement && b.requirement) return 1;
                return a.priority - b.priority;
            });

            container.innerHTML = sortedParams.map((param, index) => {
                const isRequirement = param.requirement || false;
                const isRange = param.type === 'range';
                
                let valueInput = '';
                if (isRange) {
                    valueInput = `
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="number" 
                                   class="param-value" 
                                   value="${param.valueMin || param.min || 1}" 
                                   min="${param.min}" 
                                   max="${param.max}"
                                   placeholder="Min"
                                   style="width: 60px;"
                                   onchange="updateParamRangeValue('${param.id}', 'min', this.value)"
                                   ${!param.enabled ? 'disabled' : ''}>
                            <span>-</span>
                            <input type="number" 
                                   class="param-value" 
                                   value="${param.valueMax || param.max || 30}" 
                                   min="${param.min}" 
                                   max="${param.max}"
                                   placeholder="Max"
                                   style="width: 60px;"
                                   onchange="updateParamRangeValue('${param.id}', 'max', this.value)"
                                   ${!param.enabled ? 'disabled' : ''}>
                        </div>
                    `;
                } else {
                    valueInput = `
                        <input type="${param.type}" 
                               class="param-value" 
                               value="${param.value}" 
                               min="${param.min}" 
                               max="${param.max}"
                               onchange="updateParamValue('${param.id}', this.value)"
                               ${!param.enabled ? 'disabled' : ''}>
                    `;
                }
                
                return `
                <div class="param-row ${isRequirement ? 'requirement-row' : ''}" 
                     data-param-id="${param.id}" 
                     data-param-index="${index}"
                     draggable="${!isRequirement}"
                     ondragstart="${!isRequirement ? `handleParamDragStart(event, ${index})` : ''}"
                     ondragover="${!isRequirement ? 'handleParamDragOver(event)' : ''}"
                     ondrop="${!isRequirement ? `handleParamDrop(event, ${index})` : ''}"
                     ondragend="${!isRequirement ? 'handleParamDragEnd(event)' : ''}">
                    <div class="drag-handle" style="${isRequirement ? 'opacity: 0.3; cursor: not-allowed;' : ''}">${isRequirement ? 'üîí' : '‚ò∞'}</div>
                    <div>
                        <div class="param-name">
                            ${isRequirement ? '<span style="color: #d32f2f; font-weight: 600;">[REQUIREMENT]</span> ' : ''}${escapeHtml(param.name)}
                        </div>
                        <div class="param-description">${escapeHtml(param.description)}</div>
                    </div>
                    ${valueInput}
                    <div class="param-priority">${param.priority}</div>
                    <div class="param-enabled" style="display: flex; gap: 8px; align-items: center; flex-direction: column;">
                        <label style="font-size: 11px; cursor: pointer;">
                            <input type="checkbox" 
                                   ${param.enabled ? 'checked' : ''} 
                                   onchange="toggleParamEnabled('${param.id}', this.checked)"
                                   style="margin-right: 4px;">
                            Enabled
                        </label>
                        <label style="font-size: 11px; cursor: pointer;">
                            <input type="checkbox" 
                                   ${isRequirement ? 'checked' : ''} 
                                   onchange="toggleParamRequirement('${param.id}', this.checked)"
                                   style="margin-right: 4px;">
                            Requirement
                        </label>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        function updateParamRangeValue(id, which, value) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            const numValue = parseInt(value, 10);
            if (Number.isFinite(numValue)) {
                const clamped = Math.max(param.min || 0, Math.min(param.max || 100, numValue));
                if (which === 'min') {
                    param.valueMin = clamped;
                    // Ensure min <= max
                    if (param.valueMax !== undefined && param.valueMin > param.valueMax) {
                        param.valueMax = param.valueMin;
                    }
                } else {
                    param.valueMax = clamped;
                    // Ensure min <= max
                    if (param.valueMin !== undefined && param.valueMax < param.valueMin) {
                        param.valueMin = param.valueMax;
                    }
                }
                renderAutoAssignParams();
            }
        }
        
        function toggleParamRequirement(id, isRequirement) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            param.requirement = isRequirement;
            
            // If setting as requirement, move to top of requirements and renumber priorities
            if (isRequirement) {
                const requirements = autoAssignSettingsDraft.parameters.filter(p => p.requirement && p.id !== id);
                const preferences = autoAssignSettingsDraft.parameters.filter(p => !p.requirement);
                
                // Assign priorities: requirements first, then preferences
                requirements.forEach((p, idx) => { p.priority = idx + 1; });
                param.priority = requirements.length + 1;
                preferences.forEach((p, idx) => { p.priority = requirements.length + 1 + idx + 1; });
            } else {
                // If removing requirement, move to preferences and renumber
                const requirements = autoAssignSettingsDraft.parameters.filter(p => p.requirement && p.id !== id);
                const preferences = autoAssignSettingsDraft.parameters.filter(p => !p.requirement);
                
                requirements.forEach((p, idx) => { p.priority = idx + 1; });
                preferences.forEach((p, idx) => { p.priority = requirements.length + idx + 1; });
                param.priority = requirements.length + preferences.length + 1;
            }
            
            renderAutoAssignParams();
        }

        function updateParamValue(id, value) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            const numValue = parseInt(value, 10);
            if (Number.isFinite(numValue)) {
                param.value = Math.max(param.min || 0, Math.min(param.max || 100, numValue));
            }
        }

        function toggleParamEnabled(id, enabled) {
            if (!autoAssignSettingsDraft) return;
            const param = autoAssignSettingsDraft.parameters.find(p => p.id === id);
            if (!param) return;
            param.enabled = enabled;
            renderAutoAssignParams();
        }

        function handleParamDragStart(event, index) {
            draggedParamIndex = index;
            event.dataTransfer.effectAllowed = 'move';
            event.currentTarget.classList.add('dragging');
        }

        function handleParamDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }

        function handleParamDrop(event, dropIndex) {
            event.preventDefault();
            if (draggedParamIndex === null || draggedParamIndex === dropIndex) return;
            if (!autoAssignSettingsDraft) return;

            // Sort: requirements first, then by priority
            const sortedParams = [...autoAssignSettingsDraft.parameters].sort((a, b) => {
                if (a.requirement && !b.requirement) return -1;
                if (!a.requirement && b.requirement) return 1;
                return a.priority - b.priority;
            });
            
            const draggedParam = sortedParams[draggedParamIndex];
            
            // Don't allow dragging requirements
            if (draggedParam.requirement) return;
            
            // Only allow dropping within preferences (not into requirements)
            const requirements = sortedParams.filter(p => p.requirement);
            const preferences = sortedParams.filter(p => !p.requirement);
            const draggedIndexInPreferences = preferences.indexOf(draggedParam);
            
            if (draggedIndexInPreferences === -1) return;
            
            preferences.splice(draggedIndexInPreferences, 1);
            const dropIndexInPreferences = Math.max(0, Math.min(dropIndex - requirements.length, preferences.length));
            preferences.splice(dropIndexInPreferences, 0, draggedParam);

            // Update priorities: requirements first, then preferences
            requirements.forEach((p, idx) => { p.priority = idx + 1; });
            preferences.forEach((p, idx) => { p.priority = requirements.length + idx + 1; });

            autoAssignSettingsDraft.parameters = [...requirements, ...preferences];
            renderAutoAssignParams();
        }

        function handleParamDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            draggedParamIndex = null;
        }

        function saveAutoAssignSettings() {
            if (!autoAssignSettingsDraft) return;
            data.autoAssignSettings = {
                parameters: autoAssignSettingsDraft.parameters.map(p => ({ ...p }))
            };
            saveData();
            closeAutoAssignSettingsModal();
        }

        function resetAutoAssignSettings() {
            if (!confirm('Reset all auto-assignment settings to defaults?')) return;
            
            autoAssignSettingsDraft = {
                parameters: [
                    { id: 'ridersPerCoach', name: 'Riders per Coach', value: 6, priority: 1, enabled: true, requirement: true, type: 'number', min: 1, max: 20, description: 'Maximum riders per coach (capacity multiplier)' },
                    { id: 'minLeaderLevel', name: 'Minimum Leader Level', value: 2, priority: 2, enabled: true, requirement: true, type: 'number', min: 1, max: 3, description: 'Minimum coach level required to lead a group' },
                    { id: 'preferredGroupSize', name: 'Preferred Min/Max Total Group Size', valueMin: 4, valueMax: 10, priority: 3, enabled: true, requirement: false, type: 'range', min: 1, max: 30, description: 'Preferred group size range (may be exceeded to meet requirements)' },
                    { id: 'organizeByPace', name: 'Organize Groups by Pace', value: 2, priority: 4, enabled: true, requirement: false, type: 'number', min: 0, max: 10, description: 'Preferred maximum pace range within groups' }
                ]
            };
            renderAutoAssignParams();
        }

        async function handleCoachPhotoUpload(coachId, input) {
            if (!input.files || input.files.length === 0) return;
            
            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const file = input.files[0];
            const photo = await readPhotoFileFromInput(input);
            
            coach.photo = photo;
            saveData();
            renderCoaches();
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        async function handleRiderPhotoUpload(riderId, input) {
            if (!input.files || input.files.length === 0) return;
            
            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const file = input.files[0];
            const photo = await readPhotoFileFromInput(input);
            
            rider.photo = photo;
            saveData();
            renderRiders();
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        async function handleRiderPhotoUploadInModal(input) {
            if (!input.files || input.files.length === 0) return;
            
            const photo = await readPhotoFileFromInput(input);
            if (!photo) return;

            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            
            photoPreview.src = photo;
            photoPreview.style.display = 'block';
            photoPlaceholder.style.display = 'none';
        }

        function readPhotoFileFromInput(input) {
            return new Promise(resolve => {
                if (!input || !input.files || input.files.length === 0) {
                    resolve('');
                    return;
                }

                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('');
                reader.readAsDataURL(file);
            });
        }

        function formatPhoneNumber(input) {
            let value = input.value.replace(/\D/g, ''); // Remove all non-digits
            
            if (value.length > 10) {
                value = value.substring(0, 10); // Limit to 10 digits
            }
            
            let formattedValue = '';
            if (value.length > 0) {
                formattedValue = '(' + value.substring(0, 3);
            }
            if (value.length > 3) {
                formattedValue += ') ' + value.substring(3, 6);
            }
            if (value.length > 6) {
                formattedValue += '-' + value.substring(6, 10);
            }
            
            input.value = formattedValue;
        }

        function formatPhoneForDisplay(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6, 10)}`;
            }
            return phone;
        }

        function formatPhoneForTel(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return `tel:+1${digits}`;
            } else if (digits.length === 11 && digits.startsWith('1')) {
                return `tel:+${digits}`;
            } else if (digits.length > 0) {
                return `tel:+${digits}`;
            }
            return '';
        }

        function updateRacingGroupOptions() {
            const genderSelect = document.getElementById('edit-rider-gender');
            const racingGroupSelect = document.getElementById('edit-rider-racing-group');
            
            if (!genderSelect || !racingGroupSelect) return;
            
            const gender = genderSelect.value;
            const currentValue = racingGroupSelect.value; // Save current selection
            
            // Clear existing options
            racingGroupSelect.innerHTML = '';
            
            if (!gender) {
                racingGroupSelect.disabled = true;
                racingGroupSelect.value = '';
                racingGroupSelect.innerHTML = '<option value="">Select Gender First</option>';
                return;
            }
            
            // Enable the dropdown
            racingGroupSelect.disabled = false;
            
            // Set options based on gender
            const options = gender === 'M' 
                ? ['Freshman Boys', 'JV2 Boys', 'JV1 Boys', 'Varsity Boys']
                : ['Freshman Girls', 'JV2 Girls', 'JV1 Girls', 'Varsity Girls'];
            
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                racingGroupSelect.appendChild(opt);
            });
            
            // Restore previous selection only if it's still valid for the new gender
            if (currentValue && options.includes(currentValue)) {
                racingGroupSelect.value = currentValue;
            } else {
                // Clear selection if it's not valid for the new gender
                racingGroupSelect.value = '';
            }
        }

        function updateDefaultPhoto() {
            const genderSelect = document.getElementById('edit-rider-gender');
            const photoPreview = document.getElementById('edit-rider-photo-preview');
            const photoPlaceholder = document.getElementById('edit-rider-photo-placeholder');
            const photoInput = document.getElementById('edit-rider-photo-input');
            
            if (!genderSelect || !photoPreview || !photoPlaceholder) return;
            
            // Only update if no photo has been uploaded
            if (photoInput && photoInput.files && photoInput.files.length > 0) {
                return; // Don't change if user has uploaded a photo
            }
            
            // Check if there's an existing photo that's not a default
            if (photoPreview.style.display !== 'none' && photoPreview.src) {
                const src = photoPreview.src;
                // If it's a default image, update it; otherwise keep the uploaded photo
                if (!src.includes('male_default') && !src.includes('female_default') && !src.includes('nonbinary_default')) {
                    return; // Keep uploaded photo
                }
            }
            
            const gender = genderSelect.value;
            let defaultPhoto = '';
            if (gender === 'M') {
                defaultPhoto = 'assets/male_default.png';
            } else if (gender === 'F') {
                defaultPhoto = 'assets/female_default.png';
            } else if (gender === 'NB') {
                defaultPhoto = 'assets/nonbinary_default.png';
            } else {
                defaultPhoto = 'assets/nonbinary_default.png';
            }
            
            if (defaultPhoto) {
                photoPreview.src = defaultPhoto;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                photoPreview.style.display = 'none';
                photoPlaceholder.style.display = 'flex';
            }
        }

        async function adjustCoachPace(coachId, delta) {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to update coach pace');
                return;
            }

            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const fitnessScale = getFitnessScale();
            const currentPace = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
            const newPace = Math.max(1, Math.min(fitnessScale, currentPace + delta));
            
            coach.fitness = String(newPace);
            saveData();
            
            // Update only the fitness display without re-sorting
            updateCoachFitnessDisplay(coachId, newPace);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }
        
        async function adjustCoachSkills(coachId, delta) {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to update coach skills');
                return;
            }

            const coach = data.coaches.find(c => c.id === coachId);
            if (!coach) return;

            const skillsScale = getSkillsScale();
            const currentSkills = Math.max(1, Math.min(skillsScale, parseInt(coach.skills || Math.ceil(skillsScale / 2), 10)));
            const newSkills = Math.max(1, Math.min(skillsScale, currentSkills + delta));
            
            coach.skills = String(newSkills);
            saveData();
            
            // Update only the skills display without re-sorting
            updateCoachSkillsDisplay(coachId, newSkills);
        }

        function adjustRiderPace(riderId, delta) {
            // Permission check - allow if canEditRiders exists, otherwise allow by default
            if (typeof canEditRiders === 'function' && !canEditRiders()) {
                alert('You do not have permission to update rider pace');
                return;
            }

            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const fitnessScale = getFitnessScale();
            const currentPace = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
            const newPace = Math.max(1, Math.min(fitnessScale, currentPace + delta));
            
            rider.fitness = String(newPace);
            saveData();
            
            // Update only the fitness display without re-sorting
            updateRiderFitnessDisplay(riderId, newPace);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }

        function adjustRiderSkills(riderId, delta) {
            // Permission check - allow if canEditRiders exists, otherwise allow by default
            if (typeof canEditRiders === 'function' && !canEditRiders()) {
                alert('You do not have permission to update rider skills');
                return;
            }

            const rider = data.riders.find(r => r.id === riderId);
            if (!rider) return;

            const skillsScale = getSkillsScale();
            const currentSkills = Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
            const newSkills = Math.max(1, Math.min(skillsScale, currentSkills + delta));
            
            rider.skills = String(newSkills);
            saveData();
            
            // Update only the skills display without re-sorting
            updateRiderSkillsDisplay(riderId, newSkills);
            
            if (data.currentRide) {
                const ride = data.rides.find(r => r.id === data.currentRide);
                if (ride) {
                    renderAssignments(ride);
                }
            }
        }
        
        function updateCoachFitnessDisplay(coachId, value) {
            // Update fitness display in roster without re-sorting
            // Look for pace-value in the pace column (first pace-controls div)
            const row = document.querySelector(`[data-coach-id="${coachId}"]`);
            if (row) {
                const paceCell = row.querySelector('[data-label="Pace"]');
                if (paceCell) {
                    const paceValue = paceCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }
        
        function updateCoachSkillsDisplay(coachId, value) {
            // Update skills display in roster without re-sorting
            // Look for pace-value in the skills column (second pace-controls div)
            const row = document.querySelector(`[data-coach-id="${coachId}"]`);
            if (row) {
                const skillsCell = row.querySelector('[data-label="Bike Skills"]');
                if (skillsCell) {
                    const paceValue = skillsCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }
        
        function updateRiderFitnessDisplay(riderId, value) {
            // Update fitness display in roster without re-sorting
            // Look for pace-value in the pace column (first pace-controls div)
            const row = document.querySelector(`[data-rider-id="${riderId}"]`);
            if (row) {
                const paceCell = row.querySelector('[data-label="Pace"]');
                if (paceCell) {
                    const paceValue = paceCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }
        
        function updateRiderSkillsDisplay(riderId, value) {
            // Update skills display in roster without re-sorting
            // Look for pace-value in the skills column (second pace-controls div)
            const row = document.querySelector(`[data-rider-id="${riderId}"]`);
            if (row) {
                const skillsCell = row.querySelector('[data-label="Bike Skills"]');
                if (skillsCell) {
                    const paceValue = skillsCell.querySelector('.pace-value');
                    if (paceValue) {
                        paceValue.textContent = value;
                    }
                }
            }
        }


        // Sort state for rosters
        let riderSortColumn = null;
        let riderSortDirection = 'asc'; // 'asc' or 'desc'
        let coachSortColumn = null;
        let coachSortDirection = 'asc';
        
        // Column definitions for reordering
        const riderColumnDefs = [
            { key: 'photo', label: '', sortable: false, width: '41px' },
            { key: 'name', label: 'Name', sortable: true, width: 'minmax(220px, 1.8fr)' },
            { key: 'phone', label: 'Phone', sortable: false, width: 'minmax(160px, 1fr)' },
            { key: 'gender', label: 'Gender', sortable: true, width: 'minmax(90px, 0.7fr)' },
            { key: 'grade', label: 'Grade', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'racingGroup', label: 'Racing Group', sortable: true, width: 'minmax(160px, 1fr)' },
            { key: 'pace', label: 'Fitness', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'skills', label: 'Bike Skills', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'notes', label: 'Notes', sortable: false, width: 'minmax(120px, 1fr)' },
            { key: 'actions', label: '', sortable: false, width: 'minmax(100px, 0.8fr)' }
        ];
        
        const coachColumnDefs = [
            { key: 'photo', label: '', sortable: false, width: '41px' },
            { key: 'name', label: 'Name', sortable: true, width: 'minmax(220px, 1.8fr)' },
            { key: 'phone', label: 'Phone', sortable: false, width: 'minmax(160px, 1fr)' },
            { key: 'level', label: 'Coach Level', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'pace', label: 'Fitness', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'skills', label: 'Bike Skills', sortable: true, width: 'minmax(130px, 0.9fr)' },
            { key: 'notes', label: 'Notes', sortable: false, width: 'minmax(120px, 1fr)' },
            { key: 'actions', label: '', sortable: false, width: 'minmax(100px, 0.8fr)' }
        ];
        
        // Load column order from localStorage
        function getRiderColumnOrder() {
            const saved = localStorage.getItem('riderColumnOrder');
            if (saved) {
                try {
                    const order = JSON.parse(saved);
                    // Validate order - ensure all columns are present
                    const savedKeys = new Set(order);
                    const allKeys = new Set(riderColumnDefs.map(c => c.key));
                    if (savedKeys.size === allKeys.size && [...savedKeys].every(k => allKeys.has(k))) {
                        return order;
                    }
                } catch (e) {
                    console.error('Error parsing rider column order:', e);
                }
            }
            return riderColumnDefs.map(c => c.key);
        }
        
        function getCoachColumnOrder() {
            const saved = localStorage.getItem('coachColumnOrder');
            if (saved) {
                try {
                    const order = JSON.parse(saved);
                    // Validate order - ensure all columns are present
                    const savedKeys = new Set(order);
                    const allKeys = new Set(coachColumnDefs.map(c => c.key));
                    if (savedKeys.size === allKeys.size && [...savedKeys].every(k => allKeys.has(k))) {
                        return order;
                    }
                } catch (e) {
                    console.error('Error parsing coach column order:', e);
                }
            }
            return coachColumnDefs.map(c => c.key);
        }
        
        // Save column order to localStorage
        function saveRiderColumnOrder(order) {
            localStorage.setItem('riderColumnOrder', JSON.stringify(order));
        }
        
        function saveCoachColumnOrder(order) {
            localStorage.setItem('coachColumnOrder', JSON.stringify(order));
        }
        
        // Load column widths from localStorage
        function getRiderColumnWidths() {
            const saved = localStorage.getItem('riderColumnWidths');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error parsing rider column widths:', e);
                }
            }
            return {};
        }
        
        function getCoachColumnWidths() {
            const saved = localStorage.getItem('coachColumnWidths');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error parsing coach column widths:', e);
                }
            }
            return {};
        }
        
        // Save column widths to localStorage
        function saveRiderColumnWidths(widths) {
            localStorage.setItem('riderColumnWidths', JSON.stringify(widths));
        }
        
        function saveCoachColumnWidths(widths) {
            localStorage.setItem('coachColumnWidths', JSON.stringify(widths));
        }
        
        // Calculate minimum width for a column based on content
        function calculateMinColumnWidth(type, key, order) {
            const items = type === 'rider' ? data.riders : data.coaches;
            if (!items || items.length === 0) {
                const def = type === 'rider' ? riderColumnDefs.find(c => c.key === key) : coachColumnDefs.find(c => c.key === key);
                return def ? parseInt(def.width.match(/\d+/)?.[0] || '100') : 100;
            }
            
            let maxWidth = 0;
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.whiteSpace = 'nowrap';
            tempDiv.style.fontSize = '14px';
            tempDiv.style.padding = '8px';
            document.body.appendChild(tempDiv);
            
            items.forEach(item => {
                let content = '';
                switch(key) {
                    case 'photo':
                        maxWidth = Math.max(maxWidth, 41);
                        break;
                    case 'name':
                        content = item.name || '';
                        break;
                    case 'phone':
                        content = formatPhoneForDisplay(item.phone || '');
                        break;
                    case 'gender':
                        content = (item.gender || 'M').toUpperCase();
                        break;
                    case 'grade':
                        content = formatGradeLabel(item.grade || '9th');
                        break;
                    case 'racingGroup':
                        content = item.racingGroup || '';
                        break;
                    case 'pace':
                        content = String(Math.max(1, Math.min(getFitnessScale(), parseInt(item.fitness || Math.ceil(getFitnessScale() / 2), 10))));
                        break;
                    case 'skills':
                        content = String(Math.max(1, Math.min(getSkillsScale(), parseInt(item.skills || Math.ceil(getSkillsScale() / 2), 10))));
                        break;
                    case 'level':
                        const levelRaw = item.coachingLicenseLevel || item.level || '1';
                        content = levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                        break;
                    case 'notes':
                        maxWidth = Math.max(maxWidth, 120);
                        break;
                    case 'actions':
                        maxWidth = Math.max(maxWidth, 100);
                        break;
                }
                if (content) {
                    tempDiv.textContent = content;
                    maxWidth = Math.max(maxWidth, tempDiv.offsetWidth);
                }
            });
            
            document.body.removeChild(tempDiv);
            
            // Add padding and ensure minimum
            return Math.max(maxWidth + 20, 80);
        }
        
        // Get grid template columns string based on order and widths
        function getRiderGridTemplate(order) {
            const widths = getRiderColumnWidths();
            return order.map((key, index) => {
                const def = riderColumnDefs.find(c => c.key === key);
                if (key === 'photo') {
                    return '41px'; // Photo column is fixed
                }
                if (widths[key]) {
                    return `${widths[key]}px`;
                }
                return def ? def.width : '1fr';
            }).join(' ');
        }
        
        function getCoachGridTemplate(order) {
            const widths = getCoachColumnWidths();
            return order.map((key, index) => {
                const def = coachColumnDefs.find(c => c.key === key);
                if (key === 'photo') {
                    return '41px'; // Photo column is fixed
                }
                if (widths[key]) {
                    return `${widths[key]}px`;
                }
                return def ? def.width : '1fr';
            }).join(' ');
        }
        
        // Column resizing handlers
        let resizingColumn = null;
        let resizingStartX = 0;
        let resizingStartWidth = 0;
        let resizingMinWidth = 0;
        let resizingHeaderElement = null;
        
        function handleColumnResizeStart(event, type, key) {
            event.preventDefault();
            event.stopPropagation();
            
            resizingColumn = { type, key };
            resizingStartX = event.clientX;
            resizingHeaderElement = event.target.closest('.roster-header');
            
            const order = type === 'rider' ? getRiderColumnOrder() : getCoachColumnOrder();
            const widths = type === 'rider' ? getRiderColumnWidths() : getCoachColumnWidths();
            const currentWidth = widths[key];
            
            if (currentWidth) {
                resizingStartWidth = currentWidth;
            } else {
                const def = type === 'rider' ? riderColumnDefs.find(c => c.key === key) : coachColumnDefs.find(c => c.key === key);
                const match = def.width.match(/(\d+)px/);
                resizingStartWidth = match ? parseInt(match[1]) : 200;
            }
            
            resizingMinWidth = calculateMinColumnWidth(type, key, order);
            
            document.addEventListener('mousemove', handleColumnResize);
            document.addEventListener('mouseup', handleColumnResizeEnd);
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        }
        
        function handleColumnResize(event) {
            if (!resizingColumn) return;
            
            const deltaX = event.clientX - resizingStartX;
            const newWidth = Math.max(resizingMinWidth, resizingStartWidth + deltaX);
            
            const widths = resizingColumn.type === 'rider' ? getRiderColumnWidths() : getCoachColumnWidths();
            widths[resizingColumn.key] = newWidth;
            
            if (resizingColumn.type === 'rider') {
                saveRiderColumnWidths(widths);
                renderRiders();
            } else {
                saveCoachColumnWidths(widths);
                renderCoaches();
            }
        }
        
        function handleColumnResizeEnd(event) {
            if (resizingColumn) {
                resizingColumn = null;
                resizingHeaderElement = null;
                document.removeEventListener('mousemove', handleColumnResize);
                document.removeEventListener('mouseup', handleColumnResizeEnd);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        }
        
        // Drag and drop handlers for column reordering
        let draggedColumnKey = null;
        let draggedColumnType = null;
        
        function handleColumnDragStart(event, type, key) {
            // Prevent dragging the name column (it's locked in position)
            if (key === 'name') {
                event.preventDefault();
                return false;
            }
            draggedColumnKey = key;
            draggedColumnType = type;
            event.dataTransfer.effectAllowed = 'move';
            event.target.style.opacity = '0.5';
        }
        
        function handleColumnDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const target = event.currentTarget;
            if (target !== event.target) {
                target.style.backgroundColor = '#e3f2fd';
            }
        }
        
        function handleColumnDrop(event, type, targetKey) {
            event.preventDefault();
            event.stopPropagation();
            
            // Prevent dropping on or moving the name column
            if (targetKey === 'name' || draggedColumnKey === 'name') {
                event.target.style.backgroundColor = '';
                return;
            }
            
            if (draggedColumnKey && draggedColumnType === type && draggedColumnKey !== targetKey) {
                // Prevent moving name column or dropping on name column
                if (draggedColumnKey === 'name' || targetKey === 'name') {
                    event.target.style.backgroundColor = '';
                    return;
                }
                
                let order = type === 'rider' ? getRiderColumnOrder() : getCoachColumnOrder();
                const draggedIndex = order.indexOf(draggedColumnKey);
                const targetIndex = order.indexOf(targetKey);
                
                // Ensure name column stays in its position (index 1, after photo)
                if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== 1 && targetIndex !== 1) {
                    // Remove dragged column from its position
                    order.splice(draggedIndex, 1);
                    // Insert at target position (but not at position 1 where name is)
                    const insertIndex = targetIndex > draggedIndex ? targetIndex - 1 : targetIndex;
                    if (insertIndex !== 1 && insertIndex !== 0) {
                        order.splice(insertIndex, 0, draggedColumnKey);
                    } else {
                        // If trying to insert at name position, insert after it
                        order.splice(2, 0, draggedColumnKey);
                    }
                    
                    // Save new order
                    if (type === 'rider') {
                        saveRiderColumnOrder(order);
                        renderRiders();
                    } else {
                        saveCoachColumnOrder(order);
                        renderCoaches();
                    }
                }
            }
            
            // Reset visual feedback
            event.target.style.backgroundColor = '';
        }
        
        function handleColumnDragEnd(event) {
            event.target.style.opacity = '';
            // Reset all header backgrounds
            const headers = document.querySelectorAll('.roster-header > div');
            headers.forEach(h => h.style.backgroundColor = '');
            draggedColumnKey = null;
            draggedColumnType = null;
        }
        
        // Group state for rosters
        let riderGroupBy = '';
        let coachGroupBy = '';

        function sortRiders(column) {
            // Toggle direction if clicking the same column
            if (riderSortColumn === column) {
                riderSortDirection = riderSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                riderSortColumn = column;
                riderSortDirection = 'asc';
            }
            renderRiders();
        }

        function sortCoaches(column) {
            // Toggle direction if clicking the same column
            if (coachSortColumn === column) {
                coachSortDirection = coachSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                coachSortColumn = column;
                coachSortDirection = 'asc';
            }
            renderCoaches();
        }

        function getSortableLastName(name) {
            if (!name) return '';
            const parts = name.trim().split(/\s+/);
            return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : (parts[0] || '').toLowerCase();
        }

        function getGradeSortValue(grade) {
            const gradeMap = { '9th': 1, '10th': 2, '11th': 3, '12th': 4 };
            return gradeMap[grade] || 0;
        }

        function getRacingGroupSortValue(racingGroup) {
            const groupOrder = {
                'Freshman Boys': 1, 'Freshman Girls': 1,
                'JV2 Boys': 2, 'JV2 Girls': 2,
                'JV1 Boys': 3, 'JV1 Girls': 3,
                'Varsity Boys': 4, 'Varsity Girls': 4
            };
            return groupOrder[racingGroup] || 99;
        }

        function groupRiders(groupBy) {
            riderGroupBy = groupBy || '';
            renderRiders();
        }

        function groupCoaches(groupBy) {
            coachGroupBy = groupBy || '';
            renderCoaches();
        }

        function getRiderGroupValue(rider, groupBy) {
            if (!groupBy) return '';
            switch (groupBy) {
                case 'name':
                    const lastName = getSortableLastName(rider.name || '');
                    return lastName ? lastName.charAt(0).toUpperCase() : 'Other';
                case 'gender':
                    return (rider.gender || 'M').toUpperCase();
                case 'grade':
                    return formatGradeLabel(rider.grade || '9th');
                case 'racingGroup':
                    return rider.racingGroup || 'No Group';
                case 'pace':
                    return `Fitness ${rider.fitness || '5'}`;
                case 'skills':
                    return `Bike Skills ${rider.skills || '2'}`;
                default:
                    return '';
            }
        }

        function getCoachGroupValue(coach, groupBy) {
            if (!groupBy) return '';
            switch (groupBy) {
                case 'name':
                    const lastName = getSortableLastName(coach.name || '');
                    return lastName ? lastName.charAt(0).toUpperCase() : 'Other';
                case 'level':
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    return levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                case 'pace':
                    return `Fitness ${coach.fitness || '5'}`;
                default:
                    return '';
            }
        }

        function renderRiders() {
            const list = document.getElementById('riders-list');
            if (data.riders.length === 0) {
                list.innerHTML = '<div class="empty-state">No riders yet. Click "Add Team Rider" below to get started.</div>';
                return;
            }
            
            // Sort riders
            let sortedRiders = [...data.riders];
            if (riderSortColumn) {
                sortedRiders.sort((a, b) => {
                    let aVal, bVal;
                    switch (riderSortColumn) {
                        case 'name':
                            const aLastName = getSortableLastName(a.name || '');
                            const bLastName = getSortableLastName(b.name || '');
                            if (aLastName !== bLastName) {
                                aVal = aLastName;
                                bVal = bLastName;
                            } else {
                                // If last names are equal, sort by first name
                                const aParts = (a.name || '').trim().split(/\s+/);
                                const bParts = (b.name || '').trim().split(/\s+/);
                                aVal = aParts[0] ? aParts[0].toLowerCase() : '';
                                bVal = bParts[0] ? bParts[0].toLowerCase() : '';
                            }
                            break;
                        case 'gender':
                            aVal = (a.gender || '').toUpperCase();
                            bVal = (b.gender || '').toUpperCase();
                            break;
                        case 'grade':
                            aVal = getGradeSortValue(a.grade || '9th');
                            bVal = getGradeSortValue(b.grade || '9th');
                            break;
                        case 'racingGroup':
                            aVal = getRacingGroupSortValue(a.racingGroup || '');
                            bVal = getRacingGroupSortValue(b.racingGroup || '');
                            if (aVal === bVal) {
                                // Secondary sort by name of group if same level
                                aVal = (a.racingGroup || '').toLowerCase();
                                bVal = (b.racingGroup || '').toLowerCase();
                            }
                            break;
                        case 'pace':
                            aVal = parseInt(a.fitness || '5', 10);
                            bVal = parseInt(b.fitness || '5', 10);
                            break;
                        case 'skills':
                            aVal = parseInt(a.skills || '2', 10);
                            bVal = parseInt(b.skills || '2', 10);
                            break;
                        default:
                            return 0;
                    }
                    
                    let comparison = 0;
                    if (aVal < bVal) comparison = -1;
                    if (aVal > bVal) comparison = 1;
                    
                    return riderSortDirection === 'asc' ? comparison : -comparison;
                });
            }
            
            const getSortIndicator = (column) => {
                if (riderSortColumn !== column) {
                    return '<span class="sort-indicator">‚áÖ</span>';
                }
                return riderSortDirection === 'asc' 
                    ? '<span class="sort-indicator active">‚Üë</span>' 
                    : '<span class="sort-indicator active">‚Üì</span>';
            };
            
            // Get column order
            const columnOrder = getRiderColumnOrder();
            const gridTemplate = getRiderGridTemplate(columnOrder);
            
            // Build header cells in order
            const headerCells = columnOrder.map(key => {
                const def = riderColumnDefs.find(c => c.key === key);
                if (!def) return '<div></div>';
                
                let content = '';
                // Name column is not draggable (locked in position)
                const isDraggable = key !== 'name';
                const draggableAttr = isDraggable ? 'draggable="true"' : 'draggable="false"';
                const dragHandlers = isDraggable ? `ondragstart="handleColumnDragStart(event, 'rider', '${key}')" ondragover="handleColumnDragOver(event)" ondrop="handleColumnDrop(event, 'rider', '${key}')" ondragend="handleColumnDragEnd(event)"` : '';
                
                // Add resize handle for resizable columns (not photo, not actions)
                const resizeHandle = (key !== 'photo' && key !== 'actions') ? `<div class="column-resize-handle" onmousedown="handleColumnResizeStart(event, 'rider', '${key}')"></div>` : '';
                
                if (def.sortable) {
                    content = `<div class="roster-header-sortable" style="position: relative;" onclick="sortRiders('${key === 'name' ? 'name' : key === 'pace' ? 'pace' : key === 'skills' ? 'skills' : key}')" ${draggableAttr} ${dragHandlers}>${def.label} ${getSortIndicator(key === 'name' ? 'name' : key === 'pace' ? 'pace' : key === 'skills' ? 'skills' : key)}${resizeHandle}</div>`;
                } else {
                    content = `<div style="position: relative;" ${draggableAttr} ${dragHandlers}>${def.label}${resizeHandle}</div>`;
                }
                return content;
            });
            
            const header = `
                <div class="roster-header rider-grid-template" style="grid-template-columns: ${gridTemplate};">
                    ${headerCells.join('')}
                </div>
            `;

            // Group riders if grouping is enabled
            let groupedRiders = [];
            if (riderGroupBy) {
                const groups = new Map();
                sortedRiders.forEach(rider => {
                    const groupValue = getRiderGroupValue(rider, riderGroupBy);
                    if (!groups.has(groupValue)) {
                        groups.set(groupValue, []);
                    }
                    groups.get(groupValue).push(rider);
                });
                
                // Sort group keys
                const sortedGroupKeys = Array.from(groups.keys()).sort((a, b) => {
                    if (riderGroupBy === 'name') {
                        return a.localeCompare(b);
                    } else if (riderGroupBy === 'grade') {
                        return getGradeSortValue(a) - getGradeSortValue(b);
                    } else if (riderGroupBy === 'racingGroup') {
                        return getRacingGroupSortValue(a) - getRacingGroupSortValue(b);
                    } else if (riderGroupBy === 'pace') {
                        const aPace = parseInt(a.replace('Pace ', '') || '5', 10);
                        const bPace = parseInt(b.replace('Pace ', '') || '5', 10);
                        return aPace - bPace;
                    } else if (riderGroupBy === 'skills') {
                        const aSkills = parseInt(a.replace('Bike Skills ', '').replace('Skills ', '') || '2', 10);
                        const bSkills = parseInt(b.replace('Skills ', '') || '2', 10);
                        return aSkills - bSkills;
                    }
                    return a.localeCompare(b);
                });
                
                sortedGroupKeys.forEach(groupKey => {
                    groupedRiders.push({ type: 'header', value: groupKey });
                    groups.get(groupKey).forEach(rider => {
                        groupedRiders.push({ type: 'rider', data: rider });
                    });
                });
            } else {
                sortedRiders.forEach(rider => {
                    groupedRiders.push({ type: 'rider', data: rider });
                });
            }

            let htmlContent = header;
            groupedRiders.forEach(item => {
                if (item.type === 'header') {
                    // Convert gender values to display labels
                    let displayValue = item.value;
                    if (riderGroupBy === 'gender') {
                        if (item.value === 'F') {
                            displayValue = 'Girls';
                        } else if (item.value === 'M') {
                            displayValue = 'Boys';
                        }
                    }
                    htmlContent += `<div class="roster-group-header">${escapeHtml(displayValue)}</div>`;
                } else {
                    const rider = item.data;
                    const fitnessScale = getFitnessScale();
                    const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
                    const photoMarkup = rider.photo
                        ? `<img src="${escapeHtml(rider.photo)}" alt="${escapeHtml(rider.name || 'Rider')}">`
                        : `<span class="photo-placeholder">üë§</span>`;

                    const gradeValue = formatGradeLabel(rider.grade);
                    const racingValue = rider.racingGroup || '';
                    const genderValue = (rider.gender || 'M').toUpperCase();
                    const hasNotes = rider.notes && rider.notes.trim().length > 0;
                    const notesIcon = hasNotes ? `<span class="notes-icon" onclick="showNotesModal(${rider.id}, 'rider')" title="View notes">üìù</span>` : '';

                    // Build row cells in column order
                    const rowCells = columnOrder.map(key => {
                        switch(key) {
                            case 'photo':
                                return `<div class="roster-photo" style="position: relative;">
                                    ${photoMarkup}
                                    <div class="photo-edit-overlay">
                                        <span class="photo-edit-icon">‚úèÔ∏è</span>
                                    </div>
                                    <input type="file" id="rider-photo-input-${rider.id}" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleRiderPhotoUpload(${rider.id}, this)">
                                </div>`;
                            case 'name':
                                const riderRole = getRiderRole(rider.id);
                                const riderNameDisplay = riderRole 
                                    ? `${escapeHtml(rider.name || '')} <span style="font-style: italic; color: #666; margin-left: 8px; font-weight: normal;">${escapeHtml(riderRole)}</span>`
                                    : escapeHtml(rider.name || '');
                                return `<div class="roster-cell roster-name" data-label="Name">
                                    ${riderNameDisplay}
                                    ${rider.phone ? `<a href="${formatPhoneForTel(rider.phone)}" class="roster-phone-icon" title="Call ${formatPhoneForDisplay(rider.phone)}" aria-label="Call ${formatPhoneForDisplay(rider.phone)}">üìû</a>` : ''}
                                </div>`;
                            case 'phone':
                                return `<div class="roster-cell" data-label="Phone">
                                    ${formatPhoneForDisplay(rider.phone || '')}
                                </div>`;
                            case 'gender':
                                return `<div class="roster-cell" data-label="Gender">
                                    ${escapeHtml(genderValue)}
                                </div>`;
                            case 'grade':
                                return `<div class="roster-cell" data-label="Grade">
                                    ${escapeHtml(gradeValue)}
                                </div>`;
                            case 'racingGroup':
                                return `<div class="roster-cell" data-label="Racing Group">
                                    ${escapeHtml(racingValue)}
                                </div>`;
                            case 'pace':
                                return `<div class="roster-cell" data-label="Pace">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustRiderPace(${rider.id}, -1)">‚ñº</span>
                                        <span class="pace-value">${fitnessValue}</span>
                                        <span class="pace-arrow" onclick="adjustRiderPace(${rider.id}, 1)">‚ñ≤</span>
                                    </div>
                                </div>`;
                            case 'skills':
                                return `<div class="roster-cell" data-label="Bike Skills">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustRiderSkills(${rider.id}, -1)">‚ñº</span>
                                        <span class="pace-value">${(() => {
                                            const skillsScale = getSkillsScale();
                                            return Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
                                        })()}</span>
                                        <span class="pace-arrow" onclick="adjustRiderSkills(${rider.id}, 1)">‚ñ≤</span>
                                    </div>
                                </div>`;
                            case 'notes':
                                return `<div class="roster-cell" data-label="Notes">
                                    ${notesIcon}
                                </div>`;
                            case 'actions':
                                return `<div class="roster-actions">
                                    <button class="btn-small" onclick="openEditRiderModal(${rider.id})">Edit Record</button>
                                </div>`;
                            default:
                                return '<div></div>';
                        }
                    });
                    
                    htmlContent += `
                        <div class="roster-row rider-grid-template" data-rider-id="${rider.id}" style="grid-template-columns: ${gridTemplate};">
                            ${rowCells.join('')}
                        </div>
                    `;
                }
            });
            list.innerHTML = htmlContent;
        }

        // Coach management
        async function addCoach() {
            if (!canEditCoaches()) {
                alert('You do not have permission to add coaches');
                return;
            }

            const name = document.getElementById('coach-name').value.trim();
            const phone = document.getElementById('coach-phone').value.trim();
            const level = document.getElementById('coach-level').value;
            const fitnessInput = document.getElementById('coach-fitness').value;
            const notes = document.getElementById('coach-notes').value.trim();
            
            if (!name) {
                alert('Please enter a coach name');
                return;
            }

            const fitnessValue = Math.max(1, Math.min(10, parseInt(fitnessInput || '5', 10)));

            // Read photo (readPhotoFile returns a Promise)
            const photo = await readPhotoFile('coach-photo');
            
            const coachData = {
                name,
                photo,
                phone,
                level,
                fitness: String(fitnessValue),
                notes
            };

            saveCoachToDB(coachData);
            resetCoachForm();
            renderCoaches();
        }

        function resetCoachForm() {
            document.getElementById('coach-photo').value = '';
            document.getElementById('coach-name').value = '';
            document.getElementById('coach-phone').value = '';
            document.getElementById('coach-level').value = '1';
            document.getElementById('coach-fitness').value = '5';
            document.getElementById('coach-notes').value = '';
            handleFileChange('coach-photo', 'coach-photo-name');
        }

        async function deleteCoach(id) {
            if (!canEditCoaches()) {
                alert('You do not have permission to delete coaches');
                return;
            }

            if (confirm('Delete this coach?')) {
                // Remove from coaches array
                data.coaches = data.coaches.filter(c => c.id !== id);
                
                // Also update any rides that reference this coach
                for (const ride of data.rides) {
                    if (ride.availableCoaches && ride.availableCoaches.includes(id)) {
                        ride.availableCoaches = ride.availableCoaches.filter(coachId => coachId !== id);
                        // Update groups if needed
                        if (ride.groups) {
                            ride.groups.forEach(group => {
                                if (group.coaches) {
                                    Object.keys(group.coaches).forEach(key => {
                                        if (group.coaches[key] === id) {
                                            group.coaches[key] = null;
                                        }
                                    });
                                    // Also check extraRoam array
                                    if (Array.isArray(group.coaches.extraRoam)) {
                                        group.coaches.extraRoam = group.coaches.extraRoam.filter(coachId => coachId !== id);
                                    }
                                }
                            });
                        }
                        saveRideToDB(ride);
                    }
                }
                
                saveData();
                renderCoaches();
                if (data.currentRide) {
                    renderRides();
                }
            }
        }

        function renderCoaches() {
            const list = document.getElementById('coaches-list');
            if (data.coaches.length === 0) {
                list.innerHTML = '<div class="empty-state">No coaches yet. Click "Add Coach" below to get started.</div>';
                return;
            }
            
            // Separate coaches with roles from those without
            const coachesWithRoles = [];
            const coachesWithoutRoles = [];
            
            data.coaches.forEach(coach => {
                if (getCoachRole(coach.id)) {
                    coachesWithRoles.push(coach);
                } else {
                    coachesWithoutRoles.push(coach);
                }
            });
            
            // Sort coaches
            let sortedCoachesWithRoles = [...coachesWithRoles];
            let sortedCoachesWithoutRoles = [...coachesWithoutRoles];
            
            const sortCoachesArray = (coaches) => {
                if (!coachSortColumn) return coaches;
                return [...coaches].sort((a, b) => {
                    let aVal, bVal;
                    switch (coachSortColumn) {
                        case 'name':
                            const aLastName = getSortableLastName(a.name || '');
                            const bLastName = getSortableLastName(b.name || '');
                            if (aLastName !== bLastName) {
                                aVal = aLastName;
                                bVal = bLastName;
                            } else {
                                // If last names are equal, sort by first name
                                const aParts = (a.name || '').trim().split(/\s+/);
                                const bParts = (b.name || '').trim().split(/\s+/);
                                aVal = aParts[0] ? aParts[0].toLowerCase() : '';
                                bVal = bParts[0] ? bParts[0].toLowerCase() : '';
                            }
                            break;
                        case 'level':
                            // Support both old 'level' and new 'coachingLicenseLevel' fields
                            const aLevelRaw = a.coachingLicenseLevel || a.level || '1';
                            const bLevelRaw = b.coachingLicenseLevel || b.level || '1';
                            // Handle N/A as 0 for sorting
                            aVal = (aLevelRaw === 'N/A' || aLevelRaw === 'NA') ? 0 : parseInt(aLevelRaw, 10);
                            bVal = (bLevelRaw === 'N/A' || bLevelRaw === 'NA') ? 0 : parseInt(bLevelRaw, 10);
                            break;
                        case 'pace':
                            aVal = parseInt(a.fitness || '5', 10);
                            bVal = parseInt(b.fitness || '5', 10);
                            break;
                        case 'skills':
                            const skillsScale = getSkillsScale();
                            aVal = Math.max(1, Math.min(skillsScale, parseInt(a.skills || Math.ceil(skillsScale / 2), 10)));
                            bVal = Math.max(1, Math.min(skillsScale, parseInt(b.skills || Math.ceil(skillsScale / 2), 10)));
                            break;
                        default:
                            return 0;
                    }
                    
                    let comparison = 0;
                    if (aVal < bVal) comparison = -1;
                    if (aVal > bVal) comparison = 1;
                    
                    return coachSortDirection === 'asc' ? comparison : -comparison;
                });
            };
            
            sortedCoachesWithRoles = sortCoachesArray(sortedCoachesWithRoles);
            sortedCoachesWithoutRoles = sortCoachesArray(sortedCoachesWithoutRoles);
            
            // Combine: role coaches first, then others
            const sortedCoaches = [...sortedCoachesWithRoles, ...sortedCoachesWithoutRoles];
            
            const getSortIndicator = (column) => {
                if (coachSortColumn !== column) {
                    return '<span class="sort-indicator">‚áÖ</span>';
                }
                return coachSortDirection === 'asc' 
                    ? '<span class="sort-indicator active">‚Üë</span>' 
                    : '<span class="sort-indicator active">‚Üì</span>';
            };
            
            // Get column order
            const columnOrder = getCoachColumnOrder();
            const gridTemplate = getCoachGridTemplate(columnOrder);
            
            // Build header cells in order
            const headerCells = columnOrder.map(key => {
                const def = coachColumnDefs.find(c => c.key === key);
                if (!def) return '<div></div>';
                
                // Name column is not draggable (locked in position)
                const isDraggable = key !== 'name';
                const draggableAttr = isDraggable ? 'draggable="true"' : 'draggable="false"';
                const dragHandlers = isDraggable ? `ondragstart="handleColumnDragStart(event, 'coach', '${key}')" ondragover="handleColumnDragOver(event)" ondrop="handleColumnDrop(event, 'coach', '${key}')" ondragend="handleColumnDragEnd(event)"` : '';
                
                // Add resize handle for resizable columns (not photo, not actions)
                const resizeHandle = (key !== 'photo' && key !== 'actions') ? `<div class="column-resize-handle" onmousedown="handleColumnResizeStart(event, 'coach', '${key}')"></div>` : '';
                
                let content = '';
                if (def.sortable) {
                    const sortKey = key === 'level' ? 'level' : key === 'pace' ? 'pace' : 'name';
                    content = `<div class="roster-header-sortable" style="position: relative;" onclick="sortCoaches('${sortKey}')" ${draggableAttr} ${dragHandlers}>${def.label} ${getSortIndicator(sortKey)}${resizeHandle}</div>`;
                } else {
                    content = `<div style="position: relative;" ${draggableAttr} ${dragHandlers}>${def.label}${resizeHandle}</div>`;
                }
                return content;
            });
            
            const header = `
                <div class="roster-header coach-grid-template" style="grid-template-columns: ${gridTemplate};">
                    ${headerCells.join('')}
                </div>
            `;

            // Group coaches if grouping is enabled
            let groupedCoaches = [];
            if (coachGroupBy) {
                const groups = new Map();
                // Use sortedCoaches which was created above
                sortedCoaches.forEach(coach => {
                    const groupValue = getCoachGroupValue(coach, coachGroupBy);
                    if (!groups.has(groupValue)) {
                        groups.set(groupValue, []);
                    }
                    groups.get(groupValue).push(coach);
                });
                
                // Sort group keys
                const sortedGroupKeys = Array.from(groups.keys()).sort((a, b) => {
                    if (coachGroupBy === 'name') {
                        return a.localeCompare(b);
                    } else if (coachGroupBy === 'level') {
                        const aLevel = parseInt(a.replace('Level ', '') || '1', 10);
                        const bLevel = parseInt(b.replace('Level ', '') || '1', 10);
                        return aLevel - bLevel;
                    } else if (coachGroupBy === 'pace') {
                        const aPace = parseInt(a.replace('Pace ', '') || '5', 10);
                        const bPace = parseInt(b.replace('Pace ', '') || '5', 10);
                        return aPace - bPace;
                    }
                    return a.localeCompare(b);
                });
                
                sortedGroupKeys.forEach(groupKey => {
                    groupedCoaches.push({ type: 'header', value: groupKey });
                    groups.get(groupKey).forEach(coach => {
                        groupedCoaches.push({ type: 'coach', data: coach });
                    });
                });
            } else {
                sortedCoaches.forEach(coach => {
                    groupedCoaches.push({ type: 'coach', data: coach });
                });
            }

            let htmlContent = header;
            let isFirstNonRoleCoach = true;
            let hasRoleCoaches = sortedCoachesWithRoles.length > 0;
            let lastItemWasRoleCoach = false;
            groupedCoaches.forEach((item, index) => {
                if (item.type === 'header') {
                    htmlContent += `<div class="roster-group-header">${escapeHtml(item.value)}</div>`;
                    lastItemWasRoleCoach = false;
                } else {
                    const coach = item.data;
                    // Check if this is the first coach without a role (after role coaches)
                    const hasRole = getCoachRole(coach.id);
                    if (hasRoleCoaches && !hasRole && isFirstNonRoleCoach) {
                        htmlContent += `<div style="grid-column: 1 / -1; height: 1px; background: #ddd; margin: 12px 0;"></div>`;
                        isFirstNonRoleCoach = false;
                    }
                    lastItemWasRoleCoach = hasRole;
                    // Support both old 'level' and new 'coachingLicenseLevel' fields
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    const levelNum = levelRaw === 'N/A' ? 0 : parseInt(levelRaw || '1', 10);
                    
                    // Determine photo - use uploaded photo or default based on gender
                    let photoSrc = coach.photo;
                    if (!photoSrc || (!photoSrc.startsWith('data:') && !photoSrc.startsWith('http') && !photoSrc.startsWith('assets/'))) {
                        const gender = coach.gender || '';
                        if (gender === 'M') photoSrc = 'assets/male_default.png';
                        else if (gender === 'F') photoSrc = 'assets/female_default.png';
                        else photoSrc = 'assets/nonbinary_default.png';
                    }
                    const photoMarkup = photoSrc
                        ? `<img src="${escapeHtml(photoSrc)}" alt="${escapeHtml(coach.name || 'Coach')}">`
                        : `<span class="photo-placeholder">üö¥</span>`;
                    const fitnessScale = getFitnessScale();
                    const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
                    const levelLabel = levelRaw === 'N/A' ? 'N/A' : `Level ${levelRaw}`;
                    const hasNotes = coach.notes && coach.notes.trim().length > 0;
                    const notesIcon = hasNotes ? `<span class="notes-icon" onclick="showNotesModal(${coach.id}, 'coach')" title="View notes">üìù</span>` : '';
                    const levelClass = levelRaw === 'N/A' || levelNum === 0 ? 'coach-level-na' : levelNum === 1 ? 'coach-level-1' : levelNum === 2 ? 'coach-level-2' : levelNum === 3 ? 'coach-level-3' : '';

                    // Build row cells in column order
                    const rowCells = columnOrder.map(key => {
                        switch(key) {
                            case 'photo':
                                return `<div class="roster-photo" style="position: relative;">
                                    ${photoMarkup}
                                    <div class="photo-edit-overlay">
                                        <span class="photo-edit-icon">‚úèÔ∏è</span>
                                    </div>
                                    <input type="file" id="coach-photo-input-${coach.id}" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" onchange="handleCoachPhotoUpload(${coach.id}, this)">
                                </div>`;
                            case 'name':
                                const coachRole = getCoachRole(coach.id);
                                const coachNameDisplay = coachRole 
                                    ? `${escapeHtml(coach.name || '')} <span style="font-style: italic; color: #666; margin-left: 8px; font-weight: normal;">${escapeHtml(coachRole)}</span>`
                                    : escapeHtml(coach.name || '');
                                return `<div class="roster-cell roster-name" data-label="Name">
                                    ${coachNameDisplay}
                                    ${coach.phone ? `<a href="${formatPhoneForTel(coach.phone)}" class="roster-phone-icon coach-phone-icon" title="Call ${formatPhoneForDisplay(coach.phone)}" aria-label="Call ${formatPhoneForDisplay(coach.phone)}">üìû</a>` : ''}
                                </div>`;
                            case 'phone':
                                return `<div class="roster-cell" data-label="Phone">
                                    ${formatPhoneForDisplay(coach.phone || '')}
                                </div>`;
                            case 'level':
                                return `<div class="roster-cell" data-label="Coach Level">
                                    ${escapeHtml(levelLabel)}
                                </div>`;
                            case 'pace':
                                return `<div class="roster-cell" data-label="Pace">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustCoachPace(${coach.id}, -1)">‚ñº</span>
                                        <span class="pace-value">${fitnessValue}</span>
                                        <span class="pace-arrow" onclick="adjustCoachPace(${coach.id}, 1)">‚ñ≤</span>
                                    </div>
                                </div>`;
                            case 'skills':
                                const skillsScale = getSkillsScale();
                                const skillsValue = Math.max(1, Math.min(skillsScale, parseInt(coach.skills || Math.ceil(skillsScale / 2), 10)));
                                return `<div class="roster-cell" data-label="Bike Skills">
                                    <div class="pace-controls">
                                        <span class="pace-arrow" onclick="adjustCoachSkills(${coach.id}, -1)">‚ñº</span>
                                        <span class="pace-value">${skillsValue}</span>
                                        <span class="pace-arrow" onclick="adjustCoachSkills(${coach.id}, 1)">‚ñ≤</span>
                                    </div>
                                </div>`;
                            case 'notes':
                                return `<div class="roster-cell" data-label="Notes">
                                    ${notesIcon}
                                </div>`;
                            case 'actions':
                                return `<div class="roster-actions">
                                    <button class="btn-small" onclick="openEditCoachModal(${coach.id})">Edit Record</button>
                                </div>`;
                            default:
                                return '<div></div>';
                        }
                    });
                    
                    htmlContent += `
                        <div class="roster-row coach-grid-template ${levelClass}" data-coach-id="${coach.id}" style="grid-template-columns: ${gridTemplate};">
                            ${rowCells.join('')}
                        </div>
                    `;
                }
            });
            list.innerHTML = htmlContent;
        }

        // Ride management
        async function createRide() {
            if (!canCreateEditRides()) {
                alert('You do not have permission to create rides');
                return;
            }

            const date = document.getElementById('ride-date').value;
            
            if (!date) {
                alert('Please select a date');
                return;
            }
            
            const rideData = {
                date: date,
                availableCoaches: [],
                availableRiders: [],
                assignments: {},
                groups: []
            };

            try {
                const newRide = saveRideToDB(rideData);
                data.currentRide = newRide.id;
                document.getElementById('ride-date').value = '';
                renderRides();
                loadCurrentRide();
            } catch (error) {
                console.error('Error creating ride:', error);
                alert('Error creating ride: ' + (error.message || 'Unknown error'));
            }
        }

        let currentEditingCoachId = null;

        function openEditCoachModal(id) {
            const coach = data.coaches.find(c => c.id === id);
            if (!coach) return;

            currentEditingCoachId = id;
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-coach-modal-title');
            if (titleEl) titleEl.textContent = 'Edit Coach';
            
            const deleteBtn = document.getElementById('delete-coach-btn');
            if (deleteBtn) deleteBtn.style.display = 'block';

            // Populate name fields (prefer explicit first/last if present, otherwise split full name)
            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            const coachFullName = coach.name || '';
            let coachFirstName = coach.firstName || '';
            let coachLastName = coach.lastName || '';
            if (!coachFirstName && !coachLastName && coachFullName) {
                const nameParts = coachFullName.trim().split(' ');
                if (nameParts.length > 1) {
                    coachLastName = nameParts.pop();
                    coachFirstName = nameParts.join(' ');
                } else {
                    coachFirstName = coachFullName;
                }
            }
            if (coachFirstNameInput) coachFirstNameInput.value = coachFirstName || '';
            if (coachLastNameInput) coachLastNameInput.value = coachLastName || '';
            
            // Format phone number
            const coachPhone = (coach.phone || '').replace(/\D/g, '');
            if (coachPhone.length === 10) {
                const formattedPhone = `(${coachPhone.substring(0, 3)}) ${coachPhone.substring(3, 6)}-${coachPhone.substring(6, 10)}`;
                document.getElementById('edit-coach-phone').value = formattedPhone;
            } else if (coach.phone) {
                document.getElementById('edit-coach-phone').value = formatPhoneForDisplay(coach.phone);
            } else {
                document.getElementById('edit-coach-phone').value = '';
            }
            
            // Populate all CSV fields
            document.getElementById('edit-coach-email').value = coach.email || '';
            
            // Format work phone
            const workPhone = (coach.workPhone || '').replace(/\D/g, '');
            if (workPhone.length === 10) {
                document.getElementById('edit-coach-work-phone').value = `(${workPhone.substring(0, 3)}) ${workPhone.substring(3, 6)}-${workPhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-coach-work-phone').value = coach.workPhone || '';
            }
            
            // Format home phone
            const homePhone = (coach.homePhone || '').replace(/\D/g, '');
            if (homePhone.length === 10) {
                document.getElementById('edit-coach-home-phone').value = `(${homePhone.substring(0, 3)}) ${homePhone.substring(3, 6)}-${homePhone.substring(6, 10)}`;
            } else {
                document.getElementById('edit-coach-home-phone').value = coach.homePhone || '';
            }
            
            document.getElementById('edit-coach-gender').value = coach.gender || '';
            
            // Support both old 'level' and new 'coachingLicenseLevel' fields
            const coachLevel = coach.coachingLicenseLevel || coach.level || '1';
            document.getElementById('edit-coach-level').value = coachLevel;
            
            document.getElementById('edit-coach-registered').value = coach.registered || '';
            document.getElementById('edit-coach-paid').value = coach.paid || '';
            document.getElementById('edit-coach-background-check').value = coach.backgroundCheck || '';
            document.getElementById('edit-coach-level3-exam').value = coach.level3ExamCompleted || '';
            document.getElementById('edit-coach-pdu-ceu').value = coach.pduCeuUnits || '';
            document.getElementById('edit-coach-field-work-hours').value = coach.fieldWorkHours || '';
            document.getElementById('edit-coach-first-aid').value = coach.firstAidTypeExpires || '';
            document.getElementById('edit-coach-cpr-expires').value = coach.cprExpires || '';
            document.getElementById('edit-coach-concussion-training').value = coach.concussionTrainingCompleted || '';
            document.getElementById('edit-coach-nica-philosophy').value = coach.nicaPhilosophyCompleted || '';
            document.getElementById('edit-coach-abuse-awareness').value = coach.athleteAbuseAwarenessCompleted || '';
            document.getElementById('edit-coach-license-level1').value = coach.licenseLevel1Completed || '';
            document.getElementById('edit-coach-license-level2').value = coach.licenseLevel2Completed || '';
            document.getElementById('edit-coach-license-level3').value = coach.licenseLevel3Completed || '';
            document.getElementById('edit-coach-otb-classroom').value = coach.otbSkills101ClassroomCompleted || '';
            document.getElementById('edit-coach-otb-outdoor').value = coach.otbSkills101OutdoorCompleted || '';
            document.getElementById('edit-coach-nica-summit').value = coach.nicaLeaderSummitCompleted || '';
            
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-coach-fitness').value = Math.max(1, Math.min(fitnessScale, parseInt(coach.fitness || Math.ceil(fitnessScale / 2), 10)));
            document.getElementById('edit-coach-skills').value = Math.max(1, Math.min(skillsScale, parseInt(coach.skills || Math.ceil(skillsScale / 2), 10)));
            document.getElementById('edit-coach-notes').value = coach.notes || '';

            // Update photo preview
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            if (coach.photo) {
                photoPreview.src = coach.photo;
                photoPreview.style.display = 'block';
                photoPlaceholder.style.display = 'none';
            } else {
                photoPreview.style.display = 'none';
                photoPlaceholder.style.display = 'flex';
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function openAddCoachModal() {
            currentEditingCoachId = null;
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;

            const titleEl = document.getElementById('edit-coach-modal-title');
            if (titleEl) titleEl.textContent = 'Add Coach';
            
            const deleteBtn = document.getElementById('delete-coach-btn');
            if (deleteBtn) deleteBtn.style.display = 'none';

            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            if (coachFirstNameInput) coachFirstNameInput.value = '';
            if (coachLastNameInput) coachLastNameInput.value = '';
            document.getElementById('edit-coach-phone').value = '';
            document.getElementById('edit-coach-level').value = 'N/A';
            const fitnessScale = getFitnessScale();
            const skillsScale = getSkillsScale();
            document.getElementById('edit-coach-fitness').value = Math.ceil(fitnessScale / 2);
            document.getElementById('edit-coach-skills').value = Math.ceil(skillsScale / 2);
            document.getElementById('edit-coach-notes').value = '';

            // Reset photo preview
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            photoPreview.style.display = 'none';
            photoPlaceholder.style.display = 'flex';
            document.getElementById('edit-coach-photo-input').value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeEditCoachModal() {
            const modal = document.getElementById('edit-coach-modal');
            if (!modal) return;
            // Blur any focused elements before hiding modal to avoid aria-hidden warning
            const focusedElement = document.activeElement;
            if (focusedElement && modal.contains(focusedElement)) {
                focusedElement.blur();
            }
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentEditingCoachId = null;
        }

        async function saveCoachFromModal() {
            // Permission check - allow if canEditCoaches exists, otherwise allow by default
            if (typeof canEditCoaches === 'function' && !canEditCoaches()) {
                alert('You do not have permission to edit coach records');
                return;
            }

            const coachFirstNameInput = document.getElementById('edit-coach-first-name');
            const coachLastNameInput = document.getElementById('edit-coach-last-name');
            const firstName = coachFirstNameInput ? coachFirstNameInput.value.trim() : '';
            const lastName = coachLastNameInput ? coachLastNameInput.value.trim() : '';
            const name = `${firstName} ${lastName}`.trim();
            if (!firstName && !lastName) {
                alert('Please enter a coach first or last name');
                return;
            }

            const phoneInput = document.getElementById('edit-coach-phone').value.trim();
            const phoneDigits = phoneInput.replace(/\D/g, '');
            
            if (phoneDigits.length !== 10) {
                alert('Please enter a valid 10-digit phone number');
                return;
            }
            
            const phone = phoneDigits; // Store as digits only
            const levelValue = document.getElementById('edit-coach-level').value;
            const fitnessInput = document.getElementById('edit-coach-fitness').value;
            const notes = document.getElementById('edit-coach-notes').value.trim();

            const fitnessScale = getFitnessScale();
            const fitnessValue = Math.max(1, Math.min(fitnessScale, parseInt(fitnessInput || Math.ceil(fitnessScale / 2), 10)));
            const coachingLicenseLevel = ['1', '2', '3', 'N/A'].includes(levelValue) ? levelValue : 'N/A';

            // Get photo from preview or input
            let photo = '';
            const photoPreview = document.getElementById('edit-coach-photo-preview');
            if (photoPreview.style.display !== 'none' && photoPreview.src) {
                photo = photoPreview.src;
            } else {
                // If no photo uploaded, use default based on gender
                const gender = coach?.gender || '';
                if (gender === 'M') photo = 'assets/male_default.png';
                else if (gender === 'F') photo = 'assets/female_default.png';
                else photo = 'assets/nonbinary_default.png';
            }

            // Get all CSV fields
            const email = document.getElementById('edit-coach-email').value.trim();
            const workPhoneInput = document.getElementById('edit-coach-work-phone').value.trim();
            const workPhoneDigits = workPhoneInput.replace(/\D/g, '');
            const workPhone = workPhoneDigits.length === 10 ? workPhoneDigits : '';
            const homePhoneInput = document.getElementById('edit-coach-home-phone').value.trim();
            const homePhoneDigits = homePhoneInput.replace(/\D/g, '');
            const homePhone = homePhoneDigits.length === 10 ? homePhoneDigits : '';
            const gender = document.getElementById('edit-coach-gender').value || '';
            
            const coachData = {
                name,
                firstName,
                lastName,
                phone,
                photo,
                email,
                workPhone,
                homePhone,
                gender,
                coachingLicenseLevel,
                registered: document.getElementById('edit-coach-registered').value.trim(),
                paid: document.getElementById('edit-coach-paid').value.trim(),
                backgroundCheck: document.getElementById('edit-coach-background-check').value.trim(),
                level3ExamCompleted: document.getElementById('edit-coach-level3-exam').value.trim(),
                pduCeuUnits: document.getElementById('edit-coach-pdu-ceu').value.trim(),
                fieldWorkHours: document.getElementById('edit-coach-field-work-hours').value.trim(),
                firstAidTypeExpires: document.getElementById('edit-coach-first-aid').value.trim(),
                cprExpires: document.getElementById('edit-coach-cpr-expires').value.trim(),
                concussionTrainingCompleted: document.getElementById('edit-coach-concussion-training').value.trim(),
                nicaPhilosophyCompleted: document.getElementById('edit-coach-nica-philosophy').value.trim(),
                athleteAbuseAwarenessCompleted: document.getElementById('edit-coach-abuse-awareness').value.trim(),
                licenseLevel1Completed: document.getElementById('edit-coach-license-level1').value.trim(),
                licenseLevel2Completed: document.getElementById('edit-coach-license-level2').value.trim(),
                licenseLevel3Completed: document.getElementById('edit-coach-license-level3').value.trim(),
                otbSkills101ClassroomCompleted: document.getElementById('edit-coach-otb-classroom').value.trim(),
                otbSkills101OutdoorCompleted: document.getElementById('edit-coach-otb-outdoor').value.trim(),
                nicaLeaderSummitCompleted: document.getElementById('edit-coach-nica-summit').value.trim(),
                fitness: String(fitnessValue),
                skills: String(skillsValue),
                notes
            };

            // Note: Permission checks removed - all users can edit coach data in localStorage mode

            if (currentEditingCoachId) {
                coachData.id = currentEditingCoachId;
            }

            try {
                saveCoachToDB(coachData);
                renderCoaches();
                closeEditCoachModal();
                if (data.currentRide) {
                    const ride = data.rides.find(r => r.id === data.currentRide);
                    if (ride) {
                        renderAssignments(ride);
                    }
                }
            } catch (error) {
                console.error('Error saving coach:', error);
                alert('Error saving coach: ' + (error.message || 'Unknown error'));
            }
        }

        async function handleCoachPhotoUploadInModal(input) {
            if (!input.files || input.files.length === 0) return;
            
            const photo = await readPhotoFileFromInput(input);
            if (!photo) return;

            const photoPreview = document.getElementById('edit-coach-photo-preview');
            const photoPlaceholder = document.getElementById('edit-coach-photo-placeholder');
            
            photoPreview.src = photo;
            photoPreview.style.display = 'block';
            photoPlaceholder.style.display = 'none';
        }

        function deleteCoachFromModal() {
            if (!currentEditingCoachId) return;
            if (!confirm('Delete this coach?')) return;
            
            deleteCoach(currentEditingCoachId);
            closeEditCoachModal();
        }

        function getValidPracticeDates() {
            // Returns a Set of valid practice date strings (ISO format) that match the calendar
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            const validDates = new Set();
            let seasonStart = null;
            let seasonEnd = null;
            
            // If season dates are set, use them; otherwise determine from individual rides
            if (startDate && endDate && startDate <= endDate) {
                seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                
                // Add regular practices based on day of week
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                    if (matchedPractices.length > 0) {
                        validDates.add(dateKey);
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            } else {
                // No season dates set - determine range from individual rides
                const rideDates = [];
                if (Array.isArray(data.rides)) {
                    data.rides.forEach(ride => {
                        if (!ride.date) return;
                        const rideDate = parseISODate(ride.date);
                        if (rideDate) rideDates.push(rideDate);
                    });
                }
                
                if (rideDates.length === 0) {
                    return validDates; // Empty set
                }
                
                rideDates.sort((a, b) => a - b);
                seasonStart = new Date(rideDates[0].getFullYear(), rideDates[0].getMonth(), 1);
                const lastRideDate = rideDates[rideDates.length - 1];
                seasonEnd = new Date(lastRideDate.getFullYear(), lastRideDate.getMonth() + 1, 0);
            }
            
            // Add individual practices from data.rides that fall within the season date range
            // Exclude deleted practices and include rescheduled practices on their new date
            if (Array.isArray(data.rides) && seasonStart && seasonEnd) {
                data.rides.forEach(ride => {
                    if (!ride.date) return;
                    // Skip deleted practices
                    if (ride.deleted) return;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return;
                    
                    // Check if ride date is within season range
                    if (rideDate >= seasonStart && rideDate <= seasonEnd) {
                        const dateKey = formatDateToISO(rideDate);
                        // Include rescheduled practices on their new date
                        if (ride.rescheduledFrom) {
                            validDates.add(dateKey);
                        } else {
                            // For regular practices, only add if it matches a scheduled practice day
                            // (This prevents deleted/superseded practices from being considered valid)
                            const weekday = rideDate.getDay();
                            const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                            if (matchedPractices.length > 0) {
                                validDates.add(dateKey);
                            }
                        }
                    }
                });
            }
            
            return validDates;
        }

        function cleanInvalidRides() {
            // Remove rides that are outside the season date range (if season is set)
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            let cleaned = false;
            
            // Only clean up if season dates are explicitly set
            if (!startDate || !endDate || startDate > endDate) {
                // No season set, keep all rides (but remove ones without dates)
                const beforeLength = data.rides.length;
                data.rides = data.rides.filter(ride => {
                    if (!ride.date) {
                        cleaned = true;
                        return false;
                    }
                    return true;
                });
                if (cleaned && data.rides.length !== beforeLength) {
                    // Check if current ride was removed
                    if (data.currentRide && !data.rides.find(r => r.id === data.currentRide)) {
                        data.currentRide = null;
                    }
                    saveData();
                }
                return cleaned;
            }
            
            const seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
            const seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            // Build set of valid scheduled practice dates (dates that match recurring schedule)
            const validScheduledDates = new Set();
            if (practices.length > 0) {
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                    if (matchedPractices.length > 0) {
                        validScheduledDates.add(dateKey);
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            }
            
            // Remove rides outside season range, without dates, or that don't match the schedule
            const beforeLength = data.rides.length;
            data.rides = data.rides.filter(ride => {
                if (!ride.date) {
                    cleaned = true;
                    return false; // Remove rides without dates
                }
                const rideDate = parseISODate(ride.date);
                if (!rideDate) {
                    cleaned = true;
                    return false; // Remove rides with invalid dates
                }
                rideDate.setHours(0, 0, 0, 0);
                if (rideDate < seasonStart || rideDate > seasonEnd) {
                    cleaned = true;
                    return false; // Remove rides outside season range
                }
                
                // If there are scheduled practices defined, remove rides that don't match the schedule
                // BUT exclude rescheduled practices (they are exceptions and should be kept)
                if (practices.length > 0 && !ride.rescheduledFrom && !validScheduledDates.has(ride.date)) {
                    cleaned = true;
                    return false; // Remove rides that don't match the current schedule (unless rescheduled)
                }
                
                return true; // Keep rides within season range and matching schedule (or keep all if no schedule)
            });
            
            // If current ride was removed, clear it
            if (data.currentRide && !data.rides.find(r => r.id === data.currentRide)) {
                data.currentRide = null;
                cleaned = true;
            }
            
            if (cleaned) {
                saveData();
            }
            
            return cleaned;
        }

        function ensureRidesFromSchedule() {
            // Create rides for any scheduled practice dates that don't have rides yet
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            
            if (!startDate || !endDate || startDate > endDate || practices.length === 0) {
                return; // No schedule to create rides from
            }
            
            const seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
            const seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
            
            // Get existing ride dates (non-deleted only)
            const existingRideDates = new Set();
            const deletedRideDates = new Set(); // Track deleted dates so we don't recreate them
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.date) {
                        if (ride.deleted) {
                            deletedRideDates.add(ride.date);
                        } else {
                            existingRideDates.add(ride.date);
                        }
                    }
                });
            }
            
            // Create rides for each scheduled practice date
            const cursor = new Date(seasonStart.getTime());
            let ridesCreated = false;
            
            while (cursor <= seasonEnd) {
                const dateKey = formatDateToISO(cursor);
                const weekday = cursor.getDay();
                const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                
                // If this date has a scheduled practice and no non-deleted ride exists, create one
                // But skip if this date was explicitly deleted
                if (matchedPractices.length > 0 && !existingRideDates.has(dateKey) && !deletedRideDates.has(dateKey)) {
                    // Use the first practice time if multiple match the same day
                    const practice = matchedPractices[0];
                    const ride = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + cursor.getTime(),
                        date: dateKey,
                        time: practice.time || practice.startTime || '',
                        endTime: practice.endTime || '',
                        description: practice.description || '',
                        meetLocation: practice.meetLocation || '',
                        locationLat: practice.locationLat || null,
                        locationLng: practice.locationLng || null,
                        goals: '',
                        groups: [],
                        availableRiders: [],
                        availableCoaches: [],
                        cancelled: false
                    };
                    
                    data.rides.push(ride);
                    ridesCreated = true;
                }
                
                cursor.setDate(cursor.getDate() + 1);
            }
            
            if (ridesCreated) {
                saveData();
            }
        }
        
        function renderRides() {
            // Reload data to ensure we have the latest practice dates from team dashboard
            // This ensures practice dates are refreshed every time Practice Planner is opened
            const currentRideId = data.currentRide; // Preserve current selection
            loadData();
            if (currentRideId) {
                data.currentRide = currentRideId; // Restore current selection
            }
            
            // Clean up any rides that don't match the calendar before rendering calendar/current ride
            cleanInvalidRides();
            
            // Create rides for any scheduled practice dates that don't have rides yet
            ensureRidesFromSchedule();

            // Calendar is now rendered in settings tab, not here - refresh it to show latest dates
            renderSeasonCalendarForSettings();
            updateHeaderEditSeasonButton();
            
            // Get valid practice dates from the calendar (reads from refreshed data.seasonSettings)
            const validDates = getValidPracticeDates();
            
            // Find the next chronological practice based on current date
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time to start of day for comparison
            
            // Filter rides: exclude deleted, include cancelled (but not for auto-selection), include rescheduled on new date
            // First, get all valid rides (not deleted, today or future)
            const allValidRides = (data.rides || [])
                .filter(ride => {
                    if (!ride.date) return false;
                    // Exclude deleted practices
                    if (ride.deleted) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    
                    // Must be today or future
                    if (rideDate < today) return false;
                    
                    return true;
                });
            
            // Separate cancelled and non-cancelled rides
            const cancelledRides = allValidRides.filter(ride => ride.cancelled);
            const nonCancelledRides = allValidRides.filter(ride => !ride.cancelled);
            
            // For auto-selection, use only non-cancelled rides that match calendar (or rescheduled)
            const upcomingRides = nonCancelledRides
                .filter(ride => {
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    const dateKey = formatDateToISO(rideDate);
                    
                    // Include if it matches calendar OR if it's rescheduled (rescheduled practices are exceptions)
                    if (ride.rescheduledFrom) {
                        return true; // Always include rescheduled practices
                    }
                    
                    // For regular practices, must match a valid calendar date
                    if (validDates.size > 0 && !validDates.has(dateKey)) return false;
                    
                    return true;
                })
                .sort((a, b) => {
                    const dateA = parseISODate(a.date);
                    const dateB = parseISODate(b.date);
                    if (!dateA || !dateB) return 0;
                    return dateA - dateB;
                });
            
            // Set the next practice as current, or keep existing if it's still valid (today or future)
            if (upcomingRides.length > 0) {
                const nextRide = upcomingRides[0];
                const currentRide = data.currentRide ? data.rides.find(r => r.id === data.currentRide) : null;
                let shouldUpdate = false;
                
                if (!data.currentRide) {
                    // No current ride selected, use the next one
                    shouldUpdate = true;
                } else if (!currentRide) {
                    // Current ride ID doesn't exist anymore, use the next one
                    shouldUpdate = true;
                } else {
                    // If current ride is cancelled, keep it (user may want to reinstate it)
                    if (currentRide.cancelled) {
                        shouldUpdate = false;
                    } else {
                        const currentRideDate = parseISODate(currentRide.date);
                        if (currentRideDate) {
                            currentRideDate.setHours(0, 0, 0, 0);
                            const currentDateKey = formatDateToISO(currentRideDate);
                            
                            // Update if current ride is in the past
                            if (currentRideDate < today) {
                                shouldUpdate = true;
                            }
                            // Update if current ride doesn't match a valid calendar date (when calendar has valid dates)
                            else if (validDates.size > 0 && !validDates.has(currentDateKey)) {
                                shouldUpdate = true;
                            }
                            // If current ride is today or future and matches calendar, keep it (preserves manual selection)
                        } else {
                            // Invalid date, use the next one
                            shouldUpdate = true;
                        }
                    }
                }
                
                if (shouldUpdate) {
                    data.currentRide = nextRide.id;
                    saveData();
                }
            } else {
                // No upcoming non-cancelled practices for auto-selection
                // Check if we should show a cancelled practice
                const currentRide = data.currentRide ? data.rides.find(r => r.id === data.currentRide) : null;
                if (currentRide && currentRide.cancelled && !currentRide.deleted) {
                    // Keep cancelled practice visible so user can reinstate it
                    const currentRideDate = parseISODate(currentRide.date);
                    if (currentRideDate) {
                        currentRideDate.setHours(0, 0, 0, 0);
                        if (currentRideDate < today) {
                            // Cancelled practice is in the past, clear it
                            data.currentRide = null;
                            saveData();
                            const currentRideElement = document.getElementById('current-ride');
                            if (currentRideElement) {
                                currentRideElement.style.display = 'none';
                            }
                        }
                        // Otherwise keep it visible (today or future)
                    }
                } else if (!currentRide || (currentRide && currentRide.deleted)) {
                    // Hide the current ride section if it's deleted or doesn't exist
                    data.currentRide = null;
                    const currentRideElement = document.getElementById('current-ride');
                    if (currentRideElement) {
                        currentRideElement.style.display = 'none';
                    }
                }
            }
            
            if (data.currentRide) {
                const currentRide = data.rides.find(r => r.id === data.currentRide);
                // Only load if ride exists and is not deleted
                if (currentRide && !currentRide.deleted) {
                    loadCurrentRide();
                } else {
                    // Ride was deleted, clear selection
                    data.currentRide = null;
                    saveData();
                    const currentRideElement = document.getElementById('current-ride');
                    if (currentRideElement) {
                        currentRideElement.style.display = 'none';
                    }
                    const navSection = document.getElementById('practice-navigation');
                    if (navSection) navSection.style.display = 'none';
                }
            } else {
                // Hide navigation if no current ride
                const navSection = document.getElementById('practice-navigation');
                if (navSection) navSection.style.display = 'none';
            }
        }

        function updateHeaderEditSeasonButton() {
            // Season Setup button is now always visible in user menu - no need to show/hide
            // Function kept for backwards compatibility but does nothing
        }

        function loadRide(rideId) {
            data.currentRide = rideId;
            saveData();
            loadCurrentRide();
        }

        function loadSeasonSettings() {
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            
            // Populate date fields
            const startDateInput = document.getElementById('season-start-date');
            const endDateInput = document.getElementById('season-end-date');
            if (startDateInput) startDateInput.value = settings.startDate || '';
            if (endDateInput) endDateInput.value = settings.endDate || '';
            
            // Load scale settings
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            if (fitnessScaleInput) {
                fitnessScaleInput.value = settings.fitnessScale || 5;
                if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = settings.fitnessScale || 5;
            }
            if (skillsScaleInput) {
                skillsScaleInput.value = settings.skillsScale || 3;
                if (skillsScaleDisplay) skillsScaleDisplay.textContent = settings.skillsScale || 3;
            }
            
            // Load practice rows
            seasonSettingsDraft = {
                startDate: settings.startDate || '',
                endDate: settings.endDate || '',
                practices: Array.isArray(settings.practices)
                    ? settings.practices.map(practice => ({
                        id: practice.id || generateId(),
                        dayOfWeek: practice.dayOfWeek,
                        time: practice.time || practice.startTime || '',
                        endTime: practice.endTime || '',
                        description: practice.description || '',
                        meetLocation: practice.meetLocation || '',
                        locationLat: practice.locationLat || null,
                        locationLng: practice.locationLng || null
                    }))
                    : []
            };
            
            renderPracticeRows();
            
            // Load and render roles
            renderCoachRoles();
            renderRiderRoles();
            updateRoleDropdowns();
        }
        
        // Role management functions
        function renderCoachRoles() {
            const container = document.getElementById('coach-roles-container');
            if (!container) return;
            
            if (!data.coachRoles || data.coachRoles.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No coach roles assigned</div>';
                return;
            }
            
            let html = '';
            data.coachRoles.forEach((role, index) => {
                const coach = data.coaches.find(c => c.id === role.coachId);
                const coachName = coach ? coach.name : `Coach ID: ${role.coachId}`;
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
                        <span style="flex: 1; font-weight: 600;">${escapeHtml(role.roleName)}</span>
                        <span style="flex: 1;">${escapeHtml(coachName)}</span>
                        <button class="btn-small danger" onclick="removeCoachRole(${index})">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function renderRiderRoles() {
            const container = document.getElementById('rider-roles-container');
            if (!container) return;
            
            if (!data.riderRoles || data.riderRoles.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic; padding: 8px;">No rider roles assigned</div>';
                return;
            }
            
            let html = '';
            data.riderRoles.forEach((role, index) => {
                const rider = data.riders.find(r => r.id === role.riderId);
                const riderName = rider ? rider.name : `Rider ID: ${role.riderId}`;
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
                        <span style="flex: 1; font-weight: 600;">${escapeHtml(role.roleName)}</span>
                        <span style="flex: 1;">${escapeHtml(riderName)}</span>
                        <button class="btn-small danger" onclick="removeRiderRole(${index})">Remove</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateRoleDropdowns() {
            // Update coach dropdown
            const coachSelect = document.getElementById('new-coach-role-coach');
            if (coachSelect) {
                coachSelect.innerHTML = '<option value="">Select Coach</option>';
                data.coaches.forEach(coach => {
                    const option = document.createElement('option');
                    option.value = coach.id;
                    option.textContent = coach.name || 'Unnamed Coach';
                    coachSelect.appendChild(option);
                });
            }
            
            // Update rider dropdown
            const riderSelect = document.getElementById('new-rider-role-rider');
            if (riderSelect) {
                riderSelect.innerHTML = '<option value="">Select Rider</option>';
                data.riders.forEach(rider => {
                    const option = document.createElement('option');
                    option.value = rider.id;
                    option.textContent = rider.name || 'Unnamed Rider';
                    riderSelect.appendChild(option);
                });
            }
        }
        
        function addCoachRole() {
            const roleNameInput = document.getElementById('new-coach-role-name');
            const coachSelect = document.getElementById('new-coach-role-coach');
            
            if (!roleNameInput || !coachSelect) return;
            
            const roleName = roleNameInput.value.trim();
            const coachId = parseInt(coachSelect.value, 10);
            
            if (!roleName) {
                alert('Please enter a role name');
                return;
            }
            
            if (!coachId) {
                alert('Please select a coach');
                return;
            }
            
            // Check if coach already has a role
            const existingRole = data.coachRoles.find(r => r.coachId === coachId);
            if (existingRole) {
                if (!confirm(`Coach already has role "${existingRole.roleName}". Replace it?`)) {
                    return;
                }
                // Remove existing role
                data.coachRoles = data.coachRoles.filter(r => r.coachId !== coachId);
            }
            
            // Add new role
            data.coachRoles.push({ roleName, coachId });
            saveData();
            
            // Clear inputs
            roleNameInput.value = '';
            coachSelect.value = '';
            
            // Refresh display
            renderCoachRoles();
            renderCoaches();
        }
        
        function addRiderRole() {
            const roleNameInput = document.getElementById('new-rider-role-name');
            const riderSelect = document.getElementById('new-rider-role-rider');
            
            if (!roleNameInput || !riderSelect) return;
            
            const roleName = roleNameInput.value.trim();
            const riderId = parseInt(riderSelect.value, 10);
            
            if (!roleName) {
                alert('Please enter a role name');
                return;
            }
            
            if (!riderId) {
                alert('Please select a rider');
                return;
            }
            
            // Check if rider already has a role
            const existingRole = data.riderRoles.find(r => r.riderId === riderId);
            if (existingRole) {
                if (!confirm(`Rider already has role "${existingRole.roleName}". Replace it?`)) {
                    return;
                }
                // Remove existing role
                data.riderRoles = data.riderRoles.filter(r => r.riderId !== riderId);
            }
            
            // Add new role
            data.riderRoles.push({ roleName, riderId });
            saveData();
            
            // Clear inputs
            roleNameInput.value = '';
            riderSelect.value = '';
            
            // Refresh display
            renderRiderRoles();
            renderRiders();
        }
        
        function removeCoachRole(index) {
            if (confirm('Remove this coach role?')) {
                data.coachRoles.splice(index, 1);
                saveData();
                renderCoachRoles();
                renderCoaches();
            }
        }
        
        function removeRiderRole(index) {
            if (confirm('Remove this rider role?')) {
                data.riderRoles.splice(index, 1);
                saveData();
                renderRiderRoles();
                renderRiders();
            }
        }
        
        // Helper to get role for a coach/rider
        function getCoachRole(coachId) {
            if (!data.coachRoles) return null;
            const role = data.coachRoles.find(r => r.coachId === coachId);
            return role ? role.roleName : null;
        }
        
        function getRiderRole(riderId) {
            if (!data.riderRoles) return null;
            const role = data.riderRoles.find(r => r.riderId === riderId);
            return role ? role.roleName : null;
        }

        function toggleRosterView(view) {
            const ridersView = document.getElementById('roster-riders-view');
            const coachesView = document.getElementById('roster-coaches-view');
            const ridersBtn = document.getElementById('roster-toggle-riders');
            const coachesBtn = document.getElementById('roster-toggle-coaches');
            const riderGroupBy = document.getElementById('rider-group-by');
            const coachGroupBy = document.getElementById('coach-group-by');
            const groupByLabel = document.getElementById('roster-group-by-label');
            
            if (view === 'riders') {
                if (ridersView) ridersView.style.display = 'block';
                if (coachesView) coachesView.style.display = 'none';
                if (ridersBtn) {
                    ridersBtn.classList.remove('secondary');
                    ridersBtn.classList.add('active');
                }
                if (coachesBtn) {
                    coachesBtn.classList.remove('active');
                    coachesBtn.classList.add('secondary');
                }
                if (riderGroupBy) riderGroupBy.style.display = 'block';
                if (coachGroupBy) coachGroupBy.style.display = 'none';
                if (groupByLabel) groupByLabel.setAttribute('for', 'rider-group-by');
                renderRiders();
            } else {
                if (ridersView) ridersView.style.display = 'none';
                if (coachesView) coachesView.style.display = 'block';
                if (ridersBtn) {
                    ridersBtn.classList.remove('active');
                    ridersBtn.classList.add('secondary');
                }
                if (coachesBtn) {
                    coachesBtn.classList.remove('secondary');
                    coachesBtn.classList.add('active');
                }
                if (riderGroupBy) riderGroupBy.style.display = 'none';
                if (coachGroupBy) coachGroupBy.style.display = 'block';
                if (groupByLabel) groupByLabel.setAttribute('for', 'coach-group-by');
                renderCoaches();
            }
        }

        function openSeasonSetupModal() {
            // Switch to settings tab instead of opening modal
            switchTab('settings', document.querySelector('.tab[onclick*="settings"]'));
        }

        function closeSeasonSetupModal() {
            const modal = document.getElementById('season-setup-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            seasonSettingsDraft = null;
        }

        function ensureSeasonDraft() {
            if (!seasonSettingsDraft) {
                const settings = data.seasonSettings || buildDefaultSeasonSettings();
                seasonSettingsDraft = {
                    startDate: settings.startDate || '',
                    endDate: settings.endDate || '',
                    practices: Array.isArray(settings.practices)
                        ? settings.practices.map(practice => ({
                            id: practice.id || generateId(),
                            dayOfWeek: practice.dayOfWeek,
                            time: practice.time || practice.startTime || '',
                            endTime: practice.endTime || '',
                            description: practice.description || '',
                            meetLocation: practice.meetLocation || '',
                            locationLat: practice.locationLat || null,
                            locationLng: practice.locationLng || null
                        }))
                        : []
                };
            }
        }

        function renderPracticeRows() {
            ensureSeasonDraft();
            const container = document.getElementById('practice-rows');
            if (!container) return;

            if (!seasonSettingsDraft || seasonSettingsDraft.practices.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding:12px;">
                        No regular practices yet. Add one to get started.
                    </div>
                `;
                return;
            }
            
            // Keep practices in the order they were created (no sorting)
            const rowsHtml = seasonSettingsDraft.practices.map((practice, index) => {
                const isSinglePractice = practice.specificDate !== null && practice.specificDate !== undefined;
                const hasLocation = practice.locationLat && practice.locationLng;
                
                // Generate description if not set
                let defaultDescription = practice.description;
                if (!defaultDescription || defaultDescription.startsWith('Weekly Practice')) {
                    if (isSinglePractice) {
                        const practiceDate = parseISODate(practice.specificDate);
                        if (practiceDate) {
                            const dayName = DAYS_OF_WEEK[practiceDate.getDay()];
                            defaultDescription = generatePracticeDescription(dayName, practice.time || '15:30');
                        } else {
                            defaultDescription = 'Practice';
                        }
                    } else if (practice.dayOfWeek !== null && practice.dayOfWeek !== undefined) {
                        const dayName = DAYS_OF_WEEK[practice.dayOfWeek];
                        defaultDescription = generatePracticeDescription(dayName, practice.time || '15:30');
                    } else {
                        defaultDescription = `Practice ${index + 1}`;
                    }
                }

                // Render day of week or date field
                let dayFieldHtml = '';
                if (isSinglePractice) {
                    dayFieldHtml = `
                        <div class="practice-row-field">
                            <label>Date</label>
                            <input type="date" value="${practice.specificDate || ''}" onchange="updatePracticeDraft(${practice.id}, 'specificDate', this.value); updatePracticeDescription(${practice.id});">
                        </div>
                    `;
                } else {
                    const options = DAYS_OF_WEEK.map((day, dayIndex) => `
                        <option value="${dayIndex}" ${practice.dayOfWeek === dayIndex ? 'selected' : ''}>${day}</option>
                    `).join('');
                    dayFieldHtml = `
                        <div class="practice-row-field">
                            <label>Day of Week</label>
                            <select onchange="updatePracticeDraft(${practice.id}, 'dayOfWeek', this.value); updatePracticeDescription(${practice.id});">
                                ${options}
                            </select>
                        </div>
                    `;
                }

                return `
                    <div class="practice-row" data-practice-id="${practice.id}">
                        ${dayFieldHtml}
                        <div class="practice-row-field">
                            <label>Time Range</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="time" value="${practice.time || ''}" placeholder="Start" onchange="updatePracticeDraft(${practice.id}, 'time', this.value); updatePracticeDescription(${practice.id});" style="flex: 1;">
                                <span style="color: #666; font-weight: 500;">‚Äì</span>
                                <input type="time" value="${practice.endTime || ''}" placeholder="End" onchange="updatePracticeDraft(${practice.id}, 'endTime', this.value)" style="flex: 1;">
                            </div>
                        </div>
                        <div class="practice-row-field">
                            <label>Description</label>
                            <input type="text" value="${escapeHtml(defaultDescription)}" placeholder="Practice description" onchange="updatePracticeDraft(${practice.id}, 'description', this.value)" id="practice-desc-${practice.id}">
                        </div>
                        <div class="practice-row-field">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <label>Meet Location</label>
                                <span style="font-size: 10px; color: #666; margin-right: 4px;">Map</span>
                            </div>
                            <div style="display: flex; gap: 4px; align-items: flex-start;">
                                <input type="text" value="${escapeHtml(practice.meetLocation || '')}" placeholder="Enter location" onchange="updatePracticeDraft(${practice.id}, 'meetLocation', this.value)" style="flex: 1; min-height: 32px; box-sizing: border-box;">
                                <button type="button" class="btn-small location-button" onclick="openLocationMap(${practice.id})" title="Set location on map" style="height: 32px; padding: 6px 12px; display: flex; align-items: center; justify-content: center; margin-top: 0;">
                                    ${hasLocation ? 'üìç' : 'üó∫Ô∏è'}
                                </button>
                            </div>
                        </div>
                        <div style="display: flex; align-items: flex-start; padding-top: 20px;">
                            <button class="btn-small danger" onclick="removePracticeRow(${practice.id})">Remove</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = rowsHtml;
        }

        function updatePracticeDraft(id, field, value) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(practice => String(practice.id) === String(id));
            if (practiceIndex === -1) return;

            if (field === 'dayOfWeek') {
                const day = parseInt(value, 10);
                if (Number.isFinite(day) && day >= 0 && day <= 6) {
                    seasonSettingsDraft.practices[practiceIndex].dayOfWeek = day;
                    seasonSettingsDraft.practices[practiceIndex].specificDate = null; // Clear specific date when day of week is set
                    updatePracticeDescription(id);
                }
            } else if (field === 'specificDate') {
                seasonSettingsDraft.practices[practiceIndex].specificDate = value || null;
                seasonSettingsDraft.practices[practiceIndex].dayOfWeek = null; // Clear day of week when specific date is set
                updatePracticeDescription(id);
            } else if (field === 'time') {
                const normalizedTime = normalizeTimeValue(value);
                seasonSettingsDraft.practices[practiceIndex].time = normalizedTime;
                updatePracticeDescription(id);
            } else if (field === 'endTime') {
                const normalizedTime = normalizeTimeValue(value);
                seasonSettingsDraft.practices[practiceIndex].endTime = normalizedTime;
            } else if (field === 'description') {
                seasonSettingsDraft.practices[practiceIndex].description = value || '';
            } else if (field === 'meetLocation') {
                seasonSettingsDraft.practices[practiceIndex].meetLocation = value || '';
            } else if (field === 'locationLat') {
                const lat = parseFloat(value);
                seasonSettingsDraft.practices[practiceIndex].locationLat = Number.isFinite(lat) ? lat : null;
            } else if (field === 'locationLng') {
                const lng = parseFloat(value);
                seasonSettingsDraft.practices[practiceIndex].locationLng = Number.isFinite(lng) ? lng : null;
            }

            renderPracticeRows();
        }

        function addPracticeRow() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const defaultDay = seasonSettingsDraft.practices.length > 0
                ? (seasonSettingsDraft.practices[seasonSettingsDraft.practices.length - 1].dayOfWeek + 2) % 7
                : 2; // Wednesday default

            const practiceNumber = seasonSettingsDraft.practices.length + 1;
            const dayName = DAYS_OF_WEEK[defaultDay];
            const timeStr = '15:30';
            const description = generatePracticeDescription(dayName, timeStr);

            seasonSettingsDraft.practices.push({
                id: generateId(),
                dayOfWeek: defaultDay,
                specificDate: null, // Recurring practice
                time: timeStr,
                endTime: '17:00',
                description: description,
                meetLocation: '',
                locationLat: null,
                locationLng: null
            });

            renderPracticeRows();
        }

        function addSinglePracticeRow() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            // Default to today's date
            const today = new Date();
            const defaultDate = today.toISOString().split('T')[0];
            
            // Get day name for description
            const dayName = DAYS_OF_WEEK[today.getDay()];
            const timeStr = '15:30';
            const description = generatePracticeDescription(dayName, timeStr);

            seasonSettingsDraft.practices.push({
                id: generateId(),
                dayOfWeek: null, // Single practice uses specificDate instead
                specificDate: defaultDate,
                time: timeStr,
                endTime: '17:00',
                description: description,
                meetLocation: '',
                locationLat: null,
                locationLng: null
            });

            renderPracticeRows();
        }

        function parseISODate(dateStr) {
            if (!dateStr) return null;
            try {
                const date = new Date(dateStr + 'T00:00:00');
                if (isNaN(date.getTime())) return null;
                return date;
            } catch (e) {
                return null;
            }
        }

        function generatePracticeDescription(dayName, timeStr) {
            if (!dayName || !timeStr) return 'Practice';
            
            // Parse time to determine morning/afternoon/evening
            const timeParts = timeStr.split(':');
            const hour = parseInt(timeParts[0], 10);
            const minute = parseInt(timeParts[1], 10);
            const totalMinutes = hour * 60 + minute;
            
            let timeOfDay = 'practice';
            if (totalMinutes < 12 * 60) {
                timeOfDay = 'morning practice';
            } else if (totalMinutes < 17 * 60) {
                timeOfDay = 'afternoon practice';
            } else {
                timeOfDay = 'evening practice';
            }
            
            return `${dayName} ${timeOfDay}`;
        }

        function updatePracticeDescription(practiceId) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(p => String(p.id) === String(practiceId));
            if (practiceIndex === -1) return;

            const practice = seasonSettingsDraft.practices[practiceIndex];
            
            // Only update if description hasn't been manually edited (starts with day name pattern)
            const descInput = document.getElementById(`practice-desc-${practiceId}`);
            if (!descInput) return;
            
            const currentDesc = descInput.value.trim();
            // Check if description matches auto-generated pattern (day name + time of day)
            const isAutoGenerated = currentDesc && (
                currentDesc.includes('morning practice') ||
                currentDesc.includes('afternoon practice') ||
                currentDesc.includes('evening practice') ||
                currentDesc.startsWith('Weekly Practice') ||
                currentDesc === 'Practice'
            );
            
            if (isAutoGenerated || !currentDesc) {
                let dayName = null;
                
                if (practice.specificDate) {
                    const practiceDate = parseISODate(practice.specificDate);
                    if (practiceDate) {
                        dayName = DAYS_OF_WEEK[practiceDate.getDay()];
                    }
                } else if (practice.dayOfWeek !== null && practice.dayOfWeek !== undefined) {
                    dayName = DAYS_OF_WEEK[practice.dayOfWeek];
                }
                
                if (dayName && practice.time) {
                    const newDescription = generatePracticeDescription(dayName, practice.time);
                    practice.description = newDescription;
                    descInput.value = newDescription;
                }
            }
        }

        function removePracticeRow(id) {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            seasonSettingsDraft.practices = seasonSettingsDraft.practices.filter(practice => String(practice.id) !== String(id));
            renderPracticeRows();
        }


        function updateSeasonDateRange() {
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            if (startInput && endInput && startInput.value && endInput.value) {
                const startDate = parseISODate(startInput.value);
                const endDate = parseISODate(endInput.value);
                if (startDate && endDate && startDate > endDate) {
                    // Auto-adjust end date if it's before start date
                    endInput.value = startInput.value;
                }
            }
        }

        function applySeasonUpdates(scope) {
            const applyAll = confirm('Apply updates to the whole season?\n\nOK = Whole season (cancelled/rescheduled practices will be lost)\nCancel = Only from today forward');
            const fromDate = applyAll ? new Date(0) : new Date();
            fromDate.setHours(0, 0, 0, 0);
            
            // Persist current season settings (dates + regular practices) to data before re-rendering
            ensureSeasonDraft();
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            const startDateValue = startInput ? startInput.value : '';
            const endDateValue = endInput ? endInput.value : '';
            const cleanedPractices = (seasonSettingsDraft?.practices || [])
                .map(practice => normalizePracticeEntry(practice))
                .filter(Boolean);
            const practicesData = cleanedPractices.map(practice => ({
                ...practice,
                description: practice.description || '',
                meetLocation: practice.meetLocation || '',
                locationLat: practice.locationLat || null,
                locationLng: practice.locationLng || null
            }));
            data.seasonSettings = {
                startDate: startDateValue || '',
                endDate: endDateValue || '',
                practices: practicesData
            };
            
            // Determine current season range (if set)
            const seasonStart = startDateValue ? parseISODate(startDateValue) : null;
            const seasonEnd = endDateValue ? parseISODate(endDateValue) : null;
            if (seasonStart) seasonStart.setHours(0,0,0,0);
            if (seasonEnd) seasonEnd.setHours(0,0,0,0);
            
            // If applying to whole season, drop rescheduled instances entirely and force recalculation
            if (applyAll) {
                data.rides = (data.rides || []).filter(ride => !ride.rescheduledFrom);
                data.currentRide = null; // force next practice recalculation
                
                // If no regular practices remain, clear all generated rides
                if (practicesData.length === 0) {
                    data.rides = [];
                } else if (seasonStart && seasonEnd) {
                    // Trim rides outside the new season range
                    data.rides = (data.rides || []).filter(ride => {
                        if (!ride.date) return false;
                        const d = parseISODate(ride.date);
                        if (!d) return false;
                        d.setHours(0,0,0,0);
                        return d >= seasonStart && d <= seasonEnd;
                    });
                }
            }
            
            (data.rides || []).forEach(ride => {
                const rideDate = parseISODate(ride.date);
                if (!rideDate) return;
                rideDate.setHours(0, 0, 0, 0);
                if (rideDate >= fromDate) {
                    ride.cancelled = false;
                    ride.cancellationReason = '';
                    ride.rescheduledFrom = null;
                    ride.deleted = false;
                }
            });
            
            saveData();
            // Recompute calendars and current ride after cleaning
            renderAllCalendars();
            renderRides();
            alert('Updates applied. Cancelled and rescheduled practices within the selected range have been reset.');
        }

        function saveSeasonSettings() {
            ensureSeasonDraft();
            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');

            const startDateValue = startInput ? startInput.value : '';
            const endDateValue = endInput ? endInput.value : '';

            if (startDateValue && endDateValue) {
                const startDate = parseISODate(startDateValue);
                const endDate = parseISODate(endDateValue);
                if (startDate && endDate && startDate > endDate) {
                    alert('Season end date must be on or after the start date.');
                    return;
                }
            }

            const cleanedPractices = (seasonSettingsDraft?.practices || [])
                .map(practice => normalizePracticeEntry(practice))
                .filter(Boolean);

            const practicesData = cleanedPractices.map(practice => ({
                ...practice,
                description: practice.description || '',
                meetLocation: practice.meetLocation || '',
                locationLat: practice.locationLat || null,
                locationLng: practice.locationLng || null
            }));

            // Get scale settings
            const fitnessScaleInput = document.getElementById('fitness-scale');
            const skillsScaleInput = document.getElementById('skills-scale');
            const fitnessScale = fitnessScaleInput ? parseInt(fitnessScaleInput.value, 10) : 5;
            const skillsScale = skillsScaleInput ? parseInt(skillsScaleInput.value, 10) : 3;
            
            // Get old scales for conversion
            const oldFitnessScale = data.seasonSettings?.fitnessScale || 5;
            const oldSkillsScale = data.seasonSettings?.skillsScale || 3;
            
            data.seasonSettings = {
                startDate: startDateValue || '',
                endDate: endDateValue || '',
                practices: practicesData,
                fitnessScale: fitnessScale,
                skillsScale: skillsScale
            };
            
            // Convert existing data if scales changed
            if (fitnessScale !== oldFitnessScale || skillsScale !== oldSkillsScale) {
                convertAllRatingsToNewScales(oldFitnessScale, fitnessScale, oldSkillsScale, skillsScale);
            }
            
            // Update scale displays
            const fitnessScaleDisplay = document.getElementById('fitness-scale-display');
            const skillsScaleDisplay = document.getElementById('skills-scale-display');
            if (fitnessScaleDisplay) fitnessScaleDisplay.textContent = fitnessScale;
            if (skillsScaleDisplay) skillsScaleDisplay.textContent = skillsScale;

            // Save to localStorage
            saveData();
            
            closeSeasonSetupModal();
            renderAllCalendars();
            updateHeaderEditSeasonButton();
            // Trigger cleanup and validation if on Practice Planner tab
            renderRides();
        }

        async function exportSeasonSettings() {
            ensureSeasonDraft();
            if (!seasonSettingsDraft) {
                alert('No season settings to export.');
                return;
            }

            const startInput = document.getElementById('season-start-date');
            const endInput = document.getElementById('season-end-date');
            
            const exportData = {
                startDate: startInput ? startInput.value : seasonSettingsDraft.startDate || '',
                endDate: endInput ? endInput.value : seasonSettingsDraft.endDate || '',
                practices: (seasonSettingsDraft.practices || []).map(practice => ({
                    id: practice.id,
                    dayOfWeek: practice.dayOfWeek,
                    specificDate: practice.specificDate || null,
                    time: practice.time || '',
                    endTime: practice.endTime || '',
                    description: practice.description || '',
                    meetLocation: practice.meetLocation || '',
                    locationLat: practice.locationLat || null,
                    locationLng: practice.locationLng || null
                })),
                exportedAt: new Date().toISOString(),
                version: '1.0'
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // Try to use File System Access API for save dialog (modern browsers)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `team-ride-pro-settings-${new Date().toISOString().split('T')[0]}.json`,
                        types: [{
                            description: 'JSON files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    return;
                } catch (error) {
                    // User cancelled or error - fall back to download
                    if (error.name !== 'AbortError') {
                        console.error('File System Access API error:', error);
                    }
                }
            }
            
            // Fallback to download (for browsers without File System Access API)
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `team-ride-pro-settings-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importSeasonSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (!importedData || typeof importedData !== 'object') {
                            throw new Error('Invalid file format');
                        }

                        // Validate and import data
                        if (importedData.startDate) {
                            const startInput = document.getElementById('season-start-date');
                            if (startInput) startInput.value = importedData.startDate;
                        }

                        if (importedData.endDate) {
                            const endInput = document.getElementById('season-end-date');
                            if (endInput) endInput.value = importedData.endDate;
                        }

                        if (Array.isArray(importedData.practices)) {
                            ensureSeasonDraft();
                            if (seasonSettingsDraft) {
                                // Merge imported practices (or replace if user confirms)
                                if (seasonSettingsDraft.practices.length > 0) {
                                    if (!confirm(`You currently have ${seasonSettingsDraft.practices.length} practices. Import will ${importedData.practices.length > 0 ? 'replace' : 'clear'} them. Continue?`)) {
                                        return;
                                    }
                                }
                                
                                seasonSettingsDraft.practices = importedData.practices.map(practice => ({
                                    id: practice.id || generateId(),
                                    dayOfWeek: practice.specificDate ? null : (practice.dayOfWeek !== undefined ? practice.dayOfWeek : 0),
                                    specificDate: practice.specificDate || null,
                                    time: practice.time || '15:30',
                                    endTime: practice.endTime || '17:00',
                                    description: practice.description || '',
                                    meetLocation: practice.meetLocation || '',
                                    locationLat: practice.locationLat || null,
                                    locationLng: practice.locationLng || null
                                }));
                                
                                renderPracticeRows();
                                alert(`Successfully imported ${importedData.practices.length} practice(s).`);
                            }
                        } else {
                            alert('No practices found in imported file.');
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        alert('Error importing settings: ' + (error.message || 'Invalid file format'));
                    }
                };
                reader.onerror = () => {
                    alert('Error reading file.');
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // CSV Import function for riders only
        function importRidersFromCSV() {
            if (!confirm('This will replace ALL existing rider data with data from the CSV file. This action cannot be undone. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const ridersText = await readFileAsText(file);
                    await processRidersCSVImport(ridersText);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // CSV Import function for coaches only
        function importCoachesFromCSV() {
            if (!confirm('This will replace ALL existing coach data with data from the CSV file. This action cannot be undone. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const coachesText = await readFileAsText(file);
                    await processCoachesCSVImport(coachesText);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // Helper to read file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // Update riders from CSV file picker
        function updateRidersFromCSVFile() {
            if (!confirm('This will update existing riders, add new riders from CSV, and remove riders not in CSV. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const ridersText = await readFileAsText(file);
                    await updateRidersFromCSV(ridersText);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }

        // Update coaches from CSV file picker
        function updateCoachesFromCSVFile() {
            if (!confirm('This will update existing coaches, add new coaches from CSV, and remove coaches not in CSV. Continue?')) {
                return;
            }

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                    return;
                }
                
                try {
                    const coachesText = await readFileAsText(file);
                    await updateCoachesFromCSV(coachesText);
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading CSV file: ' + (error.message || 'Unknown error'));
                } finally {
                    if (document.body.contains(fileInput)) {
                        document.body.removeChild(fileInput);
                    }
                }
            };
            
            // Trigger file selection immediately (must be synchronous within user activation)
            document.body.appendChild(fileInput);
            fileInput.click();
        }
        
        // Purge all riders
        function purgeRiders() {
            if (!confirm('Are you sure you want to delete ALL riders? This action cannot be undone.')) {
                return;
            }
            
            if (!confirm('This will permanently delete all rider records. Are you absolutely sure?')) {
                return;
            }
            
            data.riders = [];
            saveData();
            renderRiders();
            alert('All riders have been deleted.');
        }
        
        // Purge all coaches
        function purgeCoaches() {
            if (!confirm('Are you sure you want to delete ALL coaches? This action cannot be undone.')) {
                return;
            }
            
            if (!confirm('This will permanently delete all coach records. Are you absolutely sure?')) {
                return;
            }
            
            data.coaches = [];
            saveData();
            renderCoaches();
            alert('All coaches have been deleted.');
        }
        
        // Process riders CSV import
        async function processRidersCSVImport(ridersText) {
            try {
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = riders[0];
                const headerMap = getRiderHeaderMap(headers);

                // Import riders
                const importedRiders = [];
                for (let i = 1; i < riders.length; i++) { // Skip header row
                    const row = riders[i];
                    if (!row || row.length === 0) continue; // Skip empty rows

                    // Get name fields using header map
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    const firstName = (row[firstNameIdx] || '').trim();
                    const lastName = (row[lastNameIdx] || '').trim();
                    if (!firstName && !lastName) continue;

                    const name = `${firstName} ${lastName}`.trim();

                    // Get gender and determine default photo
                    const genderIdx = headerMap['gender'];
                    const genderRaw = genderIdx !== undefined ? (row[genderIdx] || '').trim().toUpperCase() : '';
                    let gender = '';
                    if (genderRaw === 'M' || genderRaw === 'MALE' || genderRaw === 'MALE') gender = 'M';
                    else if (genderRaw === 'F' || genderRaw === 'FEMALE' || genderRaw === 'FEMALE') gender = 'F';
                    else if (genderRaw === 'NB' || genderRaw === 'NONBINARY' || genderRaw === 'NON-BINARY') gender = 'NB';

                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    // Helper function to get value from CSV row using header map
                    const getValue = (fieldName) => {
                        const idx = headerMap[fieldName];
                        return idx !== undefined ? (row[idx] || '').trim() : '';
                    };

                    // Helper function to get phone value
                    const getPhoneValue = (fieldName) => {
                        const val = getValue(fieldName);
                        return normalizePhoneNumber(val);
                    };

                    // Get grade
                    const gradeRaw = getValue('grade');
                    const grade = normalizeGradeValue(gradeRaw);

                    const riderData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + i * 1000,
                        name: name,
                        firstName,
                        lastName,
                        photo: defaultPhoto,
                        email: getValue('email'),
                        phone: getPhoneValue('phone'),
                        address: getValue('address'),
                        gender: gender,
                        grade: grade,
                        birthday: getValue('birthday'),
                        primaryParentName: getValue('primaryParentName'),
                        primaryParentPhone: getPhoneValue('primaryParentPhone'),
                        primaryParentEmail: getValue('primaryParentEmail'),
                        primaryParentAddress: getValue('primaryParentAddress'),
                        secondParentName: getValue('secondParentName'),
                        secondParentPhone: getPhoneValue('secondParentPhone'),
                        secondParentEmail: getValue('secondParentEmail'),
                        alternateContactName: getValue('alternateContactName'),
                        alternateContactRelationship: getValue('alternateContactRelationship'),
                        alternateContactPhone: getPhoneValue('alternateContactPhone'),
                        primaryPhysician: getValue('primaryPhysician'),
                        primaryPhysicianPhone: getPhoneValue('primaryPhysicianPhone'),
                        medicalInsuranceCompany: getValue('medicalInsuranceCompany'),
                        medicalInsuranceAccountNumber: getValue('medicalInsuranceAccountNumber'),
                        allergiesOrMedicalNeeds: getValue('allergiesOrMedicalNeeds'),
                        // Default values for fields not in CSV
                        racingGroup: 'Freshman',
                        fitness: String(Math.ceil(getFitnessScale() / 2)),
                        skills: String(Math.ceil(getSkillsScale() / 2)),
                        notes: ''
                    };
                    importedRiders.push(riderData);
                }

                // COMPLETELY REPLACE existing rider data
                data.riders = [];
                data.riders = importedRiders;
                
                // Update sample version to prevent dummy data from regenerating
                data.sampleVersion = SAMPLE_DATA_VERSION;
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderRiders();

                alert(`Successfully imported ${importedRiders.length} riders from CSV file.\n\nAll existing rider data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Process coaches CSV import
        async function processCoachesCSVImport(coachesText) {
            try {
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = coaches[0];
                const headerMap = getCoachHeaderMap(headers);

                // Import coaches
                const importedCoaches = [];
                for (let i = 1; i < coaches.length; i++) { // Skip header row
                    const row = coaches[i];
                    if (!row || row.length === 0) continue; // Skip empty rows

                    // Get name fields using header map
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    const lastName = (row[lastNameIdx] || '').trim();
                    const firstName = (row[firstNameIdx] || '').trim();
                    if (!firstName && !lastName) continue;

                    const name = `${firstName} ${lastName}`.trim();

                    // Helper function to get value from CSV row using header map
                    const getValue = (fieldName) => {
                        const idx = headerMap[fieldName];
                        if (idx === undefined) {
                            // Debug: log missing header mapping for important fields
                            if (fieldName === 'coachingLicenseLevel') {
                                console.log('Warning: coachingLicenseLevel header not found in CSV. Available headers:', headers);
                                console.log('Normalized headers:', headers.map(h => normalizeHeaderName(h)));
                                console.log('Header map:', headerMap);
                            }
                            return '';
                        }
                        const rawValue = row[idx];
                        const value = (rawValue || '').trim();
                        // Debug for license level
                        if (fieldName === 'coachingLicenseLevel') {
                            console.log(`Coach: ${name}, Column index: ${idx}, Raw CSV value: "${rawValue}", Trimmed: "${value}"`);
                        }
                        return value;
                    };

                    // Helper function to get phone value
                    const getPhoneValue = (fieldName) => {
                        const val = getValue(fieldName);
                        return normalizePhoneNumber(val);
                    };

                    // Get license level - handle various formats
                    const licenseLevelRaw = getValue('coachingLicenseLevel');
                    if (!licenseLevelRaw) {
                        console.log(`No license level value found for coach: ${name} (header map has index: ${headerMap['coachingLicenseLevel']})`);
                    }
                    const licenseLevelNormalized = licenseLevelRaw.trim().toUpperCase();
                    let licenseLevel = 'N/A';
                    
                    // Check for just the number (1, 2, 3) or with "LEVEL" prefix, handle various formats
                    // First check for exact number matches
                    if (licenseLevelNormalized === '1' || licenseLevelNormalized === 'LEVEL 1' || licenseLevelNormalized === 'LEVEL1' || licenseLevelNormalized === 'L1') {
                        licenseLevel = '1';
                    } else if (licenseLevelNormalized === '2' || licenseLevelNormalized === 'LEVEL 2' || licenseLevelNormalized === 'LEVEL2' || licenseLevelNormalized === 'L2') {
                        licenseLevel = '2';
                    } else if (licenseLevelNormalized === '3' || licenseLevelNormalized === 'LEVEL 3' || licenseLevelNormalized === 'LEVEL3' || licenseLevelNormalized === 'L3') {
                        licenseLevel = '3';
                    } else if (licenseLevelNormalized === 'N/A' || licenseLevelNormalized === 'NA' || licenseLevelNormalized === '' || licenseLevelNormalized === 'NULL' || licenseLevelNormalized === 'NONE') {
                        licenseLevel = 'N/A';
                    } else {
                        // Try to extract number from the string (e.g., "Level 1", "1", etc.)
                        const numberMatch = licenseLevelNormalized.match(/\b([123])\b/);
                        if (numberMatch) {
                            licenseLevel = numberMatch[1];
                            console.log(`Extracted license level "${licenseLevel}" from "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}") for coach: ${name}`);
                        } else {
                            // Debug: log unexpected values
                            console.log('Unexpected license level value:', licenseLevelNormalized, '(raw:', licenseLevelRaw, ') for coach:', name);
                        }
                    }

                    // Get gender
                    const genderRaw = getValue('gender').toUpperCase();
                    let gender = '';
                    if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                    else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                    else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                    // Determine default photo based on gender
                    let defaultPhoto = '';
                    if (!gender) {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    } else if (gender === 'M') {
                        defaultPhoto = 'assets/male_default.png';
                    } else if (gender === 'F') {
                        defaultPhoto = 'assets/female_default.png';
                    } else if (gender === 'NB') {
                        defaultPhoto = 'assets/nonbinary_default.png';
                    }

                    const coachData = {
                        id: Date.now() + Math.floor(Math.random() * 1000) + i * 10000,
                        name: name,
                        firstName,
                        lastName,
                        photo: defaultPhoto,
                        phone: getPhoneValue('phone'),
                        email: getValue('email'),
                        coachingLicenseLevel: licenseLevel,
                        workPhone: getPhoneValue('workPhone'),
                        homePhone: getPhoneValue('homePhone'),
                        gender: gender,
                        registered: getValue('registered'),
                        paid: getValue('paid'),
                        backgroundCheck: getValue('backgroundCheck'),
                        level3ExamCompleted: getValue('level3ExamCompleted'),
                        pduCeuUnits: getValue('pduCeuUnits'),
                        fieldWorkHours: getValue('fieldWorkHours'),
                        firstAidTypeExpires: getValue('firstAidTypeExpires'),
                        cprExpires: getValue('cprExpires'),
                        concussionTrainingCompleted: getValue('concussionTrainingCompleted'),
                        nicaPhilosophyCompleted: getValue('nicaPhilosophyCompleted'),
                        athleteAbuseAwarenessCompleted: getValue('athleteAbuseAwarenessCompleted'),
                        licenseLevel1Completed: getValue('licenseLevel1Completed'),
                        licenseLevel2Completed: getValue('licenseLevel2Completed'),
                        licenseLevel3Completed: getValue('licenseLevel3Completed'),
                        otbSkills101ClassroomCompleted: getValue('otbSkills101ClassroomCompleted'),
                        otbSkills101OutdoorCompleted: getValue('otbSkills101OutdoorCompleted'),
                        nicaLeaderSummitCompleted: getValue('nicaLeaderSummitCompleted'),
                        // Default values for fields not in CSV
                        fitness: String(Math.ceil(getFitnessScale() / 2)),
                        skills: String(Math.ceil(getSkillsScale() / 2)),
                        notes: ''
                    };
                    importedCoaches.push(coachData);
                }

                // COMPLETELY REPLACE existing coach data
                data.coaches = [];
                data.coaches = importedCoaches;
                
                // Update sample version to prevent dummy data from regenerating
                data.sampleVersion = SAMPLE_DATA_VERSION;
                
                // Force save to localStorage
                saveData();
                
                // Re-render
                renderCoaches();

                alert(`Successfully imported ${importedCoaches.length} coaches from CSV file.\n\nAll existing coach data has been replaced.`);
            } catch (error) {
                console.error('CSV import error:', error);
                alert('Error importing CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        function parseCSV(text) {
            const lines = [];
            let currentLine = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    currentLine.push(currentField);
                    currentField = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && nextChar === '\n') {
                        i++; // Skip \n after \r
                    }
                    currentLine.push(currentField);
                    lines.push(currentLine);
                    currentLine = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }

            // Add last field and line
            if (currentField || currentLine.length > 0) {
                currentLine.push(currentField);
                lines.push(currentLine);
            }

            return lines;
        }

        // Helper function to normalize CSV header names for matching
        function normalizeHeaderName(header) {
            return header.trim().toLowerCase()
                .replace(/[^a-z0-9]/g, '')
                .replace(/\s+/g, '');
        }

        // Map CSV headers to rider field names
        function getRiderHeaderMap(headers) {
            const map = {};
            headers.forEach((header, index) => {
                const normalized = normalizeHeaderName(header);
                // Map common variations
                if (normalized.includes('firstname') || normalized === 'firstname') {
                    map['firstName'] = index;
                } else if (normalized.includes('lastname') || normalized === 'lastname') {
                    map['lastName'] = index;
                } else if (normalized.includes('rideremail') || normalized.includes('email') && !normalized.includes('parent')) {
                    map['email'] = index;
                } else if (normalized.includes('ridercell') || normalized.includes('cellnumber') || (normalized.includes('phone') && !normalized.includes('parent'))) {
                    map['phone'] = index;
                } else if (normalized.includes('rideraddress') || normalized.includes('address') && !normalized.includes('parent')) {
                    map['address'] = index;
                } else if (normalized.includes('ridergender') || normalized.includes('gender') && !normalized.includes('parent')) {
                    map['gender'] = index;
                } else if (normalized.includes('ridergrade') || normalized.includes('grade') && !normalized.includes('parent')) {
                    map['grade'] = index;
                } else if (normalized.includes('riderbirthday') || normalized.includes('birthday')) {
                    map['birthday'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('cell')) {
                    // Check for "Primary Parent/Guardian Cell Number" - must check cell before name to avoid false matches
                    map['primaryParentPhone'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('email')) {
                    // Check for "Primary Parent/Guardian Email"
                    map['primaryParentEmail'] = index;
                } else if (normalized.includes('primaryparent') && normalized.includes('address')) {
                    // Check for "Primary Parent/Guardian Address if different"
                    map['primaryParentAddress'] = index;
                } else if (normalized.includes('primaryparentguardian') || (normalized.includes('primaryparent') && normalized.includes('name'))) {
                    // Check for "Primary Parent/Guardian" - must be last to avoid matching other primary parent fields
                    map['primaryParentName'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('name')) {
                    map['secondParentName'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('cell')) {
                    map['secondParentPhone'] = index;
                } else if (normalized.includes('secondparent') && normalized.includes('email')) {
                    map['secondParentEmail'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('contact') && normalized.includes('name')) {
                    map['alternateContactName'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('relationship')) {
                    map['alternateContactRelationship'] = index;
                } else if (normalized.includes('alternate') && normalized.includes('cell')) {
                    map['alternateContactPhone'] = index;
                } else if (normalized.includes('primaryphysician') && !normalized.includes('phone')) {
                    map['primaryPhysician'] = index;
                } else if (normalized.includes('primaryphysician') && normalized.includes('phone')) {
                    map['primaryPhysicianPhone'] = index;
                } else if (normalized.includes('medicalinsurance') && normalized.includes('company')) {
                    map['medicalInsuranceCompany'] = index;
                } else if (normalized.includes('medicalinsurance') && (normalized.includes('account') || normalized.includes('number'))) {
                    map['medicalInsuranceAccountNumber'] = index;
                } else if (normalized.includes('allerg') || normalized.includes('medicalneeds')) {
                    map['allergiesOrMedicalNeeds'] = index;
                }
            });
            return map;
        }

        // Map CSV headers to coach field names
        function getCoachHeaderMap(headers) {
            const map = {};
            headers.forEach((header, index) => {
                const normalized = normalizeHeaderName(header);
                if (normalized.includes('lastname') || normalized === 'lastname') {
                    map['lastName'] = index;
                } else if (normalized.includes('firstname') || normalized === 'firstname') {
                    map['firstName'] = index;
                } else if (normalized.includes('coachinglicenselevel') || 
                          (normalized.includes('license') && normalized.includes('level') && !normalized.includes('completed'))) {
                    // Only map if not already mapped (prefer more specific matches)
                    // Match "coaching license level" or "license level" but exclude "license level 1 completed" etc.
                    if (!map['coachingLicenseLevel']) {
                        map['coachingLicenseLevel'] = index;
                    }
                } else if (normalized.includes('email') && !normalized.includes('parent')) {
                    map['email'] = index;
                } else if (normalized.includes('cellphone') || (normalized.includes('phone') && !normalized.includes('work') && !normalized.includes('home'))) {
                    map['phone'] = index;
                } else if (normalized.includes('workphone')) {
                    map['workPhone'] = index;
                } else if (normalized.includes('homephone')) {
                    map['homePhone'] = index;
                } else if (normalized.includes('gender')) {
                    map['gender'] = index;
                } else if (normalized.includes('registered')) {
                    map['registered'] = index;
                } else if (normalized.includes('paid')) {
                    map['paid'] = index;
                } else if (normalized.includes('backgroundcheck')) {
                    map['backgroundCheck'] = index;
                } else if (normalized.includes('level3exam')) {
                    map['level3ExamCompleted'] = index;
                } else if (normalized.includes('pdu') || normalized.includes('ceu')) {
                    map['pduCeuUnits'] = index;
                } else if (normalized.includes('fieldwork')) {
                    map['fieldWorkHours'] = index;
                } else if (normalized.includes('firstaid')) {
                    map['firstAidTypeExpires'] = index;
                } else if (normalized.includes('cpr') && normalized.includes('expires')) {
                    map['cprExpires'] = index;
                } else if (normalized.includes('concussion')) {
                    map['concussionTrainingCompleted'] = index;
                } else if (normalized.includes('nicaphilosophy') || normalized.includes('safetyrisk')) {
                    map['nicaPhilosophyCompleted'] = index;
                } else if (normalized.includes('athleteabuse')) {
                    map['athleteAbuseAwarenessCompleted'] = index;
                } else if (normalized.includes('licenselevel1')) {
                    map['licenseLevel1Completed'] = index;
                } else if (normalized.includes('licenselevel2')) {
                    map['licenseLevel2Completed'] = index;
                } else if (normalized.includes('licenselevel3')) {
                    map['licenseLevel3Completed'] = index;
                } else if (normalized.includes('otbskills101classroom')) {
                    map['otbSkills101ClassroomCompleted'] = index;
                } else if (normalized.includes('otbskills101outdoor') || normalized.includes('otbskills101training')) {
                    map['otbSkills101OutdoorCompleted'] = index;
                } else if (normalized.includes('nicaleadersummit')) {
                    map['nicaLeaderSummitCompleted'] = index;
                }
            });
            return map;
        }

        // Update riders from CSV (matches by name, updates fields, adds new, removes missing)
        async function updateRidersFromCSV(ridersText) {
            try {
                // Parse CSV
                const riders = parseCSV(ridersText);
                if (riders.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = riders[0];
                const headerMap = getRiderHeaderMap(headers);

                // Helper function to get value from CSV row using header map
                const getValue = (row, fieldName) => {
                    const idx = headerMap[fieldName];
                    return idx !== undefined ? (row[idx] || '').trim() : '';
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV riders by name (firstName + lastName)
                const csvRidersMap = new Map();
                for (let i = 1; i < riders.length; i++) {
                    const row = riders[i];
                    if (!row || row.length === 0) continue;

                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    let firstName = (row[firstNameIdx] || '').trim();
                    let lastName = (row[lastNameIdx] || '').trim();
                    
                    // Handle cases where name might be in a single field
                    if (!firstName && !lastName) continue;
                    if (!lastName && firstName) {
                        // Try to split if only one name field has data
                        const parts = firstName.split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    const nameKey = `${firstName}|${lastName}`;
                    csvRidersMap.set(nameKey, row);
                }

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'skills', 'notes', 'racingGroup', 'photo', 'id'];

                // Helper function to extract firstName and lastName from rider object
                const getRiderNames = (rider) => {
                    let firstName = (rider.firstName || '').trim();
                    let lastName = (rider.lastName || '').trim();
                    
                    // If firstName/lastName don't exist, try to split the name field
                    if (!firstName && !lastName && rider.name) {
                        const parts = rider.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = rider.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };

                // Debug output
                const debugOutput = [];
                debugOutput.push('=== CSV UPDATE DEBUG ===');
                debugOutput.push(`CSV Riders in file: ${csvRidersMap.size}`);
                debugOutput.push(`Existing Riders in roster: ${data.riders.length}`);
                debugOutput.push('');
                
                // Debug: Show sample rider object structure
                if (data.riders.length > 0) {
                    const sampleRider = data.riders[0];
                    debugOutput.push('Sample Rider Object Fields:');
                    const riderFields = Object.keys(sampleRider).sort();
                    riderFields.forEach(field => {
                        const value = sampleRider[field];
                        const displayValue = (value === undefined || value === null) ? 'undefined/null' : (value === '' ? '""' : String(value).substring(0, 50));
                        debugOutput.push(`  ${field}: ${displayValue}`);
                    });
                    debugOutput.push('');
                }
                
                // Debug: Show header mapping
                debugOutput.push('Header Mapping:');
                Object.keys(headerMap).sort().forEach(fieldName => {
                    const colIndex = headerMap[fieldName];
                    const headerName = headers[colIndex] || 'UNKNOWN';
                    debugOutput.push(`  ${fieldName} -> Column ${colIndex}: "${headerName}"`);
                });
                debugOutput.push('');
                
                debugOutput.push('CSV Name Keys:');
                for (const [key, row] of csvRidersMap.entries()) {
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                    const firstName = (row[firstNameIdx] || '').trim();
                    const lastName = (row[lastNameIdx] || '').trim();
                    debugOutput.push(`  "${key}" -> "${firstName} ${lastName}"`);
                }
                debugOutput.push('');
                debugOutput.push('Roster Name Keys:');
                for (const rider of data.riders) {
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName}|${lastName}`;
                    debugOutput.push(`  "${nameKey}" -> "${rider.name || 'NO NAME'}" (ID: ${rider.id})`);
                }
                debugOutput.push('');

                // Update existing riders and track which ones were found in CSV
                const updatedRiders = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;
                const changedFields = [];

                for (const rider of data.riders) {
                    const { firstName, lastName } = getRiderNames(rider);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    // Debug: log if name key is empty or malformed
                    if (!firstName && !lastName) {
                        console.warn('Rider has no name:', rider);
                        continue; // Skip riders with no name
                    }
                    
                    if (csvRidersMap.has(nameKey)) {
                        // Rider found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvRidersMap.get(nameKey);
                        
                        // Create updated rider object, preserving non-CSV fields
                        const updatedRider = { ...rider };
                        let fieldsChanged = 0;
                        const riderChangedFields = [];
                        
                        // Helper to compare and update field
                        const updateField = (fieldName, newVal) => {
                            // Get the actual current value from the original rider object
                            // Check if property exists using 'in' operator to handle undefined vs missing property
                            const oldVal = (fieldName in rider) ? rider[fieldName] : undefined;
                            // Normalize for comparison: treat undefined, null, and empty string as equivalent
                            const normalizedOld = (oldVal === undefined || oldVal === null || oldVal === '') ? '' : String(oldVal).trim();
                            const normalizedNew = (newVal === undefined || newVal === null || newVal === '') ? '' : String(newVal).trim();
                            
                            // Only update if values are actually different
                            if (normalizedOld !== normalizedNew) {
                                updatedRider[fieldName] = newVal;
                                fieldsChanged++;
                                riderChangedFields.push(`${fieldName}: "${normalizedOld}" -> "${normalizedNew}"`);
                                return true;
                            }
                            return false;
                        };
                        
                        // Update fields from CSV (only if they exist in CSV)
                        if (headerMap['phone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'phone');
                            updateField('phone', newVal);
                        }
                        if (headerMap['address'] !== undefined) {
                            const newVal = getValue(csvRow, 'address');
                            updateField('address', newVal);
                        }
                        if (headerMap['gender'] !== undefined) {
                            const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                            let newGender = '';
                            if (genderRaw === 'M' || genderRaw === 'MALE') newGender = 'M';
                            else if (genderRaw === 'F' || genderRaw === 'FEMALE') newGender = 'F';
                            else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') newGender = 'NB';
                            updateField('gender', newGender);
                        }
                        if (headerMap['grade'] !== undefined) {
                            const gradeRaw = getValue(csvRow, 'grade');
                            const newGrade = normalizeGradeValue(gradeRaw);
                            updateField('grade', newGrade);
                        }
                        if (headerMap['birthday'] !== undefined) {
                            const newVal = getValue(csvRow, 'birthday');
                            updateField('birthday', newVal);
                        }
                        if (headerMap['primaryParentName'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentName');
                            updateField('primaryParentName', newVal);
                        }
                        if (headerMap['primaryParentPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'primaryParentPhone');
                            updateField('primaryParentPhone', newVal);
                        }
                        if (headerMap['primaryParentEmail'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentEmail');
                            updateField('primaryParentEmail', newVal);
                        }
                        if (headerMap['primaryParentAddress'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryParentAddress');
                            updateField('primaryParentAddress', newVal);
                        }
                        if (headerMap['secondParentName'] !== undefined) {
                            const newVal = getValue(csvRow, 'secondParentName');
                            updateField('secondParentName', newVal);
                        }
                        if (headerMap['secondParentPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'secondParentPhone');
                            updateField('secondParentPhone', newVal);
                        }
                        if (headerMap['secondParentEmail'] !== undefined) {
                            const newVal = getValue(csvRow, 'secondParentEmail');
                            updateField('secondParentEmail', newVal);
                        }
                        if (headerMap['alternateContactName'] !== undefined) {
                            const newVal = getValue(csvRow, 'alternateContactName');
                            updateField('alternateContactName', newVal);
                        }
                        if (headerMap['alternateContactRelationship'] !== undefined) {
                            const newVal = getValue(csvRow, 'alternateContactRelationship');
                            updateField('alternateContactRelationship', newVal);
                        }
                        if (headerMap['alternateContactPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'alternateContactPhone');
                            updateField('alternateContactPhone', newVal);
                        }
                        if (headerMap['primaryPhysician'] !== undefined) {
                            const newVal = getValue(csvRow, 'primaryPhysician');
                            updateField('primaryPhysician', newVal);
                        }
                        if (headerMap['primaryPhysicianPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'primaryPhysicianPhone');
                            updateField('primaryPhysicianPhone', newVal);
                        }
                        if (headerMap['medicalInsuranceCompany'] !== undefined) {
                            const newVal = getValue(csvRow, 'medicalInsuranceCompany');
                            updateField('medicalInsuranceCompany', newVal);
                        }
                        if (headerMap['medicalInsuranceAccountNumber'] !== undefined) {
                            const newVal = getValue(csvRow, 'medicalInsuranceAccountNumber');
                            updateField('medicalInsuranceAccountNumber', newVal);
                        }
                        if (headerMap['allergiesOrMedicalNeeds'] !== undefined) {
                            const newVal = getValue(csvRow, 'allergiesOrMedicalNeeds');
                            updateField('allergiesOrMedicalNeeds', newVal);
                        }
                        
                        // Update name fields (use original case from CSV)
                        const csvFirstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                        const csvLastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                        const csvFirstName = (csvRow[csvFirstNameIdx] || '').trim();
                        const csvLastName = (csvRow[csvLastNameIdx] || '').trim();
                        const newName = `${csvFirstName} ${csvLastName}`.trim();
                        updateField('firstName', csvFirstName);
                        updateField('lastName', csvLastName);
                        updateField('name', newName);
                        
                        totalFieldsUpdated += fieldsChanged;
                        if (fieldsChanged > 0) {
                            debugOutput.push(`‚úì MATCHED: "${nameKey}" (${rider.name || 'NO NAME'}) - ${fieldsChanged} field(s) changed:`);
                            riderChangedFields.forEach(f => debugOutput.push(`    ${f}`));
                        } else {
                            debugOutput.push(`‚úì MATCHED: "${nameKey}" (${rider.name || 'NO NAME'}) - No changes`);
                        }
                        updatedRiders.push(updatedRider);
                    } else {
                        // Rider not in CSV - remove them (don't add to updatedRiders)
                        removedCount++;
                        debugOutput.push(`‚úó NOT IN CSV: "${nameKey}" (${rider.name || 'NO NAME'}) - Will be REMOVED`);
                    }
                }

                // Add new riders from CSV that weren't in the roster
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvRidersMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        // New rider from CSV
                        const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 0;
                        const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 1;
                        const firstName = (csvRow[firstNameIdx] || '').trim();
                        const lastName = (csvRow[lastNameIdx] || '').trim();
                        const name = `${firstName} ${lastName}`.trim();
                        debugOutput.push(`+ NEW IN CSV: "${nameKey}" (${firstName} ${lastName}) - Will be ADDED`);

                        // Get gender for default photo
                        const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                        let gender = '';
                        if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                        else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                        else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const gradeRaw = getValue(csvRow, 'grade');
                        const grade = normalizeGradeValue(gradeRaw);

                        const newRider = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 1000,
                            name: name,
                            firstName,
                            lastName,
                            photo: defaultPhoto,
                            email: getValue(csvRow, 'email'),
                            phone: getPhoneValue(csvRow, 'phone'),
                            address: getValue(csvRow, 'address'),
                            gender: gender,
                            grade: grade,
                            birthday: getValue(csvRow, 'birthday'),
                            primaryParentName: getValue(csvRow, 'primaryParentName'),
                            primaryParentPhone: getPhoneValue(csvRow, 'primaryParentPhone'),
                            primaryParentEmail: getValue(csvRow, 'primaryParentEmail'),
                            primaryParentAddress: getValue(csvRow, 'primaryParentAddress'),
                            secondParentName: getValue(csvRow, 'secondParentName'),
                            secondParentPhone: getPhoneValue(csvRow, 'secondParentPhone'),
                            secondParentEmail: getValue(csvRow, 'secondParentEmail'),
                            alternateContactName: getValue(csvRow, 'alternateContactName'),
                            alternateContactRelationship: getValue(csvRow, 'alternateContactRelationship'),
                            alternateContactPhone: getPhoneValue(csvRow, 'alternateContactPhone'),
                            primaryPhysician: getValue(csvRow, 'primaryPhysician'),
                            primaryPhysicianPhone: getPhoneValue(csvRow, 'primaryPhysicianPhone'),
                            medicalInsuranceCompany: getValue(csvRow, 'medicalInsuranceCompany'),
                            medicalInsuranceAccountNumber: getValue(csvRow, 'medicalInsuranceAccountNumber'),
                            allergiesOrMedicalNeeds: getValue(csvRow, 'allergiesOrMedicalNeeds'),
                            racingGroup: 'Freshman',
                            fitness: String(Math.ceil(getFitnessScale() / 2)),
                            skills: String(Math.ceil(getSkillsScale() / 2)),
                            notes: ''
                        };
                        updatedRiders.push(newRider);
                        addedCount++;
                    }
                }

                // Update data
                data.riders = updatedRiders;
                saveData();
                renderRiders();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new rider(s)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} rider(s) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                // Add summary to debug output
                debugOutput.push('');
                debugOutput.push('=== SUMMARY ===');
                debugOutput.push(`Total fields updated: ${totalFieldsUpdated}`);
                debugOutput.push(`Riders matched and updated: ${updatedCount}`);
                debugOutput.push(`New riders added: ${addedCount}`);
                debugOutput.push(`Riders removed: ${removedCount}`);
                
                // Display debug output
                const debugDiv = document.getElementById('rider-update-debug');
                if (debugDiv) {
                    debugDiv.innerHTML = debugOutput.join('<br>');
                    debugDiv.style.display = 'block';
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Update coaches from CSV (matches by name, updates fields, adds new, removes missing)
        async function updateCoachesFromCSV(coachesText) {
            try {
                // Parse CSV
                const coaches = parseCSV(coachesText);
                if (coaches.length < 2) {
                    alert('CSV file must contain at least a header row and one data row.');
                    return;
                }

                // Get header mapping
                const headers = coaches[0];
                const headerMap = getCoachHeaderMap(headers);

                // Debug output
                const debugOutput = [];
                debugOutput.push('=== CSV UPDATE DEBUG ===');
                debugOutput.push(`CSV Coaches in file: ${coaches.length - 1}`);
                debugOutput.push(`Existing Coaches in roster: ${data.coaches.length}`);
                debugOutput.push('');
                
                // Debug: Show sample coach object structure
                if (data.coaches.length > 0) {
                    const sampleCoach = data.coaches[0];
                    debugOutput.push('Sample Coach Object Fields:');
                    const coachFields = Object.keys(sampleCoach).sort();
                    coachFields.forEach(field => {
                        const value = sampleCoach[field];
                        const displayValue = (value === undefined || value === null) ? 'undefined/null' : (value === '' ? '""' : String(value).substring(0, 50));
                        debugOutput.push(`  ${field}: ${displayValue}`);
                    });
                    debugOutput.push('');
                }
                
                // Debug: Show header mapping
                debugOutput.push('Header Mapping:');
                Object.keys(headerMap).sort().forEach(fieldName => {
                    const colIndex = headerMap[fieldName];
                    const headerName = headers[colIndex] || 'UNKNOWN';
                    debugOutput.push(`  ${fieldName} -> Column ${colIndex}: "${headerName}"`);
                });
                debugOutput.push('');
                
                // Debug: Check if coachingLicenseLevel is mapped
                if (!headerMap['coachingLicenseLevel']) {
                    debugOutput.push('WARNING: coachingLicenseLevel not found in header map!');
                    debugOutput.push('Available headers:', headers.join(', '));
                }

                // Helper function to get value from CSV row using header map
                const getValue = (row, fieldName) => {
                    const idx = headerMap[fieldName];
                    if (idx === undefined) {
                        // Debug: log missing header mapping for important fields
                        if (fieldName === 'coachingLicenseLevel') {
                            console.log('Warning: coachingLicenseLevel header not found in CSV. Available headers:', headers);
                            console.log('Header map:', headerMap);
                            debugOutput.push(`ERROR: ${fieldName} header not found!`);
                        }
                        return '';
                    }
                    const value = (row[idx] || '').trim();
                    return value;
                };

                const getPhoneValue = (row, fieldName) => {
                    const val = getValue(row, fieldName);
                    return normalizePhoneNumber(val);
                };

                // Create a map of CSV coaches by name (firstName + lastName)
                const csvCoachesMap = new Map();
                for (let i = 1; i < coaches.length; i++) {
                    const row = coaches[i];
                    if (!row || row.length === 0) continue;

                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    let lastName = (row[lastNameIdx] || '').trim();
                    let firstName = (row[firstNameIdx] || '').trim();
                    
                    // Handle cases where name might be in a single field
                    if (!firstName && !lastName) continue;
                    if (!lastName && firstName) {
                        // Try to split if only one name field has data
                        const parts = firstName.split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    const nameKey = `${firstName}|${lastName}`;
                    csvCoachesMap.set(nameKey, row);
                }
                
                // Helper function to extract firstName and lastName from coach object
                const getCoachNames = (coach) => {
                    let firstName = (coach.firstName || '').trim();
                    let lastName = (coach.lastName || '').trim();
                    
                    // If firstName/lastName don't exist, try to split the name field
                    if (!firstName && !lastName && coach.name) {
                        const parts = coach.name.trim().split(/\s+/);
                        if (parts.length > 1) {
                            lastName = parts.pop();
                            firstName = parts.join(' ');
                        } else {
                            firstName = coach.name.trim();
                        }
                    }
                    
                    // Normalize: lowercase and remove extra spaces
                    firstName = firstName.toLowerCase().replace(/\s+/g, ' ').trim();
                    lastName = lastName.toLowerCase().replace(/\s+/g, ' ').trim();
                    
                    return { firstName, lastName };
                };
                
                debugOutput.push('CSV Name Keys:');
                for (const [key, row] of csvCoachesMap.entries()) {
                    const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                    const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                    const lastName = (row[lastNameIdx] || '').trim();
                    const firstName = (row[firstNameIdx] || '').trim();
                    debugOutput.push(`  "${key}" -> "${firstName} ${lastName}"`);
                }
                debugOutput.push('');
                debugOutput.push('Roster Name Keys:');
                for (const coach of data.coaches) {
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    debugOutput.push(`  "${nameKey}" -> "${coach.name || 'NO NAME'}" (ID: ${coach.id})`);
                }
                debugOutput.push('');

                // Fields that should NOT be updated from CSV (preserve existing values)
                const preserveFields = ['fitness', 'notes', 'photo', 'id'];

                // Update existing coaches and track which ones were found in CSV
                const updatedCoaches = [];
                const csvKeysFound = new Set();
                let removedCount = 0;
                let updatedCount = 0;
                let totalFieldsUpdated = 0;

                for (const coach of data.coaches) {
                    const { firstName, lastName } = getCoachNames(coach);
                    const nameKey = `${firstName}|${lastName}`;
                    
                    // Debug: log if name key is empty or malformed
                    if (!firstName && !lastName) {
                        console.warn('Coach has no name:', coach);
                        continue; // Skip coaches with no name
                    }
                    
                    if (csvCoachesMap.has(nameKey)) {
                        // Coach found in CSV - update fields from CSV
                        csvKeysFound.add(nameKey);
                        updatedCount++;
                        const csvRow = csvCoachesMap.get(nameKey);
                        
                        // Create updated coach object, preserving non-CSV fields
                        const updatedCoach = { ...coach };
                        let fieldsChanged = 0;
                        const coachChangedFields = [];
                        
                        // Helper to compare and update field
                        const updateField = (fieldName, newVal) => {
                            // Get the actual current value from the original coach object
                            // Use 'in' operator to check if property exists (handles undefined vs missing property)
                            const oldVal = (fieldName in coach) ? coach[fieldName] : undefined;
                            // Normalize for comparison: treat undefined, null, and empty string as equivalent
                            const normalizedOld = (oldVal === undefined || oldVal === null || oldVal === '') ? '' : String(oldVal).trim();
                            const normalizedNew = (newVal === undefined || newVal === null || newVal === '') ? '' : String(newVal).trim();
                            
                            // Only update if values are actually different
                            if (normalizedOld !== normalizedNew) {
                                updatedCoach[fieldName] = newVal;
                                fieldsChanged++;
                                coachChangedFields.push(`${fieldName}: "${normalizedOld}" -> "${normalizedNew}"`);
                                return true;
                            }
                            return false;
                        };
                        
                        // Update fields from CSV (only if they exist in CSV)
                        if (headerMap['email'] !== undefined) {
                            const newVal = getValue(csvRow, 'email');
                            updateField('email', newVal);
                        }
                        if (headerMap['phone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'phone');
                            updateField('phone', newVal);
                        }
                        if (headerMap['workPhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'workPhone');
                            updateField('workPhone', newVal);
                        }
                        if (headerMap['homePhone'] !== undefined) {
                            const newVal = getPhoneValue(csvRow, 'homePhone');
                            updateField('homePhone', newVal);
                        }
                        if (headerMap['coachingLicenseLevel'] !== undefined) {
                            const licenseLevelRaw = getValue(csvRow, 'coachingLicenseLevel');
                            const licenseLevelNormalized = licenseLevelRaw.trim().toUpperCase();
                            let newLevel = 'N/A';
                            
                            // Check for just the number (1, 2, 3) or with "LEVEL" prefix
                            if (licenseLevelNormalized === '1' || licenseLevelNormalized === 'LEVEL 1' || licenseLevelNormalized === 'LEVEL1' || licenseLevelNormalized === 'L1') {
                                newLevel = '1';
                            } else if (licenseLevelNormalized === '2' || licenseLevelNormalized === 'LEVEL 2' || licenseLevelNormalized === 'LEVEL2' || licenseLevelNormalized === 'L2') {
                                newLevel = '2';
                            } else if (licenseLevelNormalized === '3' || licenseLevelNormalized === 'LEVEL 3' || licenseLevelNormalized === 'LEVEL3' || licenseLevelNormalized === 'L3') {
                                newLevel = '3';
                            } else if (licenseLevelNormalized === 'N/A' || licenseLevelNormalized === 'NA' || licenseLevelNormalized === '' || licenseLevelNormalized === 'NULL' || licenseLevelNormalized === 'NONE') {
                                newLevel = 'N/A';
                            } else {
                                // Try to extract number from the string (e.g., "Level 1", "1", etc.)
                                const numberMatch = licenseLevelNormalized.match(/\b([123])\b/);
                                if (numberMatch) {
                                    newLevel = numberMatch[1];
                                    debugOutput.push(`  Extracted license level "${newLevel}" from "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}")`);
                                } else {
                                    debugOutput.push(`  Warning: Unexpected license level value: "${licenseLevelNormalized}" (raw: "${licenseLevelRaw}") - defaulting to N/A`);
                                }
                            }
                            updateField('coachingLicenseLevel', newLevel);
                        }
                        if (headerMap['gender'] !== undefined) {
                            const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                            let newGender = '';
                            if (genderRaw === 'M' || genderRaw === 'MALE') newGender = 'M';
                            else if (genderRaw === 'F' || genderRaw === 'FEMALE') newGender = 'F';
                            else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') newGender = 'NB';
                            updateField('gender', newGender);
                        }
                        if (headerMap['registered'] !== undefined) {
                            const newVal = getValue(csvRow, 'registered');
                            updateField('registered', newVal);
                        }
                        if (headerMap['paid'] !== undefined) {
                            const newVal = getValue(csvRow, 'paid');
                            updateField('paid', newVal);
                        }
                        if (headerMap['backgroundCheck'] !== undefined) {
                            const newVal = getValue(csvRow, 'backgroundCheck');
                            updateField('backgroundCheck', newVal);
                        }
                        if (headerMap['level3ExamCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'level3ExamCompleted');
                            updateField('level3ExamCompleted', newVal);
                        }
                        if (headerMap['pduCeuUnits'] !== undefined) {
                            const newVal = getValue(csvRow, 'pduCeuUnits');
                            updateField('pduCeuUnits', newVal);
                        }
                        if (headerMap['fieldWorkHours'] !== undefined) {
                            const newVal = getValue(csvRow, 'fieldWorkHours');
                            updateField('fieldWorkHours', newVal);
                        }
                        if (headerMap['firstAidTypeExpires'] !== undefined) {
                            const newVal = getValue(csvRow, 'firstAidTypeExpires');
                            updateField('firstAidTypeExpires', newVal);
                        }
                        if (headerMap['cprExpires'] !== undefined) {
                            const newVal = getValue(csvRow, 'cprExpires');
                            updateField('cprExpires', newVal);
                        }
                        if (headerMap['concussionTrainingCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'concussionTrainingCompleted');
                            updateField('concussionTrainingCompleted', newVal);
                        }
                        if (headerMap['nicaPhilosophyCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'nicaPhilosophyCompleted');
                            updateField('nicaPhilosophyCompleted', newVal);
                        }
                        if (headerMap['athleteAbuseAwarenessCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'athleteAbuseAwarenessCompleted');
                            updateField('athleteAbuseAwarenessCompleted', newVal);
                        }
                        if (headerMap['licenseLevel1Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel1Completed');
                            updateField('licenseLevel1Completed', newVal);
                        }
                        if (headerMap['licenseLevel2Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel2Completed');
                            updateField('licenseLevel2Completed', newVal);
                        }
                        if (headerMap['licenseLevel3Completed'] !== undefined) {
                            const newVal = getValue(csvRow, 'licenseLevel3Completed');
                            updateField('licenseLevel3Completed', newVal);
                        }
                        if (headerMap['otbSkills101ClassroomCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'otbSkills101ClassroomCompleted');
                            updateField('otbSkills101ClassroomCompleted', newVal);
                        }
                        if (headerMap['otbSkills101OutdoorCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'otbSkills101OutdoorCompleted');
                            updateField('otbSkills101OutdoorCompleted', newVal);
                        }
                        if (headerMap['nicaLeaderSummitCompleted'] !== undefined) {
                            const newVal = getValue(csvRow, 'nicaLeaderSummitCompleted');
                            updateField('nicaLeaderSummitCompleted', newVal);
                        }
                        
                        // Update name fields (use original case from CSV)
                        const csvLastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                        const csvFirstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                        const csvLastName = (csvRow[csvLastNameIdx] || '').trim();
                        const csvFirstName = (csvRow[csvFirstNameIdx] || '').trim();
                        const newName = `${csvFirstName} ${csvLastName}`.trim();
                        updateField('firstName', csvFirstName);
                        updateField('lastName', csvLastName);
                        updateField('name', newName);
                        
                        totalFieldsUpdated += fieldsChanged;
                        if (fieldsChanged > 0) {
                            debugOutput.push(`‚úì MATCHED: "${nameKey}" (${coach.name || 'NO NAME'}) - ${fieldsChanged} field(s) changed:`);
                            coachChangedFields.forEach(f => debugOutput.push(`    ${f}`));
                        } else {
                            debugOutput.push(`‚úì MATCHED: "${nameKey}" (${coach.name || 'NO NAME'}) - No changes`);
                        }
                        updatedCoaches.push(updatedCoach);
                    } else {
                        // Coach not in CSV - remove them (don't add to updatedCoaches)
                        removedCount++;
                        debugOutput.push(`‚úó NOT IN CSV: "${nameKey}" (${coach.name || 'NO NAME'}) - Will be REMOVED`);
                    }
                }

                // Add new coaches from CSV that weren't in the roster
                let addedCount = 0;
                for (const [nameKey, csvRow] of csvCoachesMap.entries()) {
                    if (!csvKeysFound.has(nameKey)) {
                        // New coach from CSV
                        const lastNameIdx = headerMap['lastName'] !== undefined ? headerMap['lastName'] : 0;
                        const firstNameIdx = headerMap['firstName'] !== undefined ? headerMap['firstName'] : 1;
                        const lastName = (csvRow[lastNameIdx] || '').trim();
                        const firstName = (csvRow[firstNameIdx] || '').trim();
                        const name = `${firstName} ${lastName}`.trim();
                        debugOutput.push(`+ NEW IN CSV: "${nameKey}" (${firstName} ${lastName}) - Will be ADDED`);

                        // Get gender for default photo
                        const genderRaw = getValue(csvRow, 'gender').toUpperCase();
                        let gender = '';
                        if (genderRaw === 'M' || genderRaw === 'MALE') gender = 'M';
                        else if (genderRaw === 'F' || genderRaw === 'FEMALE') gender = 'F';
                        else if (genderRaw === 'NB' || genderRaw === 'NONBINARY') gender = 'NB';

                        let defaultPhoto = '';
                        if (!gender) {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        } else if (gender === 'M') {
                            defaultPhoto = 'assets/male_default.png';
                        } else if (gender === 'F') {
                            defaultPhoto = 'assets/female_default.png';
                        } else if (gender === 'NB') {
                            defaultPhoto = 'assets/nonbinary_default.png';
                        }

                        const licenseLevelRaw = getValue(csvRow, 'coachingLicenseLevel').trim().toUpperCase();
                        let licenseLevel = 'N/A';
                        // Check for just the number (1, 2, 3) or with "LEVEL" prefix
                        if (licenseLevelRaw === '1' || licenseLevelRaw === 'LEVEL 1' || licenseLevelRaw === 'LEVEL1') licenseLevel = '1';
                        else if (licenseLevelRaw === '2' || licenseLevelRaw === 'LEVEL 2' || licenseLevelRaw === 'LEVEL2') licenseLevel = '2';
                        else if (licenseLevelRaw === '3' || licenseLevelRaw === 'LEVEL 3' || licenseLevelRaw === 'LEVEL3') licenseLevel = '3';
                        else if (licenseLevelRaw === 'N/A' || licenseLevelRaw === 'NA' || licenseLevelRaw === '') licenseLevel = 'N/A';

                        const newCoach = {
                            id: Date.now() + Math.floor(Math.random() * 1000) + addedCount * 10000,
                            name: name,
                            firstName,
                            lastName,
                            photo: defaultPhoto,
                            phone: getPhoneValue(csvRow, 'phone'),
                            email: getValue(csvRow, 'email'),
                            coachingLicenseLevel: licenseLevel,
                            workPhone: getPhoneValue(csvRow, 'workPhone'),
                            homePhone: getPhoneValue(csvRow, 'homePhone'),
                            gender: gender,
                            registered: getValue(csvRow, 'registered'),
                            paid: getValue(csvRow, 'paid'),
                            backgroundCheck: getValue(csvRow, 'backgroundCheck'),
                            level3ExamCompleted: getValue(csvRow, 'level3ExamCompleted'),
                            pduCeuUnits: getValue(csvRow, 'pduCeuUnits'),
                            fieldWorkHours: getValue(csvRow, 'fieldWorkHours'),
                            firstAidTypeExpires: getValue(csvRow, 'firstAidTypeExpires'),
                            cprExpires: getValue(csvRow, 'cprExpires'),
                            concussionTrainingCompleted: getValue(csvRow, 'concussionTrainingCompleted'),
                            nicaPhilosophyCompleted: getValue(csvRow, 'nicaPhilosophyCompleted'),
                            athleteAbuseAwarenessCompleted: getValue(csvRow, 'athleteAbuseAwarenessCompleted'),
                            licenseLevel1Completed: getValue(csvRow, 'licenseLevel1Completed'),
                            licenseLevel2Completed: getValue(csvRow, 'licenseLevel2Completed'),
                            licenseLevel3Completed: getValue(csvRow, 'licenseLevel3Completed'),
                            otbSkills101ClassroomCompleted: getValue(csvRow, 'otbSkills101ClassroomCompleted'),
                            otbSkills101OutdoorCompleted: getValue(csvRow, 'otbSkills101OutdoorCompleted'),
                            nicaLeaderSummitCompleted: getValue(csvRow, 'nicaLeaderSummitCompleted'),
                            fitness: String(Math.ceil(getFitnessScale() / 2)),
                            skills: String(Math.ceil(getSkillsScale() / 2)),
                            notes: ''
                        };
                        updatedCoaches.push(newCoach);
                        addedCount++;
                    }
                }

                // Update data
                data.coaches = updatedCoaches;
                saveData();
                renderCoaches();

                // Build alert message
                const alertParts = [];
                if (totalFieldsUpdated > 0) {
                    alertParts.push(`${totalFieldsUpdated} field(s) updated`);
                }
                if (addedCount > 0) {
                    alertParts.push(`Added ${addedCount} new coach(es)`);
                }
                if (removedCount > 0) {
                    alertParts.push(`Removed ${removedCount} coach(es) not found in CSV`);
                }
                if (alertParts.length === 0) {
                    alertParts.push('No changes detected');
                }
                
                // Add summary to debug output
                debugOutput.push('');
                debugOutput.push('=== SUMMARY ===');
                debugOutput.push(`Total fields updated: ${totalFieldsUpdated}`);
                debugOutput.push(`Coaches matched and updated: ${updatedCount}`);
                debugOutput.push(`New coaches added: ${addedCount}`);
                debugOutput.push(`Coaches removed: ${removedCount}`);
                
                // Display debug output
                const debugDiv = document.getElementById('coach-update-debug');
                if (debugDiv) {
                    debugDiv.innerHTML = debugOutput.join('<br>');
                    debugDiv.style.display = 'block';
                }
                
                alert(`Roster update complete!\n\n${alertParts.join('\n')}`);
            } catch (error) {
                console.error('CSV update error:', error);
                alert('Error updating from CSV file: ' + (error.message || 'Unknown error'));
            }
        }

        // Helper function to let user select and read a CSV file
        function selectAndReadCSVFile(type) {
            return new Promise((resolve) => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.csv';
                input.style.display = 'none';
                
                let resolved = false;
                
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) {
                        if (!resolved) {
                            resolved = true;
                            resolve(null);
                        }
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (!resolved) {
                            resolved = true;
                            resolve(e.target.result);
                        }
                    };
                    reader.onerror = () => {
                        if (!resolved) {
                            resolved = true;
                            resolve(null);
                        }
                    };
                    reader.readAsText(file);
                };
                
                // Trigger file selection
                document.body.appendChild(input);
                input.click();
                
                // Clean up and timeout
                setTimeout(() => {
                    if (document.body.contains(input)) {
                        document.body.removeChild(input);
                    }
                    if (!resolved) {
                        resolved = true;
                        resolve(null);
                    }
                }, 60000); // 60 second timeout
            });
        }

        function normalizePhoneNumber(phone) {
            if (!phone) return '';
            const digits = phone.replace(/\D/g, '');
            if (digits.length === 10) {
                return digits;
            } else if (digits.length === 11 && digits[0] === '1') {
                return digits.substring(1);
            }
            return '';
        }

        function openAddSinglePracticeModal() {
            // Add a single practice row with date field (not a separate modal)
            addSinglePracticeRow();
        }

        // Location map modal functions
        let currentPracticeIdForLocation = null;
        let map = null;
        let mapMarker = null;

        function openLocationMap(practiceId) {
            currentPracticeIdForLocation = practiceId;
            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practice = seasonSettingsDraft.practices.find(p => String(p.id) === String(practiceId));
            if (!practice) return;

            const modal = document.getElementById('location-map-modal');
            if (!modal) return;

            // Load Leaflet CSS and JS if not already loaded
            if (!document.querySelector('link[href*="leaflet"]')) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                leafletCSS.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';
                leafletCSS.crossOrigin = '';
                document.head.appendChild(leafletCSS);
            }

            if (!window.L) {
                const leafletJS = document.createElement('script');
                leafletJS.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletJS.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';
                leafletJS.crossOrigin = '';
                leafletJS.onload = () => {
                    setTimeout(() => initializeMap(practice), 100);
                };
                document.head.appendChild(leafletJS);
            } else {
                setTimeout(() => initializeMap(practice), 100);
            }

            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            const addressInput = document.getElementById('location-address');
            const searchInput = document.getElementById('location-search');

            if (latInput) latInput.value = practice.locationLat || '';
            if (lngInput) lngInput.value = practice.locationLng || '';
            if (addressInput) addressInput.value = practice.meetLocation || '';
            if (searchInput) searchInput.value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function initializeMap(practice) {
            const mapContainer = document.getElementById('map-container');
            if (!mapContainer || !window.L) {
                setTimeout(() => initializeMap(practice), 100);
                return;
            }

            // Clear existing map
            if (map) {
                map.remove();
                map = null;
                mapMarker = null;
            }

            // Remove placeholder if it exists
            const placeholder = document.getElementById('map-placeholder');
            if (placeholder) {
                placeholder.remove();
            }

            // Default to Tamalpais High School area (Mill Valley, CA)
            const defaultLat = 37.9069;
            const defaultLng = -122.5446;
            
            const lat = practice.locationLat && Number.isFinite(practice.locationLat) ? practice.locationLat : defaultLat;
            const lng = practice.locationLng && Number.isFinite(practice.locationLng) ? practice.locationLng : defaultLng;
            // Zoom level: ~5 miles view = zoom level 12-13 (higher number = more zoomed in)
            // 10 = ~50 miles, 12 = ~10 miles, 13 = ~5 miles, 15 = ~1 mile
            const zoom = practice.locationLat && practice.locationLng ? 15 : 13;

            try {
                map = L.map('map-container').setView([lat, lng], zoom);

                // Use Google Maps tiles via Leaflet
                // Google Maps tile layer (roadmap style)
                // Note: For production, you should use a Google Maps API key
                // This uses Google Maps tiles directly - may have usage limits
                L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                    attribution: '¬© Google Maps',
                    maxZoom: 20,
                    subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
                }).addTo(map);

                if (practice.locationLat && practice.locationLng && Number.isFinite(practice.locationLat) && Number.isFinite(practice.locationLng)) {
                    mapMarker = L.marker([practice.locationLat, practice.locationLng]).addTo(map);
                }

                map.on('click', function(e) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;

                    if (mapMarker) {
                        mapMarker.setLatLng([lat, lng]);
                    } else {
                        mapMarker = L.marker([lat, lng]).addTo(map);
                    }

                    updateLocationInputs(lat, lng);
                    reverseGeocode(lat, lng);
                });

                // Update inputs when manually changed
                const latInput = document.getElementById('location-latitude');
                const lngInput = document.getElementById('location-longitude');
                
                const updateMapFromInputs = () => {
                    const lat = parseFloat(latInput.value);
                    const lng = parseFloat(lngInput.value);
                    if (Number.isFinite(lat) && Number.isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        map.setView([lat, lng], 15);
                        if (mapMarker) {
                            mapMarker.setLatLng([lat, lng]);
                        } else {
                            mapMarker = L.marker([lat, lng]).addTo(map);
                        }
                        reverseGeocode(lat, lng);
                    }
                };

                if (latInput) {
                    latInput.addEventListener('change', updateMapFromInputs);
                    latInput.addEventListener('blur', updateMapFromInputs);
                }
                if (lngInput) {
                    lngInput.addEventListener('change', updateMapFromInputs);
                    lngInput.addEventListener('blur', updateMapFromInputs);
                }
            } catch (error) {
                console.error('Map initialization error:', error);
                mapContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Error loading map. Please refresh and try again.</div>';
            }
        }

        function updateLocationInputs(lat, lng) {
            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            if (latInput) latInput.value = lat.toFixed(6);
            if (lngInput) lngInput.value = lng.toFixed(6);
        }

        function reverseGeocode(lat, lng) {
            // Use Nominatim (OpenStreetMap geocoding service) with delay to respect rate limits
            // Only update address field if it's empty (don't overwrite user-entered text)
            setTimeout(() => {
                fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`, {
                    headers: {
                        'User-Agent': 'MTB Team Practice Manager'
                    }
                })
                    .then(response => response.json())
                    .then(data => {
                        const addressInput = document.getElementById('location-address');
                        // Only update if field is empty - preserve user-entered text
                        if (addressInput && data.display_name && !addressInput.value.trim()) {
                            addressInput.value = data.display_name;
                        }
                    })
                    .catch(error => {
                        console.error('Geocoding error:', error);
                    });
            }, 500);
        }

        function searchLocation() {
            const searchInput = document.getElementById('location-search');
            if (!searchInput || !searchInput.value.trim()) {
                alert('Please enter a location to search');
                return;
            }

            if (!map) {
                alert('Map is not loaded yet. Please wait a moment and try again.');
                return;
            }

            const query = encodeURIComponent(searchInput.value.trim());
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=1`, {
                headers: {
                    'User-Agent': 'MTB Team Practice Manager'
                }
            })
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const result = data[0];
                        const lat = parseFloat(result.lat);
                        const lng = parseFloat(result.lon);

                        if (Number.isFinite(lat) && Number.isFinite(lng)) {
                            map.setView([lat, lng], 15);
                            if (mapMarker) {
                                mapMarker.setLatLng([lat, lng]);
                            } else {
                                mapMarker = L.marker([lat, lng]).addTo(map);
                            }
                            updateLocationInputs(lat, lng);
                            
                            const addressInput = document.getElementById('location-address');
                            // Only update if field is empty - preserve user-entered text
                            if (addressInput && (!addressInput.value.trim())) {
                                addressInput.value = result.display_name;
                            }
                        }
                    } else {
                        alert('Location not found. Please try a different search.');
                    }
                })
                .catch(error => {
                    console.error('Search error:', error);
                    alert('Error searching for location. Please try again.');
                });
        }

        function saveLocation() {
            if (currentPracticeIdForLocation === null) return;

            const latInput = document.getElementById('location-latitude');
            const lngInput = document.getElementById('location-longitude');
            const addressInput = document.getElementById('location-address');

            const lat = latInput ? parseFloat(latInput.value) : null;
            const lng = lngInput ? parseFloat(lngInput.value) : null;
            const address = addressInput ? addressInput.value.trim() : '';

            ensureSeasonDraft();
            if (!seasonSettingsDraft) return;

            const practiceIndex = seasonSettingsDraft.practices.findIndex(
                p => String(p.id) === String(currentPracticeIdForLocation)
            );
            if (practiceIndex === -1) return;

            if (Number.isFinite(lat) && Number.isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                seasonSettingsDraft.practices[practiceIndex].locationLat = lat;
                seasonSettingsDraft.practices[practiceIndex].locationLng = lng;
            } else {
                seasonSettingsDraft.practices[practiceIndex].locationLat = null;
                seasonSettingsDraft.practices[practiceIndex].locationLng = null;
            }

            if (address) {
                seasonSettingsDraft.practices[practiceIndex].meetLocation = address;
            }

            closeLocationMapModal();
            renderPracticeRows();
        }

        function closeLocationMapModal() {
            const modal = document.getElementById('location-map-modal');
            if (!modal) return;

            if (map) {
                try {
                    map.remove();
                } catch (e) {
                    console.error('Error removing map:', e);
                }
                map = null;
                mapMarker = null;
            }

            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            currentPracticeIdForLocation = null;
        }

        function formatDateToISO(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function parseISODate(dateString) {
            if (!dateString) return null;
            // Parse date string (YYYY-MM-DD) in local time to avoid timezone issues
            const parts = dateString.split('-');
            if (parts.length !== 3) {
                // Fallback to standard parsing if format is unexpected
                const parsed = new Date(dateString);
                return Number.isNaN(parsed.getTime()) ? null : parsed;
            }
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
            const day = parseInt(parts[2], 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return null;
            }
            const parsed = new Date(year, month, day);
            return Number.isNaN(parsed.getTime()) ? null : parsed;
        }

        function openAddPracticeModal() {
            const modal = document.getElementById('add-practice-modal');
            if (!modal) return;

            const dateInput = document.getElementById('practice-date');
            const timeInput = document.getElementById('practice-time');
            
            if (dateInput) dateInput.value = '';
            if (timeInput) timeInput.value = '';

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');

            if (dateInput) {
                setTimeout(() => dateInput.focus(), 0);
            }
        }

        function closeAddPracticeModal() {
            const modal = document.getElementById('add-practice-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        function saveAddPractice() {
            const dateInput = document.getElementById('practice-date');
            const timeInput = document.getElementById('practice-time');
            
            const dateValue = dateInput ? dateInput.value : '';
            const timeValue = timeInput ? timeInput.value : '';

            if (!dateValue) {
                alert('Please select a date');
                return;
            }

            if (!timeValue) {
                alert('Please select a time');
                return;
            }

            const existingRide = data.rides.find(ride => ride.date === dateValue);
            let rideId;

            if (existingRide) {
                rideId = existingRide.id;
            } else {
                const ride = {
                    id: generateId(),
                    date: dateValue,
                    time: timeValue,
                    availableCoaches: [],
                    availableRiders: [],
                    assignments: {},
                    groups: []
                };
                data.rides.push(ride);
                rideId = ride.id;
            }

            data.currentRide = rideId;
            saveData();
            closeAddPracticeModal();
            renderRides();
            loadCurrentRide();
        }

        function formatTimeForDisplay(time) {
            if (!time) return '';
            const [hourStr, minuteStr = '00'] = time.split(':');
            const hour = parseInt(hourStr, 10);
            const minute = parseInt(minuteStr, 10) || 0;
            if (!Number.isFinite(hour)) return time;
            const period = hour >= 12 ? 'PM' : 'AM';
            const hour12 = ((hour + 11) % 12) + 1;
            return `${hour12}:${minute.toString().padStart(2, '0')} ${period}`;
        }

        function renderSeasonCalendar() {
            // Render to rides tab calendar if it exists
            const ridesContainer = document.getElementById('season-calendar');
            if (ridesContainer) {
                renderSeasonCalendarToContainer(ridesContainer);
            }
        }

        function renderSeasonCalendarForSettings() {
            // Render to settings tab calendar if it exists
            const settingsContainer = document.getElementById('season-calendar-settings');
            if (settingsContainer) {
                renderSeasonCalendarToContainer(settingsContainer);
            }
        }

        function renderAllCalendars() {
            // Render to both calendars if they exist
            renderSeasonCalendar();
            renderSeasonCalendarForSettings();
        }

        function renderSeasonCalendarToContainer(container) {
            if (!container) return;

            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const startDate = parseISODate(settings.startDate);
            const endDate = parseISODate(settings.endDate);
            const practices = Array.isArray(settings.practices) ? settings.practices : [];

            const practiceDateMap = new Map();
            let seasonStart = null;
            let seasonEnd = null;

            // If season dates are set, use them; otherwise determine from individual rides
            if (startDate && endDate && startDate <= endDate) {
                seasonStart = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                seasonEnd = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

                // Add regular practices based on day of week
                const cursor = new Date(seasonStart.getTime());
                while (cursor <= seasonEnd) {
                    const dateKey = formatDateToISO(cursor);
                    const weekday = cursor.getDay();
                    const matchedPractices = practices.filter(practice => practice.dayOfWeek === weekday);
                    if (matchedPractices.length > 0) {
                        practiceDateMap.set(dateKey, matchedPractices.map(practice => practice.time));
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            } else {
                // No season dates set - determine range from individual rides
                const rideDates = [];
                if (Array.isArray(data.rides)) {
                    data.rides.forEach(ride => {
                        if (!ride.date) return;
                        const rideDate = parseISODate(ride.date);
                        if (rideDate) rideDates.push(rideDate);
                    });
                }
                
                if (rideDates.length === 0) {
                    container.className = 'season-calendar-empty';
                    container.innerHTML = `
                        Set your season dates and practices to populate the calendar.
                    `;
                    return;
                }

                rideDates.sort((a, b) => a - b);
                seasonStart = new Date(rideDates[0].getFullYear(), rideDates[0].getMonth(), 1);
                const lastRideDate = rideDates[rideDates.length - 1];
                seasonEnd = new Date(lastRideDate.getFullYear(), lastRideDate.getMonth() + 1, 0);
            }

            // Track practice states: cancelled, deleted, rescheduled
            const cancelledDates = new Set();
            const deletedDates = new Set();
            const rescheduledDates = new Map(); // dateKey -> { originalDate, newDate }
            const rescheduledOriginalDates = new Set(); // Track original dates of rescheduled practices
            
            // Track race dates
            const raceDates = new Map(); // dateKey -> { name, location, isPreRide: boolean }
            if (Array.isArray(data.races)) {
                data.races.forEach(race => {
                    if (race.raceDate) {
                        const raceDate = parseISODate(race.raceDate);
                        if (raceDate && raceDate >= seasonStart && raceDate <= seasonEnd) {
                            const dateKey = formatDateToISO(raceDate);
                            const existing = raceDates.get(dateKey) || { names: [], locations: [], isPreRide: false };
                            existing.names.push(race.name || 'Race');
                            existing.locations.push(race.location || '');
                            existing.isPreRide = false;
                            raceDates.set(dateKey, existing);
                        }
                    }
                    if (race.preRideDate && race.preRideDate !== race.raceDate) {
                        const preRideDate = parseISODate(race.preRideDate);
                        if (preRideDate && preRideDate >= seasonStart && preRideDate <= seasonEnd) {
                            const dateKey = formatDateToISO(preRideDate);
                            const existing = raceDates.get(dateKey) || { names: [], locations: [], isPreRide: true };
                            existing.names.push(race.name || 'Race');
                            existing.locations.push(race.location || '');
                            existing.isPreRide = true;
                            raceDates.set(dateKey, existing);
                        }
                    }
                });
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Find current/next practice
            let currentPracticeDate = null;
            const upcomingRides = (data.rides || [])
                .filter(ride => {
                    if (!ride.date || ride.deleted || ride.cancelled) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    return rideDate >= today;
                })
                .sort((a, b) => {
                    const dateA = parseISODate(a.date);
                    const dateB = parseISODate(b.date);
                    if (!dateA || !dateB) return 0;
                    return dateA - dateB;
                });
            if (upcomingRides.length > 0) {
                const nextRideDate = parseISODate(upcomingRides[0].date);
                if (nextRideDate) {
                    nextRideDate.setHours(0, 0, 0, 0);
                    currentPracticeDate = nextRideDate;
                }
            }
            
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (!ride.date) return;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return;
                    
                    // Skip deleted practices
                    if (ride.deleted) {
                        const dateKey = formatDateToISO(rideDate);
                        deletedDates.add(dateKey);
                        return;
                    }
                    
                    // Track rescheduled practices: hide original date, show new date
                    if (ride.rescheduledFrom) {
                        const originalDate = parseISODate(ride.rescheduledFrom);
                        if (originalDate) {
                            const originalKey = formatDateToISO(originalDate);
                            const newKey = formatDateToISO(rideDate);
                            rescheduledDates.set(originalKey, { originalDate, newDate: rideDate });
                            rescheduledOriginalDates.add(originalKey);
                            // Treat original date as deleted so it does not render
                            deletedDates.add(originalKey);
                        }
                    }
                    
                    // Check if ride date is within season range
                    if (rideDate >= seasonStart && rideDate <= seasonEnd) {
                        const dateKey = formatDateToISO(rideDate);
                        
                        // Track cancelled practices
                        if (ride.cancelled) {
                            cancelledDates.add(dateKey);
                        }
                        
                        const existingTimes = practiceDateMap.get(dateKey) || [];
                        const rideTime = ride.time || '';
                        if (rideTime && !existingTimes.includes(rideTime)) {
                            existingTimes.push(rideTime);
                        }
                        if (existingTimes.length > 0) {
                            practiceDateMap.set(dateKey, existingTimes);
                        } else if (!practiceDateMap.has(dateKey)) {
                            // Even if no time, mark as practice date
                            practiceDateMap.set(dateKey, []);
                        }
                    }
                });
            }
            
            // Remove deleted dates from practice map
            deletedDates.forEach(dateKey => {
                practiceDateMap.delete(dateKey);
            });

            if (practiceDateMap.size === 0) {
                container.className = 'season-calendar-empty';
                container.innerHTML = `
                    None of the saved practices fall within the chosen season dates.
                `;
                return;
            }

            const firstMonth = new Date(seasonStart.getFullYear(), seasonStart.getMonth(), 1);
            const lastMonth = new Date(seasonEnd.getFullYear(), seasonEnd.getMonth(), 1);

            const months = [];
            const monthCursor = new Date(firstMonth.getTime());
            while (monthCursor <= lastMonth) {
                months.push({
                    year: monthCursor.getFullYear(),
                    month: monthCursor.getMonth()
                });
                monthCursor.setMonth(monthCursor.getMonth() + 1);
            }

            const weekdaysHeader = DAYS_OF_WEEK.map(day => day.slice(0, 3));

            const monthsHtml = months.map(({ year, month }) => {
                const monthStart = new Date(year, month, 1);
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const firstWeekday = monthStart.getDay();

                let cellsHtml = weekdaysHeader.map(day => `<div class="weekday">${day}</div>`).join('');

                for (let i = 0; i < firstWeekday; i++) {
                    cellsHtml += '<div class="month-cell empty"></div>';
                }

                for (let day = 1; day <= daysInMonth; day++) {
                    const currentDate = new Date(year, month, day);
                    const dateKey = formatDateToISO(currentDate);
                    const practiceTimes = practiceDateMap.get(dateKey);
                    const isPractice = Array.isArray(practiceTimes);
                    const isRescheduledOriginal = rescheduledOriginalDates.has(dateKey);
                    const isRescheduledNew = Array.from(rescheduledDates.values()).some(entry => formatDateToISO(entry.newDate) === dateKey);
                    const raceInfo = raceDates.get(dateKey);
                    const isRace = !!raceInfo;
                    
                    // Also check if this is a rescheduled original date (even if not in practice map)
                    const isPracticeOrRescheduled = isPractice || isRescheduledOriginal || isRescheduledNew;
                    
                    const tooltip = isPractice && practiceTimes.length > 0 ? practiceTimes.map(formatTimeForDisplay).join(', ') : '';
                    let titleText = '';
                    if (isRace) {
                        const raceNames = raceInfo.names.join(', ');
                        const raceType = raceInfo.isPreRide ? 'Pre-Ride' : 'Race';
                        titleText = `${raceType}: ${raceNames}`;
                        if (raceInfo.locations.some(loc => loc)) {
                            titleText += ` (${raceInfo.locations.filter(loc => loc).join(', ')})`;
                        }
                    } else if (tooltip) {
                        titleText = `Practice at ${tooltip}`;
                    } else if (isPracticeOrRescheduled) {
                        titleText = 'Practice';
                    }
                    const titleAttr = titleText ? ` title="${escapeHtml(titleText)}"` : '';
                    
                    let ariaLabel = '';
                    if (isRace) {
                        const raceNames = raceInfo.names.join(', ');
                        const raceType = raceInfo.isPreRide ? 'Pre-Ride' : 'Race';
                        ariaLabel = `${raceType} on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}: ${raceNames}`;
                    } else if (tooltip) {
                        ariaLabel = `Practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })} at ${tooltip}`;
                    } else if (isPracticeOrRescheduled) {
                        ariaLabel = `Practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
                    } else {
                        ariaLabel = `No practice on ${currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
                    }
                    const ariaAttr = ` aria-label="${escapeHtml(ariaLabel)}"`;

                    if (isPracticeOrRescheduled || isRace) {
                        const isCancelled = cancelledDates.has(dateKey);
                        const isDeleted = deletedDates.has(dateKey);
                        
                        // Determine if past, current (next), or future
                        currentDate.setHours(0, 0, 0, 0);
                        const isPast = currentDate < today;
                        const isNext = currentPracticeDate && formatDateToISO(currentDate) === formatDateToISO(currentPracticeDate);
                        
                        if (isDeleted && !isRace) {
                            // Don't show deleted practices (but still show races)
                            cellsHtml += `
                                <div class="month-cell"${ariaAttr}>
                                    <div class="day-number">${day}</div>
                                </div>
                            `;
                            continue;
                        }
                        
                        let cellClass = isRace ? 'race' : 'practice';
                        let cellStyle = '';
                        
                        if (isRace) {
                            // Green for races
                            cellClass += ' race';
                            cellStyle = 'background: #4CAF50; color: white;';
                        } else if (isCancelled) {
                            // Light blue with red slash for cancelled
                            cellClass += ' cancelled';
                            cellStyle = 'background: #B3E5FC; position: relative;';
                        } else if (isRescheduledOriginal || isRescheduledNew) {
                            // Light blue for rescheduled
                            cellClass += ' rescheduled';
                            cellStyle = 'background: #B3E5FC;';
                        } else if (isNext) {
                            // Orange for next practice
                            cellClass += ' next';
                            cellStyle = 'background: #FF9800; color: white;';
                        } else if (isPast) {
                            // Grey for past practices
                            cellClass += ' past';
                            cellStyle = 'background: #E0E0E0; color: #757575;';
                        }
                        
                        const slashStyle = isCancelled ? '<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center;"><div style="width: 100%; height: 2px; background: #f44336; transform: rotate(-45deg);"></div></div>' : '';
                        
                        cellsHtml += `
                            <div class="month-cell ${cellClass}"${titleAttr}${ariaAttr} data-date="${dateKey}" onclick="handlePracticeDateClick('${dateKey}', event)" style="${cellStyle}">
                                <div class="day-number">${day}</div>
                                ${slashStyle}
                            </div>
                        `;
                    } else {
                        cellsHtml += `
                            <div class="month-cell"${ariaAttr}>
                                <div class="day-number">${day}</div>
                            </div>
                        `;
                    }
                }

                return `
                    <div class="season-month">
                        <div class="month-header">${monthStart.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</div>
                        <div class="month-grid">
                            ${cellsHtml}
                        </div>
                    </div>
                `;
            }).join('');
            
            container.className = 'season-calendar';
            container.innerHTML = monthsHtml;
        }

        let contextMenuDate = null;

        function handlePracticeDateClick(dateString, event) {
            if (!dateString) return;
            
            // Store the date for context menu actions
            contextMenuDate = dateString;
            
            // Determine if this date is cancelled
            const cancelledRide = (data.rides || []).find(r => r.date === dateString && !r.deleted && r.cancelled);
            const restoreBtn = document.getElementById('restore-practice-btn');
            if (restoreBtn) {
                restoreBtn.style.display = cancelledRide ? 'block' : 'none';
            }
            
            // Show context menu at click position
            const contextMenu = document.getElementById('practice-context-menu');
            if (!contextMenu) return;
            
            // Hide any existing context menu
            contextMenu.style.display = 'none';
            
            // Position menu near click
            if (event) {
                const x = event.clientX || (event.touches && event.touches[0].clientX);
                const y = event.clientY || (event.touches && event.touches[0].clientY);
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
            } else {
                // Fallback positioning
                contextMenu.style.left = '50%';
                contextMenu.style.top = '50%';
            }
            
            contextMenu.style.display = 'block';
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!contextMenu.contains(e.target) && !e.target.closest('[data-date="' + dateString + '"]')) {
                        contextMenu.style.display = 'none';
                        document.removeEventListener('click', closeMenu);
                    }
                }, { once: true });
            }, 10);
        }

        function deletePracticeFromContext() {
            if (!contextMenuDate) return;
            
            if (!confirm(`Are you sure you want to delete the practice on ${contextMenuDate}? This action cannot be undone.`)) {
                document.getElementById('practice-context-menu').style.display = 'none';
                return;
            }
            
            // Find and mark as deleted
            const ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            if (ride) {
                ride.deleted = true;
                // If this ride was rescheduled from another date, ensure original date stays hidden
                if (ride.rescheduledFrom) {
                    const originalDate = formatDateToISO(parseISODate(ride.rescheduledFrom));
                    // Mark any ride on original date as deleted too
                    const originalRide = data.rides.find(r => r.date === originalDate && !r.deleted);
                    if (originalRide) {
                        originalRide.deleted = true;
                    }
                }
                saveData();
                renderAllCalendars();
            }
            
            document.getElementById('practice-context-menu').style.display = 'none';
        }

        function cancelPracticeFromContext() {
            if (!contextMenuDate) return;
            
            const modal = document.getElementById('cancel-practice-modal');
            if (modal) {
                modal.classList.add('visible');
                modal.setAttribute('aria-hidden', 'false');
                document.getElementById('practice-context-menu').style.display = 'none';
            }
        }

        function closeCancelPracticeModal() {
            const modal = document.getElementById('cancel-practice-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        function confirmCancelPractice() {
            if (!contextMenuDate) return;
            
            const reason = document.getElementById('cancel-reason').value;
            if (!reason) return;
            
            // Find or create ride
            let ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            if (!ride) {
                ride = {
                    id: generateId(),
                    date: contextMenuDate,
                    availableCoaches: [],
                    availableRiders: [],
                    assignments: {},
                    groups: []
                };
                data.rides.push(ride);
            }
            
            ride.cancelled = true;
            ride.cancellationReason = reason;
            saveData();
            
            closeCancelPracticeModal();
            renderAllCalendars();
        }

        function getDefaultPracticeForDate(dateStr) {
            const settings = data.seasonSettings || buildDefaultSeasonSettings();
            const practices = Array.isArray(settings.practices) ? settings.practices : [];
            const date = parseISODate(dateStr);
            if (!date) return {};
            const iso = formatDateToISO(date);
            // Specific date takes priority
            const specific = practices.find(p => p.specificDate === iso);
            if (specific) return { time: specific.time || '', endTime: specific.endTime || '', meetLocation: specific.meetLocation || '' };
            // Fallback to day-of-week recurring
            const dow = date.getDay();
            const recurring = practices.find(p => p.dayOfWeek === dow);
            if (recurring) return { time: recurring.time || '', endTime: recurring.endTime || '', meetLocation: recurring.meetLocation || '' };
            return {};
        }

        function reschedulePracticeFromContext() {
            if (!contextMenuDate) return;
            
            // Find existing ride to get current values (include cancelled), or the original if rescheduled
            let ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted);
            if (!ride) {
                ride = data.rides.find(r => r.rescheduledFrom === contextMenuDate && !r.deleted);
            }
            const defaults = getDefaultPracticeForDate(contextMenuDate);
            
            const modal = document.getElementById('reschedule-practice-modal');
            if (modal) {
                // Pre-fill with current values
                document.getElementById('reschedule-date').value = contextMenuDate;
                document.getElementById('reschedule-time').value = ride ? (ride.time || defaults.time || '') : (defaults.time || '');
                document.getElementById('reschedule-end-time').value = ride ? (ride.endTime || defaults.endTime || '') : (defaults.endTime || '');
                document.getElementById('reschedule-location').value = ride ? (ride.meetLocation || defaults.meetLocation || '') : (defaults.meetLocation || '');
                
                modal.classList.add('visible');
                modal.setAttribute('aria-hidden', 'false');
                document.getElementById('practice-context-menu').style.display = 'none';
            }
        }

        function closeReschedulePracticeModal() {
            const modal = document.getElementById('reschedule-practice-modal');
            if (modal) {
                modal.classList.remove('visible');
                modal.setAttribute('aria-hidden', 'true');
            }
        }

        function confirmReschedulePractice() {
            if (!contextMenuDate) return;
            
            const newDate = document.getElementById('reschedule-date').value;
            const newTime = document.getElementById('reschedule-time').value;
            const newEndTime = document.getElementById('reschedule-end-time').value;
            const newLocation = document.getElementById('reschedule-location').value;
            
            if (!newDate) {
                alert('Please select a new date.');
                return;
            }
            
            // Parse contextMenuDate - it might be in ISO format already or a date string
            const originalDateParsed = parseISODate(contextMenuDate) || new Date(contextMenuDate);
            const originalDateKey = formatDateToISO(originalDateParsed);
            const newDateParsed = parseISODate(newDate);
            if (!newDateParsed) {
                alert('Invalid date selected.');
                return;
            }
            const newDateKey = formatDateToISO(newDateParsed);
            
            // Find existing ride on the original date (including those already rescheduled from this date)
            let ride = data.rides.find(r => r.date === originalDateKey && !r.deleted);
            
            // Also check if there's already a ride rescheduled from this date
            if (!ride) {
                ride = data.rides.find(r => r.rescheduledFrom === originalDateKey && !r.deleted);
            }
            
            if (!ride) {
                // If no ride exists, try to find one on a scheduled practice day for this date
                // This handles cases where we're rescheduling a practice that was auto-generated
                const originalDateObj = parseISODate(originalDateKey);
                if (originalDateObj) {
                    const weekday = originalDateObj.getDay();
                    const settings = data.seasonSettings || {};
                    const practices = Array.isArray(settings.practices) ? settings.practices : [];
                    const hasScheduledPractice = practices.some(p => p.dayOfWeek === weekday);
                    
                    if (hasScheduledPractice) {
                        // Create a new ride for rescheduling
                        ride = {
                            id: generateId(),
                            date: originalDateKey,
                            availableCoaches: [],
                            availableRiders: [],
                            assignments: {},
                            groups: [],
                            goals: '',
                            cancelled: false
                        };
                        data.rides.push(ride);
                    } else {
                        alert('No practice found on this date to reschedule.');
                        return;
                    }
                } else {
                    alert('Invalid date selected.');
                    return;
                }
            }
            
            // Check if there's already a ride on the new date
            const existingRideOnNewDate = data.rides.find(r => r.date === newDateKey && !r.deleted && r.id !== ride.id);
            if (existingRideOnNewDate) {
                // Merge data into existing ride
                existingRideOnNewDate.rescheduledFrom = originalDateKey;
                if (newTime) existingRideOnNewDate.time = newTime;
                if (newEndTime) existingRideOnNewDate.endTime = newEndTime;
                if (newLocation) existingRideOnNewDate.meetLocation = newLocation;
                // Preserve other fields from the original ride
                if (ride.availableCoaches) existingRideOnNewDate.availableCoaches = ride.availableCoaches;
                if (ride.availableRiders) existingRideOnNewDate.availableRiders = ride.availableRiders;
                if (ride.groups) existingRideOnNewDate.groups = ride.groups;
                if (ride.goals) existingRideOnNewDate.goals = ride.goals;
                
                // Mark original ride as deleted
                ride.deleted = true;
                ride = existingRideOnNewDate;
            } else {
                // Store original date for tracking
                ride.rescheduledFrom = originalDateKey;
                
                // Update to new date and values
                ride.date = newDateKey;
                if (newTime) ride.time = newTime;
                if (newEndTime) ride.endTime = newEndTime;
                if (newLocation) ride.meetLocation = newLocation;
            }
            
            // Mark any other rides on the original date as deleted
            data.rides.forEach(r => {
                if (r.date === originalDateKey && !r.deleted && r.id !== ride.id) {
                    r.deleted = true;
                }
            });
            
            saveData();
            
            closeReschedulePracticeModal();
            document.activeElement?.blur(); // Fix aria-hidden warning
            renderAllCalendars();
            renderRides();
            
            // Update current ride if we just rescheduled it
            if (data.currentRide && data.rides.find(r => r.id === data.currentRide && !r.deleted)) {
                loadCurrentRide();
            }
        }

        function restoreCancelledPractice() {
            if (!contextMenuDate) return;
            const ride = data.rides.find(r => r.date === contextMenuDate && !r.deleted && r.cancelled);
            if (ride) {
                ride.cancelled = false;
                ride.cancellationReason = '';
                saveData();
                renderAllCalendars();
            }
            document.getElementById('practice-context-menu').style.display = 'none';
        }

        function updatePracticeNavigation() {
            const navSection = document.getElementById('practice-navigation');
            const priorBtn = document.getElementById('prior-practice-btn');
            const nextBtn = document.getElementById('next-practice-btn');
            const dateDisplay = document.getElementById('current-practice-date');
            
            if (!navSection || !priorBtn || !nextBtn || !dateDisplay) return;
            
            const currentRide = data.rides.find(r => r.id === data.currentRide);
            if (!currentRide) {
                navSection.style.display = 'none';
                return;
            }
            
            navSection.style.display = 'flex';
            const rideDate = parseISODate(currentRide.date);
            const dateText = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' }) : currentRide.date;
            dateDisplay.textContent = dateText;
            
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            // Get all rides sorted by date (excluding deleted and rescheduled original dates)
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            
            // Enable/disable prior button
            if (currentIndex > 0) {
                priorBtn.disabled = false;
                priorBtn.style.opacity = '1';
                priorBtn.style.cursor = 'pointer';
            } else {
                priorBtn.disabled = true;
                priorBtn.style.opacity = '0.5';
                priorBtn.style.cursor = 'not-allowed';
            }
            
            // Enable/disable next button
            if (currentIndex >= 0 && currentIndex < allRides.length - 1) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                nextBtn.style.cursor = 'pointer';
            } else {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
                nextBtn.style.cursor = 'not-allowed';
            }
        }

        function navigateToPriorPractice() {
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            if (currentIndex > 0) {
                data.currentRide = allRides[currentIndex - 1].id;
                saveData();
                loadCurrentRide();
            }
        }

        function navigateToNextPractice() {
            // Build a set of original dates that have been rescheduled (to exclude them)
            const rescheduledOriginalDates = new Set();
            if (Array.isArray(data.rides)) {
                data.rides.forEach(ride => {
                    if (ride.rescheduledFrom && !ride.deleted) {
                        const originalDateKey = typeof ride.rescheduledFrom === 'string' 
                            ? ride.rescheduledFrom 
                            : formatDateToISO(parseISODate(ride.rescheduledFrom));
                        if (originalDateKey) {
                            rescheduledOriginalDates.add(originalDateKey);
                        }
                    }
                });
            }
            
            const allRides = (data.rides || [])
                .filter(r => {
                    // Exclude deleted practices
                    if (!r.date || r.deleted) return false;
                    
                    // Exclude rescheduled practices on their original date
                    const dateKey = formatDateToISO(parseISODate(r.date));
                    if (rescheduledOriginalDates.has(dateKey) && !r.rescheduledFrom) {
                        return false;
                    }
                    
                    return true;
                })
                .map(r => ({ id: r.id, date: parseISODate(r.date) }))
                .filter(r => r.date)
                .sort((a, b) => a.date - b.date);
            
            const currentIndex = allRides.findIndex(r => r.id === data.currentRide);
            if (currentIndex >= 0 && currentIndex < allRides.length - 1) {
                data.currentRide = allRides[currentIndex + 1].id;
                saveData();
                loadCurrentRide();
            }
        }

        function loadCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                document.getElementById('current-ride').style.display = 'none';
                const navSection = document.getElementById('practice-navigation');
                if (navSection) navSection.style.display = 'none';
                return;
            }
            
            document.getElementById('current-ride').style.display = 'block';
            const rideDate = parseISODate(ride.date);
            const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            document.getElementById('ride-title').textContent = `Practice: ${dateDisplay}`;
            
            // Render practice attendance lists if section is open
            const attendanceContent = document.getElementById('practice-attendance-content');
            if (attendanceContent && attendanceContent.style.display !== 'none') {
                renderPracticeAttendanceLists();
            }
            
            // Update navigation buttons
            updatePracticeNavigation();
            
            // Load practice goals
            const goalsInput = document.getElementById('practice-goals');
            if (goalsInput) {
                goalsInput.value = ride.goals || '';
            }
            
            // Update button based on cancellation status
            const cancelButton = document.getElementById('cancel-practice-btn');
            if (cancelButton) {
                if (ride.cancelled) {
                    cancelButton.textContent = 'Reinstate Practice';
                    cancelButton.className = 'btn-small';
                    cancelButton.style.backgroundColor = '#4CAF50';
                    cancelButton.style.color = '#ffffff';
                    cancelButton.style.borderColor = '#4CAF50';
                    cancelButton.onclick = reinstatePractice;
                } else {
                    cancelButton.textContent = 'Cancel Practice';
                    cancelButton.className = 'danger btn-small';
                    cancelButton.style.backgroundColor = '';
                    cancelButton.style.color = '';
                    cancelButton.style.borderColor = '';
                    cancelButton.onclick = deleteCurrentRide;
                }
            }
            
            // Disable assignment buttons if cancelled
            const autoAssignButton = document.querySelector('#current-ride .action-bar button:first-child');
            const clearAssignmentsButton = document.querySelector('#current-ride .action-bar button.secondary');
            if (ride.cancelled) {
                if (autoAssignButton) {
                    autoAssignButton.disabled = true;
                    autoAssignButton.style.opacity = '0.5';
                    autoAssignButton.style.cursor = 'not-allowed';
                }
                if (clearAssignmentsButton) {
                    clearAssignmentsButton.disabled = true;
                    clearAssignmentsButton.style.opacity = '0.5';
                    clearAssignmentsButton.style.cursor = 'not-allowed';
                }
            } else {
                if (autoAssignButton) {
                    autoAssignButton.disabled = false;
                    autoAssignButton.style.opacity = '';
                    autoAssignButton.style.cursor = '';
                }
                if (clearAssignmentsButton) {
                    clearAssignmentsButton.disabled = false;
                    clearAssignmentsButton.style.opacity = '';
                    clearAssignmentsButton.style.cursor = '';
                }
            }
            
            if (!ride.cancelled) {
            renderAssignments(ride);
            } else {
                // Show message that practice is cancelled
                const assignmentsContainer = document.getElementById('assignments');
                if (assignmentsContainer) {
                    assignmentsContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #757575;"><p style="font-size: 16px; margin: 0;">This practice has been cancelled.</p><p style="font-size: 14px; margin: 10px 0 0 0;">Assignments are not available for cancelled practices.</p></div>';
                }
            }
        }

        function setAllCoaches(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            if (selectAll) {
                ride.availableCoaches = Array.from(new Set(data.coaches.map(coach => coach.id)));
            } else {
                ride.availableCoaches = [];
                if (!Array.isArray(ride.groups)) {
                    ride.groups = [];
                }
                ride.groups.forEach(group => {
                    group.coaches.leader = null;
                    group.coaches.sweep = null;
                    group.coaches.roam = null;
                    group.coaches.extraRoam = [];
                    group.riders = [];
                    group.fitnessTag = null;
                });
            }

            saveData();
            renderAssignments(ride);
        }

        function setAllRiders(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            if (selectAll) {
                ride.availableRiders = Array.from(new Set(data.riders.map(rider => rider.id)));
            } else {
                ride.availableRiders = [];
                if (!Array.isArray(ride.groups)) {
                    ride.groups = [];
                }
                ride.groups.forEach(group => {
                    group.riders = [];
                    group.fitnessTag = null;
                });
            }

            saveData();
            renderAssignments(ride);
        }

        function toggleCoachAvailability(coachId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const index = ride.availableCoaches.indexOf(coachId);
            if (index > -1) {
                ride.availableCoaches.splice(index, 1);
                removeCoachFromGroups(ride, coachId);
            } else {
                ride.availableCoaches.push(coachId);
            }
            
            saveData();
            renderAssignments(ride);
        }

        function toggleRiderAvailability(riderId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const index = ride.availableRiders.indexOf(riderId);
            if (index > -1) {
                ride.availableRiders.splice(index, 1);
                removeRiderFromGroups(ride, riderId);
            } else {
                ride.availableRiders.push(riderId);
            }
            
            saveData();
            renderAssignments(ride);
        }

        function deleteCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            ride.cancelled = true;
            saveData();
            renderRides();
            loadCurrentRide();
        }

        function reinstatePractice() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            ride.cancelled = false;
            saveData();
            renderRides();
            loadCurrentRide();
        }

        function permanentlyDeleteCurrentRide() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected to delete.');
                return;
            }
            
            const rideDate = ride.date ? parseISODate(ride.date) : null;
            const dateDisplay = rideDate 
                ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })
                : 'this practice';
            
            if (!confirm(`Are you sure you want to permanently delete the practice on ${dateDisplay}?\n\nThis will remove it from the calendar and cannot be undone.`)) {
                return;
            }
            
            // Mark the ride as deleted instead of removing it (so it stays in exception list)
            ride.deleted = true;
            
            // Clear current ride selection
            data.currentRide = null;
            
            saveData();
            renderRides();
            renderAllCalendars();
            
            // Hide the current ride section
            const currentRideSection = document.getElementById('current-ride');
            if (currentRideSection) {
                currentRideSection.style.display = 'none';
            }
        }

        // Helper function to validate requirements
        function validateRequirements(availableCoaches, availableRiders, debugLines) {
            const requirements = getRequirements();
            
            for (const req of requirements) {
                if (req.id === 'ridersPerCoach') {
                    const ridersPerCoach = req.value || 6;
                    const totalCapacity = availableCoaches.length * ridersPerCoach;
                    if (availableRiders.length > totalCapacity) {
                        const errorMsg = `Not enough coaches to meet requirement: ${availableRiders.length} riders need ${Math.ceil(availableRiders.length / ridersPerCoach)} coaches (at ${ridersPerCoach} riders per coach), but only ${availableCoaches.length} coaches available.`;
                        debugLines.push(`‚ùå Requirement validation failed: ${errorMsg}`);
                        alert(errorMsg);
                        return false;
                    }
                    debugLines.push(`‚úì Requirement 1 (Riders per Coach): ${availableRiders.length} riders can be accommodated by ${availableCoaches.length} coaches (capacity: ${totalCapacity})`);
                } else if (req.id === 'minLeaderLevel') {
                    const minLeaderLevel = req.value || 2;
                    const leaders = availableCoaches.filter(coach => {
                        const level = parseInt(coach.level, 10);
                        return Number.isFinite(level) && level >= minLeaderLevel;
                    });
                    if (leaders.length === 0) {
                        const errorMsg = `Not enough qualifying coaches to meet minimum requirements: Need at least one Level ${minLeaderLevel}+ coach, but none available.`;
                        debugLines.push(`‚ùå Requirement validation failed: ${errorMsg}`);
                        alert(errorMsg);
                        return false;
                    }
                    const ridersPerLeader = Math.ceil(availableRiders.length / leaders.length);
                    const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
                    if (ridersPerLeader > ridersPerCoach * 2) { // Allow some flexibility, but warn if way over
                        debugLines.push(`‚ö†Ô∏è Warning: Dividing ${availableRiders.length} riders among ${leaders.length} Level ${minLeaderLevel}+ leaders results in ~${ridersPerLeader} riders per leader, which may exceed capacity.`);
                    }
                    debugLines.push(`‚úì Requirement 2 (Minimum Leader Level): ${leaders.length} Level ${minLeaderLevel}+ coaches available for ${availableRiders.length} riders (~${ridersPerLeader} riders per leader)`);
                }
            }
            return true;
        }
        
        // Auto-assignment algorithm - SEQUENTIAL REQUIREMENT-BASED VERSION
        function autoAssign() {
            alert('Auto-assign is temporarily disabled while we update the grouping logic. Please assign riders and coaches manually for now.');
            return;

            // ORIGINAL AUTO-ASSIGN LOGIC (currently disabled)
            try {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) {
                alert('No practice selected.');
                return;
            }
            if (ride.cancelled) {
                alert('Cannot assign riders and coaches to a cancelled practice.');
                return;
            }
            
            const availableCoaches = ride.availableCoaches
                .map(id => getCoachById(id))
                .filter(Boolean);

            const debugLines = [];
            debugLines.push(`Auto-assign run at ${new Date().toLocaleString()}`);
            debugLines.push(`Available coaches selected: ${availableCoaches.length}`);
            debugLines.push(`Available riders selected: ${ride.availableRiders.length}`);
            
            // Add auto-assignment settings to debug output
            debugLines.push('');
            debugLines.push('Auto-Assignment Settings:');
            if (data.autoAssignSettings && Array.isArray(data.autoAssignSettings.parameters)) {
                const sortedParams = [...data.autoAssignSettings.parameters].sort((a, b) => {
                    if (a.requirement && !b.requirement) return -1;
                    if (!a.requirement && b.requirement) return 1;
                    return a.priority - b.priority;
                });
                sortedParams.forEach(param => {
                    const status = param.enabled ? '‚úì' : '‚úó';
                    const reqMark = param.requirement ? '[REQUIREMENT] ' : '';
                    let valueStr = '';
                    if (param.type === 'range') {
                        valueStr = `${param.valueMin || param.min || 1}-${param.valueMax || param.max || 30}`;
                    } else {
                        valueStr = String(param.value || 'N/A');
                    }
                    debugLines.push(`  [${status}] ${reqMark}Priority ${param.priority}: ${param.name} = ${valueStr}${param.enabled ? '' : ' (disabled)'}`);
                });
            } else {
                debugLines.push('  Using default settings (settings not initialized)');
            }
            debugLines.push('');

            if (availableCoaches.length === 0) {
                alert('Please select available coaches first');
                autoAssignDebugLog = debugLines.concat('Aborted: no coaches selected.').join('\n');
                updateDebugOutput();
                return;
            }
            
            if (ride.availableRiders.length === 0) {
                alert('Please select available riders first');
                autoAssignDebugLog = debugLines.concat('Aborted: no riders selected.').join('\n');
                updateDebugOutput();
                return;
            }
            
            // STEP 1: Validate all requirements sequentially
            debugLines.push('=== STEP 1: Validating Requirements ===');
            if (!validateRequirements(availableCoaches, ride.availableRiders, debugLines)) {
                autoAssignDebugLog = debugLines.join('\n');
                updateDebugOutput();
                return;
            }
            debugLines.push('');
            
            // Get requirement values
            const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
            const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
            const leaders = availableCoaches.filter(coach => {
                const level = parseInt(coach.level, 10);
                return Number.isFinite(level) && level >= minLeaderLevel;
            });

            // STEP 2: Create groups based on eligible leaders (REQUIREMENT)
            debugLines.push('=== STEP 2: Creating Groups Based on Eligible Leaders ===');
            const sortedRiders = ride.availableRiders
                .map(id => getRiderById(id))
                .filter(Boolean);
            
            // Sort leaders by level (highest first), then by fitness
            const sortedLeaders = [...leaders].sort((a, b) => {
                const aLevel = parseInt(a.level, 10) || 0;
                const bLevel = parseInt(b.level, 10) || 0;
                if (aLevel !== bLevel) return bLevel - aLevel;
                const aFitness = parseInt(a.fitness || '5', 10);
                const bFitness = parseInt(b.fitness || '5', 10);
                return bFitness - aFitness;
            });
            
            // Create one group per eligible leader - RESERVE them as leaders
            ride.groups = [];
            const reservedLeaderIds = new Set();
            sortedLeaders.forEach((leader, index) => {
                const group = createGroup(`Group ${index + 1}`);
                group.coaches.leader = leader.id;
                reservedLeaderIds.add(leader.id);
                ride.groups.push(group);
            });
            
            debugLines.push(`Created ${ride.groups.length} groups, each with a Level ${minLeaderLevel}+ leader reserved.`);
            debugLines.push('');
            
            // Get remaining coaches (not reserved as leaders)
            const remainingCoaches = availableCoaches.filter(coach => !reservedLeaderIds.has(coach.id));
            
            // STEP 3: Assign riders evenly within preferred size range (PRIORITY 3)
            debugLines.push('=== STEP 3: Assigning Riders Within Preferred Group Size ===');
            const preferredGroupSizeParam = data.autoAssignSettings?.parameters?.find(p => p.id === 'preferredGroupSize');
            const preferredMin = preferredGroupSizeParam?.valueMin || 4;
            const preferredMax = preferredGroupSizeParam?.valueMax || 10;
            
            // Calculate target size per group to distribute evenly within preferred range
            const totalRiders = sortedRiders.length;
            const numGroups = ride.groups.length;
            
            // Try to distribute evenly, but stay within preferred range
            let baseSize = Math.floor(totalRiders / numGroups);
            let remainder = totalRiders % numGroups;
            
            // Adjust baseSize to fit within preferred range
            if (baseSize < preferredMin) {
                baseSize = preferredMin;
                remainder = totalRiders - (baseSize * numGroups);
            } else if (baseSize > preferredMax) {
                baseSize = preferredMax;
                remainder = totalRiders - (baseSize * numGroups);
            }
            
            debugLines.push(`Distributing ${totalRiders} riders across ${numGroups} groups: base size ${baseSize}, remainder ${remainder} (preferred range: ${preferredMin}-${preferredMax})`);
            
            // Assign riders evenly - give some groups one extra rider if needed
            let riderIndex = 0;
            ride.groups.forEach((group, groupIdx) => {
                group.riders = [];
                const groupSize = baseSize + (groupIdx < remainder ? 1 : 0);
                for (let i = 0; i < groupSize && riderIndex < sortedRiders.length; i++) {
                    group.riders.push(sortedRiders[riderIndex].id);
                    riderIndex++;
                }
            });
            
            // If there are still unassigned riders (shouldn't happen with even distribution, but handle it)
            while (riderIndex < sortedRiders.length) {
                // Find group with fewest riders that's below preferred max
                let targetGroup = ride.groups
                    .filter(g => g.riders.length < preferredMax)
                    .sort((a, b) => a.riders.length - b.riders.length)[0];
                
                if (!targetGroup) {
                    // All groups at preferred max, assign to smallest group (will exceed preference)
                    targetGroup = ride.groups.sort((a, b) => a.riders.length - b.riders.length)[0];
                    debugLines.push(`Note: ${targetGroup.label} will exceed preferred max size (${targetGroup.riders.length + 1} > ${preferredMax}) to place all riders.`);
                }
                
                targetGroup.riders.push(sortedRiders[riderIndex].id);
                riderIndex++;
            }
            
            debugLines.push(`Assigned ${sortedRiders.length} riders across ${ride.groups.length} groups.`);
            ride.groups.forEach((group, idx) => {
                debugLines.push(`  ${group.label}: ${group.riders.length} riders`);
            });
            
            // Re-validate requirements after rider assignment
            debugLines.push('Re-validating requirements after rider assignment...');
            let requirementsMet = true;
            ride.groups.forEach((group, idx) => {
                // Calculate current capacity (only leader assigned at this point)
                const currentCoachCount = countGroupCoaches(group);
                const currentCapacity = currentCoachCount * ridersPerCoach;
                
                // Calculate projected capacity after all coaches are assigned (estimate: leader + sweep + roam = 3 coaches)
                const projectedCoachCount = 3; // Leader + sweep + roam (minimum)
                const projectedCapacity = projectedCoachCount * ridersPerCoach;
                
                if (group.riders.length > projectedCapacity) {
                    debugLines.push(`‚ö†Ô∏è Group ${idx + 1} has ${group.riders.length} riders, which exceeds projected capacity of ${projectedCapacity} (${ridersPerCoach} per coach √ó ${projectedCoachCount} coaches). Requirement may be violated.`);
                    requirementsMet = false;
                } else if (group.riders.length > currentCapacity) {
                    // This is expected - more coaches will be added later
                    debugLines.push(`Note: Group ${idx + 1} has ${group.riders.length} riders (current capacity: ${currentCapacity} with ${currentCoachCount} coach(es)). More coaches will be assigned later.`);
                }
                
                const leader = getCoachById(group.coaches.leader);
                if (!leader) {
                    debugLines.push(`‚ùå Group ${idx + 1} has no leader assigned!`);
                    requirementsMet = false;
                } else {
                    const leaderLevel = parseInt(leader.level, 10) || 0;
                    if (leaderLevel < minLeaderLevel) {
                        debugLines.push(`‚ùå Group ${idx + 1} leader is Level ${leaderLevel}, but requirement is Level ${minLeaderLevel}+`);
                        requirementsMet = false;
                    }
                }
            });
            
            if (!requirementsMet) {
                debugLines.push('‚ö†Ô∏è Some requirements may not be fully met after initial assignment.');
            } else {
                debugLines.push('‚úì All requirements met after rider assignment.');
            }
            debugLines.push('');
            
            // Initialize group properties
            ride.groups.forEach(group => {
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                } else {
                    group.coaches.extraRoam = Array.from(new Set(group.coaches.extraRoam));
                }
            });
            
            // STEP 4: Organize groups by pace (if preference enabled) - ALLOWING size adjustment within preferred range
            const organizeByPaceParam = data.autoAssignSettings?.parameters?.find(p => p.id === 'organizeByPace');
            if (organizeByPaceParam && organizeByPaceParam.enabled) {
                debugLines.push('=== STEP 4: Organizing Groups by Pace (Allowing Size Adjustment) ===');
                const maxPaceSpread = organizeByPaceParam.value || 2;
                debugLines.push(`Preferred maximum fitness spread: ${maxPaceSpread}`);
                debugLines.push(`Group size can vary within preferred range: ${preferredMin}-${preferredMax}`);
                
                // Sort all riders by pace (fastest to slowest)
                const allRidersSorted = sortedRiders.slice().sort((a, b) => {
                    const aPace = parseInt(a.fitness || '5', 10);
                    const bPace = parseInt(b.fitness || '5', 10);
                    return bPace - aPace; // Fastest first
                });
                
                // Clear current assignments
                ride.groups.forEach(group => {
                    group.riders = [];
                    group.fitnessTag = null;
                });
                
                // Strategy: Group riders by pace clusters, then distribute clusters to groups
                // First, identify pace clusters
                const paceClusters = [];
                let currentCluster = [];
                let currentClusterPace = null;
                
                allRidersSorted.forEach(rider => {
                    const riderPace = parseInt(rider.fitness || '5', 10);
                    
                    if (currentCluster.length === 0) {
                        // Start new cluster
                        currentCluster = [rider];
                        currentClusterPace = riderPace;
                    } else {
                        const paceDiff = Math.abs(riderPace - currentClusterPace);
                        if (paceDiff <= maxPaceSpread) {
                            // Add to current cluster
                            currentCluster.push(rider);
                        } else {
                            // Start new cluster
                            paceClusters.push([...currentCluster]);
                            currentCluster = [rider];
                            currentClusterPace = riderPace;
                        }
                    }
                });
                if (currentCluster.length > 0) {
                    paceClusters.push(currentCluster);
                }
                
                debugLines.push(`Identified ${paceClusters.length} pace clusters:`);
                paceClusters.forEach((cluster, idx) => {
                    const clusterPace = parseInt(cluster[0].fitness || '5', 10);
                    debugLines.push(`  Cluster ${idx + 1}: ${cluster.length} riders at pace ${clusterPace}`);
                });
                
                // Distribute clusters to groups, prioritizing pace alignment
                // Strategy: Assign entire clusters to groups when possible, split large clusters
                const groupAssignments = ride.groups.map(() => []);
                
                // Sort clusters by pace (fastest first) for assignment
                const sortedClusters = [...paceClusters].sort((a, b) => {
                    const aPace = parseInt(a[0].fitness || '5', 10);
                    const bPace = parseInt(b[0].fitness || '5', 10);
                    return bPace - aPace; // Fastest first
                });
                
                // Distribute clusters to groups
                sortedClusters.forEach((cluster, clusterIdx) => {
                    const clusterPace = parseInt(cluster[0].fitness || '5', 10);
                    const clusterSize = cluster.length;
                    
                    // Find groups that can accommodate this cluster (or part of it)
                    const availableGroups = ride.groups
                        .map((g, idx) => ({
                            group: g,
                            idx,
                            currentSize: groupAssignments[idx].length,
                            spaceAvailable: preferredMax - groupAssignments[idx].length
                        }))
                        .filter(g => g.spaceAvailable > 0)
                        .sort((a, b) => {
                            // Prefer groups with similar pace
                            const aRiders = groupAssignments[a.idx].map(id => getRiderById(id)).filter(Boolean);
                            const aAvgPace = aRiders.length > 0
                                ? aRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / aRiders.length
                                : clusterPace;
                            const bRiders = groupAssignments[b.idx].map(id => getRiderById(id)).filter(Boolean);
                            const bAvgPace = bRiders.length > 0
                                ? bRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / bRiders.length
                                : clusterPace;
                            
                            const aPaceDiff = Math.abs(clusterPace - aAvgPace);
                            const bPaceDiff = Math.abs(clusterPace - bAvgPace);
                            
                            // Prefer groups with similar pace, then more space
                            if (aPaceDiff !== bPaceDiff) {
                                return aPaceDiff - bPaceDiff;
                            }
                            return b.spaceAvailable - a.spaceAvailable;
                        });
                    
                    // Assign cluster riders to groups
                    let clusterRiderIdx = 0;
                    while (clusterRiderIdx < cluster.length && availableGroups.length > 0) {
                        // Find best group for remaining riders
                        const bestGroup = availableGroups[0];
                        const ridersToAssign = Math.min(bestGroup.spaceAvailable, cluster.length - clusterRiderIdx);
                        
                        for (let i = 0; i < ridersToAssign && clusterRiderIdx < cluster.length; i++) {
                            groupAssignments[bestGroup.idx].push(cluster[clusterRiderIdx].id);
                            clusterRiderIdx++;
                            bestGroup.currentSize++;
                            bestGroup.spaceAvailable--;
                        }
                        
                        // Remove group if it's full
                        if (bestGroup.spaceAvailable === 0) {
                            availableGroups.shift();
                        } else {
                            // Re-sort to maintain order
                            availableGroups.sort((a, b) => {
                                const aRiders = groupAssignments[a.idx].map(id => getRiderById(id)).filter(Boolean);
                                const aAvgPace = aRiders.length > 0
                                    ? aRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / aRiders.length
                                    : clusterPace;
                                const bRiders = groupAssignments[b.idx].map(id => getRiderById(id)).filter(Boolean);
                                const bAvgPace = bRiders.length > 0
                                    ? bRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / bRiders.length
                                    : clusterPace;
                                
                                const aPaceDiff = Math.abs(clusterPace - aAvgPace);
                                const bPaceDiff = Math.abs(clusterPace - bAvgPace);
                                
                                if (aPaceDiff !== bPaceDiff) {
                                    return aPaceDiff - bPaceDiff;
                                }
                                return b.spaceAvailable - a.spaceAvailable;
                            });
                        }
                    }
                    
                    // If cluster still has riders, assign to any group with space (will exceed preferred max)
                    while (clusterRiderIdx < cluster.length) {
                        const smallestGroupIdx = ride.groups.reduce((minIdx, g, idx) => {
                            return groupAssignments[idx].length < groupAssignments[minIdx].length ? idx : minIdx;
                        }, 0);
                        groupAssignments[smallestGroupIdx].push(cluster[clusterRiderIdx].id);
                        clusterRiderIdx++;
                    }
                });
                
                // Verify all riders were assigned
                const totalAssigned = groupAssignments.reduce((sum, arr) => sum + arr.length, 0);
                if (totalAssigned !== allRidersSorted.length) {
                    debugLines.push(`‚ö†Ô∏è Warning: Only assigned ${totalAssigned} of ${allRidersSorted.length} riders during pace organization.`);
                }
                
                // Ensure no empty groups - redistribute if needed
                const emptyGroupIndices = [];
                groupAssignments.forEach((assignment, idx) => {
                    if (assignment.length === 0) {
                        emptyGroupIndices.push(idx);
                    }
                });
                
                if (emptyGroupIndices.length > 0) {
                    debugLines.push(`‚ö†Ô∏è Found ${emptyGroupIndices.length} empty group(s) after pace organization. Redistributing...`);
                    
                    // Find groups with most riders to redistribute
                    const groupsBySize = ride.groups
                        .map((g, idx) => ({ group: g, idx, size: groupAssignments[idx].length }))
                        .sort((a, b) => b.size - a.size);
                    
                    emptyGroupIndices.forEach(emptyIdx => {
                        // Take riders from largest groups to fill empty group
                        for (let i = 0; i < groupsBySize.length && groupAssignments[emptyIdx].length < preferredMin; i++) {
                            const sourceGroup = groupsBySize[i];
                            if (sourceGroup.idx === emptyIdx) continue;
                            if (sourceGroup.size <= preferredMin) break; // Don't take from groups at minimum
                            
                            // Take one rider from source group
                            const riderId = groupAssignments[sourceGroup.idx].pop();
                            if (riderId) {
                                groupAssignments[emptyIdx].push(riderId);
                                sourceGroup.size--;
                            }
                        }
                    });
                    
                    debugLines.push(`‚úì Redistributed riders to eliminate empty groups.`);
                }
                
                // Apply assignments to groups
                ride.groups.forEach((group, idx) => {
                    group.riders = groupAssignments[idx];
                });
                
                // Balance group sizes while maintaining pace alignment - MULTIPLE PASSES
                debugLines.push(`Balancing group sizes while maintaining pace alignment (multiple passes)...`);
                let balancingRounds = 0;
                const maxBalancingRounds = 20; // Increased for more thorough optimization
                
                while (balancingRounds < maxBalancingRounds) {
                    balancingRounds++;
                    let movedAny = false;
                    const roundMoves = [];
                    const roundSkipped = [];
                    
                    // Calculate group info with average pace
                    const groupInfo = ride.groups.map((g, idx) => {
                        const riders = groupAssignments[idx].map(id => getRiderById(id)).filter(Boolean);
                        const avgPace = riders.length > 0
                            ? riders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / riders.length
                            : 0;
                        return {
                            group: g,
                            idx,
                            size: groupAssignments[idx].length,
                            riders,
                            avgPace
                        };
                    });
                    
                    debugLines.push(`  Round ${balancingRounds}:`);
                    
                    // PASS 1: Find riders that would fit better in other groups (even if currently within spread)
                    for (let i = 0; i < groupInfo.length; i++) {
                        const sourceGroup = groupInfo[i];
                        if (sourceGroup.size === 0) continue;
                        
                        sourceGroup.riders.forEach(rider => {
                            const riderPace = parseInt(rider.fitness || '5', 10);
                            const currentPaceDiff = Math.abs(riderPace - sourceGroup.avgPace);
                            
                            // Find a better group for this rider
                            let bestTarget = null;
                            let bestScore = -Infinity;
                            
                            for (let j = 0; j < groupInfo.length; j++) {
                                if (i === j) continue;
                                const targetGroup = groupInfo[j];
                                
                                // Check if target group can accept this rider
                                if (targetGroup.size >= preferredMax && sourceGroup.size <= preferredMin) continue;
                                
                                const targetPaceDiff = Math.abs(riderPace - targetGroup.avgPace);
                                
                                // Only consider if target group is a better fit (smaller fitness difference)
                                if (targetPaceDiff >= currentPaceDiff) continue;
                                
                                // Score: prefer groups where rider fits within pace spread, and helps balance sizes
                                let score = 0;
                                if (targetPaceDiff <= maxPaceSpread) {
                                    score = 1000 - targetPaceDiff; // Excellent fit
                                } else {
                                    score = 500 - targetPaceDiff; // Better than current, but not ideal
                                }
                                
                                // Bonus for helping balance sizes (especially if it helps both groups)
                                const sizeDiff = Math.abs(targetGroup.size - sourceGroup.size);
                                if (sizeDiff > 1) {
                                    score += 200; // Strongly prefer moves that help balance
                                }
                                
                                // Prefer groups that need riders (below preferred min)
                                if (targetGroup.size < preferredMin) {
                                    score += 100;
                                }
                                
                                // Bonus if source group is too large
                                if (sourceGroup.size > preferredMax) {
                                    score += 150;
                                }
                                
                                // Extra bonus if both groups benefit (size balance + pace improvement)
                                if (sizeDiff > 1 && targetPaceDiff < currentPaceDiff) {
                                    score += 100;
                                }
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = targetGroup;
                                }
                            }
                            
                            // Move rider to best target if it's a significant improvement
                            if (bestTarget && bestScore > 400) { // Only move if score indicates good improvement
                                const riderIdx = groupAssignments[sourceGroup.idx].indexOf(rider.id);
                                if (riderIdx >= 0) {
                                    const oldAvgPace = sourceGroup.avgPace.toFixed(1);
                                    const targetOldAvgPace = bestTarget.avgPace.toFixed(1);
                                    
                                    groupAssignments[sourceGroup.idx].splice(riderIdx, 1);
                                    sourceGroup.size--;
                                    sourceGroup.riders = sourceGroup.riders.filter(r => r.id !== rider.id);
                                    
                                    groupAssignments[bestTarget.idx].push(rider.id);
                                    bestTarget.size++;
                                    bestTarget.riders.push(rider);
                                    
                                    // Recalculate average pace for both groups
                                    if (sourceGroup.riders.length > 0) {
                                        sourceGroup.avgPace = sourceGroup.riders
                                            .reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / sourceGroup.riders.length;
                                    }
                                    if (bestTarget.riders.length > 0) {
                                        bestTarget.avgPace = bestTarget.riders
                                            .reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / bestTarget.riders.length;
                                    }
                                    
                                    const newAvgPace = sourceGroup.avgPace.toFixed(1);
                                    const targetNewAvgPace = bestTarget.avgPace.toFixed(1);
                                    
                                    roundMoves.push(`    ‚úì Moved ${rider.name} (Fitness ${riderPace}) from ${sourceGroup.group.label} (avg ${oldAvgPace}‚Üí${newAvgPace}) to ${bestTarget.group.label} (avg ${targetOldAvgPace}‚Üí${targetNewAvgPace}) [score: ${bestScore.toFixed(0)}]`);
                                    movedAny = true;
                                }
                            } else {
                                const bestTargetInfo = bestTarget ? `best: ${bestTarget.group.label} (score ${bestScore.toFixed(0)}, below threshold 400)` : 'no suitable target found';
                                roundSkipped.push(`    - ${rider.name} (Fitness ${riderPace}) in ${sourceGroup.group.label} (avg ${sourceGroup.avgPace.toFixed(1)}, diff ${currentPaceDiff.toFixed(1)}): ${bestTargetInfo}`);
                            }
                        });
                    }
                    
                    if (roundMoves.length > 0) {
                        debugLines.push(...roundMoves);
                    }
                    if (roundSkipped.length > 0 && balancingRounds <= 3) { // Only show skipped for first 3 rounds to avoid clutter
                        debugLines.push(`    Skipped (${roundSkipped.length} riders):`);
                        debugLines.push(...roundSkipped.slice(0, 15)); // Limit to first 15
                        if (roundSkipped.length > 15) {
                            debugLines.push(`    ... and ${roundSkipped.length - 15} more`);
                        }
                    }
                    
                    if (!movedAny && balancingRounds <= 3) {
                        debugLines.push(`    No moves made this round.`);
                    }
                    
                    // PASS 2: Balance sizes by moving compatible riders between groups
                    // BUT: Only move if it doesn't hurt pace alignment significantly
                    const groupsBySize = [...groupInfo].sort((a, b) => b.size - a.size);
                    const pass2Moves = [];
                    
                    for (let i = 0; i < groupsBySize.length; i++) {
                        const largeGroup = groupsBySize[i];
                        if (largeGroup.size <= preferredMin) break;
                        
                        for (let j = groupsBySize.length - 1; j > i; j--) {
                            const smallGroup = groupsBySize[j];
                            if (smallGroup.size >= preferredMax) break;
                            
                            const sizeDiff = largeGroup.size - smallGroup.size;
                            if (sizeDiff <= 1) continue;
                            
                            // Find riders in large group that would fit well in small group
                            // AND check that moving them improves or maintains pace alignment
                            const ridersToMove = largeGroup.riders.filter(rider => {
                                const riderPace = parseInt(rider.fitness || '5', 10);
                                const paceDiffToSmall = Math.abs(riderPace - smallGroup.avgPace);
                                const paceDiffToLarge = Math.abs(riderPace - largeGroup.avgPace);
                                
                                // Only move if: fits in small group AND improves pace alignment
                                return paceDiffToSmall <= maxPaceSpread && paceDiffToSmall < paceDiffToLarge;
                            });
                            
                            if (ridersToMove.length === 0) continue;
                            
                            // Calculate how many riders to move to balance
                            const targetSize = Math.floor((largeGroup.size + smallGroup.size) / 2);
                            const ridersNeeded = Math.min(
                                targetSize - smallGroup.size,
                                largeGroup.size - targetSize,
                                ridersToMove.length,
                                preferredMax - smallGroup.size
                            );
                            
                            if (ridersNeeded > 0) {
                                // Move best-fitting riders (those that improve pace alignment most)
                                ridersToMove
                                    .sort((a, b) => {
                                        const aPace = parseInt(a.fitness || '5', 10);
                                        const bPace = parseInt(b.fitness || '5', 10);
                                        const aDiffToSmall = Math.abs(aPace - smallGroup.avgPace);
                                        const bDiffToSmall = Math.abs(bPace - smallGroup.avgPace);
                                        const aDiffToLarge = Math.abs(aPace - largeGroup.avgPace);
                                        const bDiffToLarge = Math.abs(bPace - largeGroup.avgPace);
                                        
                                        // Prefer riders that improve pace alignment more
                                        const aImprovement = aDiffToLarge - aDiffToSmall;
                                        const bImprovement = bDiffToLarge - bDiffToSmall;
                                        if (aImprovement !== bImprovement) {
                                            return bImprovement - aImprovement; // More improvement first
                                        }
                                        return aDiffToSmall - bDiffToSmall; // Then by fit to small group
                                    })
                                    .slice(0, ridersNeeded)
                                    .forEach(rider => {
                                        const riderIdx = groupAssignments[largeGroup.idx].indexOf(rider.id);
                                        if (riderIdx >= 0) {
                                            const riderPace = parseInt(rider.fitness || '5', 10);
                                            const oldLargeDiff = Math.abs(riderPace - largeGroup.avgPace);
                                            const oldSmallDiff = Math.abs(riderPace - smallGroup.avgPace);
                                            
                                            const oldLargeAvg = largeGroup.avgPace.toFixed(1);
                                            const oldSmallAvg = smallGroup.avgPace.toFixed(1);
                                            
                                            groupAssignments[largeGroup.idx].splice(riderIdx, 1);
                                            largeGroup.size--;
                                            largeGroup.riders = largeGroup.riders.filter(r => r.id !== rider.id);
                                            
                                            groupAssignments[smallGroup.idx].push(rider.id);
                                            smallGroup.size++;
                                            smallGroup.riders.push(rider);
                                            
                                            // Recalculate average pace
                                            if (largeGroup.riders.length > 0) {
                                                largeGroup.avgPace = largeGroup.riders
                                                    .reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / largeGroup.riders.length;
                                            }
                                            if (smallGroup.riders.length > 0) {
                                                smallGroup.avgPace = smallGroup.riders
                                                    .reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / smallGroup.riders.length;
                                            }
                                            
                                            const newLargeAvg = largeGroup.avgPace.toFixed(1);
                                            const newSmallAvg = smallGroup.avgPace.toFixed(1);
                                            const newLargeDiff = Math.abs(riderPace - largeGroup.avgPace);
                                            const newSmallDiff = Math.abs(riderPace - smallGroup.avgPace);
                                            
                                            pass2Moves.push(`    ‚úì Size balance: Moved ${rider.name} (Fitness ${riderPace}) from ${largeGroup.group.label} (${largeGroup.size + 1}‚Üí${largeGroup.size}, avg ${oldLargeAvg}‚Üí${newLargeAvg}, fitness diff ${oldLargeDiff.toFixed(1)}‚Üí${newLargeDiff.toFixed(1)}) to ${smallGroup.group.label} (${smallGroup.size - 1}‚Üí${smallGroup.size}, avg ${oldSmallAvg}‚Üí${newSmallAvg}, fitness diff ${oldSmallDiff.toFixed(1)}‚Üí${newSmallDiff.toFixed(1)})`);
                                            movedAny = true;
                                        }
                                    });
                            }
                        }
                    }
                    
                    if (pass2Moves.length > 0) {
                        debugLines.push(`    PASS 2 (Size Balancing - pace-aware):`);
                        debugLines.push(...pass2Moves);
                    }
                    
                    if (!movedAny) {
                        if (balancingRounds <= 3) {
                            debugLines.push(`    No moves made this round.`);
                        }
                        break; // No more improvements possible
                    }
                }
                
                // Re-apply assignments after balancing
                ride.groups.forEach((group, idx) => {
                    group.riders = groupAssignments[idx];
                });
                
                // Sort groups by average pace (fastest first) for final ordering
                ride.groups.sort((a, b) => {
                    const aRiders = a.riders.map(id => getRiderById(id)).filter(Boolean);
                    const bRiders = b.riders.map(id => getRiderById(id)).filter(Boolean);
                    const aAvgPace = aRiders.length > 0
                        ? aRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / aRiders.length
                        : 0;
                    const bAvgPace = bRiders.length > 0
                        ? bRiders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / bRiders.length
                        : 0;
                    return bAvgPace - aAvgPace; // Fastest first (descending)
                });
                
                debugLines.push(`Reorganized riders by pace with flexible group sizes (${balancingRounds} balancing round(s)).`);
                ride.groups.forEach((group, idx) => {
                    const riders = group.riders.map(id => getRiderById(id)).filter(Boolean);
                    const avgPace = riders.length > 0
                        ? (riders.reduce((sum, r) => sum + parseInt(r.fitness || '5', 10), 0) / riders.length).toFixed(1)
                        : 'N/A';
                    const paceRange = riders.length > 0
                        ? `${Math.min(...riders.map(r => parseInt(r.fitness || '5', 10)))}-${Math.max(...riders.map(r => parseInt(r.fitness || '5', 10)))}`
                        : 'N/A';
                    debugLines.push(`  ${group.label}: ${group.riders.length} riders, avg pace ${avgPace}, range ${paceRange}`);
                });
                
                // Re-validate requirements after pace organization
                debugLines.push('Re-validating requirements after pace organization...');
                requirementsMet = true;
                ride.groups.forEach((group, idx) => {
                    // Calculate current capacity (only leader assigned at this point)
                    const currentCoachCount = countGroupCoaches(group);
                    const currentCapacity = currentCoachCount * ridersPerCoach;
                    
                    // Calculate projected capacity after all coaches are assigned (estimate: leader + sweep + roam = 3 coaches)
                    const projectedCoachCount = 3; // Leader + sweep + roam (minimum)
                    const projectedCapacity = projectedCoachCount * ridersPerCoach;
                    
                    if (group.riders.length > projectedCapacity) {
                        debugLines.push(`‚ö†Ô∏è Group ${idx + 1} has ${group.riders.length} riders, which exceeds projected capacity of ${projectedCapacity} (${ridersPerCoach} per coach √ó ${projectedCoachCount} coaches). Requirement may be violated.`);
                        requirementsMet = false;
                    } else if (group.riders.length > currentCapacity) {
                        // This is expected - more coaches will be added later
                        debugLines.push(`Note: Group ${idx + 1} has ${group.riders.length} riders (current capacity: ${currentCapacity} with ${currentCoachCount} coach(es), projected: ${projectedCapacity} with ${projectedCoachCount} coaches).`);
                    }
                    
                    if (group.riders.length < preferredMin) {
                        debugLines.push(`‚ö†Ô∏è Group ${idx + 1} below preferred min: ${group.riders.length} < ${preferredMin}`);
                    }
                    if (group.riders.length > preferredMax) {
                        debugLines.push(`‚ö†Ô∏è Group ${idx + 1} exceeds preferred max: ${group.riders.length} > ${preferredMax}`);
                    }
                    const leader = getCoachById(group.coaches.leader);
                    if (leader) {
                        const leaderLevel = parseInt(leader.level, 10) || 0;
                        if (leaderLevel < minLeaderLevel) {
                            debugLines.push(`‚ùå Group ${idx + 1} leader requirement violated after pace organization.`);
                            requirementsMet = false;
                        }
                    }
                });
                
                if (requirementsMet) {
                    debugLines.push('‚úì All requirements still met after pace organization.');
                    } else {
                    debugLines.push('‚ö†Ô∏è Some requirements violated after pace organization.');
                }
                debugLines.push('');
            }
            
            // STEP 5: Remove empty groups and reassign their coaches
            debugLines.push('=== STEP 5: Removing Empty Groups and Reassigning Coaches ===');
            const groupsWithRiders = ride.groups.filter(g => g.riders.length > 0);
            const emptyGroups = ride.groups.filter(g => g.riders.length === 0);
            
            if (emptyGroups.length > 0) {
                debugLines.push(`Found ${emptyGroups.length} empty group(s). Reassigning coaches...`);
                
                emptyGroups.forEach(emptyGroup => {
                    const coachesToReassign = [];
                    
                    // Collect all coaches from empty group
                    if (emptyGroup.coaches.leader) coachesToReassign.push({ id: emptyGroup.coaches.leader, role: 'leader' });
                    if (emptyGroup.coaches.sweep) coachesToReassign.push({ id: emptyGroup.coaches.sweep, role: 'sweep' });
                    if (emptyGroup.coaches.roam) coachesToReassign.push({ id: emptyGroup.coaches.roam, role: 'roam' });
                    if (Array.isArray(emptyGroup.coaches.extraRoam)) {
                        emptyGroup.coaches.extraRoam.forEach(id => {
                            coachesToReassign.push({ id, role: 'extraRoam' });
                        });
                    }
                    
                    debugLines.push(`  ${emptyGroup.label}: Reassigning ${coachesToReassign.length} coach(es)`);
                    
                    // Reassign coaches to groups with riders
                    coachesToReassign.forEach(({ id, role }) => {
                        const coach = getCoachById(id);
                        if (!coach) return;
                        
                        // Find a group that needs this type of coach
                        let targetGroup = null;
                        
                        if (role === 'leader') {
                            // For leaders, check if any group needs a Level 2+ leader
                            const coachLevel = parseInt(coach.level, 10) || 0;
                            if (coachLevel >= minLeaderLevel) {
                                // Check if any group has a leader that doesn't meet requirement
                                targetGroup = groupsWithRiders.find(g => {
                                    const currentLeader = getCoachById(g.coaches.leader);
                                    if (!currentLeader) return true;
                                    const currentLeaderLevel = parseInt(currentLeader.level, 10) || 0;
                                    return currentLeaderLevel < minLeaderLevel;
                                });
                                
                                // If no group needs a leader upgrade, assign as extra roam
                                if (!targetGroup) {
                                    targetGroup = groupsWithRiders.sort((a, b) => a.riders.length - b.riders.length)[0];
                                    if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                        targetGroup.coaches.extraRoam = [];
                                    }
                                    targetGroup.coaches.extraRoam.push(id);
                                    debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (extraRoam)`);
                                } else {
                                    targetGroup.coaches.leader = id;
                                    debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (leader)`);
                                }
                            } else {
                                // Level 1 leader - assign as extra roam
                                targetGroup = groupsWithRiders.sort((a, b) => a.riders.length - b.riders.length)[0];
                                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                    targetGroup.coaches.extraRoam = [];
                                }
                                targetGroup.coaches.extraRoam.push(id);
                                debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (extraRoam)`);
                            }
                        } else if (role === 'sweep') {
                            // Assign sweep to group that doesn't have one
                            targetGroup = groupsWithRiders.find(g => !g.coaches.sweep);
                            if (!targetGroup) {
                                // All groups have sweep - assign as extra roam
                                targetGroup = groupsWithRiders.sort((a, b) => a.riders.length - b.riders.length)[0];
                                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                    targetGroup.coaches.extraRoam = [];
                                }
                                targetGroup.coaches.extraRoam.push(id);
                                debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (extraRoam)`);
                            } else {
                                targetGroup.coaches.sweep = id;
                                debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (sweep)`);
                            }
                        } else if (role === 'roam') {
                            // Assign roam to group that doesn't have one
                            targetGroup = groupsWithRiders.find(g => !g.coaches.roam);
                            if (!targetGroup) {
                                // All groups have roam - assign as extra roam
                                targetGroup = groupsWithRiders.sort((a, b) => a.riders.length - b.riders.length)[0];
                                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                    targetGroup.coaches.extraRoam = [];
                                }
                                targetGroup.coaches.extraRoam.push(id);
                                debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (extraRoam)`);
                            } else {
                                targetGroup.coaches.roam = id;
                                debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (roam)`);
                            }
                        } else if (role === 'extraRoam') {
                            // Assign to group with fewest extra roam coaches
                            targetGroup = groupsWithRiders.sort((a, b) => {
                                const aExtra = Array.isArray(a.coaches.extraRoam) ? a.coaches.extraRoam.length : 0;
                                const bExtra = Array.isArray(b.coaches.extraRoam) ? b.coaches.extraRoam.length : 0;
                                return aExtra - bExtra;
                            })[0];
                            if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                                targetGroup.coaches.extraRoam = [];
                            }
                            targetGroup.coaches.extraRoam.push(id);
                            debugLines.push(`    ${coach.name || 'Coach'} ‚Üí ${targetGroup.label} (extraRoam)`);
                        }
                });
            });
            
                // Remove empty groups
                emptyGroups.forEach(emptyGroup => {
                    const index = ride.groups.indexOf(emptyGroup);
                    if (index >= 0) {
                        ride.groups.splice(index, 1);
                        debugLines.push(`  Removed ${emptyGroup.label} (empty group)`);
                    }
                });
                
                debugLines.push(`‚úì Removed ${emptyGroups.length} empty group(s) and reassigned their coaches.`);
            } else {
                debugLines.push(`‚úì No empty groups found.`);
            }
            debugLines.push('');
            
            // FINAL STEP: Ensure ALL riders are placed (implicit highest priority)
            debugLines.push('=== FINAL STEP: Ensuring All Riders Are Placed ===');
            const allAssignedRiderIds = new Set();
            ride.groups.forEach(group => {
                group.riders.forEach(id => allAssignedRiderIds.add(id));
            });
            
            // Get all available rider IDs (not objects)
            const allAvailableRiderIds = new Set(ride.availableRiders);
            const unplacedRiderIds = ride.availableRiders.filter(id => !allAssignedRiderIds.has(id));
            
            if (unplacedRiderIds.length > 0) {
                debugLines.push(`‚ö†Ô∏è ${unplacedRiderIds.length} riders not yet assigned. Placing them now...`);
                
                unplacedRiderIds.forEach(riderId => {
                    // Find group with most room (up to capacity)
                    let targetGroup = ride.groups
                        .filter(g => {
                            const capacity = groupCapacity(g);
                            return g.riders.length < capacity;
                        })
                        .sort((a, b) => b.riders.length - a.riders.length)[0]; // Largest that has room
                    
                    if (!targetGroup) {
                        // All groups at capacity - find smallest group to exceed preference
                        targetGroup = ride.groups.sort((a, b) => a.riders.length - b.riders.length)[0];
                        debugLines.push(`Note: ${targetGroup.label} will exceed preferred max size to place all riders.`);
                    }
                    
                    targetGroup.riders.push(riderId);
                });
                
                debugLines.push(`‚úì All ${ride.availableRiders.length} riders now assigned.`);
            } else {
                debugLines.push(`‚úì All ${ride.availableRiders.length} riders are assigned.`);
            }
            debugLines.push('');

            // Assign remaining coaches to groups with fair distribution
            debugLines.push('=== Assigning Remaining Coaches ===');
            
            // Helper function to count coaches in a group (local scope for this section)
            const countCoachesInGroupLocal = (group) => {
                let count = 0;
                if (group.coaches.leader) count++;
                if (group.coaches.sweep) count++;
                if (group.coaches.roam) count++;
                if (Array.isArray(group.coaches.extraRoam)) {
                    count += group.coaches.extraRoam.filter(Boolean).length;
                }
                return count;
            };
            
            // Helper function to get the next available role for a group
            const getNextRole = (group) => {
                if (!group.coaches.sweep) return 'sweep';
                if (!group.coaches.roam) return 'roam';
                return 'extraRoam';
            };
            
            let coachIndex = 0;
            let assignedCount = 0;
            
            // Phase 1: Ensure all groups have at least 2 coaches (leader + sweep/roam)
            // Assign 2nd coach to groups that only have a leader
            while (coachIndex < remainingCoaches.length) {
                const groupsWithOneCoach = ride.groups.filter(g => countCoachesInGroupLocal(g) === 1);
                if (groupsWithOneCoach.length === 0) break; // All groups have at least 2 coaches
                
                const targetGroup = groupsWithOneCoach[0];
                const role = getNextRole(targetGroup);
                if (role === 'sweep') {
                    targetGroup.coaches.sweep = remainingCoaches[coachIndex].id;
                } else if (role === 'roam') {
                    targetGroup.coaches.roam = remainingCoaches[coachIndex].id;
                }
                coachIndex++;
                assignedCount++;
            }
            
            // Phase 2: Ensure all groups have at least 3 coaches before any group gets a 4th
            // Assign 3rd coach to groups that only have 2 coaches
            while (coachIndex < remainingCoaches.length) {
                const groupsWithTwoCoaches = ride.groups.filter(g => countCoachesInGroupLocal(g) === 2);
                if (groupsWithTwoCoaches.length === 0) break; // All groups have at least 3 coaches
                
                const targetGroup = groupsWithTwoCoaches[0];
                const role = getNextRole(targetGroup);
                if (role === 'roam') {
                    targetGroup.coaches.roam = remainingCoaches[coachIndex].id;
                } else if (role === 'extraRoam') {
                    // This shouldn't happen if group has 2 coaches, but handle it anyway
                    if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                        targetGroup.coaches.extraRoam = [];
                    }
                    targetGroup.coaches.extraRoam.push(remainingCoaches[coachIndex].id);
                }
                coachIndex++;
                assignedCount++;
            }
            
            // Phase 3: Now assign 4th coaches (extraRoam) only after all groups have 3 coaches
            while (coachIndex < remainingCoaches.length) {
                const groupsWithThreeCoaches = ride.groups.filter(g => countCoachesInGroupLocal(g) === 3);
                if (groupsWithThreeCoaches.length === 0) break; // No groups have exactly 3 coaches
                
                const targetGroup = groupsWithThreeCoaches[0];
                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                    targetGroup.coaches.extraRoam = [];
                }
                targetGroup.coaches.extraRoam.push(remainingCoaches[coachIndex].id);
                coachIndex++;
                assignedCount++;
            }
            
            debugLines.push(`Assigned ${assignedCount} remaining coaches to groups with fair distribution.`);
            debugLines.push('');
            
            let groupsInfo = computeGroupsInfo(ride);

            // Final rider smoothing: DISABLED - pace organization already handles this
            // Skip rider smoothing to preserve pace organization from Step 4
            /*
            let ridersAdjusted = true;
            while (ridersAdjusted) {
                ridersAdjusted = false;
                const sortedGroupsByFitnessDesc = ride.groups
                    .slice()
                    .sort((a, b) => getGroupFitnessScore(b) - getGroupFitnessScore(a));
                const sortedGroupsByFitnessAsc = [...sortedGroupsByFitnessDesc].reverse();

                sortedGroupsByFitnessAsc.forEach(lowerGroup => {
                    const lowerFitness = getGroupFitnessScore(lowerGroup);
                    const ridersSnapshot = lowerGroup.riders
                        .map(id => getRiderById(id))
                        .filter(Boolean);

                    const maxFitnessSpread = getMAX_FITNESS_SPREAD();
                    ridersSnapshot.forEach(rider => {
                        const riderFitness = parseInt(rider.fitness || '5', 10);
                        if (!Number.isFinite(riderFitness)) return;
                        if (riderFitness <= lowerFitness + maxFitnessSpread) return;

                        const targetGroup = sortedGroupsByFitnessDesc.find(group => {
                            if (group === lowerGroup) return false;
                            const groupFitness = getGroupFitnessScore(group);
                            if (groupFitness <= lowerFitness) return false;
                            if (group.riders.includes(rider.id)) return false;
                            const capacity = groupCapacity(group);
                            if (group.riders.length >= capacity) return false;
                            if (Math.abs(riderFitness - groupFitness) > maxFitnessSpread + 2) return false;
                            return true;
                        });

                        if (targetGroup) {
                            lowerGroup.riders = lowerGroup.riders.filter(id => id !== rider.id);
                            targetGroup.riders.push(rider.id);
                            ridersAdjusted = true;
                            debugLines.push(`Adjusted: moved ${rider.name || 'Rider'} (Fitness ${riderFitness}) from ${lowerGroup.label} to ${targetGroup.label} for better fitness alignment.`);
                        }
                    });
                });
            }
            */
            groupsInfo = computeGroupsInfo(ride);

            const coachBalance = rebalanceGroupCoaches(ride, availableCoaches, debugLines);

            const coachAssignmentMapAfter = getCoachAssignmentMap(ride);
            const totalAssignedCoaches = Object.keys(coachAssignmentMapAfter).length;
            const unassignedCoachCount = Math.max(availableCoaches.length - totalAssignedCoaches, 0);
            if (coachBalance.extrasAssigned > 0) {
                const assignmentsSummary = coachBalance.extraAssignments.map(entry => {
                    const coach = getCoachById(entry.coachId);
                    const group = findGroupById(ride, entry.groupId);
                    const coachName = coach ? (coach.name || 'Coach') : 'Coach';
                    const groupLabel = group ? group.label : 'Group';
                    return `${coachName} ‚Üí ${groupLabel}`;
                }).join(', ');
                debugLines.push(`Extra roam coaches assigned: ${assignmentsSummary}`);
            }
            debugLines.push(`Unique coaches assigned: ${totalAssignedCoaches}/${availableCoaches.length}`);
            if (unassignedCoachCount > 0) {
                debugLines.push(`Coaches remaining without group assignment: ${unassignedCoachCount}`);
                if (!coachBalance.allGroupsStaffed) {
                    debugLines.push('Not enough coaches to staff every group with a Roam coach; remaining coaches left unassigned.');
                }
            } else {
                debugLines.push('All selected coaches assigned to groups.');
            }

            debugLines.push('Coach pace alignment details:');
            ride.groups
                .slice()
                .sort((a, b) => getGroupFitnessScore(b) - getGroupFitnessScore(a))
                .forEach(group => {
                    const groupFitness = getGroupFitnessScore(group);
                    const leader = getCoachById(group.coaches.leader);
                    const sweep = getCoachById(group.coaches.sweep);
                    const roam = getCoachById(group.coaches.roam);
                    const extra = Array.isArray(group.coaches.extraRoam)
                        ? group.coaches.extraRoam
                            .map(id => getCoachById(id))
                            .filter(Boolean)
                        : [];

                    const leaderInfo = leader
                        ? `${leader.name || 'Coach'} (L${leader.level || '1'}, Fitness ${getCoachFitnessValue(leader)})`
                        : 'None';
                    const sweepInfo = sweep
                        ? `${sweep.name || 'Coach'} (Fitness ${getCoachFitnessValue(sweep)})`
                        : 'None';
                    const roamInfo = roam
                        ? `${roam.name || 'Coach'} (Fitness ${getCoachFitnessValue(roam)})`
                        : 'None';
                    const extraInfo = extra.length
                        ? extra.map(coach => `${coach.name || 'Coach'} (Fitness ${getCoachFitnessValue(coach)})`).join(', ')
                        : 'None';

                    debugLines.push(
                        `${group.label} ‚Ä¢ target pace ${groupFitness}: ` +
                        `Leader ${leaderInfo} | Sweep ${sweepInfo} | Roam ${roamInfo} | Roam+ ${extraInfo}`
                    );
                });
            debugLines.push('');

            // STEP: Consolidate small groups (1-2 riders with single leader) into larger groups with 3 leaders
            debugLines.push('');
            debugLines.push('=== CONSOLIDATION STEP: Combining Small Groups ===');
            const minGroupSize = getAutoAssignSetting('minGroupSize', 4);
            const smallGroups = ride.groups.filter(group => {
                const riderCount = group.riders.length;
                const coachCount = countGroupCoaches(group);
                // Identify groups with 1-2 riders and only 1 coach (just the leader)
                return riderCount <= 2 && coachCount === 1 && group.coaches.leader;
            });
            
            if (smallGroups.length > 0) {
                debugLines.push(`Found ${smallGroups.length} small group(s) to consolidate:`);
                smallGroups.forEach(group => {
                    debugLines.push(`  ${group.label}: ${group.riders.length} rider(s), ${countGroupCoaches(group)} coach(es)`);
                });
                
                // Get all currently assigned coach IDs to find unassigned coaches
                const assignedCoachIds = new Set();
                ride.groups.forEach(g => {
                    if (g.coaches.leader) assignedCoachIds.add(g.coaches.leader);
                    if (g.coaches.sweep) assignedCoachIds.add(g.coaches.sweep);
                    if (g.coaches.roam) assignedCoachIds.add(g.coaches.roam);
                    if (Array.isArray(g.coaches.extraRoam)) {
                        g.coaches.extraRoam.forEach(id => assignedCoachIds.add(id));
                    }
                });
                
                // Get unassigned coaches from available coaches
                const unassignedCoaches = availableCoaches.filter(c => !assignedCoachIds.has(c.id));
                
                // Try to combine small groups together
                // Target: groups with 3 leaders (leader + sweep + roam)
                const targetLeaderCount = 3;
                let consolidated = 0;
                
                // Sort small groups by rider count (smallest first)
                const sortedSmallGroups = [...smallGroups].sort((a, b) => a.riders.length - b.riders.length);
                
                // Process groups in batches to create consolidated groups
                while (sortedSmallGroups.length >= 2) {
                    // Take up to 3 small groups to combine (aiming for 3-6 riders total)
                    const groupsToCombine = sortedSmallGroups.splice(0, Math.min(3, sortedSmallGroups.length));
                    const totalRiders = groupsToCombine.reduce((sum, g) => sum + g.riders.length, 0);
                    
                    if (totalRiders < minGroupSize && sortedSmallGroups.length > 0) {
                        // If still too small, try to add one more group
                        if (sortedSmallGroups.length > 0) {
                            const nextGroup = sortedSmallGroups[0];
                            const newTotal = totalRiders + nextGroup.riders.length;
                            if (newTotal <= 10) { // Don't exceed max group size
                                groupsToCombine.push(sortedSmallGroups.shift());
                            }
                        }
                    }
                    
                    // Create a new consolidated group
                    const consolidatedGroup = createGroup(`Group ${ride.groups.length + 1}`);
                    
                    // Collect all riders from groups to combine
                    const allRiders = [];
                    const allLeaders = [];
                    groupsToCombine.forEach(group => {
                        allRiders.push(...group.riders);
                        if (group.coaches.leader) {
                            allLeaders.push(group.coaches.leader);
                        }
                    });
                    
                    // Assign riders
                    consolidatedGroup.riders = allRiders;
                    
                    // Assign coaches: use up to 3 leaders, then assign remaining as sweep/roam
                    if (allLeaders.length >= targetLeaderCount) {
                        // Use first 3 as leader, sweep, roam
                        consolidatedGroup.coaches.leader = allLeaders[0];
                        consolidatedGroup.coaches.sweep = allLeaders[1];
                        consolidatedGroup.coaches.roam = allLeaders[2];
                        // Remaining leaders become extraRoam
                        if (allLeaders.length > targetLeaderCount) {
                            consolidatedGroup.coaches.extraRoam = allLeaders.slice(targetLeaderCount);
                        }
                    } else if (allLeaders.length === 2) {
                        // Use both as leader and sweep
                        consolidatedGroup.coaches.leader = allLeaders[0];
                        consolidatedGroup.coaches.sweep = allLeaders[1];
                        // Try to find a roam from unassigned coaches
                        const availableForRoam = unassignedCoaches
                            .filter(c => !allLeaders.includes(c.id))[0];
                        if (availableForRoam) {
                            consolidatedGroup.coaches.roam = availableForRoam.id;
                            assignedCoachIds.add(availableForRoam.id); // Mark as assigned
                        }
                    } else if (allLeaders.length === 1) {
                        // Use as leader, try to find sweep and roam from unassigned coaches
                        consolidatedGroup.coaches.leader = allLeaders[0];
                        const availableForSweep = unassignedCoaches
                            .filter(c => c.id !== allLeaders[0])[0];
                        if (availableForSweep) {
                            consolidatedGroup.coaches.sweep = availableForSweep.id;
                            assignedCoachIds.add(availableForSweep.id); // Mark as assigned
                            const availableForRoam = unassignedCoaches
                                .filter(c => c.id !== allLeaders[0] && c.id !== availableForSweep.id)[0];
                            if (availableForRoam) {
                                consolidatedGroup.coaches.roam = availableForRoam.id;
                                assignedCoachIds.add(availableForRoam.id); // Mark as assigned
                            }
                        }
                    }
                    
                    // Add consolidated group
                    ride.groups.push(consolidatedGroup);
                    
                    // Remove the original small groups
                    groupsToCombine.forEach(groupToRemove => {
                        const index = ride.groups.indexOf(groupToRemove);
                        if (index >= 0) {
                            ride.groups.splice(index, 1);
                        }
                    });
                    
                    consolidated++;
                    const leaderNames = [];
                    if (consolidatedGroup.coaches.leader) {
                        const leader = getCoachById(consolidatedGroup.coaches.leader);
                        leaderNames.push(leader ? leader.name : 'Coach');
                    }
                    if (consolidatedGroup.coaches.sweep) {
                        const sweep = getCoachById(consolidatedGroup.coaches.sweep);
                        leaderNames.push(sweep ? sweep.name : 'Coach');
                    }
                    if (consolidatedGroup.coaches.roam) {
                        const roam = getCoachById(consolidatedGroup.coaches.roam);
                        leaderNames.push(roam ? roam.name : 'Coach');
                    }
                    
                    debugLines.push(`‚úì Combined ${groupsToCombine.length} small group(s) into ${consolidatedGroup.label}: ${consolidatedGroup.riders.length} riders, ${countGroupCoaches(consolidatedGroup)} coach(es) (${leaderNames.join(', ')})`);
                }
                
                // Remove any remaining small groups that couldn't be combined
                const remainingSmall = ride.groups.filter(group => {
                    const riderCount = group.riders.length;
                    const coachCount = countGroupCoaches(group);
                    return riderCount <= 2 && coachCount === 1 && group.coaches.leader;
                });
                
                if (remainingSmall.length > 0) {
                    debugLines.push(`Note: ${remainingSmall.length} small group(s) could not be consolidated (insufficient groups or coaches to combine).`);
                }
                
                debugLines.push(`Consolidated ${consolidated} group(s).`);
            } else {
                debugLines.push(`‚úì No small groups found to consolidate.`);
            }
            debugLines.push('');

            // Recursive rebalancing step: Ensure fair coach distribution after consolidation
            debugLines.push('=== REBALANCING STEP: Fair Coach Distribution ===');
            
            // Helper function to count coaches in a group
            const countCoachesInGroup = (group) => {
                let count = 0;
                if (group.coaches.leader) count++;
                if (group.coaches.sweep) count++;
                if (group.coaches.roam) count++;
                if (Array.isArray(group.coaches.extraRoam)) {
                    count += group.coaches.extraRoam.filter(Boolean).length;
                }
                return count;
            };
            
            // Helper function to get a coach from a group (prefer extraRoam, then roam, then sweep)
            const removeCoachFromGroup = (group) => {
                if (Array.isArray(group.coaches.extraRoam) && group.coaches.extraRoam.length > 0) {
                    return group.coaches.extraRoam.pop();
                }
                if (group.coaches.roam) {
                    const coachId = group.coaches.roam;
                    group.coaches.roam = null;
                    return coachId;
                }
                if (group.coaches.sweep) {
                    const coachId = group.coaches.sweep;
                    group.coaches.sweep = null;
                    return coachId;
                }
                return null;
            };
            
            // Helper function to add a coach to a group (prefer sweep, then roam, then extraRoam)
            const addCoachToGroup = (group, coachId) => {
                if (!group.coaches.sweep) {
                    group.coaches.sweep = coachId;
                    return 'sweep';
                }
                if (!group.coaches.roam) {
                    group.coaches.roam = coachId;
                    return 'roam';
                }
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                }
                group.coaches.extraRoam.push(coachId);
                return 'extraRoam';
            };
            
            let rebalanceIterations = 0;
            const maxRebalanceIterations = 50; // Safety limit
            let changesMade = true;
            
            while (changesMade && rebalanceIterations < maxRebalanceIterations) {
                rebalanceIterations++;
                changesMade = false;
                
                // Get coach counts for all groups
                const groupsWithCounts = ride.groups.map(group => ({
                    group,
                    count: countCoachesInGroup(group)
                }));
                
                // Find minimum and maximum coach counts
                const counts = groupsWithCounts.map(g => g.count);
                const minCount = Math.min(...counts);
                const maxCount = Math.max(...counts);
                
                // If all groups have the same count (or within 1), we're done
                if (maxCount - minCount <= 1) {
                    break;
                }
                
                // Phase 1: Ensure all groups have at least 2 coaches before any have 3+
                if (minCount === 1 && maxCount >= 3) {
                    const groupsWithOne = groupsWithCounts.filter(g => g.count === 1).map(g => g.group);
                    const groupsWithThreeOrMore = groupsWithCounts.filter(g => g.count >= 3).map(g => g.group);
                    
                    for (const targetGroup of groupsWithOne) {
                        if (groupsWithThreeOrMore.length === 0) break;
                        
                        // Find a group with 3+ coaches that we can take from
                        const sourceGroup = groupsWithThreeOrMore.find(g => countCoachesInGroup(g) >= 3);
                        if (!sourceGroup) break;
                        
                        const coachId = removeCoachFromGroup(sourceGroup);
                        if (coachId) {
                            const role = addCoachToGroup(targetGroup, coachId);
                            const coach = getCoachById(coachId);
                            debugLines.push(`  Moved ${coach ? coach.name : 'Coach'} from ${sourceGroup.label} to ${targetGroup.label} (${role})`);
                            changesMade = true;
                            
                            // Update counts
                            const newSourceCount = countCoachesInGroup(sourceGroup);
                            if (newSourceCount < 3) {
                                const index = groupsWithThreeOrMore.indexOf(sourceGroup);
                                if (index >= 0) groupsWithThreeOrMore.splice(index, 1);
                            }
                        }
                    }
                    continue;
                }
                
                // Phase 2: Ensure all groups have at least 3 coaches before any have 4+
                if (minCount === 2 && maxCount >= 4) {
                    const groupsWithTwo = groupsWithCounts.filter(g => g.count === 2).map(g => g.group);
                    const groupsWithFourOrMore = groupsWithCounts.filter(g => g.count >= 4).map(g => g.group);
                    
                    for (const targetGroup of groupsWithTwo) {
                        if (groupsWithFourOrMore.length === 0) break;
                        
                        const sourceGroup = groupsWithFourOrMore.find(g => countCoachesInGroup(g) >= 4);
                        if (!sourceGroup) break;
                        
                        const coachId = removeCoachFromGroup(sourceGroup);
                        if (coachId) {
                            const role = addCoachToGroup(targetGroup, coachId);
                            const coach = getCoachById(coachId);
                            debugLines.push(`  Moved ${coach ? coach.name : 'Coach'} from ${sourceGroup.label} to ${targetGroup.label} (${role})`);
                            changesMade = true;
                            
                            const newSourceCount = countCoachesInGroup(sourceGroup);
                            if (newSourceCount < 4) {
                                const index = groupsWithFourOrMore.indexOf(sourceGroup);
                                if (index >= 0) groupsWithFourOrMore.splice(index, 1);
                            }
                        }
                    }
                    continue;
                }
                
                // Phase 3: Balance groups that have 3 coaches with groups that have 4+
                if (minCount === 3 && maxCount >= 4) {
                    const groupsWithThree = groupsWithCounts.filter(g => g.count === 3).map(g => g.group);
                    const groupsWithFourOrMore = groupsWithCounts.filter(g => g.count >= 4).map(g => g.group);
                    
                    for (const targetGroup of groupsWithThree) {
                        if (groupsWithFourOrMore.length === 0) break;
                        
                        const sourceGroup = groupsWithFourOrMore.find(g => countCoachesInGroup(g) >= 4);
                        if (!sourceGroup) break;
                        
                        const coachId = removeCoachFromGroup(sourceGroup);
                        if (coachId) {
                            const role = addCoachToGroup(targetGroup, coachId);
                            const coach = getCoachById(coachId);
                            debugLines.push(`  Moved ${coach ? coach.name : 'Coach'} from ${sourceGroup.label} to ${targetGroup.label} (${role})`);
                            changesMade = true;
                            
                            const newSourceCount = countCoachesInGroup(sourceGroup);
                            if (newSourceCount < 4) {
                                const index = groupsWithFourOrMore.indexOf(sourceGroup);
                                if (index >= 0) groupsWithFourOrMore.splice(index, 1);
                            }
                        }
                    }
                    continue;
                }
                
                // If we get here, we can't make more improvements
                break;
            }
            
            if (rebalanceIterations >= maxRebalanceIterations) {
                debugLines.push(`  ‚ö†Ô∏è Rebalancing stopped after ${maxRebalanceIterations} iterations (safety limit).`);
            } else if (changesMade) {
                debugLines.push(`  ‚úì Rebalancing completed in ${rebalanceIterations} iteration(s).`);
            } else {
                debugLines.push(`  ‚úì Coach distribution is already balanced.`);
            }
            
            // Show final distribution
            const finalCounts = ride.groups.map(g => countCoachesInGroup(g));
            const finalMin = Math.min(...finalCounts);
            const finalMax = Math.max(...finalCounts);
            debugLines.push(`  Final distribution: ${finalMin}-${finalMax} coaches per group.`);
            debugLines.push('');

            // Final step: Renumber all groups sequentially (1, 2, 3, 4...) without gaps
            debugLines.push('');
            debugLines.push('=== FINAL STEP: Renumbering Groups Sequentially ===');
            const groupCountBefore = ride.groups.length;
            renumberGroups(ride, true); // Use sequential renumbering
            debugLines.push(`Renumbered ${groupCountBefore} group(s) sequentially (Group 1 through Group ${groupCountBefore}).`);
            debugLines.push('');
            
            ride.assignments = {};
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);

            ride.groups.forEach(group => {
                const groupFitnessLabel = group.fitnessTag ? `Fitness ${group.fitnessTag}` : 'Mixed Fitness';
                debugLines.push(`${group.label} ‚Äî ${group.riders.length} riders ‚Ä¢ ${groupFitnessLabel}`);

                const leader = getCoachById(group.coaches.leader);
                const sweep = getCoachById(group.coaches.sweep);
                const roam = getCoachById(group.coaches.roam);
                const extraCoaches = Array.isArray(group.coaches.extraRoam)
                    ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                    : [];

                const formatCoach = (coach, role) => coach
                    ? `${coach.name || 'Coach'} (Role ${role}, Level ${coach.level || '1'}, Fitness ${getCoachFitnessValue(coach)})`
                    : `${role}: None`;

                debugLines.push(`  Coaches:`);
                debugLines.push(`    ${formatCoach(leader, 'Leader')}`);
                debugLines.push(`    ${formatCoach(sweep, 'Sweep')}`);
                debugLines.push(`    ${formatCoach(roam, 'Roam')}`);
                if (extraCoaches.length > 0) {
                    extraCoaches.forEach((coach, idx) => {
                        debugLines.push(`    ${formatCoach(coach, `Roam+${idx + 1}`)}`);
                    });
                } else {
                    debugLines.push(`    Roam+: None`);
                }

                const riderDetails = group.riders
                    .map(id => getRiderById(id))
                    .filter(Boolean)
                    .map(rider => {
                        const fitness = parseInt(rider.fitness || '5', 10);
                        const grade = rider.grade ? formatGradeLabel(rider.grade) : 'N/A';
                        return `${rider.name || 'Rider'} (Grade ${grade}, Fitness ${Number.isFinite(fitness) ? fitness : 'N/A'})`;
                    });

                if (riderDetails.length > 0) {
                    debugLines.push(`  Riders:`);
                    riderDetails.forEach(detail => debugLines.push(`    ${detail}`));
                } else {
                    debugLines.push(`  Riders: (none)`);
                }

                if (group.riders.length > 10) {
                    debugLines.push(`  ‚ö†Ô∏è ${group.label} exceeds the 10 rider target (current: ${group.riders.length}).`);
                }
            });
            debugLines.push('');

            // Verify all riders are placed
            const finalAssignedCount = ride.groups.reduce((sum, g) => sum + g.riders.length, 0);
            if (finalAssignedCount === ride.availableRiders.length) {
                debugLines.push(`‚úì All ${ride.availableRiders.length} riders successfully assigned.`);
            } else {
                debugLines.push(`‚ö†Ô∏è Warning: ${finalAssignedCount} riders assigned, but ${ride.availableRiders.length} were available.`);
            }

            autoAssignDebugLog = debugLines.join('\n');
            updateDebugOutput();
            } catch (error) {
                console.error('Error in autoAssign:', error);
                alert(`Error during auto-assignment: ${error.message}\n\nCheck the browser console for details.`);
                autoAssignDebugLog = `Error: ${error.message}\n\nStack trace:\n${error.stack}`;
                updateDebugOutput();
            }
        }

        function clearAssignments() {
            if (!confirm('Clear all assignments? This will delete all groups and remove all rider and coach assignments.')) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Delete all groups
            ride.groups = [];
            ride.assignments = {};
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
            autoAssignDebugLog = `Assignments cleared at ${new Date().toLocaleString()}.`;
            updateDebugOutput();
        }

        // Assignment rendering and drag-drop
        function renderAssignments(ride) {
            const container = document.getElementById('assignments');
            if (!container) return;

            // Sort groups by fitness (descending) so Group 1 is fastest
            ride.groups.sort((a, b) => {
                const fitnessA = getGroupFitnessScore(a);
                const fitnessB = getGroupFitnessScore(b);
                if (fitnessB !== fitnessA) return fitnessB - fitnessA;
                // If fitness is equal, sort by size (larger first)
                const sizeDiff = b.riders.length - a.riders.length;
                if (sizeDiff !== 0) return sizeDiff;
                // If size is also equal, maintain original order (stable sort by ID)
                return a.id - b.id;
            });
            
            renumberGroups(ride);

            const coachAssignmentMap = getCoachAssignmentMap(ride);
            const assignedCoachIds = new Set(
                Object.keys(coachAssignmentMap)
                    .map(id => parseInt(id, 10))
                    .filter(id => Number.isFinite(id))
            );

            const totalAssignedRiders = ride.groups.reduce((sum, group) => sum + group.riders.length, 0);
            const riderAssignmentMap = {};
            const groupLabelMap = {};
            ride.groups.forEach(group => {
                groupLabelMap[group.id] = group.label;
                group.riders.forEach(riderId => {
                    riderAssignmentMap[riderId] = group.id;
                });
            });
            
            // Get sort preference for unassigned riders (default to 'pace')
            const unassignedRidersSort = ride.unassignedRidersSort || 'pace';
            
            const unassignedRiders = data.riders
                .filter(rider => !riderAssignmentMap[rider.id])
                .map(rider => {
                    const isAvailable = ride.availableRiders.includes(rider.id);
                    return {
                        rider,
                        isAvailable,
                        fitness: (() => {
                            const fitnessScale = getFitnessScale();
                            return Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10)));
                        })(),
                        skills: (() => {
                            const skillsScale = getSkillsScale();
                            return Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10)));
                        })(),
                        grade: parseInt(rider.grade || '0', 10) || 0,
                        gender: (rider.gender || 'M').toUpperCase(),
                        lastName: getSortableLastName(rider.name || ''),
                        name: (rider.name || '').toLowerCase()
                    };
                }).sort((a, b) => {
                    if (a.isAvailable !== b.isAvailable) return a.isAvailable ? -1 : 1;
                    
                    if (unassignedRidersSort === 'pace') {
                        if (b.fitness !== a.fitness) return b.fitness - a.fitness;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'skills') {
                        if (b.skills !== a.skills) return b.skills - a.skills;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'grade') {
                        if (b.grade !== a.grade) return b.grade - a.grade;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (unassignedRidersSort === 'gender') {
                        if (a.gender !== b.gender) return a.gender.localeCompare(b.gender);
                        return a.lastName.localeCompare(b.lastName);
                    } else { // name
                        return a.lastName.localeCompare(b.lastName) || a.name.localeCompare(b.name);
                    }
                });

            const riderCardsHtml = unassignedRiders
                .map(({ rider, isAvailable }) => renderRiderCardHtml(rider, {
                    draggable: true,
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel: isAvailable ? '' : 'Unavailable',
                    checkboxHandler: `toggleRiderAvailability(${rider.id})`,
                    compact: true,
                    sortBy: unassignedRidersSort
                }))
                .join('');

            // Get sort preference for unassigned coaches (default to 'pace')
            const unassignedCoachesSort = ride.unassignedCoachesSort || 'pace';
            
            const unassignedCoaches = data.coaches
                .filter(coach => !coachAssignmentMap[coach.id])
                .map(coach => {
                const isAvailable = ride.availableCoaches.includes(coach.id);
                const fitness = getCoachFitnessValue(coach);
                const level = parseInt(coach.level || '1', 10);
                return {
                    coach,
                    isAvailable,
                    fitness,
                    level,
                    lastName: getSortableLastName(coach.name || ''),
                    name: (coach.name || '').toLowerCase()
                };
            }).sort((a, b) => {
                if (a.isAvailable !== b.isAvailable) return a.isAvailable ? -1 : 1;
                
                if (unassignedCoachesSort === 'pace') {
                    const fitnessDiff = b.fitness - a.fitness;
                    if (fitnessDiff !== 0) return fitnessDiff;
                    return a.lastName.localeCompare(b.lastName);
                } else if (unassignedCoachesSort === 'level') {
                    const levelDiff = b.level - a.level;
                    if (levelDiff !== 0) return levelDiff;
                    return a.lastName.localeCompare(b.lastName);
                } else { // name
                    return a.lastName.localeCompare(b.lastName) || a.name.localeCompare(b.name);
                }
            });

            const coachCardsHtml = unassignedCoaches
                .map(({ coach, isAvailable }) => renderCoachCardHtml(coach, null, 'unassigned', {
                    draggable: true,
                    showAttendance: true,
                    isAvailable,
                    assignmentLabel: isAvailable ? '' : 'Unavailable',
                    checkboxHandler: `toggleCoachAvailability(${coach.id})`,
                    compact: true,
                    sortBy: unassignedCoachesSort
                }))
                .join('');

            const renderGroupCard = (group) => {
                const coachCount = countGroupCoaches(group);
                const capacity = groupCapacity(group);
                const warnings = [];

                if (!group.coaches.leader) {
                    warnings.push('Assign a leader (Level 2 or 3)');
                } else {
                    const leader = getCoachById(group.coaches.leader);
                    const leaderLevel = leader ? parseInt(leader.level, 10) : 0;
                    if (!Number.isFinite(leaderLevel) || leaderLevel < 2) {
                        warnings.push('Leader must be Level 2 or 3');
                    }
                }

                if (coachCount === 0) {
                    warnings.push('Add at least one coach to this group');
                }

                if (coachCount > 0 && group.riders.length > capacity) {
                    warnings.push('Group is over capacity');
                }

                const riderFitnesses = group.riders
                    .map(id => getRiderById(id))
                    .filter(Boolean)
                    .map(r => String(Math.max(1, Math.min(10, parseInt(r.fitness || '5', 10)))));

                if (riderFitnesses.length === 0) {
                    group.fitnessTag = null;
                } else {
                    const uniqueFitnesses = Array.from(new Set(riderFitnesses));
                    if (uniqueFitnesses.length === 1) {
                        group.fitnessTag = uniqueFitnesses[0];
                    } else if (!group.fitnessTag) {
                        group.fitnessTag = uniqueFitnesses[0];
                    }
                }

                // Get sort preference for this group (default to 'pace')
                const sortBy = group.sortBy || 'pace';
                
                const riderObjects = group.riders
                    .map(id => getRiderById(id))
                    .filter(Boolean)
                    .sort((a, b) => {
                        if (sortBy === 'pace') {
                            const aPace = parseInt(a.fitness || '5', 10);
                            const bPace = parseInt(b.fitness || '5', 10);
                            if (bPace !== aPace) return bPace - aPace; // Descending (fastest first)
                            // If pace is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'skills') {
                            const aSkills = parseInt(a.skills || '2', 10);
                            const bSkills = parseInt(b.skills || '2', 10);
                            if (bSkills !== aSkills) return bSkills - aSkills; // Descending (higher skills first)
                            // If skills is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'grade') {
                            const aGrade = parseInt(a.grade || '0', 10) || 0;
                            const bGrade = parseInt(b.grade || '0', 10) || 0;
                            if (bGrade !== aGrade) return bGrade - aGrade; // Descending (higher grade first)
                            // If grade is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else if (sortBy === 'gender') {
                            const aGender = (a.gender || 'M').toUpperCase();
                            const bGender = (b.gender || 'M').toUpperCase();
                            if (aGender !== bGender) return aGender.localeCompare(bGender);
                            // If gender is equal, sort by name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || ''));
                        } else { // name
                            return getSortableLastName(a.name || '').localeCompare(getSortableLastName(b.name || '')) || (a.name || '').localeCompare(b.name || '');
                        }
                    });

                // Get groups sorted by fitness to determine if we can move up/down
                const sortedGroups = ride.groups.slice().sort((a, b) => {
                    const fitnessA = getGroupFitnessScore(a);
                    const fitnessB = getGroupFitnessScore(b);
                    if (fitnessB !== fitnessA) return fitnessB - fitnessA;
                    return b.riders.length - a.riders.length;
                });
                const currentGroupIndex = sortedGroups.findIndex(g => g.id === group.id);
                const canMoveUp = currentGroupIndex > 0;
                const canMoveDown = currentGroupIndex >= 0 && currentGroupIndex < sortedGroups.length - 1;

                const ridersHtml = riderObjects
                    .map((rider, index) => {
                        const isAvailable = ride.availableRiders.includes(rider.id);
                        return renderRiderCardHtml(rider, {
                            draggable: true,
                            showAttendance: true,
                            isAvailable,
                            assignmentLabel: isAvailable ? '' : 'Unavailable',
                            checkboxHandler: `toggleRiderAvailability(${rider.id})`,
                            compact: true,
                            showMoveControls: true,
                            groupId: group.id,
                            canMoveUp: canMoveUp,
                            canMoveDown: canMoveDown,
                            sortBy: sortBy
                        });
                    })
                    .join('') || '<div class="empty-message">No riders assigned</div>';

                const paceLabel = group.fitnessTag ? `Fitness ${escapeHtml(group.fitnessTag)}` : 'Mixed Fitness';
                const warningsHtml = warnings.length ? `<div class="warning-text">${warnings.join(' ‚Ä¢ ')}</div>` : '';
                
                return `
                    <div class="coach-group" style="border: none !important; border-style: none !important; outline: none;">
                        <div class="coach-group-header" style="border: none !important; border-style: none !important;">
                            <span>${group.label}</span>
                            <div class="group-header-stats">
                                <select class="group-sort-select" onchange="changeGroupSort(${group.id}, this.value)" title="Sort by">
                                    <option value="pace" ${sortBy === 'pace' ? 'selected' : ''}>Sort by: Fitness</option>
                                    <option value="skills" ${sortBy === 'skills' ? 'selected' : ''}>Sort by: Bike Skills</option>
                                    <option value="grade" ${sortBy === 'grade' ? 'selected' : ''}>Sort by: Grade</option>
                                    <option value="gender" ${sortBy === 'gender' ? 'selected' : ''}>Sort by: Gender</option>
                                    <option value="name" ${sortBy === 'name' ? 'selected' : ''}>Sort by: Name</option>
                                </select>
                                <span class="capacity-badge">${paceLabel}</span>
                                <span class="capacity-badge">${coachCount} coach${coachCount === 1 ? '' : 'es'}</span>
                                <span class="capacity-badge">${coachCount > 0 ? `${group.riders.length}/${capacity} riders` : 'No coaches assigned'}</span>
                                <button class="danger btn-small" onclick="deleteGroup(${group.id})">Remove</button>
                        </div>
                                    </div>
                        <div class="group-body" style="display: flex; flex-direction: column; border: none !important; border-style: none !important;">
                            <div class="group-coaches" 
                                 data-group-id="${group.id}"
                                 style="width: 100%; margin-bottom: 12px; border: none !important; border-style: none !important; min-height: 40px;">
                                ${renderGroupCoachesInline(group, ride)}
                            </div>
                            <div class="group-riders"
                                 data-drop-type="rider"
                                 data-group-id="${group.id}"
                                 ondrop="drop(event)"
                                 ondragover="allowDrop(event)"
                                 ondragleave="dragLeave(event)"
                                 style="width: 100%; border: none !important; border-style: none !important;">
                                ${ridersHtml}
                            </div>
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
                            <label style="display: block; margin-bottom: 6px; font-size: 12px; font-weight: 500; color: #666;">Route</label>
                            <select onchange="updateGroupRoute(${group.id}, this.value)" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="">-- Select Route --</option>
                                ${renderRouteOptions(group.routeId)}
                            </select>
                        </div>
                        ${warningsHtml}
                    </div>
                `;
            };

            const groupsHtml = ride.groups.length
                ? ride.groups.slice().sort((a, b) => {
                    // Extract numeric value from group label (e.g., "Group 1" -> 1)
                    const getGroupNumber = (group) => {
                        const label = group.label || `Group ${group.id}`;
                        const match = label.match(/\d+/);
                        return match ? parseInt(match[0], 10) : group.id;
                    };
                    return getGroupNumber(a) - getGroupNumber(b);
                }).map(renderGroupCard).join('')
                : renderEmptyGroupCard();

            const centerColumnHtml = `
                <div class="assignment-column groups-column" style="width: 100%; display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 16px; max-width: 100%;">
                    <div style="grid-column: 1 / -1;">
                        <button class="btn-small" onclick="addGroup()">Add Group</button>
                    </div>
                    ${groupsHtml}
                </div>
            `;

            container.innerHTML = centerColumnHtml;
            updateDebugOutput();
            
            // Re-render practice attendance lists if open to show updated assignments
            const attendanceContent = document.getElementById('practice-attendance-content');
            if (attendanceContent && attendanceContent.style.display !== 'none') {
                renderPracticeAttendanceLists();
            }
        }

        function updatePracticeGoals() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const goalsInput = document.getElementById('practice-goals');
            if (goalsInput) {
                ride.goals = goalsInput.value.trim();
                saveRideToDB(ride);
            }
        }
        
        function togglePracticeAttendance() {
            const content = document.getElementById('practice-attendance-content');
            const arrow = document.getElementById('practice-attendance-arrow');
            if (!content || !arrow) return;
            
            const isVisible = content.style.display !== 'none';
            content.style.display = isVisible ? 'none' : 'block';
            arrow.textContent = isVisible ? '‚ñº' : '‚ñ≤';
            
            // Always render lists when opening to ensure they're up to date
            if (!isVisible) {
                renderPracticeAttendanceLists();
            }
        }
        
        function renderPracticeAttendanceLists() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Initialize arrays if they don't exist
            if (!Array.isArray(ride.availableRiders)) {
                ride.availableRiders = data.riders.map(r => r.id); // All riders available by default
            }
            if (!Array.isArray(ride.availableCoaches)) {
                ride.availableCoaches = []; // No coaches available by default
            }
            
            // Build rider assignment map
            const riderAssignmentMap = {};
            const groupLabelMap = {};
            ride.groups.forEach(group => {
                groupLabelMap[group.id] = group.label;
                group.riders.forEach(riderId => {
                    riderAssignmentMap[riderId] = group.id;
                });
            });
            
            // Build coach assignment map
            const coachAssignmentMap = getCoachAssignmentMap(ride);
            
            // Get sort preferences
            const ridersSort = ride.practiceRidersSort || 'pace';
            const coachesSort = ride.practiceCoachesSort || 'pace';
            
            // Process and sort riders
            const ridersData = data.riders.map(rider => {
                const isAvailable = ride.availableRiders.includes(rider.id);
                const assignedGroupId = riderAssignmentMap[rider.id];
                const assignedGroupLabel = assignedGroupId ? groupLabelMap[assignedGroupId] : null;
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                
                // Extract firstName and lastName
                let firstName = rider.firstName || '';
                let lastName = rider.lastName || '';
                if (!firstName && !lastName && rider.name) {
                    const nameParts = rider.name.trim().split(' ');
                    if (nameParts.length > 1) {
                        lastName = nameParts.pop() || '';
                        firstName = nameParts.join(' ') || '';
                    } else {
                        firstName = nameParts[0] || '';
                    }
                }
                
                return {
                    rider,
                    isAvailable,
                    assignedGroupId,
                    assignedGroupLabel,
                    fitness: Math.max(1, Math.min(fitnessScale, parseInt(rider.fitness || Math.ceil(fitnessScale / 2), 10))),
                    skills: Math.max(1, Math.min(skillsScale, parseInt(rider.skills || Math.ceil(skillsScale / 2), 10))),
                    grade: parseInt(rider.grade || '0', 10) || 0,
                    gender: (rider.gender || 'M').toUpperCase(),
                    firstName: (firstName || '').toLowerCase(),
                    lastName: (lastName || getSortableLastName(rider.name || '')).toLowerCase(),
                    name: (rider.name || '').toLowerCase()
                };
            });
            
            // Separate attending (available) and non-attending riders, then sort each group
            const attendingRiders = ridersData.filter(r => r.isAvailable);
            const nonAttendingRiders = ridersData.filter(r => !r.isAvailable);
            
            // Sort riders based on selected criteria
            const allRidersForSort = [...ridersData];
            
            allRidersForSort.sort((a, b) => {
                if (ridersSort === 'assignedGroup') {
                    // Sort by assigned group - unassigned first, then by group label
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        return a.assignedGroupId !== null ? 1 : -1; // Unassigned first
                    }
                    if (a.assignedGroupId && b.assignedGroupId) {
                        const groupCompare = (a.assignedGroupLabel || '').localeCompare(b.assignedGroupLabel || '');
                        if (groupCompare !== 0) return groupCompare;
                    }
                    return a.lastName.localeCompare(b.lastName);
                } else if (ridersSort === 'availability') {
                    // Sort by availability - available first
                    if (a.isAvailable !== b.isAvailable) {
                        return a.isAvailable ? -1 : 1;
                    }
                    // Then by assigned group
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        return a.assignedGroupId !== null ? 1 : -1;
                    }
                    return a.lastName.localeCompare(b.lastName);
                } else {
                    // For other sorts, keep existing logic but apply to all riders
                    if (ridersSort === 'pace') {
                        if (b.fitness !== a.fitness) return b.fitness - a.fitness;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'skills') {
                        if (b.skills !== a.skills) return b.skills - a.skills;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'grade') {
                        if (b.grade !== a.grade) return b.grade - a.grade;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'gender') {
                        if (a.gender !== b.gender) return a.gender.localeCompare(b.gender);
                        return a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'firstName') {
                        const firstNameCompare = a.firstName.localeCompare(b.firstName);
                        if (firstNameCompare !== 0) return firstNameCompare;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (ridersSort === 'lastName') {
                        const lastNameCompare = a.lastName.localeCompare(b.lastName);
                        if (lastNameCompare !== 0) return lastNameCompare;
                        return a.firstName.localeCompare(b.firstName);
                    } else { // fallback
                        return a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName);
                    }
                }
            });
            
            // Only separate attending/non-attending when sorting by availability
            let sortedRiders;
            if (ridersSort === 'availability') {
                // Availability sort - available first, then unavailable
                sortedRiders = allRidersForSort;
            } else {
                // For all other sorts, keep riders in their sorted order regardless of availability
                // Don't move absent riders to bottom unless sorting by availability
                sortedRiders = allRidersForSort;
            }
            
            // Render riders list
            const ridersList = document.getElementById('practice-riders-list');
            if (ridersList) {
                const riderCardsHtml = sortedRiders.map(({ rider, isAvailable, assignedGroupLabel }) => {
                    const assignmentLabel = assignedGroupLabel ? `(Group ${assignedGroupLabel.replace('Group ', '')})` : '';
                    return renderRiderCardHtml(rider, {
                        draggable: isAvailable,
                        showAttendance: true,
                        isAvailable,
                        assignmentLabel,
                        checkboxHandler: `toggleRiderAvailability(${rider.id}, this.checked)`,
                        compact: true,
                        sortBy: ridersSort
                    });
                }).join('');
                
                const totalRiders = data.riders.length;
                const attendingRidersCount = attendingRiders.length;
                
                // Create header outside scrollable area
                const ridersHeader = document.createElement('div');
                ridersHeader.style.cssText = 'background: #fff; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #e0e0e0;';
                ridersHeader.innerHTML = `
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: space-between;">
                        <h3 style="margin: 0;">Riders <span style="font-weight: normal; font-size: 14px; color: #666;">(${attendingRidersCount} of ${totalRiders})</span></h3>
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <select class="group-sort-select" onchange="changePracticeRidersSort(this.value)" title="Sort by" style="font-size: 12px; padding: 4px 8px;">
                                <option value="pace" ${ridersSort === 'pace' ? 'selected' : ''}>Sort by: Fitness</option>
                                <option value="skills" ${ridersSort === 'skills' ? 'selected' : ''}>Sort by: Bike Skills</option>
                                <option value="grade" ${ridersSort === 'grade' ? 'selected' : ''}>Sort by: Grade</option>
                                <option value="gender" ${ridersSort === 'gender' ? 'selected' : ''}>Sort by: Gender</option>
                                <option value="firstName" ${ridersSort === 'firstName' ? 'selected' : ''}>Sort by: First Name</option>
                                <option value="lastName" ${ridersSort === 'lastName' ? 'selected' : ''}>Sort by: Last Name</option>
                                <option value="assignedGroup" ${ridersSort === 'assignedGroup' ? 'selected' : ''}>Sort by: Assigned Group</option>
                                <option value="availability" ${ridersSort === 'availability' ? 'selected' : ''}>Sort by: Availability</option>
                            </select>
                            <div class="checkbox-actions">
                                <button class="btn-small" onclick="setAllPracticeRiders(true)">Select All</button>
                                <button class="btn-small secondary" onclick="setAllPracticeRiders(false)">Clear All</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create scrollable content area
                const ridersContent = document.createElement('div');
                ridersContent.className = 'rider-drop-list attendance-list';
                ridersContent.setAttribute('data-drop-type', 'rider');
                ridersContent.setAttribute('data-group-id', 'unassigned');
                ridersContent.setAttribute('ondrop', 'drop(event)');
                ridersContent.setAttribute('ondragover', 'allowDrop(event)');
                ridersContent.setAttribute('ondragleave', 'dragLeave(event)');
                ridersContent.style.cssText = 'overflow-y: auto; flex: 1; min-height: 0; border: none;';
                ridersContent.innerHTML = riderCardsHtml || '<div class="empty-message">No riders in roster.</div>';
                
                // Clear and rebuild structure
                ridersList.innerHTML = '';
                ridersList.appendChild(ridersHeader);
                ridersList.appendChild(ridersContent);
            }
            
            // Process and sort coaches - exclude N/A level coaches
            const coachesData = data.coaches
                .filter(coach => {
                    // Exclude coaches with N/A coaching level
                    const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                    return levelRaw !== 'N/A' && levelRaw !== 'N/a' && levelRaw !== 'n/a';
                })
                .map(coach => {
                const isAvailable = ride.availableCoaches.includes(coach.id);
                let assignedGroupId = null;
                let assignedGroupLabel = null;
                
                // Check if coach is assigned to any group using the assignment map
                const assignment = coachAssignmentMap[coach.id];
                if (assignment) {
                    assignedGroupId = assignment.groupId;
                    assignedGroupLabel = groupLabelMap[assignment.groupId];
                }
                
                // Extract firstName and lastName
                let firstName = coach.firstName || '';
                let lastName = coach.lastName || '';
                if (!firstName && !lastName && coach.name) {
                    const nameParts = coach.name.trim().split(' ');
                    if (nameParts.length > 1) {
                        lastName = nameParts.pop() || '';
                        firstName = nameParts.join(' ') || '';
                    } else {
                        firstName = nameParts[0] || '';
                    }
                }
                
                return {
                    coach,
                    isAvailable,
                    assignedGroupId,
                    assignedGroupLabel,
                    fitness: getCoachFitnessValue(coach),
                    level: (() => {
                        const levelRaw = coach.coachingLicenseLevel || coach.level || '1';
                        if (levelRaw === 'N/A' || levelRaw === 'N/a' || levelRaw === 'n/a') return 0;
                        return parseInt(levelRaw, 10) || 0;
                    })(),
                    firstName: (firstName || '').toLowerCase(),
                    lastName: (lastName || getSortableLastName(coach.name || '')).toLowerCase(),
                    name: (coach.name || '').toLowerCase()
                };
            });
            
            // Separate attending and non-attending coaches
            const attendingCoaches = coachesData.filter(c => c.isAvailable);
            const nonAttendingCoaches = coachesData.filter(c => !c.isAvailable);
            
            // Sort coaches based on selected criteria
            const allCoachesForSort = [...coachesData];
            
            allCoachesForSort.sort((a, b) => {
                if (coachesSort === 'assignedGroup') {
                    // Sort by assigned group - unassigned first, then by group label
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        return a.assignedGroupId !== null ? 1 : -1; // Unassigned first
                    }
                    if (a.assignedGroupId && b.assignedGroupId) {
                        const groupCompare = (a.assignedGroupLabel || '').localeCompare(b.assignedGroupLabel || '');
                        if (groupCompare !== 0) return groupCompare;
                    }
                    return a.lastName.localeCompare(b.lastName);
                } else if (coachesSort === 'availability') {
                    // Sort by availability - available first
                    if (a.isAvailable !== b.isAvailable) {
                        return a.isAvailable ? -1 : 1;
                    }
                    // Then by assigned group
                    if ((a.assignedGroupId !== null) !== (b.assignedGroupId !== null)) {
                        return a.assignedGroupId !== null ? 1 : -1;
                    }
                    return a.lastName.localeCompare(b.lastName);
                } else {
                    // For other sorts, apply to all coaches
                    if (coachesSort === 'pace') {
                        const fitnessDiff = b.fitness - a.fitness;
                        if (fitnessDiff !== 0) return fitnessDiff;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'level') {
                        // Sort by level descending (3, 2, 1), treating 0/N/A as lowest
                        const levelDiff = b.level - a.level;
                        if (levelDiff !== 0) return levelDiff;
                        // If levels are equal, sort by last name
                        return a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'firstName') {
                        const firstNameCompare = a.firstName.localeCompare(b.firstName);
                        if (firstNameCompare !== 0) return firstNameCompare;
                        return a.lastName.localeCompare(b.lastName);
                    } else if (coachesSort === 'lastName') {
                        const lastNameCompare = a.lastName.localeCompare(b.lastName);
                        if (lastNameCompare !== 0) return lastNameCompare;
                        return a.firstName.localeCompare(b.firstName);
                    } else { // fallback
                        return a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName);
                    }
                }
            });
            
            // Only separate attending/non-attending when sorting by availability
            let sortedCoaches;
            if (coachesSort === 'availability') {
                // Availability sort - available first, then unavailable
                sortedCoaches = allCoachesForSort;
            } else {
                // For all other sorts, keep coaches in their sorted order regardless of availability
                // Don't move absent coaches to bottom unless sorting by availability
                sortedCoaches = allCoachesForSort;
            }
            
            // Render coaches list
            const coachesList = document.getElementById('practice-coaches-list');
            if (coachesList) {
                const coachCardsHtml = sortedCoaches.map(({ coach, isAvailable, assignedGroupLabel }) => {
                    const assignmentLabel = assignedGroupLabel ? `(Group ${assignedGroupLabel.replace('Group ', '')})` : '';
                    return renderCoachCardHtml(coach, null, 'unassigned', {
                        draggable: isAvailable,
                        showAttendance: true,
                        isAvailable,
                        assignmentLabel,
                        checkboxHandler: `toggleCoachAvailability(${coach.id}, this.checked)`,
                        compact: true,
                        sortBy: coachesSort
                    });
                }).join('');
                
                const totalCoaches = data.coaches.length;
                const attendingCoachesCount = attendingCoaches.length;
                
                // Create header outside scrollable area
                const coachesHeader = document.createElement('div');
                coachesHeader.style.cssText = 'background: #fff; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #e0e0e0;';
                coachesHeader.innerHTML = `
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: space-between;">
                        <h3 style="margin: 0;">Coaches <span style="font-weight: normal; font-size: 14px; color: #666;">(${attendingCoachesCount} of ${totalCoaches})</span></h3>
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <select class="group-sort-select" onchange="changePracticeCoachesSort(this.value)" title="Sort by" style="font-size: 12px; padding: 4px 8px;">
                                <option value="pace" ${coachesSort === 'pace' ? 'selected' : ''}>Sort by: Fitness</option>
                                <option value="level" ${coachesSort === 'level' ? 'selected' : ''}>Sort by: Level</option>
                                <option value="firstName" ${coachesSort === 'firstName' ? 'selected' : ''}>Sort by: First Name</option>
                                <option value="lastName" ${coachesSort === 'lastName' ? 'selected' : ''}>Sort by: Last Name</option>
                                <option value="assignedGroup" ${coachesSort === 'assignedGroup' ? 'selected' : ''}>Sort by: Assigned Group</option>
                                <option value="availability" ${coachesSort === 'availability' ? 'selected' : ''}>Sort by: Availability</option>
                            </select>
                            <div class="checkbox-actions">
                                <button class="btn-small" onclick="setAllPracticeCoaches(true)">Select All</button>
                                <button class="btn-small secondary" onclick="setAllPracticeCoaches(false)">Clear All</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create scrollable content area
                const coachesContent = document.createElement('div');
                coachesContent.className = 'coach-drop-list attendance-list';
                coachesContent.setAttribute('data-drop-type', 'coach');
                coachesContent.setAttribute('data-role', 'unassigned');
                coachesContent.setAttribute('data-group-id', 'unassigned');
                coachesContent.setAttribute('ondrop', 'drop(event)');
                coachesContent.setAttribute('ondragover', 'allowDrop(event)');
                coachesContent.setAttribute('ondragleave', 'dragLeave(event)');
                coachesContent.style.cssText = 'overflow-y: auto; flex: 1; min-height: 0; border: none;';
                coachesContent.innerHTML = coachCardsHtml || '<div class="empty-message">No coaches in roster.</div>';
                
                // Clear and rebuild structure
                coachesList.innerHTML = '';
                coachesList.appendChild(coachesHeader);
                coachesList.appendChild(coachesContent);
            }
        }
        
        function toggleRiderAvailability(riderId, isAvailable) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (!Array.isArray(ride.availableRiders)) {
                ride.availableRiders = [];
            }
            
            if (isAvailable) {
                if (!ride.availableRiders.includes(riderId)) {
                    ride.availableRiders.push(riderId);
                }
            } else {
                ride.availableRiders = ride.availableRiders.filter(id => id !== riderId);
                // Remove rider from all groups if marked absent
                ride.groups.forEach(group => {
                    group.riders = group.riders.filter(id => id !== riderId);
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        function toggleCoachAvailability(coachId, isAvailable) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (!Array.isArray(ride.availableCoaches)) {
                ride.availableCoaches = [];
            }
            
            if (isAvailable) {
                if (!ride.availableCoaches.includes(coachId)) {
                    ride.availableCoaches.push(coachId);
                }
            } else {
                ride.availableCoaches = ride.availableCoaches.filter(id => id !== coachId);
                // Remove coach from all groups if marked absent
                ride.groups.forEach(group => {
                    if (group.coaches.leader === coachId) group.coaches.leader = null;
                    if (group.coaches.sweep === coachId) group.coaches.sweep = null;
                    if (group.coaches.roam === coachId) group.coaches.roam = null;
                    if (Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = group.coaches.extraRoam.filter(id => id !== coachId);
                    }
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        function changePracticeRidersSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'name', 'assignedGroup', 'availability'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace';
            }
            
            ride.practiceRidersSort = sortBy;
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }
        
        function changePracticeCoachesSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const validSorts = ['pace', 'level', 'name', 'assignedGroup', 'availability'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace';
            }
            
            ride.practiceCoachesSort = sortBy;
            saveRideToDB(ride);
            renderPracticeAttendanceLists();
        }
        
        function setAllPracticeRiders(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (selectAll) {
                ride.availableRiders = data.riders.map(r => r.id);
            } else {
                ride.availableRiders = [];
                // Remove riders from all groups if clearing all
                ride.groups.forEach(group => {
                    group.riders = [];
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        function setAllPracticeCoaches(selectAll) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (selectAll) {
                ride.availableCoaches = data.coaches.map(c => c.id);
            } else {
                ride.availableCoaches = [];
                // Remove coaches from all groups if clearing all
                ride.groups.forEach(group => {
                    if (group.coaches.leader) group.coaches.leader = null;
                    if (group.coaches.sweep) group.coaches.sweep = null;
                    if (group.coaches.roam) group.coaches.roam = null;
                    if (Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                });
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            renderPracticeAttendanceLists();
        }
        
        // Attendance frame resizing
        let attendanceResizeActive = false;
        let attendanceResizeStartY = 0;
        let attendanceResizeStartHeight = 0;
        
        function startResizeAttendance(event) {
            event.preventDefault();
            attendanceResizeActive = true;
            attendanceResizeStartY = event.clientY;
            const container = document.getElementById('practice-attendance-lists-container');
            if (container) {
                attendanceResizeStartHeight = container.offsetHeight;
            }
            
            document.addEventListener('mousemove', handleAttendanceResize);
            document.addEventListener('mouseup', stopResizeAttendance);
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
        }
        
        function handleAttendanceResize(event) {
            if (!attendanceResizeActive) return;
            
            const deltaY = event.clientY - attendanceResizeStartY;
            const container = document.getElementById('practice-attendance-lists-container');
            if (container) {
                const newHeight = Math.max(200, Math.min(800, attendanceResizeStartHeight + deltaY));
                container.style.height = newHeight + 'px';
            }
        }
        
        function stopResizeAttendance() {
            attendanceResizeActive = false;
            document.removeEventListener('mousemove', handleAttendanceResize);
            document.removeEventListener('mouseup', stopResizeAttendance);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        function updateGroupRoute(groupId, routeId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const group = ride.groups.find(g => String(g.id) === String(groupId));
            if (!group) return;
            
            group.routeId = routeId || null;
            saveRideToDB(ride);
        }

        function renderRouteOptions(selectedRouteId) {
            const routes = data.routes || [];
            if (routes.length === 0) {
                return '<option value="">No routes available</option>';
            }
            
            return routes.map(route => {
                const selected = selectedRouteId && String(route.id) === String(selectedRouteId) ? 'selected' : '';
                let routeText = escapeHtml(route.name || 'Unnamed Route');
                
                // Add distance, elevation, and time if available
                const details = [];
                if (route.distance) details.push(route.distance);
                if (route.elevation) details.push(route.elevation);
                if (route.estimatedTime) details.push(route.estimatedTime);
                if (details.length > 0) {
                    routeText += ` (${details.join(' / ')})`;
                }
                
                return `<option value="${route.id}" ${selected}>${routeText}</option>`;
            }).join('');
        }

        function switchUnassignedView(view) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (view !== 'riders' && view !== 'coaches') {
                view = 'riders'; // Default to riders if invalid
            }
            
            ride.unassignedView = view;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function updateDebugOutput() {
            const debugEl = document.getElementById('auto-assign-debug');
            const copyBtn = document.getElementById('copy-debug-btn');
            if (!debugEl) return;
            if (autoAssignDebugLog) {
                debugEl.style.display = 'block';
                debugEl.textContent = autoAssignDebugLog;
                if (copyBtn) copyBtn.style.display = 'block';
            } else {
                debugEl.style.display = 'none';
                debugEl.textContent = '';
                if (copyBtn) copyBtn.style.display = 'none';
            }
        }
        
        function copyDebugToClipboard() {
            if (!autoAssignDebugLog) return;
            navigator.clipboard.writeText(autoAssignDebugLog).then(() => {
                const btn = document.getElementById('copy-debug-btn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        }

        function addGroup() {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            // Find next available group number
            const existingLabels = ride.groups.map(g => g.label).filter(Boolean);
            let nextNumber = 1;
            while (existingLabels.includes(`Group ${nextNumber}`)) {
                nextNumber++;
            }
            const group = createGroup(`Group ${nextNumber}`);
            ride.groups.push(group);
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeGroupSort(groupId, sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            group.sortBy = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeUnassignedRidersSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'skills', 'grade', 'gender', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            ride.unassignedRidersSort = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function changeUnassignedCoachesSort(sortBy) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            // Validate sortBy value
            const validSorts = ['pace', 'level', 'name'];
            if (!validSorts.includes(sortBy)) {
                sortBy = 'pace'; // Default to pace if invalid
            }
            
            ride.unassignedCoachesSort = sortBy;
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function deleteGroup(groupId) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            const numericId = parseInt(groupId, 10);
            if (!Number.isFinite(numericId)) return;

            const group = findGroupById(ride, numericId);
            if (!group) return;

            if (!confirm('Delete this group? Riders will move back to the unassigned list.')) {
                return;
            }

            ride.groups = ride.groups.filter(g => g.id !== numericId);
            // Don't renumber - keep other group names persistent
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        // Drag and drop functions
        function allowDrop(ev) {
            let payload;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('application/json') || '{}');
            } catch (err) {
                payload = {};
            }
            const expectedType = ev.currentTarget.dataset.dropType;
            if (expectedType && payload.type && expectedType !== payload.type) {
                return;
            }
            ev.preventDefault();
            
            // Highlight drop target
            const target = ev.currentTarget;
            if (target.classList.contains('coach-inline-item')) {
                // Highlighting a coach name
                target.style.background = '#e3f2fd';
                target.style.border = '2px solid #1976d2';
            } else if (target.classList.contains('coach-drop-zone')) {
                // Highlighting space between coaches
                target.style.background = '#e3f2fd';
                target.style.height = '8px';
                target.style.margin = '4px 0';
            }
            target.classList.add('drag-over');
        }

        function dragLeave(ev) {
            const target = ev.currentTarget;
            target.classList.remove('drag-over');
            
            // Remove highlight
            if (target.classList.contains('coach-inline-item')) {
                const index = parseInt(target.dataset.insertPosition || '0', 10);
                target.style.background = index % 2 === 0 ? '#f9f9f9' : '#fff';
                target.style.border = 'none';
            } else if (target.classList.contains('coach-drop-zone')) {
                target.style.background = 'transparent';
                target.style.height = '2px';
                target.style.margin = '2px 0';
            }
        }

        function drag(ev) {
            const type = ev.target.dataset.dragType;
            if (!type) return;

            const payload = { type };
            if (type === 'rider') {
                payload.riderId = parseInt(ev.target.dataset.riderId, 10);
            } else if (type === 'coach') {
                payload.coachId = parseInt(ev.target.dataset.coachId, 10);
                if (ev.target.dataset.sourceGroupId) {
                    payload.sourceGroupId = ev.target.dataset.sourceGroupId;
                }
                if (ev.target.dataset.sourceRole) {
                    payload.sourceRole = ev.target.dataset.sourceRole;
                }
            } else {
                return;
            }

            ev.dataTransfer.setData('application/json', JSON.stringify(payload));
            ev.target.classList.add('dragging');
        }

        function dragEnd(ev) {
            ev.target.classList.remove('dragging');
        }

        function drop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.remove('drag-over');
            
            let payload = null;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('application/json'));
            } catch (err) {
                payload = null;
            }
            if (!payload || !payload.type) return;
            
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;
            
            if (payload.type === 'rider') {
                handleRiderDrop(ride, payload, ev.currentTarget);
            } else if (payload.type === 'coach') {
                handleCoachDrop(ride, payload, ev.currentTarget, ev);
            }

            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        }

        function handleRiderDrop(ride, payload, dropTarget) {
            const riderId = parseInt(payload.riderId, 10);
            if (!Number.isFinite(riderId)) return;

            const dropType = dropTarget.dataset.dropType;
            if (dropType && dropType !== 'rider') return;

            const targetGroupId = dropTarget.dataset.groupId;
            let previousGroupId = null;

            ride.groups.forEach(group => {
                if (group.riders.includes(riderId)) {
                    previousGroupId = group.id;
                }
            });

            removeRiderFromGroups(ride, riderId);

            if (targetGroupId !== 'unassigned') {
                const numericGroupId = parseInt(targetGroupId, 10);
                const group = findGroupById(ride, numericGroupId);
                if (!group) {
                    if (previousGroupId !== null) {
                        const previousGroup = findGroupById(ride, previousGroupId);
                        if (previousGroup) {
                            previousGroup.riders.push(riderId);
                        }
                    }
                    renderAssignments(ride);
                    return;
                }

                const coachCount = countGroupCoaches(group);
                if (coachCount === 0) {
                    alert('Assign at least one coach before adding riders to this group.');
                    if (previousGroupId !== null) {
                        const previousGroup = findGroupById(ride, previousGroupId);
                        if (previousGroup) {
                            previousGroup.riders.push(riderId);
                        }
                    }
                    renderAssignments(ride);
                    return;
                }

                const capacity = groupCapacity(group);
                if (group.riders.length >= capacity) {
                    alert(`This group is at capacity (${capacity} riders).`);
                    if (previousGroupId !== null) {
                        const previousGroup = findGroupById(ride, previousGroupId);
                        if (previousGroup) {
                            previousGroup.riders.push(riderId);
                        }
                    }
                    renderAssignments(ride);
                    return;
                }

                if (!group.riders.includes(riderId)) {
                    group.riders.push(riderId);
                    const rider = getRiderById(riderId);
                    if (!group.fitnessTag && rider) {
                        group.fitnessTag = rider.fitness || null;
                    }
                }
            }
            
            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        let pendingCoachMove = null;
        
        function showCoachMoveMenu(event, coachId, groupId, rideId) {
            const menu = document.getElementById('coach-move-context-menu');
            if (!menu) return;
            
            const ride = data.rides.find(r => r.id === rideId);
            if (!ride) return;
            
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            const currentRole = getCoachRoleInGroup(group, coachId);
            if (!currentRole) return;
            
            // Store move info
            pendingCoachMove = { ride, coachId, groupId, rideId };
            
            // Build role options (other roles in current group)
            const roleOptionsDiv = document.getElementById('coach-move-role-options');
            roleOptionsDiv.innerHTML = '';
            
            const roles = ['leader', 'sweep', 'roam'];
            roles.forEach(role => {
                if (role !== currentRole && role !== 'extraRoam') {
                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                    const hasCoach = role === 'leader' ? group.coaches.leader : role === 'sweep' ? group.coaches.sweep : group.coaches.roam;
                    
                    // Check if coach can be leader (Level 2/3 only)
                    const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                    if (role === 'leader' && (!Number.isFinite(level) || level < 2)) {
                        return; // Skip leader option if not eligible
                    }
                    
                    const button = document.createElement('button');
                    button.className = 'context-menu-item';
                    button.style.cssText = 'width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;';
                    button.textContent = hasCoach ? `Swap with ${roleLabel}` : `Move to ${roleLabel}`;
                    button.onclick = () => {
                        moveCoachToRole(ride, coachId, groupId, role);
                        menu.style.display = 'none';
                        pendingCoachMove = null;
                    };
                    roleOptionsDiv.appendChild(button);
                }
            });
            
            // Build group options (other groups)
            const groupOptionsDiv = document.getElementById('coach-move-group-options');
            groupOptionsDiv.innerHTML = '';
            
            ride.groups.forEach(otherGroup => {
                if (otherGroup.id !== groupId) {
                    const button = document.createElement('button');
                    button.className = 'context-menu-item';
                    button.style.cssText = 'width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; font-size: 14px; color: #333;';
                    const groupLabel = otherGroup.label || `Group ${otherGroup.id}`;
                    button.textContent = `Move to ${groupLabel}`;
                    button.onclick = () => {
                        moveCoachToGroup(ride, coachId, groupId, otherGroup.id);
                        menu.style.display = 'none';
                        pendingCoachMove = null;
                    };
                    groupOptionsDiv.appendChild(button);
                }
            });
            
            // Position menu at button location
            menu.style.display = 'block';
            const rect = event.target.getBoundingClientRect();
            menu.style.left = `${rect.right + 5}px`;
            menu.style.top = `${rect.top}px`;
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && e.target !== event.target) {
                    menu.style.display = 'none';
                    pendingCoachMove = null;
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }
        
        function moveCoachToRole(ride, coachId, groupId, targetRole) {
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            // Check Level 2/3 requirement for leader
            if (targetRole === 'leader') {
                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                if (!Number.isFinite(level) || level < 2) {
                    alert('Only Level 2 or Level 3 coaches can serve as leader.');
                    return;
                }
            }
            
            const currentRole = getCoachRoleInGroup(group, coachId);
            if (!currentRole) return;
            
            // Get the coach currently in the target role
            let targetCoachId = null;
            if (targetRole === 'leader') targetCoachId = group.coaches.leader;
            else if (targetRole === 'sweep') targetCoachId = group.coaches.sweep;
            else if (targetRole === 'roam') targetCoachId = group.coaches.roam;
            
            // Swap roles
            if (targetCoachId) {
                // Clear both roles
                if (currentRole === 'leader') group.coaches.leader = null;
                else if (currentRole === 'sweep') group.coaches.sweep = null;
                else if (currentRole === 'roam') group.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(group.coaches.extraRoam)) {
                    const index = group.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                }
                
                // Assign coaches to new roles
                if (targetRole === 'leader') group.coaches.leader = coachId;
                else if (targetRole === 'sweep') group.coaches.sweep = coachId;
                else if (targetRole === 'roam') group.coaches.roam = coachId;
                
                // Assign target coach to current role
                if (currentRole === 'leader') group.coaches.leader = targetCoachId;
                else if (currentRole === 'sweep') group.coaches.sweep = targetCoachId;
                else if (currentRole === 'roam') group.coaches.roam = targetCoachId;
                else if (currentRole === 'extraRoam') {
                    if (!Array.isArray(group.coaches.extraRoam)) group.coaches.extraRoam = [];
                    group.coaches.extraRoam.push(targetCoachId);
                }
            } else {
                // Target role is empty, just move coach
                if (currentRole === 'leader') group.coaches.leader = null;
                else if (currentRole === 'sweep') group.coaches.sweep = null;
                else if (currentRole === 'roam') group.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(group.coaches.extraRoam)) {
                    const index = group.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) group.coaches.extraRoam.splice(index, 1);
                }
                
                if (targetRole === 'leader') group.coaches.leader = coachId;
                else if (targetRole === 'sweep') group.coaches.sweep = coachId;
                else if (targetRole === 'roam') group.coaches.roam = coachId;
            }
            
            const capacity = groupCapacity(group);
            if (capacity < group.riders.length) {
                group.riders = group.riders.slice(0, capacity);
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function moveCoachToGroup(ride, coachId, sourceGroupId, targetGroupId) {
            const sourceGroup = findGroupById(ride, sourceGroupId);
            const targetGroup = findGroupById(ride, targetGroupId);
            if (!sourceGroup || !targetGroup) return;
            
            const coach = getCoachById(coachId);
            if (!coach) return;
            
            // Remove coach from source group
            const currentRole = getCoachRoleInGroup(sourceGroup, coachId);
            if (currentRole) {
                if (currentRole === 'leader') sourceGroup.coaches.leader = null;
                else if (currentRole === 'sweep') sourceGroup.coaches.sweep = null;
                else if (currentRole === 'roam') sourceGroup.coaches.roam = null;
                else if (currentRole === 'extraRoam' && Array.isArray(sourceGroup.coaches.extraRoam)) {
                    const index = sourceGroup.coaches.extraRoam.indexOf(coachId);
                    if (index >= 0) sourceGroup.coaches.extraRoam.splice(index, 1);
                }
            }
            
            // Ensure coach is available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            
            // Add to target group at next available position
            if (!targetGroup.coaches.leader) {
                const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                if (Number.isFinite(level) && level >= 2) {
                    targetGroup.coaches.leader = coachId;
                } else {
                    targetGroup.coaches.sweep = coachId;
                }
            } else if (!targetGroup.coaches.sweep) {
                targetGroup.coaches.sweep = coachId;
            } else if (!targetGroup.coaches.roam) {
                targetGroup.coaches.roam = coachId;
            } else {
                if (!Array.isArray(targetGroup.coaches.extraRoam)) {
                    targetGroup.coaches.extraRoam = [];
                }
                targetGroup.coaches.extraRoam.push(coachId);
            }
            
            const capacity = groupCapacity(targetGroup);
            if (capacity < targetGroup.riders.length) {
                targetGroup.riders = targetGroup.riders.slice(0, capacity);
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function showCoachDropContextMenu(event, ride, coachId, groupId, targetCoachId = null) {
            const menu = document.getElementById('coach-drop-context-menu');
            if (!menu) return;
            
            // Store drop info for context menu actions
            pendingCoachDrop = { ride, coachId, groupId, targetCoachId };
            
            // Position menu at drop location
            menu.style.display = 'block';
            menu.style.left = `${event.clientX}px`;
            menu.style.top = `${event.clientY}px`;
            
            // Remove existing event listeners by cloning
            const addBtn = document.getElementById('coach-drop-add');
            const swapBtn = document.getElementById('coach-drop-swap');
            
            const newAddBtn = addBtn.cloneNode(true);
            const newSwapBtn = swapBtn.cloneNode(true);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);
            swapBtn.parentNode.replaceChild(newSwapBtn, swapBtn);
            
            // Update button text if dropping on specific coach
            if (targetCoachId) {
                const targetCoach = getCoachById(targetCoachId);
                newSwapBtn.textContent = targetCoach ? `Swap with ${targetCoach.name}` : 'Swap with Coach';
                newAddBtn.textContent = 'Add Coach to Group';
            } else {
                newSwapBtn.textContent = 'Swap with Coach';
                newAddBtn.textContent = 'Add Coach to Group';
            }
            
            // Add new event listeners
            newAddBtn.addEventListener('click', handleCoachDropAdd);
            newSwapBtn.addEventListener('click', handleCoachDropSwap);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.style.display = 'none';
                    pendingCoachDrop = null;
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }
        
        function handleCoachDropAdd() {
            if (!pendingCoachDrop) return;
            const { ride, coachId, groupId } = pendingCoachDrop;
            const menu = document.getElementById('coach-drop-context-menu');
            if (menu) menu.style.display = 'none';
            
            const group = findGroupById(ride, groupId);
            if (!group) {
                pendingCoachDrop = null;
                return;
            }
            
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            addCoachToGroup(ride, coachId, groupId);
            
            const capacity = groupCapacity(group);
            if (capacity < group.riders.length) {
                group.riders = group.riders.slice(0, capacity);
            }
            
            saveRideToDB(ride);
            renderAssignments(ride);
            pendingCoachDrop = null;
        }
        
        function handleCoachDropSwap() {
            if (!pendingCoachDrop) return;
            const { ride, coachId, groupId, targetCoachId } = pendingCoachDrop;
            const menu = document.getElementById('coach-drop-context-menu');
            if (menu) menu.style.display = 'none';
            
            if (targetCoachId) {
                // Direct swap with specific coach
                swapCoachWithTarget(ride, coachId, groupId, targetCoachId);
                const group = findGroupById(ride, groupId);
                if (group) {
                    const capacity = groupCapacity(group);
                    if (capacity < group.riders.length) {
                        group.riders = group.riders.slice(0, capacity);
                    }
                }
                saveRideToDB(ride);
                renderAssignments(ride);
            } else {
                // For swap when dropping on group container, show selection dialog
                swapCoachInGroup(ride, coachId, groupId);
            }
            pendingCoachDrop = null;
        }
        
        function insertCoachAtPosition(ride, coachId, groupId, position) {
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Remove coach from any other groups first
            removeCoachFromGroups(ride, coachId);
            
            // Get current coaches in order
            const coachesOrder = [];
            if (group.coaches.leader) coachesOrder.push({ id: group.coaches.leader, role: 'leader' });
            if (group.coaches.sweep) coachesOrder.push({ id: group.coaches.sweep, role: 'sweep' });
            if (group.coaches.roam) coachesOrder.push({ id: group.coaches.roam, role: 'roam' });
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) coachesOrder.push({ id, role: 'extraRoam' });
                });
            }
            
            // Insert at position
            coachesOrder.splice(position, 0, { id: coachId, role: null });
            
            // Clear all roles
            group.coaches.leader = null;
            group.coaches.sweep = null;
            group.coaches.roam = null;
            group.coaches.extraRoam = [];
            
            // Reassign roles based on new order: Leader, Sweep, Roam, then Roam for rest
            coachesOrder.forEach((coach, index) => {
                const coachObj = getCoachById(coach.id);
                if (!coachObj) return;
                
                if (index === 0) {
                    // First position = Leader (only if Level 2/3)
                    const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                    if (Number.isFinite(level) && level >= 2) {
                        group.coaches.leader = coach.id;
                    } else {
                        // Not eligible for leader, assign as sweep
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 1) {
                    // Second position = Sweep (or Leader if first wasn't eligible)
                    if (!group.coaches.leader) {
                        const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                        if (Number.isFinite(level) && level >= 2) {
                            group.coaches.leader = coach.id;
                        } else {
                            group.coaches.sweep = coach.id;
                        }
                    } else {
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 2) {
                    // Third position = Roam
                    group.coaches.roam = coach.id;
                } else {
                    // Additional coaches = Roam (in extraRoam array)
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam.push(coach.id);
                }
            });
        }
        
        function swapCoachWithTarget(ride, coachId, groupId, targetCoachId) {
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Get the role of the target coach (the one being dropped on)
            const targetRole = getCoachRoleInGroup(group, targetCoachId);
            if (!targetRole) {
                // Target coach not in this group, just add the dragged coach
                if (!ride.availableCoaches.includes(coachId)) {
                    ride.availableCoaches.push(coachId);
                }
                addCoachToGroup(ride, coachId, groupId);
                return;
            }
            
            // Find the dragged coach's current role and group
            let draggedCoachRole = null;
            let draggedCoachGroupId = null;
            ride.groups.forEach(g => {
                const role = getCoachRoleInGroup(g, coachId);
                if (role) {
                    draggedCoachRole = role;
                    draggedCoachGroupId = g.id;
                }
            });
            
            // Ensure both coaches are available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            if (!ride.availableCoaches.includes(targetCoachId)) {
                ride.availableCoaches.push(targetCoachId);
            }
            
            // First, assign dragged coach to target's role (before clearing target)
            if (targetRole === 'extraRoam') {
                if (!Array.isArray(group.coaches.extraRoam)) {
                    group.coaches.extraRoam = [];
                }
                // Remove target from extraRoam first
                const targetIndex = group.coaches.extraRoam.indexOf(targetCoachId);
                if (targetIndex >= 0) {
                    group.coaches.extraRoam.splice(targetIndex, 1);
                }
                // Add dragged coach
                group.coaches.extraRoam.push(coachId);
            } else {
                // Store target's role temporarily
                // Assign dragged coach to target's role
                group.coaches[targetRole] = coachId;
            }
            
            // Now handle the target coach - assign it to dragged coach's old role
            if (draggedCoachRole) {
                if (draggedCoachGroupId === groupId) {
                    // Both coaches in same group - assign target to dragged coach's old role
                    if (draggedCoachRole === 'extraRoam') {
                        if (!Array.isArray(group.coaches.extraRoam)) {
                            group.coaches.extraRoam = [];
                        }
                        // Remove dragged coach from extraRoam (it's already been moved to targetRole)
                        const draggedIndex = group.coaches.extraRoam.indexOf(coachId);
                        if (draggedIndex >= 0) {
                            group.coaches.extraRoam.splice(draggedIndex, 1);
                        }
                        // Add target to extraRoam
                        group.coaches.extraRoam.push(targetCoachId);
                    } else {
                        // Dragged coach was in a different role, assign target to that role
                        group.coaches[draggedCoachRole] = targetCoachId;
                    }
                } else {
                    // Dragged coach was in different group - assign target to that group/role
                    const sourceGroup = findGroupById(ride, draggedCoachGroupId);
                    if (sourceGroup) {
                        // Remove dragged coach from source group
                        if (draggedCoachRole === 'extraRoam') {
                            if (Array.isArray(sourceGroup.coaches.extraRoam)) {
                                const index = sourceGroup.coaches.extraRoam.indexOf(coachId);
                                if (index >= 0) {
                                    sourceGroup.coaches.extraRoam.splice(index, 1);
                                }
                            }
                        } else {
                            sourceGroup.coaches[draggedCoachRole] = null;
                        }
                        // Assign target to source group
                        if (draggedCoachRole === 'extraRoam') {
                            if (!Array.isArray(sourceGroup.coaches.extraRoam)) {
                                sourceGroup.coaches.extraRoam = [];
                            }
                            sourceGroup.coaches.extraRoam.push(targetCoachId);
                        } else {
                            sourceGroup.coaches[draggedCoachRole] = targetCoachId;
                        }
                    }
                }
            } else {
                // Dragged coach had no role - target becomes unassigned (already cleared above when we assigned dragged coach)
            }
        }

        function handleCoachDrop(ride, payload, dropTarget, ev) {
            const coachId = parseInt(payload.coachId, 10);
            if (!Number.isFinite(coachId)) return;

            const dropType = dropTarget.dataset.dropType;
            if (dropType && dropType !== 'coach') return;

            // Only handle drops from attendance lists to group role slots
            // Coaches within groups should use Move buttons, not drag-and-drop
            const targetRole = dropTarget.dataset.role || 'unassigned';
            const targetGroupIdAttr = dropTarget.dataset.groupId;

            const coach = getCoachById(coachId);
            if (!coach) {
                alert('Selected coach no longer exists.');
                renderAssignments(ride);
                return;
            }

            if (targetRole === 'unassigned') {
                removeCoachFromGroups(ride, coachId);
                saveRideToDB(ride);
                renderAssignments(ride);
                return;
            }

            const numericGroupId = parseInt(targetGroupIdAttr, 10);
            if (!Number.isFinite(numericGroupId)) return;

            const group = findGroupById(ride, numericGroupId);
            if (!group) return;

            // Only allow drops to specific role slots (from attendance list)
            if (!targetRole || targetRole === 'unassigned') {
                return; // Ignore drops on group containers - use Move button instead
            }

            const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
            if (targetRole === 'leader' && (!Number.isFinite(level) || level < 2)) {
                alert('Only Level 2 or Level 3 coaches can serve as leader.');
                renderAssignments(ride);
                return;
            }

            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }

            assignCoachToGroup(ride, coachId, numericGroupId, targetRole);

            const capacity = groupCapacity(group);
            if (capacity < group.riders.length) {
                group.riders = group.riders.slice(0, capacity);
            }

            saveRideToDB(ride);
            renderAssignments(ride);
        }
        
        function getCoachRoleInGroup(group, coachId) {
            if (group.coaches.leader === coachId) return 'leader';
            if (group.coaches.sweep === coachId) return 'sweep';
            if (group.coaches.roam === coachId) return 'roam';
            if (Array.isArray(group.coaches.extraRoam) && group.coaches.extraRoam.includes(coachId)) return 'extraRoam';
            return null;
        }
        
        function addCoachToGroup(ride, coachId, groupId) {
            const group = findGroupById(ride, groupId);
            if (!group) return false;
            
            // Remove coach from any other groups first
            removeCoachFromGroups(ride, coachId);
            
            // Ensure coach is marked as available
            if (!ride.availableCoaches.includes(coachId)) {
                ride.availableCoaches.push(coachId);
            }
            
            // Add to first available role: leader, sweep, roam, then extraRoam
            if (!group.coaches.leader) {
                const coach = getCoachById(coachId);
                if (coach) {
                    const level = parseInt(coach.coachingLicenseLevel || coach.level || '1', 10);
                    if (Number.isFinite(level) && level >= 2) {
                        group.coaches.leader = coachId;
                        return true;
                    }
                }
            }
            if (!group.coaches.sweep) {
                group.coaches.sweep = coachId;
                return true;
            }
            if (!group.coaches.roam) {
                group.coaches.roam = coachId;
                return true;
            }
            // Add to extraRoam
            if (!Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam = [];
            }
            if (!group.coaches.extraRoam.includes(coachId)) {
                group.coaches.extraRoam.push(coachId);
                return true;
            }
            return false;
        }
        
        function swapCoachInGroup(ride, coachId, groupId) {
            const group = findGroupById(ride, groupId);
            if (!group) return;
            
            // Get list of coaches in group
            const coachesInGroup = [];
            if (group.coaches.leader) {
                const coach = getCoachById(group.coaches.leader);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'leader' });
            }
            if (group.coaches.sweep) {
                const coach = getCoachById(group.coaches.sweep);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'sweep' });
            }
            if (group.coaches.roam) {
                const coach = getCoachById(group.coaches.roam);
                if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'roam' });
            }
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) {
                        const coach = getCoachById(id);
                        if (coach) coachesInGroup.push({ id: coach.id, name: coach.name, role: 'extraRoam' });
                    }
                });
            }
            
            if (coachesInGroup.length === 0) {
                addCoachToGroup(ride, coachId, groupId);
                return;
            }
            
            // Show selection dialog
            const coachList = coachesInGroup.map((c, i) => `${i + 1}. ${c.name}`).join('\n');
            const selection = prompt(`Select coach to swap with (1-${coachesInGroup.length}):\n\n${coachList}`);
            const selectedIndex = parseInt(selection, 10) - 1;
            
            if (selectedIndex >= 0 && selectedIndex < coachesInGroup.length) {
                const targetCoach = coachesInGroup[selectedIndex];
                const targetRole = targetCoach.role;
                
                // Swap the coaches
                assignCoachToGroup(ride, coachId, groupId, targetRole);
            }
        }
        
        function reorderCoachesInGroup(ride, group, draggedCoachId, targetCoachId) {
            // Get current order of coaches
            const coachesOrder = [];
            if (group.coaches.leader) coachesOrder.push({ id: group.coaches.leader, role: 'leader' });
            if (group.coaches.sweep) coachesOrder.push({ id: group.coaches.sweep, role: 'sweep' });
            if (group.coaches.roam) coachesOrder.push({ id: group.coaches.roam, role: 'roam' });
            if (Array.isArray(group.coaches.extraRoam)) {
                group.coaches.extraRoam.forEach(id => {
                    if (id) coachesOrder.push({ id, role: 'extraRoam' });
                });
            }
            
            // Find indices
            const draggedIndex = coachesOrder.findIndex(c => c.id === draggedCoachId);
            const targetIndex = coachesOrder.findIndex(c => c.id === targetCoachId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove dragged coach from its position
            const draggedCoach = coachesOrder.splice(draggedIndex, 1)[0];
            
            // Insert at target position
            const newIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
            coachesOrder.splice(newIndex, 0, draggedCoach);
            
            // Clear all roles
            group.coaches.leader = null;
            group.coaches.sweep = null;
            group.coaches.roam = null;
            group.coaches.extraRoam = [];
            
            // Reassign roles based on new order: Leader, Sweep, Roam, then Roam for rest
            coachesOrder.forEach((coach, index) => {
                const coachObj = getCoachById(coach.id);
                if (!coachObj) return;
                
                if (index === 0) {
                    // First position = Leader (only if Level 2/3)
                    const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                    if (Number.isFinite(level) && level >= 2) {
                        group.coaches.leader = coach.id;
                    } else {
                        // Not eligible for leader, assign as sweep
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 1) {
                    // Second position = Sweep (or Leader if first wasn't eligible)
                    if (!group.coaches.leader) {
                        const level = parseInt(coachObj.coachingLicenseLevel || coachObj.level || '1', 10);
                        if (Number.isFinite(level) && level >= 2) {
                            group.coaches.leader = coach.id;
                        } else {
                            group.coaches.sweep = coach.id;
                        }
                    } else {
                        group.coaches.sweep = coach.id;
                    }
                } else if (index === 2) {
                    // Third position = Roam
                    group.coaches.roam = coach.id;
                } else {
                    // Additional coaches = Roam (in extraRoam array)
                    if (!Array.isArray(group.coaches.extraRoam)) {
                        group.coaches.extraRoam = [];
                    }
                    group.coaches.extraRoam.push(coach.id);
                }
            });
        }

        function moveRiderBetweenGroups(currentGroupId, riderId, direction) {
            const ride = data.rides.find(r => r.id === data.currentRide);
            if (!ride) return;

            const currentGroup = findGroupById(ride, currentGroupId);
            if (!currentGroup) return;

            // Verify rider is in current group
            if (!currentGroup.riders.includes(riderId)) return;

            // Groups are sorted by fitness score (descending) in renderAssignments
            // So Group 1 is fastest, Group 2 is next fastest, etc.
            // direction -1 = move to previous group (faster/higher fitness) - UP arrow
            // direction 1 = move to next group (slower/lower fitness) - DOWN arrow
            
            // Get groups sorted by fitness (same order as displayed)
            const sortedGroups = ride.groups.slice().sort((a, b) => {
                const fitnessA = getGroupFitnessScore(a);
                const fitnessB = getGroupFitnessScore(b);
                if (fitnessB !== fitnessA) return fitnessB - fitnessA;
                return b.riders.length - a.riders.length;
            });

            // Find current group's index in sorted array
            const currentGroupIndex = sortedGroups.findIndex(g => g.id === currentGroupId);
            if (currentGroupIndex === -1) return;

            // Calculate target group index
            const targetGroupIndex = currentGroupIndex + direction;
            if (targetGroupIndex < 0 || targetGroupIndex >= sortedGroups.length) {
                // Cannot move - already at first or last group
                return;
            }

            const targetGroup = sortedGroups[targetGroupIndex];
            if (!targetGroup) return;

            // Check target group capacity
            const coachCount = countGroupCoaches(targetGroup);
            if (coachCount === 0) {
                alert('Target group must have at least one coach assigned before moving riders to it.');
                renderAssignments(ride);
                return;
            }

            const capacity = groupCapacity(targetGroup);
            if (targetGroup.riders.length >= capacity) {
                alert(`Target group is at capacity (${capacity} riders). Cannot add more riders.`);
                renderAssignments(ride);
                return;
            }

            // Remove rider from current group
            currentGroup.riders = currentGroup.riders.filter(id => id !== riderId);

            // Add rider to target group
            if (!targetGroup.riders.includes(riderId)) {
                targetGroup.riders.push(riderId);
            }

            // Validate requirements for both groups after move
            const currentWarnings = validateGroupRequirements(currentGroup, ride);
            const targetWarnings = validateGroupRequirements(targetGroup, ride);
            const allWarnings = [...currentWarnings, ...targetWarnings];

            if (allWarnings.length > 0) {
                const warningMsg = allWarnings.join('\n');
                alert(`Warning: Moving this rider may violate requirements:\n\n${warningMsg}\n\nThe move has been made, but please review the groups.`);
            }

            // Save immediately to localStorage
            saveRideToDB(ride);
            renderAssignments(ride);
        }

        function validateGroupRequirements(group, ride) {
            const warnings = [];
            const coachCount = countGroupCoaches(group);
            const capacity = groupCapacity(group);

            // Check minimum leader level requirement
            if (group.coaches.leader) {
                const leader = getCoachById(group.coaches.leader);
                if (leader) {
                    const leaderLevel = parseInt(leader.level, 10);
                    const minLeaderLevel = getAutoAssignSetting('minLeaderLevel', 2);
                    if (!Number.isFinite(leaderLevel) || leaderLevel < minLeaderLevel) {
                        warnings.push(`Leader must be Level ${minLeaderLevel} or higher (current: Level ${leaderLevel || 1})`);
                    }
                }
            } else {
                warnings.push('Group must have a leader assigned');
            }

            // Check riders per coach requirement
            const ridersPerCoach = getAutoAssignSetting('ridersPerCoach', 6);
            if (coachCount > 0 && group.riders.length > capacity) {
                warnings.push(`Group exceeds capacity: ${group.riders.length} riders with ${coachCount} coach(es) (capacity: ${capacity} = ${coachCount} √ó ${ridersPerCoach})`);
            }

            // Check minimum group size
            const minGroupSize = getAutoAssignSetting('minGroupSize', 4);
            if (group.riders.length < minGroupSize) {
                warnings.push(`Group below minimum size: ${group.riders.length} riders (minimum: ${minGroupSize})`);
            }

            // Check maximum group size
            const maxGroupSize = getAutoAssignSetting('maxGroupSize', 10);
            if (group.riders.length > maxGroupSize) {
                warnings.push(`Group exceeds maximum size: ${group.riders.length} riders (maximum: ${maxGroupSize})`);
            }

            return warnings;
        }

        // ============ RIDE ASSIGNMENTS (MOBILE-FRIENDLY) ============

        function getNextUpcomingRide() {
            const now = new Date();
            now.setHours(0, 0, 0, 0);
            
            // Get all non-cancelled rides with dates
            const upcomingRides = (data.rides || [])
                .filter(ride => {
                    if (ride.cancelled) return false;
                    if (!ride.date) return false;
                    const rideDate = parseISODate(ride.date);
                    if (!rideDate) return false;
                    rideDate.setHours(0, 0, 0, 0);
                    return rideDate >= now;
                })
                .map(ride => ({
                    ride,
                    date: parseISODate(ride.date)
                }))
                .filter(item => item.date !== null)
                .sort((a, b) => a.date - b.date);
            
            return upcomingRides.length > 0 ? upcomingRides[0].ride : null;
        }

        function getRouteById(routeId) {
            if (!routeId) return null;
            return (data.routes || []).find(route => String(route.id) === String(routeId)) || null;
        }

        function renderRideAssignments() {
            const container = document.getElementById('ride-assignments-container');
            if (!container) return;

            const ride = getNextUpcomingRide();
            
            if (!ride) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 18px; margin-bottom: 8px;">No upcoming ride scheduled</p>
                        <p style="font-size: 14px;">Check the Practice Planner to add practices.</p>
                    </div>
                `;
                return;
            }

            const rideDate = parseISODate(ride.date);
            const dateDisplay = rideDate ? rideDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) : ride.date;
            const goals = (ride.goals || '').trim();
            
            // Always show goals at the top (visible regardless of which groups are opened)
            let html = `
                <div style="margin-bottom: 24px;">
                    <h2 style="margin: 0 0 8px 0; font-size: 20px; color: #333;">${escapeHtml(dateDisplay)}</h2>
                    ${goals ? `<div style="padding: 12px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 4px; margin-bottom: 16px;">
                        <strong style="display: block; margin-bottom: 4px; color: #1976D2;">Practice Goals:</strong>
                        <span style="color: #555;">${escapeHtml(goals)}</span>
                    </div>` : ''}
                </div>
            `;

            if (!Array.isArray(ride.groups) || ride.groups.length === 0) {
                html += `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <p style="font-size: 16px;">No groups assigned yet</p>
                        <p style="font-size: 14px; margin-top: 8px;">Go to Practice Planner to assign riders and coaches.</p>
                    </div>
                `;
            } else {
                html += '<div class="mobile-assignment-groups">';
                
                ride.groups.forEach((group, index) => {
                    const groupId = `group-${group.id || index}`;
                    const leader = group.coaches?.leader ? getCoachById(group.coaches.leader) : null;
                    const sweep = group.coaches?.sweep ? getCoachById(group.coaches.sweep) : null;
                    const roam = group.coaches?.roam ? getCoachById(group.coaches.roam) : null;
                    const extraRoam = Array.isArray(group.coaches?.extraRoam) 
                        ? group.coaches.extraRoam.map(id => getCoachById(id)).filter(Boolean)
                        : [];
                    
                    const allCoaches = [leader, sweep, roam, ...extraRoam].filter(Boolean);
                    const riders = (group.riders || []).map(id => getRiderById(id)).filter(Boolean);
                    const route = group.routeId ? getRouteById(group.routeId) : null;
                    
                    // Build coaches with their roles
                    const coachesWithRoles = [];
                    if (leader) coachesWithRoles.push({ coach: leader, role: 'Leader' });
                    if (sweep) coachesWithRoles.push({ coach: sweep, role: 'Sweep' });
                    if (roam) coachesWithRoles.push({ coach: roam, role: 'Roam' });
                    extraRoam.forEach(coach => {
                        coachesWithRoles.push({ coach, role: 'Roam+' });
                    });
                    
                    html += `
                        <div class="mobile-group-card" style="margin-bottom: 0; border: 1px solid #ddd; border-radius: 0; overflow: hidden; background: white; border-top: ${index === 0 ? '1px solid #ddd' : 'none'};">
                            <button class="mobile-group-header" onclick="toggleMobileGroup('${groupId}')" style="width: 100%; padding: 8px 16px; background: #f5f5f5; border: none; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 600; color: #333;">
                                <span>${escapeHtml(group.label || `Group ${index + 1}`)}</span>
                                <span class="mobile-group-toggle" id="toggle-${groupId}" style="font-size: 20px; transition: transform 0.2s;">‚ñº</span>
                            </button>
                            <div class="mobile-group-content" id="${groupId}" style="display: none; padding: 16px;">
                                ${riders.length > 0 ? `
                                    <div style="margin-bottom: ${coachesWithRoles.length > 0 ? '20px' : '0'};">
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${riders.map(rider => {
                                                // Render rider card without fitness badge
                                                const riderHtml = renderRiderCardHtml(rider, { compact: true, draggable: false, showMoveControls: false, sortBy: 'name' });
                                                // Remove fitness badge by replacing badge HTML
                                                return riderHtml.replace(/<span class="badge[^"]*">Fitness \d+<\/span>/g, '');
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${coachesWithRoles.length > 0 ? `
                                    <div style="margin-top: ${riders.length > 0 ? '20px' : '0'}; margin-bottom: 16px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #666; text-transform: uppercase;">Ride Leaders</h3>
                                        <div class="roster-grid" style="display: flex; flex-direction: column; gap: 2px;">
                                            ${coachesWithRoles.map(({ coach, role }) => {
                                                // Build coach card matching rider card structure exactly
                                                const name = coach.name || 'Coach';
                                                const safeName = escapeHtml(name);
                                                const initial = escapeHtml((name.trim().charAt(0) || '?').toUpperCase());
                                                const photo = coach.photo ? escapeHtml(coach.photo) : '';
                                                const levelNum = parseInt(coach.level || '1', 10);
                                                const classes = ['coach-card', 'compact'];
                                                if (levelNum === 1) classes.push('coach-level-1');
                                                else if (levelNum === 2) classes.push('coach-level-2');
                                                else if (levelNum === 3) classes.push('coach-level-3');
                                                const roleBadge = `<span class="badge badge-level" style="background: #e3f2fd; color: #1976D2;">${escapeHtml(role)}</span>`;
                                                return `
                                                    <div class="${classes.join(' ')}">
                                                        <div class="avatar-circle coach">
                                                            ${photo ? `<img class="avatar-image" src="${photo}" alt="${safeName} photo">` : `<span class="avatar-placeholder">${initial}</span>`}
                                                        </div>
                                                        <div class="card-body">
                                                            <strong>${safeName}</strong>
                                                            <span class="badge-single">${roleBadge}</span>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${route ? (() => {
                                    // Try to get Strava URL from stored field or extract from embed code
                                    let stravaUrl = route.stravaUrl;
                                    if (!stravaUrl && route.stravaEmbedCode) {
                                        // Try to extract URL from embed code
                                        const urlMatch = route.stravaEmbedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
                                        if (urlMatch) {
                                            stravaUrl = urlMatch[0];
                                        }
                                    }
                                    return `
                                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                                            <strong style="display: block; margin-bottom: 8px; font-size: 14px; color: #666;">Route:</strong>
                                            <div style="font-size: 14px; color: #333;">
                                                <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                                                ${route.distance || route.elevation || route.estimatedTime ? `
                                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                                        ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                                                        ${route.distance && (route.elevation || route.estimatedTime) ? ' ¬∑ ' : ''}
                                                        ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                                                        ${route.elevation && route.estimatedTime ? ' ¬∑ ' : ''}
                                                        ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                                                    </div>
                                                ` : ''}
                                                ${stravaUrl ? `
                                                    <a href="${escapeHtml(stravaUrl)}" target="_blank" rel="noopener noreferrer" style="display: inline-block; margin-top: 6px; font-size: 12px; color: #FC4C02; text-decoration: none; font-weight: 500;">
                                                        View Full Map on Strava ‚Üí
                                                    </a>
                                                ` : route.stravaEmbedCode ? `
                                                    <div style="font-size: 11px; color: #999; margin-top: 4px; font-style: italic;">
                                                        (Strava link not available - route may need to be re-saved)
                                                    </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                    `;
                                })() : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }

            container.innerHTML = html;
        }

        function toggleMobileGroup(groupId) {
            const content = document.getElementById(groupId);
            const toggle = document.getElementById(`toggle-${groupId}`);
            
            if (!content || !toggle) return;
            
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            toggle.textContent = isHidden ? '‚ñ≤' : '‚ñº';
            toggle.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(180deg)';
        }

        // ============ ROUTES MANAGEMENT ============

        // Helper functions for parsing route values for sorting
        function parseDistance(distStr) {
            if (!distStr) return 0;
            const match = distStr.match(/([\d.]+)/);
            return match ? parseFloat(match[1]) : 0;
        }

        function parseElevation(elevStr) {
            if (!elevStr) return 0;
            const match = elevStr.replace(/,/g, '').match(/([\d.]+)/);
            return match ? parseFloat(match[1]) : 0;
        }

        function parseTime(timeStr) {
            if (!timeStr) return 0;
            // Handle formats like "1:30:00", "1h 30m", "90:00", etc.
            const parts = timeStr.match(/(\d+)/g);
            if (!parts) return 0;
            
            if (parts.length === 3) {
                // HH:MM:SS format
                return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
            } else if (parts.length === 2) {
                // MM:SS or HH:MM format
                return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else if (parts.length === 1) {
                // Single number (minutes)
                return parseInt(parts[0]) * 60;
            }
            return 0;
        }

        function parseTimeMidpoint(timeStr) {
            if (!timeStr || timeStr === 'N/A') return 0;
            
            // Handle time ranges like "1:30:00 - 2:00:00" or "1:30-2:00"
            const rangeMatch = timeStr.match(/(.+?)\s*-\s*(.+)/);
            if (rangeMatch) {
                const time1 = parseTime(rangeMatch[1].trim());
                const time2 = parseTime(rangeMatch[2].trim());
                // Return midpoint
                return (time1 + time2) / 2;
            }
            
            // Single time value
            return parseTime(timeStr);
        }

        function renderRoutes() {
            const container = document.getElementById('routes-grid');
            if (!container) return;

            if (!Array.isArray(data.routes) || data.routes.length === 0) {
                container.innerHTML = '<div class="empty-state">No routes added yet. Click "Add/Edit Routes..." to get started.</div>';
                return;
            }

            // Clear container
            container.innerHTML = '';

            // Get sort option
            const sortBySelect = document.getElementById('routes-sort-by');
            const sortBy = sortBySelect ? sortBySelect.value : 'distance-desc';

            // Separate Strava routes (with embed code) and manual routes (without embed code)
            let stravaRoutes = data.routes.filter(route => route.stravaEmbedCode);
            let manualRoutes = data.routes.filter(route => !route.stravaEmbedCode);

            // Sort routes
            const sortRoutes = (routes) => {
                return [...routes].sort((a, b) => {
                    let compareA, compareB;
                    
                    if (sortBy.startsWith('distance-')) {
                        compareA = parseDistance(a.distance || '0');
                        compareB = parseDistance(b.distance || '0');
                    } else if (sortBy.startsWith('elevation-')) {
                        compareA = parseElevation(a.elevation || '0');
                        compareB = parseElevation(b.elevation || '0');
                    } else if (sortBy.startsWith('time-')) {
                        compareA = parseTimeMidpoint(a.estimatedTime || '0:00');
                        compareB = parseTimeMidpoint(b.estimatedTime || '0:00');
                    } else {
                        return 0;
                    }
                    
                    // Determine sort direction
                    const isAscending = sortBy.endsWith('-asc');
                    return isAscending ? compareA - compareB : compareB - compareA;
                });
            };

            stravaRoutes = sortRoutes(stravaRoutes);
            manualRoutes = sortRoutes(manualRoutes);

            // Render Strava routes first
            stravaRoutes.forEach(route => {
                renderRouteCard(route, container);
            });

            // Add separator if both types exist
            if (stravaRoutes.length > 0 && manualRoutes.length > 0) {
                const separator = document.createElement('div');
                separator.style.cssText = 'grid-column: 1 / -1; height: 1px; background: #e0e0e0; margin: 20px 0;';
                container.appendChild(separator);
            }

            // Render manual routes below Strava routes
            manualRoutes.forEach(route => {
                renderRouteCard(route, container, true);
            });
        }

        function renderRouteCard(route, container, isManual = false) {
            const routeCard = document.createElement('div');
            // Force manual routes to span full width to appear below Strava routes
            if (isManual) {
                routeCard.style.cssText = 'width: 100%; margin-bottom: 0; grid-column: 1 / -1;';
            } else {
                routeCard.style.cssText = 'width: 420px; margin-bottom: 0;';
            }

            if (route.stravaEmbedCode && !isManual) {
                // Embed container - no card, no header, no description, just the map
                // Scale to 70% of standard size (405px * 0.7 = 283.5px, rounded to 284px)
                const embedContainer = document.createElement('div');
                embedContainer.style.cssText = 'width: 420px; height: 284px; border: none; border-radius: 0; overflow: hidden; position: relative;';
                
                // Wrapper to scale the embed content to 70%
                const embedWrapper = document.createElement('div');
                embedWrapper.style.cssText = 'transform: scale(0.7); transform-origin: top left; width: 142.86%; height: 142.86%; position: absolute; top: 0; left: 0;';
                
                // Create inner container for the embed (standard size)
                const innerContainer = document.createElement('div');
                innerContainer.style.cssText = 'width: 100%; height: 405px; position: relative;';
                
                // Insert embed code as raw HTML
                innerContainer.innerHTML = route.stravaEmbedCode;
                
                // If there are script tags, we need to execute them
                const scripts = innerContainer.querySelectorAll('script');
                scripts.forEach(oldScript => {
                    const newScript = document.createElement('script');
                    // Copy all attributes
                    Array.from(oldScript.attributes).forEach(attr => {
                        newScript.setAttribute(attr.name, attr.value);
                    });
                    // Copy script content
                    newScript.textContent = oldScript.textContent;
                    // Replace old script with new one (which will execute)
                    oldScript.parentNode.replaceChild(newScript, oldScript);
                });

                // Check if we need to load Strava embed.js
                if (innerContainer.querySelector('[data-embed-type="route"]') && 
                    !document.querySelector('script[src="https://strava-embeds.com/embed.js"]')) {
                    const stravaScript = document.createElement('script');
                    stravaScript.src = 'https://strava-embeds.com/embed.js';
                    document.head.appendChild(stravaScript);
                }
                
                embedWrapper.appendChild(innerContainer);
                embedContainer.appendChild(embedWrapper);
                routeCard.appendChild(embedContainer);
                
                // Add route info line below the map
                const routeInfoLine = document.createElement('div');
                routeInfoLine.style.cssText = 'margin-top: 8px; margin-bottom: 20px; font-size: 11px; color: #666; line-height: 1.4;';
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                const fitnessMin = route.fitnessMin !== undefined ? route.fitnessMin : 1;
                const fitnessMax = route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
                const skillsMin = route.skillsMin !== undefined ? route.skillsMin : 1;
                const skillsMax = route.skillsMax !== undefined ? route.skillsMax : skillsScale;
                
                const fitnessRange = (fitnessMin === 1 && fitnessMax === fitnessScale) ? 'ALL' : `${fitnessMin}-${fitnessMax}`;
                const skillsRange = (skillsMin === 1 && skillsMax === skillsScale) ? 'ALL' : `${skillsMin}-${skillsMax}`;
                
                const durationText = route.estimatedTime || 'N/A';
                
                routeInfoLine.textContent = `Fitness Range: ${fitnessRange} | Bike Skills Range: ${skillsRange} | Duration: ${durationText}`;
                routeCard.appendChild(routeInfoLine);
            } else {
                // For manual routes, show route info card instead of embed
                const routeInfoCard = document.createElement('div');
                routeInfoCard.style.cssText = 'padding: 20px; background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 4px;';
                routeInfoCard.innerHTML = `
                    <div style="font-weight: 600; font-size: 16px; margin-bottom: 8px;">${escapeHtml(route.name || 'Unnamed Route')}</div>
                    ${route.distance || route.elevation || route.estimatedTime ? `
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">
                            ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                            ${route.distance && (route.elevation || route.estimatedTime) ? ' ¬∑ ' : ''}
                            ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                            ${route.elevation && route.estimatedTime ? ' ¬∑ ' : ''}
                            ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                        </div>
                    ` : ''}
                    ${route.description ? `
                        <div style="font-size: 13px; color: #666; margin-top: 8px; line-height: 1.4;">${escapeHtml(route.description)}</div>
                    ` : ''}
                `;
                routeCard.appendChild(routeInfoCard);
                
                // Add route info line below the card
                const routeInfoLine = document.createElement('div');
                routeInfoLine.style.cssText = 'margin-top: 8px; margin-bottom: 20px; font-size: 11px; color: #666; line-height: 1.4;';
                
                const fitnessScale = getFitnessScale();
                const skillsScale = getSkillsScale();
                const fitnessMin = route.fitnessMin !== undefined ? route.fitnessMin : 1;
                const fitnessMax = route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
                const skillsMin = route.skillsMin !== undefined ? route.skillsMin : 1;
                const skillsMax = route.skillsMax !== undefined ? route.skillsMax : skillsScale;
                
                const fitnessRange = (fitnessMin === 1 && fitnessMax === fitnessScale) ? 'ALL' : `${fitnessMin}-${fitnessMax}`;
                const skillsRange = (skillsMin === 1 && skillsMax === skillsScale) ? 'ALL' : `${skillsMin}-${skillsMax}`;
                
                const durationText = route.estimatedTime || 'N/A';
                
                routeInfoLine.textContent = `Fitness Range: ${fitnessRange} | Bike Skills Range: ${skillsRange} | Duration: ${durationText}`;
                routeCard.appendChild(routeInfoLine);
            }
            
            container.appendChild(routeCard);
        }

        function openRoutesManagerModal() {
            const modal = document.getElementById('routes-manager-modal');
            const listContainer = document.getElementById('routes-manager-list');
            if (!modal || !listContainer) return;

            // Render routes list
            const routes = data.routes || [];
            if (routes.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No routes added yet.</div>';
            } else {
                listContainer.innerHTML = routes.map(route => {
                    const isStrava = !!route.stravaEmbedCode;
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #e0e0e0;">
                            <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; flex-wrap: nowrap;">
                                        ${isStrava ? '<img src="assets/strava_logo.png" alt="Strava" style="height: 16px; width: auto; flex-shrink: 0;">' : ''}
                                        <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0;">${escapeHtml(route.name || 'Unnamed Route')}</span>
                                    </div>
                                    ${route.distance || route.elevation || route.estimatedTime ? `
                                        <div style="font-size: 12px; color: #666;">
                                            ${route.distance ? `<span>${escapeHtml(route.distance)}</span>` : ''}
                                            ${route.distance && (route.elevation || route.estimatedTime) ? ' ¬∑ ' : ''}
                                            ${route.elevation ? `<span>${escapeHtml(route.elevation)}</span>` : ''}
                                            ${route.elevation && route.estimatedTime ? ' ¬∑ ' : ''}
                                            ${route.estimatedTime ? `<span>${escapeHtml(route.estimatedTime)}</span>` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn-small secondary" onclick="openAddRouteModal(${route.id}, ${!route.stravaEmbedCode})">Edit</button>
                                <button class="btn-small danger" onclick="deleteRouteHandler(${route.id}); openRoutesManagerModal();">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeRoutesManagerModal() {
            const modal = document.getElementById('routes-manager-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }

        function openAddRouteModal(routeId, isManualRoute = false) {
            const modal = document.getElementById('add-route-modal');
            const titleEl = document.getElementById('add-route-modal-title');
            const headerEl = document.getElementById('add-route-modal-header');
            const embedCodeSection = document.querySelector('#add-route-modal [for="route-embed-code"]')?.closest('div[style*="position: relative"]');
            const fetchContainer = document.getElementById('fetch-route-data-container');
            
            if (!modal) return;

            // Close routes manager modal if open
            closeRoutesManagerModal();

            const isEdit = routeId !== null;
            const route = isEdit ? (data.routes || []).find(r => r.id === routeId) : null;
            
            // Determine if this is a manual route (non-Strava)
            const isManual = isManualRoute || (route && !route.stravaEmbedCode);
            
            // Show/hide embed code section based on route type
            if (embedCodeSection) {
                embedCodeSection.style.display = isManual ? 'none' : 'block';
            }
            if (fetchContainer) {
                fetchContainer.style.display = isManual ? 'none' : 'block';
            }
            
            // Update header styling
            if (headerEl) {
                if (isManual) {
                    headerEl.style.backgroundColor = '';
                    headerEl.style.color = '';
                } else {
                    headerEl.style.backgroundColor = '#fc5200';
                    headerEl.style.color = 'white';
                }
            }
            
            // Update title
            if (titleEl) {
                if (isEdit) {
                    titleEl.textContent = isManual ? 'Edit Route' : 'Edit Strava Route';
                } else {
                    titleEl.textContent = isManual ? 'Add Route' : 'Add Strava Route';
                }
            }

            // Populate or clear form
            document.getElementById('route-name').value = route ? (route.name || '') : '';
            document.getElementById('route-description').value = route ? (route.description || '') : '';
            document.getElementById('route-distance').value = route ? (route.distance || '') : '';
            document.getElementById('route-elevation').value = route ? (route.elevation || '') : '';
            document.getElementById('route-time').value = route ? (route.estimatedTime || '') : '';
            document.getElementById('route-embed-code').value = route ? (route.stravaEmbedCode || '') : '';
            
            // Update placeholder text based on route type
            const nameInput = document.getElementById('route-name');
            const distanceInput = document.getElementById('route-distance');
            const elevationInput = document.getElementById('route-elevation');
            const timeInput = document.getElementById('route-time');
            
            if (isManual) {
                if (nameInput) nameInput.placeholder = 'Enter route name';
                if (distanceInput) distanceInput.placeholder = 'Enter distance (e.g., 15.5 mi)';
                if (elevationInput) elevationInput.placeholder = 'Enter elevation gain (e.g., 1,200 ft)';
                if (timeInput) timeInput.placeholder = 'Enter estimated time (e.g., 2:04:20 or 2h 4m)';
            } else {
                if (nameInput) nameInput.placeholder = 'Will be auto-filled from Strava, or enter manually';
                if (distanceInput) distanceInput.placeholder = 'Will be auto-filled from Strava';
                if (elevationInput) elevationInput.placeholder = 'Will be auto-filled from Strava';
                if (timeInput) timeInput.placeholder = 'Will be calculated from distance and elevation';
            }
            
            // Initialize fitness range slider (default to full range: 1 to current fitness scale)
            const fitnessScale = getFitnessScale();
            // For new routes, default to full range (1 to fitnessScale)
            const fitnessMin = route && route.fitnessMin !== undefined ? route.fitnessMin : 1;
            const fitnessMax = route && route.fitnessMax !== undefined ? route.fitnessMax : fitnessScale;
            // Ensure at least 1-value difference, but preserve full range for new routes
            const validFitnessMin = route ? Math.min(fitnessMin, Math.max(1, fitnessMax - 1)) : 1;
            const validFitnessMax = route ? Math.max(fitnessMax, Math.min(fitnessScale, fitnessMin + 1)) : fitnessScale;
            const fitnessMinInput = document.getElementById('route-fitness-min');
            const fitnessMaxInput = document.getElementById('route-fitness-max');
            if (fitnessMinInput && fitnessMaxInput) {
                fitnessMinInput.value = validFitnessMin;
                fitnessMaxInput.value = validFitnessMax;
                fitnessMinInput.max = validFitnessMax - 1;
                fitnessMaxInput.min = validFitnessMin + 1;
                fitnessMaxInput.max = fitnessScale;
            }
            setTimeout(() => {
                updateFitnessRange();
                setupSliderDrag('fitness', 1, fitnessScale, fitnessScale - 1);
            }, 50);
            
            // Initialize bike skills range slider (default to full range: 1 to current skills scale)
            const skillsScale = getSkillsScale();
            // For new routes, default to full range (1 to skillsScale)
            const skillsMin = route && route.skillsMin !== undefined ? route.skillsMin : 1;
            const skillsMax = route && route.skillsMax !== undefined ? route.skillsMax : skillsScale;
            // Ensure at least 1-value difference, but preserve full range for new routes
            const validSkillsMin = route ? Math.min(skillsMin, Math.max(1, skillsMax - 1)) : 1;
            const validSkillsMax = route ? Math.max(skillsMax, Math.min(skillsScale, skillsMin + 1)) : skillsScale;
            const skillsMinInput = document.getElementById('route-skills-min');
            const skillsMaxInput = document.getElementById('route-skills-max');
            if (skillsMinInput && skillsMaxInput) {
                skillsMinInput.value = validSkillsMin;
                skillsMaxInput.value = validSkillsMax;
                skillsMinInput.max = validSkillsMax - 1;
                skillsMaxInput.min = validSkillsMin + 1;
                skillsMaxInput.max = skillsScale;
            }
            setTimeout(() => {
                updateSkillsRange();
                setupSliderDrag('skills', 1, skillsScale, skillsScale - 1);
            }, 50);
            
            // Update max attributes and regenerate scale labels
            updateInputMaxAttributes();
            updateRouteSliderLabels();
            
            // Add event listeners for auto-calculating time when distance/elevation change
            const distanceInputEl = document.getElementById('route-distance');
            const elevationInputEl = document.getElementById('route-elevation');
            const timeInputEl = document.getElementById('route-time');
            
            // Remove existing listeners by cloning and replacing
            if (distanceInputEl) {
                const newDistanceInput = distanceInputEl.cloneNode(true);
                distanceInputEl.parentNode.replaceChild(newDistanceInput, distanceInputEl);
            }
            if (elevationInputEl) {
                const newElevationInput = elevationInputEl.cloneNode(true);
                elevationInputEl.parentNode.replaceChild(newElevationInput, elevationInputEl);
            }
            
            // Add new listeners
            const updatedDistanceInput = document.getElementById('route-distance');
            const updatedElevationInput = document.getElementById('route-elevation');
            const updatedTimeInput = document.getElementById('route-time');
            
            function updateTimeFromDistanceElevation() {
                const distance = updatedDistanceInput ? updatedDistanceInput.value.trim() : '';
                const elevation = updatedElevationInput ? updatedElevationInput.value.trim() : '';
                if (distance && updatedTimeInput) {
                    const calculatedTime = calculateEstimatedTime(distance, elevation);
                    if (calculatedTime) {
                        // Always update since field is readonly and calculated
                        updatedTimeInput.value = calculatedTime;
                    }
                }
            }
            
            if (updatedDistanceInput) {
                updatedDistanceInput.addEventListener('input', updateTimeFromDistanceElevation);
                updatedDistanceInput.addEventListener('blur', updateTimeFromDistanceElevation);
            }
            if (updatedElevationInput) {
                updatedElevationInput.addEventListener('input', updateTimeFromDistanceElevation);
                updatedElevationInput.addEventListener('blur', updateTimeFromDistanceElevation);
            }
            
            // Store route ID for editing and route type
            if (isEdit) {
                modal.setAttribute('data-editing-route-id', routeId);
            } else {
                modal.removeAttribute('data-editing-route-id');
            }
            modal.setAttribute('data-is-manual-route', isManual ? 'true' : 'false');

            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');

            // Setup embed code listener for auto-fetch (only for Strava routes)
            if (!isManual) {
                setupRouteDataExtraction();
            }

            // Focus on route name input for manual routes, embed code for Strava routes
            setTimeout(() => {
                if (isManual) {
                    document.getElementById('route-name').focus();
                } else {
                    document.getElementById('route-embed-code').focus();
                }
            }, 100);
        }

        // Configuration for proxy server
        const PROXY_SERVER_URL = 'http://localhost:3001'; // Change this if your server runs on a different port/URL

        function setupRouteDataExtraction() {
            const embedCodeInput = document.getElementById('route-embed-code');
            const fetchBtn = document.getElementById('fetch-route-data-btn');
            if (!embedCodeInput || !fetchBtn) return;
            
            // Enable/disable fetch button based on embed code content
            function updateButtonState() {
                const embedCode = embedCodeInput.value.trim();
                const extractedUrl = embedCode ? extractRouteUrlFromEmbed(embedCode) : null;
                const hasValidUrl = !!extractedUrl;
                
                fetchBtn.disabled = !hasValidUrl;
                
                const statusEl = document.getElementById('fetch-route-status');
                if (!hasValidUrl && embedCode) {
                    // Show helpful message if code is pasted but URL can't be extracted
                    if (statusEl) {
                        statusEl.textContent = 'Make sure the embed code contains a Strava URL';
                        statusEl.style.color = '#ff9800';
                    }
                } else if (hasValidUrl) {
                    // Show that URL was found
                    if (statusEl && !statusEl.textContent.includes('‚úì') && !statusEl.textContent.includes('Error') && !statusEl.textContent.includes('Fetching')) {
                        statusEl.textContent = 'Ready to fetch';
                        statusEl.style.color = '#4caf50';
                    }
                } else {
                    // Clear status when no embed code
                    if (statusEl && !statusEl.textContent.includes('‚úì') && !statusEl.textContent.includes('Error')) {
                        statusEl.textContent = '';
                    }
                }
            }
            
            // Check on input
            embedCodeInput.addEventListener('input', updateButtonState);
            
            // Check on paste (with slight delay to let paste complete)
            embedCodeInput.addEventListener('paste', function() {
                setTimeout(updateButtonState, 100);
            });
            
            // Initial state check
            updateButtonState();
        }

        function extractRouteUrlFromEmbed(embedCode) {
            // Method 1: Try to find URL in src attribute of iframe (old format)
            const iframeSrcMatch = embedCode.match(/src=["']([^"']*strava\.com[^"']*)["']/i);
            if (iframeSrcMatch) {
                return iframeSrcMatch[1];
            }
            
            // Method 2: Try to find any Strava URL in the code
            const urlMatch = embedCode.match(/https?:\/\/[^\s"'<>]+strava\.com[^\s"'<>]*/i);
            if (urlMatch) {
                return urlMatch[0];
            }
            
            // Method 3: Extract route ID from new Strava embed format (data-embed-id)
            // Handle both quoted and unquoted values, with optional whitespace
            const routeIdMatch = embedCode.match(/data-embed-id\s*=\s*["']?(\d+)["']?/i);
            if (routeIdMatch) {
                const routeId = routeIdMatch[1];
                // Construct Strava route URL from the route ID
                return `https://www.strava.com/routes/${routeId}`;
            }
            
            // Method 4: Try to find route ID in various patterns
            const routeIdPatterns = [
                /routes\/(\d+)/i,
                /route\/(\d+)/i,
                /\/r\/(\d+)/i
            ];
            
            for (const pattern of routeIdPatterns) {
                const match = embedCode.match(pattern);
                if (match) {
                    return `https://www.strava.com/routes/${match[1]}`;
                }
            }
            
            return null;
        }

        // Calculate estimated time based on distance and elevation
        // Uses configurable mountain biking speeds, adjusted for elevation and route length
        function calculateEstimatedTime(distanceStr, elevationStr) {
            if (!distanceStr) return null;
            
            // Get settings (with defaults)
            const settings = data.timeEstimationSettings || {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            // Parse distance (handle formats like "22.6 mi", "15.5 km", etc.)
            const distanceMatch = distanceStr.match(/(\d+\.?\d*)\s*(mi|km|miles|kilometers?)/i);
            if (!distanceMatch) return null;
            
            let distanceMiles = parseFloat(distanceMatch[1]);
            const unit = distanceMatch[2].toLowerCase();
            if (unit === 'km' || unit === 'kilometers' || unit === 'kilometer') {
                distanceMiles = distanceMiles * 0.621371; // Convert km to miles
            }
            
            // Parse elevation (handle formats like "3,079 ft", "1000 m", etc.)
            let elevationFeet = 0;
            if (elevationStr) {
                const elevMatch = elevationStr.match(/([\d,]+\.?\d*)\s*(ft|feet|m|meters?)/i);
                if (elevMatch) {
                    elevationFeet = parseFloat(elevMatch[1].replace(/,/g, ''));
                    const elevUnit = elevMatch[2].toLowerCase();
                    if (elevUnit === 'm' || elevUnit === 'meters' || elevUnit === 'meter') {
                        elevationFeet = elevationFeet * 3.28084; // Convert meters to feet
                    }
                }
            }
            
            // Calculate adjustments
            const elevationAdjustment = (elevationFeet / 1000) * settings.elevationAdjustment;
            const lengthAdjustment = Math.max(0, (distanceMiles - 10) * settings.lengthAdjustmentFactor);
            
            // Calculate speeds with adjustments
            const fastSpeed = Math.max(settings.fastSpeedMin, settings.fastSpeedBase - elevationAdjustment - lengthAdjustment);
            const slowSpeed = Math.max(settings.slowSpeedMin, settings.slowSpeedBase - elevationAdjustment - lengthAdjustment);
            
            // Calculate time in hours
            const fastTimeHours = distanceMiles / fastSpeed;
            const slowTimeHours = distanceMiles / slowSpeed;
            
            // Convert to HH:MM format, rounded to nearest 5 minutes
            function formatTime(hours) {
                const totalMinutes = Math.round(hours * 60);
                // Round to nearest 5 minutes
                const roundedMinutes = Math.round(totalMinutes / 5) * 5;
                const h = Math.floor(roundedMinutes / 60);
                const m = roundedMinutes % 60;
                
                if (h > 0) {
                    return `${h}:${String(m).padStart(2, '0')}`;
                } else {
                    return `0:${String(m).padStart(2, '0')}`;
                }
            }
            
            const fastTime = formatTime(fastTimeHours);
            const slowTime = formatTime(slowTimeHours);
            
            // Return range format: "fastTime - slowTime" or just one time if they're close
            if (fastTime === slowTime) {
                return fastTime;
            } else {
                return `${fastTime} - ${slowTime}`;
            }
        }

        async function fetchRouteDataFromEmbed() {
            const embedCodeInput = document.getElementById('route-embed-code');
            const statusEl = document.getElementById('fetch-route-status');
            const fetchBtn = document.getElementById('fetch-route-data-btn');
            
            if (!embedCodeInput) return;
            
            const embedCode = embedCodeInput.value.trim();
            if (!embedCode) {
                if (statusEl) statusEl.textContent = 'Please paste embed code first';
                return;
            }
            
            const routeUrl = extractRouteUrlFromEmbed(embedCode);
            if (!routeUrl) {
                if (statusEl) statusEl.textContent = 'Could not extract route URL from embed code';
                return;
            }
            
            // Update UI
            if (fetchBtn) {
                fetchBtn.disabled = true;
                fetchBtn.textContent = 'Fetching...';
            }
            if (statusEl) statusEl.textContent = 'Fetching route data...';
            
            try {
                const response = await fetch(`${PROXY_SERVER_URL}/api/fetch-strava-route?url=${encodeURIComponent(routeUrl)}`);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Populate form fields (always populate when auto-fill is clicked)
                if (data.name) {
                    const nameInput = document.getElementById('route-name');
                    if (nameInput) {
                        nameInput.value = data.name;
                    }
                }
                
                if (data.distance) {
                    const distanceInput = document.getElementById('route-distance');
                    if (distanceInput) {
                        distanceInput.value = data.distance;
                    }
                }
                
                if (data.elevation) {
                    const elevationInput = document.getElementById('route-elevation');
                    if (elevationInput) {
                        elevationInput.value = data.elevation;
                    }
                }
                
                // Calculate estimated time based on distance and elevation (instead of using Strava's time)
                const calculatedTime = calculateEstimatedTime(data.distance || '', data.elevation || '');
                if (calculatedTime) {
                    const timeInput = document.getElementById('route-time');
                    if (timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
                
                if (statusEl) {
                    statusEl.textContent = '‚úì Route data fetched successfully!';
                    statusEl.style.color = '#4caf50';
                }
                
            } catch (error) {
                console.error('Error fetching route data:', error);
                
                // Check for connection errors
                const isConnectionError = error.message.includes('Failed to fetch') || 
                                         error.message.includes('network') || 
                                         error.message.toLowerCase().includes('connection') ||
                                         error.message.includes('ERR_CONNECTION_REFUSED') ||
                                         error.name === 'TypeError';
                
                if (statusEl) {
                    if (isConnectionError) {
                        statusEl.innerHTML = '‚ö†Ô∏è Strava API server not available. The auto-fill feature requires a backend server to be running. You can still enter route information manually.';
                        statusEl.style.color = '#ff9800';
                    } else {
                        statusEl.textContent = `Error: ${error.message}`;
                        statusEl.style.color = '#f44336';
                    }
                }
                
                // Only show alert for non-connection errors (connection errors already have status message)
                if (!isConnectionError) {
                    let errorMessage = `Unable to fetch route data automatically.\n\nError: ${error.message}\n\n`;
                    errorMessage += `Make sure the proxy server is running on ${PROXY_SERVER_URL}\n\n`;
                    errorMessage += `You can still enter the route information manually.`;
                    alert(errorMessage);
                }
            } finally {
                if (fetchBtn) {
                    fetchBtn.disabled = false;
                    fetchBtn.textContent = 'üîç Auto-fill Route Info from Strava';
                }
            }
        }

        // Slider drag functionality
        let isDragging = false;
        let dragHandle = null;
        let dragSlider = null;
        let dragType = null;
        let dragStartX = 0;
        let dragStartPercent = 0;

        // Global drag handlers (only add once)
        if (!window.sliderDragHandlersAdded) {
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                handleDrag(e);
            });
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                handleDrag(e);
            });
            document.addEventListener('mouseup', function() {
                stopDrag();
            });
            document.addEventListener('touchend', function() {
                stopDrag();
            });
            window.sliderDragHandlersAdded = true;
        }

        function handleDrag(e) {
            if (!isDragging || !dragSlider) return;
            
            const track = document.getElementById(`route-${dragSlider}-slider-track`);
            if (!track) return;
            
            const rect = track.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let percent = ((clientX - rect.left) / rect.width) * 100;
            percent = Math.max(0, Math.min(100, percent));
            
            const sliderMax = dragSlider === 'fitness' ? 10 : 4;
            const value = Math.round(1 + (percent / 100) * (sliderMax - 1));
            updateSliderValue(dragSlider, dragType, value);
        }

        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                if (dragHandle) dragHandle.style.cursor = 'grab';
                dragHandle = null;
                dragSlider = null;
                dragType = null;
                dragStartX = 0;
                dragStartPercent = 0;
            }
        }

        function setupSliderDrag(sliderName, minValue, maxValue, totalRange) {
            const minHandle = document.getElementById(`route-${sliderName}-min-handle`);
            const maxHandle = document.getElementById(`route-${sliderName}-max-handle`);
            const track = document.getElementById(`route-${sliderName}-slider-track`);
            
            if (!minHandle || !maxHandle || !track) return;

            // Remove existing listeners by cloning and replacing
            const newMinHandle = minHandle.cloneNode(true);
            const newMaxHandle = maxHandle.cloneNode(true);
            minHandle.parentNode.replaceChild(newMinHandle, minHandle);
            maxHandle.parentNode.replaceChild(newMaxHandle, maxHandle);

            function startDrag(e, type) {
                isDragging = true;
                dragHandle = type === 'min' ? newMinHandle : newMaxHandle;
                dragSlider = sliderName;
                dragType = type;
                dragHandle.style.cursor = 'grabbing';
                e.preventDefault();
                e.stopPropagation();
            }

            newMinHandle.addEventListener('mousedown', (e) => startDrag(e, 'min'));
            newMaxHandle.addEventListener('mousedown', (e) => startDrag(e, 'max'));
            newMinHandle.addEventListener('touchstart', (e) => startDrag(e, 'min'));
            newMaxHandle.addEventListener('touchstart', (e) => startDrag(e, 'max'));
        }

        function updateSliderValue(sliderName, type, newValue) {
            // Get elements fresh each time (handles may have been cloned)
            const minHandle = document.getElementById(`route-${sliderName}-min-handle`);
            const maxHandle = document.getElementById(`route-${sliderName}-max-handle`);
            const range = document.getElementById(`route-${sliderName}-slider-range`);
            const minValueDisplay = document.getElementById(`route-${sliderName}-min-value`);
            const maxValueDisplay = document.getElementById(`route-${sliderName}-max-value`);
            const minInput = document.getElementById(`route-${sliderName}-min`);
            const maxInput = document.getElementById(`route-${sliderName}-max`);
            
            if (!minInput || !maxInput) return;
            
            const sliderMax = sliderName === 'fitness' ? getFitnessScale() : getSkillsScale();
            let minValue = parseInt(minInput.value);
            let maxValue = parseInt(maxInput.value);
            
            if (type === 'min') {
                // Min cannot exceed (max - 1) to maintain at least 1-value range
                newValue = Math.max(1, Math.min(newValue, maxValue - 1));
                minInput.value = newValue;
                minValue = newValue;
                // Update max input's min constraint
                maxInput.min = minValue + 1;
            } else if (type === 'max') {
                // Max cannot go below (min + 1) to maintain at least 1-value range
                newValue = Math.max(minValue + 1, Math.min(newValue, sliderMax));
                maxInput.value = newValue;
                maxValue = newValue;
                // Update min input's max constraint
                minInput.max = maxValue - 1;
            }
            
            const minPercent = ((minValue - 1) / (sliderMax - 1)) * 100;
            const maxPercent = ((maxValue - 1) / (sliderMax - 1)) * 100;
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }

        function updateFitnessRange() {
            const minInput = document.getElementById('route-fitness-min');
            const maxInput = document.getElementById('route-fitness-max');
            let minValue = parseInt(minInput.value);
            let maxValue = parseInt(maxInput.value);
            
            // Enforce constraints: min < max and at least 1-value difference
            if (minValue >= maxValue) {
                if (minInput === document.activeElement || dragType === 'min') {
                    maxValue = Math.min(10, minValue + 1);
                    maxInput.value = maxValue;
                } else {
                    minValue = Math.max(1, maxValue - 1);
                    minInput.value = minValue;
                }
            }
            
            const minPercent = ((minValue - 1) / 9) * 100;
            const maxPercent = ((maxValue - 1) / 9) * 100;
            
            const range = document.getElementById('route-fitness-slider-range');
            const minHandle = document.getElementById('route-fitness-min-handle');
            const maxHandle = document.getElementById('route-fitness-max-handle');
            const minValueDisplay = document.getElementById('route-fitness-min-value');
            const maxValueDisplay = document.getElementById('route-fitness-max-value');
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }
        
        function updateSkillsRange() {
            const minInput = document.getElementById('route-skills-min');
            const maxInput = document.getElementById('route-skills-max');
            let minValue = parseInt(minInput.value);
            let maxValue = parseInt(maxInput.value);
            
            // Enforce constraints: min < max and at least 1-value difference
            if (minValue >= maxValue) {
                if (minInput === document.activeElement || dragType === 'min') {
                    maxValue = Math.min(4, minValue + 1);
                    maxInput.value = maxValue;
                } else {
                    minValue = Math.max(1, maxValue - 1);
                    minInput.value = minValue;
                }
            }
            
            const minPercent = ((minValue - 1) / 3) * 100;
            const maxPercent = ((maxValue - 1) / 3) * 100;
            
            const range = document.getElementById('route-skills-slider-range');
            const minHandle = document.getElementById('route-skills-min-handle');
            const maxHandle = document.getElementById('route-skills-max-handle');
            const minValueDisplay = document.getElementById('route-skills-min-value');
            const maxValueDisplay = document.getElementById('route-skills-max-value');
            
            if (range && minHandle && maxHandle) {
                range.style.left = minPercent + '%';
                range.style.width = (maxPercent - minPercent) + '%';
                minHandle.style.left = minPercent + '%';
                maxHandle.style.left = maxPercent + '%';
            }
            if (minValueDisplay) minValueDisplay.textContent = minValue;
            if (maxValueDisplay) maxValueDisplay.textContent = maxValue;
        }
        
        function showEmbedCodeTooltip(event) {
            const tooltip = document.getElementById('embed-code-tooltip');
            if (!tooltip) return;
            
            tooltip.style.display = 'block';
            
            // Position tooltip relative to the icon
            const icon = event.target;
            const iconRect = icon.getBoundingClientRect();
            const container = tooltip.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            // Calculate position relative to container
            const relativeLeft = iconRect.left - containerRect.left;
            const relativeTop = iconRect.top - containerRect.top;
            
            // Position to the right of the icon
            tooltip.style.left = (relativeLeft + iconRect.width + 8) + 'px';
            tooltip.style.top = (relativeTop - 4) + 'px';
            
            // Adjust if tooltip would go off screen
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                if (tooltipRect.right > containerRect.right) {
                    // Position to the left of icon instead
                    tooltip.style.left = (relativeLeft - tooltipRect.width - 8) + 'px';
                }
                
                if (tooltipRect.bottom > containerRect.bottom) {
                    // Position above icon
                    tooltip.style.top = (relativeTop - tooltipRect.height - 8) + 'px';
                }
            }, 0);
        }
        
        function hideEmbedCodeTooltip() {
            const tooltip = document.getElementById('embed-code-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function closeAddRouteModal() {
            const modal = document.getElementById('add-route-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            hideEmbedCodeTooltip();
        }

        // Store original settings when modal opens for discard functionality
        let timeEstimationSettingsOriginal = null;

        function openTimeEstimationSettings() {
            const modal = document.getElementById('time-estimation-settings-modal');
            if (!modal) {
                console.error('Time estimation settings modal not found');
                return;
            }
            
            // Load current settings
            const settings = data.timeEstimationSettings || {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            // Store original settings for discard functionality
            timeEstimationSettingsOriginal = JSON.parse(JSON.stringify(settings));
            
            const fastSpeedInput = document.getElementById('time-settings-fast-speed');
            const slowSpeedInput = document.getElementById('time-settings-slow-speed');
            const fastMinInput = document.getElementById('time-settings-fast-min');
            const slowMinInput = document.getElementById('time-settings-slow-min');
            const elevationInput = document.getElementById('time-settings-elevation');
            const lengthInput = document.getElementById('time-settings-length');
            
            if (fastSpeedInput) fastSpeedInput.value = settings.fastSpeedBase;
            if (slowSpeedInput) slowSpeedInput.value = settings.slowSpeedBase;
            if (fastMinInput) fastMinInput.value = settings.fastSpeedMin;
            if (slowMinInput) slowMinInput.value = settings.slowSpeedMin;
            if (elevationInput) elevationInput.value = settings.elevationAdjustment;
            if (lengthInput) lengthInput.value = settings.lengthAdjustmentFactor;
            
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }

        function closeTimeEstimationSettings() {
            const modal = document.getElementById('time-estimation-settings-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            timeEstimationSettingsOriginal = null;
        }

        function saveTimeEstimationSettings() {
            // Save current values (updateTimeEstimationSettings already saves to data and localStorage)
            updateTimeEstimationSettings();
            closeTimeEstimationSettings();
        }

        function discardTimeEstimationSettings() {
            if (!timeEstimationSettingsOriginal) {
                closeTimeEstimationSettings();
                return;
            }
            
            // Restore original values
            const fastSpeedInput = document.getElementById('time-settings-fast-speed');
            const slowSpeedInput = document.getElementById('time-settings-slow-speed');
            const fastMinInput = document.getElementById('time-settings-fast-min');
            const slowMinInput = document.getElementById('time-settings-slow-min');
            const elevationInput = document.getElementById('time-settings-elevation');
            const lengthInput = document.getElementById('time-settings-length');
            
            if (fastSpeedInput) fastSpeedInput.value = timeEstimationSettingsOriginal.fastSpeedBase;
            if (slowSpeedInput) slowSpeedInput.value = timeEstimationSettingsOriginal.slowSpeedBase;
            if (fastMinInput) fastMinInput.value = timeEstimationSettingsOriginal.fastSpeedMin;
            if (slowMinInput) slowMinInput.value = timeEstimationSettingsOriginal.slowSpeedMin;
            if (elevationInput) elevationInput.value = timeEstimationSettingsOriginal.elevationAdjustment;
            if (lengthInput) lengthInput.value = timeEstimationSettingsOriginal.lengthAdjustmentFactor;
            
            // Restore data object
            data.timeEstimationSettings = JSON.parse(JSON.stringify(timeEstimationSettingsOriginal));
            saveData();
            
            // Recalculate time for current route if modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
            
            closeTimeEstimationSettings();
        }

        function previewTimeEstimationSettings() {
            // Preview changes without saving - just update the time estimate if route modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    // Temporarily update settings for preview
                    const tempSettings = {
                        fastSpeedBase: parseFloat(document.getElementById('time-settings-fast-speed').value) || 12.5,
                        slowSpeedBase: parseFloat(document.getElementById('time-settings-slow-speed').value) || 10,
                        fastSpeedMin: parseFloat(document.getElementById('time-settings-fast-min').value) || 5.5,
                        slowSpeedMin: parseFloat(document.getElementById('time-settings-slow-min').value) || 4,
                        elevationAdjustment: parseFloat(document.getElementById('time-settings-elevation').value) || 0.5,
                        lengthAdjustmentFactor: parseFloat(document.getElementById('time-settings-length').value) || 0.1
                    };
                    
                    // Temporarily set settings for calculation
                    const originalSettings = data.timeEstimationSettings;
                    data.timeEstimationSettings = tempSettings;
                    
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    
                    // Restore original settings
                    data.timeEstimationSettings = originalSettings;
                    
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
        }

        function updateTimeEstimationSettings() {
            const settings = {
                fastSpeedBase: parseFloat(document.getElementById('time-settings-fast-speed').value) || 12.5,
                slowSpeedBase: parseFloat(document.getElementById('time-settings-slow-speed').value) || 10,
                fastSpeedMin: parseFloat(document.getElementById('time-settings-fast-min').value) || 5.5,
                slowSpeedMin: parseFloat(document.getElementById('time-settings-slow-min').value) || 4,
                elevationAdjustment: parseFloat(document.getElementById('time-settings-elevation').value) || 0.5,
                lengthAdjustmentFactor: parseFloat(document.getElementById('time-settings-length').value) || 0.1
            };
            
            data.timeEstimationSettings = settings;
            saveData();
            
            // Recalculate time for current route if modal is open
            const routeModal = document.getElementById('add-route-modal');
            if (routeModal && !routeModal.classList.contains('hidden')) {
                const distanceInput = document.getElementById('route-distance');
                const elevationInput = document.getElementById('route-elevation');
                const timeInput = document.getElementById('route-time');
                
                if (distanceInput && distanceInput.value.trim()) {
                    const calculatedTime = calculateEstimatedTime(distanceInput.value.trim(), elevationInput ? elevationInput.value.trim() : '');
                    if (calculatedTime && timeInput) {
                        timeInput.value = calculatedTime;
                    }
                }
            }
        }

        function resetTimeEstimationSettings() {
            const defaults = {
                fastSpeedBase: 12.5,
                slowSpeedBase: 10,
                fastSpeedMin: 5.5,
                slowSpeedMin: 4,
                elevationAdjustment: 0.5,
                lengthAdjustmentFactor: 0.1
            };
            
            document.getElementById('time-settings-fast-speed').value = defaults.fastSpeedBase;
            document.getElementById('time-settings-slow-speed').value = defaults.slowSpeedBase;
            document.getElementById('time-settings-fast-min').value = defaults.fastSpeedMin;
            document.getElementById('time-settings-slow-min').value = defaults.slowSpeedMin;
            document.getElementById('time-settings-elevation').value = defaults.elevationAdjustment;
            document.getElementById('time-settings-length').value = defaults.lengthAdjustmentFactor;
            
            previewTimeEstimationSettings();
        }

        function saveRoute() {
            const modal = document.getElementById('add-route-modal');
            const isEdit = modal && modal.hasAttribute('data-editing-route-id');
            const routeId = isEdit ? parseInt(modal.getAttribute('data-editing-route-id'), 10) : null;
            const isManual = modal && modal.getAttribute('data-is-manual-route') === 'true';

            const nameInput = document.getElementById('route-name');
            const descriptionInput = document.getElementById('route-description');
            const distanceInput = document.getElementById('route-distance');
            const elevationInput = document.getElementById('route-elevation');
            const timeInput = document.getElementById('route-time');
            const embedCodeInput = document.getElementById('route-embed-code');
            const fitnessMinInput = document.getElementById('route-fitness-min');
            const fitnessMaxInput = document.getElementById('route-fitness-max');
            const skillsMinInput = document.getElementById('route-skills-min');
            const skillsMaxInput = document.getElementById('route-skills-max');

            const name = nameInput.value.trim();
            const embedCode = embedCodeInput ? embedCodeInput.value.trim() : '';
            const fitnessMin = parseInt(fitnessMinInput.value);
            const fitnessMax = parseInt(fitnessMaxInput.value);
            const skillsMin = parseInt(skillsMinInput.value);
            const skillsMax = parseInt(skillsMaxInput.value);

            if (!name) {
                alert('Please enter a route name');
                return;
            }

            // Only require embed code for Strava routes
            if (!isManual && !embedCode) {
                alert('Please paste the Strava embed code');
                return;
            }

            // Extract Strava URL from embed code if it exists
            let stravaUrl = null;
            if (embedCode && !isManual) {
                stravaUrl = extractRouteUrlFromEmbed(embedCode);
                // Clean up URL - remove query parameters that might break the link
                if (stravaUrl) {
                    stravaUrl = stravaUrl.split('?')[0];
                }
            }

            // Initialize routes array if needed
            if (!Array.isArray(data.routes)) {
                data.routes = [];
            }

            if (isEdit && routeId) {
                // Update existing route
                const routeIndex = data.routes.findIndex(r => r.id === routeId);
                if (routeIndex >= 0) {
                    data.routes[routeIndex] = {
                        ...data.routes[routeIndex],
                        name: name,
                        description: descriptionInput.value.trim() || null,
                        stravaEmbedCode: isManual ? null : embedCode,
                        stravaUrl: isManual ? null : stravaUrl,
                        distance: distanceInput.value.trim() || null,
                        elevation: elevationInput.value.trim() || null,
                        estimatedTime: timeInput ? timeInput.value.trim() || null : null,
                        fitnessMin: fitnessMin,
                        fitnessMax: fitnessMax,
                        skillsMin: skillsMin,
                        skillsMax: skillsMax
                    };
                }
            } else {
                // Add new route
                const route = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    name: name,
                    description: descriptionInput.value.trim() || null,
                    stravaEmbedCode: isManual ? null : embedCode,
                    stravaUrl: isManual ? null : stravaUrl,
                    distance: distanceInput.value.trim() || null,
                    elevation: elevationInput.value.trim() || null,
                    estimatedTime: timeInput ? timeInput.value.trim() || null : null,
                    fitnessMin: fitnessMin,
                    fitnessMax: fitnessMax,
                    skillsMin: skillsMin,
                    skillsMax: skillsMax
                };
                data.routes.push(route);
            }
            
            // Save to localStorage
            saveData();
            
            // Render routes
            renderRoutes();
            
            // Close modal and reopen routes manager
            closeAddRouteModal();
            openRoutesManagerModal();
        }

        function deleteRouteHandler(routeId) {
            if (!confirm('Are you sure you want to delete this route?')) {
                return;
            }

            // Remove from local data
            data.routes = data.routes.filter(r => r.id !== routeId);
            
            // Save to localStorage
            saveData();
            
            // Re-render routes
            renderRoutes();
        }

        // ============ RACES MANAGEMENT ============
        
        function openAddRacesModal() {
            const modal = document.getElementById('add-races-modal');
            if (!modal) return;
            
            // Initialize races array if needed
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            renderRacesList();
            
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
        }
        
        function closeAddRacesModal() {
            const modal = document.getElementById('add-races-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
        }
        
        function renderRacesList() {
            const container = document.getElementById('races-list-container');
            if (!container) return;
            
            if (!Array.isArray(data.races) || data.races.length === 0) {
                container.innerHTML = '<p style="color: #666; font-size: 14px; margin-bottom: 12px;">No races added yet. Click "Add Another Race" to get started.</p>';
                addRaceEntry();
                return;
            }
            
            container.innerHTML = data.races.map((race, index) => {
                const raceDate = race.raceDate || '';
                const preRideDate = race.preRideDate || '';
                const name = escapeHtml(race.name || '');
                const location = escapeHtml(race.location || '');
                
                return `
                    <div class="form-row" style="border: 1px solid #ddd; border-radius: 4px; padding: 12px; margin-bottom: 12px; background: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 8px;">
                            <strong style="color: #333;">Race ${index + 1}</strong>
                            <button class="btn-small danger" onclick="removeRaceEntry(${index})" style="padding: 4px 8px; font-size: 11px;">Remove</button>
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Race Name</label>
                            <input type="text" id="race-name-${index}" value="${name}" placeholder="e.g., NorCal League Race 1" style="width: 100%;">
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Race Date</label>
                            <input type="date" id="race-date-${index}" value="${raceDate}" style="width: 100%;">
                        </div>
                        <div style="flex: 1; margin-right: 8px;">
                            <label class="field-label">Pre-Ride Date</label>
                            <input type="date" id="preride-date-${index}" value="${preRideDate}" style="width: 100%;">
                        </div>
                        <div style="flex: 1;">
                            <label class="field-label">Location</label>
                            <input type="text" id="race-location-${index}" value="${location}" placeholder="e.g., Granite Bay" style="width: 100%;">
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function addRaceEntry() {
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            data.races.push({
                id: Date.now() + Math.floor(Math.random() * 1000),
                name: '',
                raceDate: '',
                preRideDate: '',
                location: ''
            });
            
            renderRacesList();
        }
        
        function removeRaceEntry(index) {
            if (!confirm('Are you sure you want to remove this race?')) {
                return;
            }
            
            if (Array.isArray(data.races) && index >= 0 && index < data.races.length) {
                data.races.splice(index, 1);
                renderRacesList();
            }
        }
        
        function saveRaces() {
            if (!Array.isArray(data.races)) {
                data.races = [];
            }
            
            // Collect all race data from inputs
            const racesContainer = document.getElementById('races-list-container');
            if (!racesContainer) return;
            
            const raceInputs = racesContainer.querySelectorAll('[id^="race-name-"]');
            const updatedRaces = [];
            
            raceInputs.forEach((nameInput, index) => {
                const raceId = nameInput.id.replace('race-name-', '');
                const name = nameInput.value.trim();
                const raceDateInput = document.getElementById(`race-date-${raceId}`);
                const preRideDateInput = document.getElementById(`preride-date-${raceId}`);
                const locationInput = document.getElementById(`race-location-${raceId}`);
                
                const raceDate = raceDateInput ? raceDateInput.value.trim() : '';
                const preRideDate = preRideDateInput ? preRideDateInput.value.trim() : '';
                const location = locationInput ? locationInput.value.trim() : '';
                
                // Only save if at least name or date is provided
                if (name || raceDate) {
                    // Find existing race by index or create new
                    const existingRace = data.races[index];
                    updatedRaces.push({
                        id: existingRace ? existingRace.id : (Date.now() + Math.floor(Math.random() * 1000) + index),
                        name: name,
                        raceDate: raceDate,
                        preRideDate: preRideDate,
                        location: location
                    });
                }
            });
            
            data.races = updatedRaces;
            saveData();
            
            // Re-render calendar to show races
            renderSeasonCalendar();
            renderSeasonCalendarForSettings();
            
            closeAddRacesModal();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
